var tD = Object.defineProperty;
var nD = (t, e, n) => e in t ? tD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Pe = (t, e, n) => nD(t, typeof e != "symbol" ? e + "" : e, n);
import { pushScopeId as iD, popScopeId as rD, defineComponent as ke, nextTick as Il, openBlock as P, createBlock as Re, createElementBlock as L, normalizeClass as Ot, renderSlot as Wi, normalizeProps as By, guardReactiveProps as Qy, withScopeId as sD, resolveComponent as nr, normalizeStyle as sn, withKeys as Qf, createElementVNode as A, Fragment as Yt, createCommentVNode as ei, mergeProps as sr, withCtx as ze, createVNode as fe, ref as pt, createApp as oD, h as li, toDisplayString as Ft, withDirectives as ut, unref as Z, computed as Be, vModelText as Fn, getCurrentInstance as Bd, effectScope as aD, inject as lD, onMounted as Gi, onUnmounted as Fy, watch as In, isRef as cD, shallowRef as ru, Text as uD, KeepAlive as dD, resolveDynamicComponent as Ni, onBeforeUnmount as hc, markRaw as R, watchEffect as hD, reactive as fD, render as Mu, customRef as pD, provide as sv, renderList as Fr, readonly as mD, getCurrentScope as gD, onScopeDispose as bD, resolveDirective as OD, withModifiers as su, vModelSelect as ZA, vShow as HA, vModelCheckbox as qA, createStaticVNode as yD, Transition as _D } from "vue";
const vD = ["top", "right", "bottom", "left"], ov = ["start", "end"], av = /* @__PURE__ */ vD.reduce((t, e) => t.concat(e, e + "-" + ov[0], e + "-" + ov[1]), []), ta = Math.min, Xo = Math.max, xD = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, wD = {
  start: "end",
  end: "start"
};
function ub(t, e, n) {
  return Xo(t, ta(e, n));
}
function za(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Yr(t) {
  return t.split("-")[0];
}
function cr(t) {
  return t.split("-")[1];
}
function XA(t) {
  return t === "x" ? "y" : "x";
}
function zy(t) {
  return t === "y" ? "height" : "width";
}
function wa(t) {
  return ["top", "bottom"].includes(Yr(t)) ? "y" : "x";
}
function Uy(t) {
  return XA(wa(t));
}
function jA(t, e, n) {
  n === void 0 && (n = !1);
  const i = cr(t), r = Uy(t), s = zy(r);
  let o = r === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (o = fp(o)), [o, fp(o)];
}
function SD(t) {
  const e = fp(t);
  return [hp(t), e, hp(e)];
}
function hp(t) {
  return t.replace(/start|end/g, (e) => wD[e]);
}
function kD(t, e, n) {
  const i = ["left", "right"], r = ["right", "left"], s = ["top", "bottom"], o = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? r : i : e ? i : r;
    case "left":
    case "right":
      return e ? s : o;
    default:
      return [];
  }
}
function ED(t, e, n, i) {
  const r = cr(t);
  let s = kD(Yr(t), n === "start", i);
  return r && (s = s.map((o) => o + "-" + r), e && (s = s.concat(s.map(hp)))), s;
}
function fp(t) {
  return t.replace(/left|right|bottom|top/g, (e) => xD[e]);
}
function CD(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function YA(t) {
  return typeof t != "number" ? CD(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function ou(t) {
  const {
    x: e,
    y: n,
    width: i,
    height: r
  } = t;
  return {
    width: i,
    height: r,
    top: n,
    left: e,
    right: e + i,
    bottom: n + r,
    x: e,
    y: n
  };
}
function lv(t, e, n) {
  let {
    reference: i,
    floating: r
  } = t;
  const s = wa(e), o = Uy(e), a = zy(o), l = Yr(e), c = s === "y", u = i.x + i.width / 2 - r.width / 2, d = i.y + i.height / 2 - r.height / 2, h = i[a] / 2 - r[a] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: u,
        y: i.y - r.height
      };
      break;
    case "bottom":
      f = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      f = {
        x: i.x + i.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: i.x - r.width,
        y: d
      };
      break;
    default:
      f = {
        x: i.x,
        y: i.y
      };
  }
  switch (cr(e)) {
    case "start":
      f[o] -= h * (n && c ? -1 : 1);
      break;
    case "end":
      f[o] += h * (n && c ? -1 : 1);
      break;
  }
  return f;
}
const AD = async (t, e, n) => {
  const {
    placement: i = "bottom",
    strategy: r = "absolute",
    middleware: s = [],
    platform: o
  } = n, a = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: t,
    floating: e,
    strategy: r
  }), {
    x: u,
    y: d
  } = lv(c, i, l), h = i, f = {}, p = 0;
  for (let m = 0; m < a.length; m++) {
    const {
      name: g,
      fn: b
    } = a[m], {
      x: _,
      y,
      data: O,
      reset: x
    } = await b({
      x: u,
      y: d,
      initialPlacement: i,
      placement: h,
      strategy: r,
      middlewareData: f,
      rects: c,
      platform: o,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = _ ?? u, d = y ?? d, f = {
      ...f,
      [g]: {
        ...f[g],
        ...O
      }
    }, x && p <= 50 && (p++, typeof x == "object" && (x.placement && (h = x.placement), x.rects && (c = x.rects === !0 ? await o.getElementRects({
      reference: t,
      floating: e,
      strategy: r
    }) : x.rects), {
      x: u,
      y: d
    } = lv(c, h, l)), m = -1);
  }
  return {
    x: u,
    y: d,
    placement: h,
    strategy: r,
    middlewareData: f
  };
};
async function t0(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: i,
    y: r,
    platform: s,
    rects: o,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: h = !1,
    padding: f = 0
  } = za(e, t), p = YA(f), g = a[h ? d === "floating" ? "reference" : "floating" : d], b = ou(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(g))) == null || n ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), _ = d === "floating" ? {
    x: i,
    y: r,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, y = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), O = await (s.isElement == null ? void 0 : s.isElement(y)) ? await (s.getScale == null ? void 0 : s.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = ou(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: _,
    offsetParent: y,
    strategy: l
  }) : _);
  return {
    top: (b.top - x.top + p.top) / O.y,
    bottom: (x.bottom - b.bottom + p.bottom) / O.y,
    left: (b.left - x.left + p.left) / O.x,
    right: (x.right - b.right + p.right) / O.x
  };
}
const TD = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: i,
      placement: r,
      rects: s,
      platform: o,
      elements: a,
      middlewareData: l
    } = e, {
      element: c,
      padding: u = 0
    } = za(t, e) || {};
    if (c == null)
      return {};
    const d = YA(u), h = {
      x: n,
      y: i
    }, f = Uy(r), p = zy(f), m = await o.getDimensions(c), g = f === "y", b = g ? "top" : "left", _ = g ? "bottom" : "right", y = g ? "clientHeight" : "clientWidth", O = s.reference[p] + s.reference[f] - h[f] - s.floating[p], x = h[f] - s.reference[f], v = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
    let w = v ? v[y] : 0;
    (!w || !await (o.isElement == null ? void 0 : o.isElement(v))) && (w = a.floating[y] || s.floating[p]);
    const T = O / 2 - x / 2, S = w / 2 - m[p] / 2 - 1, $ = ta(d[b], S), I = ta(d[_], S), F = $, V = w - m[p] - I, q = w / 2 - m[p] / 2 + T, K = ub(F, q, V), ie = !l.arrow && cr(r) != null && q !== K && s.reference[p] / 2 - (q < F ? $ : I) - m[p] / 2 < 0, k = ie ? q < F ? q - F : q - V : 0;
    return {
      [f]: h[f] + k,
      data: {
        [f]: K,
        centerOffset: q - K - k,
        ...ie && {
          alignmentOffset: k
        }
      },
      reset: ie
    };
  }
});
function MD(t, e, n) {
  return (t ? [...n.filter((r) => cr(r) === t), ...n.filter((r) => cr(r) !== t)] : n.filter((r) => Yr(r) === r)).filter((r) => t ? cr(r) === t || (e ? hp(r) !== r : !1) : !0);
}
const PD = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var n, i, r;
      const {
        rects: s,
        middlewareData: o,
        placement: a,
        platform: l,
        elements: c
      } = e, {
        crossAxis: u = !1,
        alignment: d,
        allowedPlacements: h = av,
        autoAlignment: f = !0,
        ...p
      } = za(t, e), m = d !== void 0 || h === av ? MD(d || null, f, h) : h, g = await t0(e, p), b = ((n = o.autoPlacement) == null ? void 0 : n.index) || 0, _ = m[b];
      if (_ == null)
        return {};
      const y = jA(_, s, await (l.isRTL == null ? void 0 : l.isRTL(c.floating)));
      if (a !== _)
        return {
          reset: {
            placement: m[0]
          }
        };
      const O = [g[Yr(_)], g[y[0]], g[y[1]]], x = [...((i = o.autoPlacement) == null ? void 0 : i.overflows) || [], {
        placement: _,
        overflows: O
      }], v = m[b + 1];
      if (v)
        return {
          data: {
            index: b + 1,
            overflows: x
          },
          reset: {
            placement: v
          }
        };
      const w = x.map(($) => {
        const I = cr($.placement);
        return [$.placement, I && u ? (
          // Check along the mainAxis and main crossAxis side.
          $.overflows.slice(0, 2).reduce((F, V) => F + V, 0)
        ) : (
          // Check only the mainAxis.
          $.overflows[0]
        ), $.overflows];
      }).sort(($, I) => $[1] - I[1]), S = ((r = w.filter(($) => $[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        cr($[0]) ? 2 : 3
      ).every((I) => I <= 0))[0]) == null ? void 0 : r[0]) || w[0][0];
      return S !== a ? {
        data: {
          index: b + 1,
          overflows: x
        },
        reset: {
          placement: S
        }
      } : {};
    }
  };
}, RD = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, i;
      const {
        placement: r,
        middlewareData: s,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: h,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = za(t, e);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const b = Yr(r), _ = wa(a), y = Yr(a) === a, O = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), x = h || (y || !m ? [fp(a)] : SD(a)), v = p !== "none";
      !h && v && x.push(...ED(a, m, p, O));
      const w = [a, ...x], T = await t0(e, g), S = [];
      let $ = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (u && S.push(T[b]), d) {
        const q = jA(r, o, O);
        S.push(T[q[0]], T[q[1]]);
      }
      if ($ = [...$, {
        placement: r,
        overflows: S
      }], !S.every((q) => q <= 0)) {
        var I, F;
        const q = (((I = s.flip) == null ? void 0 : I.index) || 0) + 1, K = w[q];
        if (K)
          return {
            data: {
              index: q,
              overflows: $
            },
            reset: {
              placement: K
            }
          };
        let ie = (F = $.filter((k) => k.overflows[0] <= 0).sort((k, N) => k.overflows[1] - N.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!ie)
          switch (f) {
            case "bestFit": {
              var V;
              const k = (V = $.filter((N) => {
                if (v) {
                  const W = wa(N.placement);
                  return W === _ || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  W === "y";
                }
                return !0;
              }).map((N) => [N.placement, N.overflows.filter((W) => W > 0).reduce((W, X) => W + X, 0)]).sort((N, W) => N[1] - W[1])[0]) == null ? void 0 : V[0];
              k && (ie = k);
              break;
            }
            case "initialPlacement":
              ie = a;
              break;
          }
        if (r !== ie)
          return {
            reset: {
              placement: ie
            }
          };
      }
      return {};
    }
  };
};
async function $D(t, e) {
  const {
    placement: n,
    platform: i,
    elements: r
  } = t, s = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)), o = Yr(n), a = cr(n), l = wa(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = s && l ? -1 : 1, d = za(e, t);
  let {
    mainAxis: h,
    crossAxis: f,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return a && typeof p == "number" && (f = a === "end" ? p * -1 : p), l ? {
    x: f * u,
    y: h * c
  } : {
    x: h * c,
    y: f * u
  };
}
const ND = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, i;
      const {
        x: r,
        y: s,
        placement: o,
        middlewareData: a
      } = e, l = await $D(e, t);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (i = a.arrow) != null && i.alignmentOffset ? {} : {
        x: r + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, DD = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: i,
        placement: r
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (g) => {
            let {
              x: b,
              y: _
            } = g;
            return {
              x: b,
              y: _
            };
          }
        },
        ...l
      } = za(t, e), c = {
        x: n,
        y: i
      }, u = await t0(e, l), d = wa(Yr(r)), h = XA(d);
      let f = c[h], p = c[d];
      if (s) {
        const g = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", _ = f + u[g], y = f - u[b];
        f = ub(_, f, y);
      }
      if (o) {
        const g = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", _ = p + u[g], y = p - u[b];
        p = ub(_, p, y);
      }
      const m = a.fn({
        ...e,
        [h]: f,
        [d]: p
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - i
        }
      };
    }
  };
}, ID = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      const {
        placement: n,
        rects: i,
        platform: r,
        elements: s
      } = e, {
        apply: o = () => {
        },
        ...a
      } = za(t, e), l = await t0(e, a), c = Yr(n), u = cr(n), d = wa(n) === "y", {
        width: h,
        height: f
      } = i.floating;
      let p, m;
      c === "top" || c === "bottom" ? (p = c, m = u === (await (r.isRTL == null ? void 0 : r.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (m = c, p = u === "end" ? "top" : "bottom");
      const g = f - l.top - l.bottom, b = h - l.left - l.right, _ = ta(f - l[p], g), y = ta(h - l[m], b), O = !e.middlewareData.shift;
      let x = _, v = y;
      if (d ? v = u || O ? ta(y, b) : b : x = u || O ? ta(_, g) : g, O && !u) {
        const T = Xo(l.left, 0), S = Xo(l.right, 0), $ = Xo(l.top, 0), I = Xo(l.bottom, 0);
        d ? v = h - 2 * (T !== 0 || S !== 0 ? T + S : Xo(l.left, l.right)) : x = f - 2 * ($ !== 0 || I !== 0 ? $ + I : Xo(l.top, l.bottom));
      }
      await o({
        ...e,
        availableWidth: v,
        availableHeight: x
      });
      const w = await r.getDimensions(s.floating);
      return h !== w.width || f !== w.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Di(t) {
  var e;
  return ((e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function zr(t) {
  return Di(t).getComputedStyle(t);
}
const cv = Math.min, au = Math.max, pp = Math.round;
function GA(t) {
  const e = zr(t);
  let n = parseFloat(e.width), i = parseFloat(e.height);
  const r = t.offsetWidth, s = t.offsetHeight, o = pp(n) !== r || pp(i) !== s;
  return o && (n = r, i = s), { width: n, height: i, fallback: o };
}
function So(t) {
  return JA(t) ? (t.nodeName || "").toLowerCase() : "";
}
let xh;
function KA() {
  if (xh) return xh;
  const t = navigator.userAgentData;
  return t && Array.isArray(t.brands) ? (xh = t.brands.map((e) => e.brand + "/" + e.version).join(" "), xh) : navigator.userAgent;
}
function Ur(t) {
  return t instanceof Di(t).HTMLElement;
}
function fo(t) {
  return t instanceof Di(t).Element;
}
function JA(t) {
  return t instanceof Di(t).Node;
}
function uv(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof Di(t).ShadowRoot || t instanceof ShadowRoot;
}
function n0(t) {
  const { overflow: e, overflowX: n, overflowY: i, display: r } = zr(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + i + n) && !["inline", "contents"].includes(r);
}
function LD(t) {
  return ["table", "td", "th"].includes(So(t));
}
function db(t) {
  const e = /firefox/i.test(KA()), n = zr(t), i = n.backdropFilter || n.WebkitBackdropFilter;
  return n.transform !== "none" || n.perspective !== "none" || !!i && i !== "none" || e && n.willChange === "filter" || e && !!n.filter && n.filter !== "none" || ["transform", "perspective"].some((r) => n.willChange.includes(r)) || ["paint", "layout", "strict", "content"].some((r) => {
    const s = n.contain;
    return s != null && s.includes(r);
  });
}
function e3() {
  return !/^((?!chrome|android).)*safari/i.test(KA());
}
function Wy(t) {
  return ["html", "body", "#document"].includes(So(t));
}
function t3(t) {
  return fo(t) ? t : t.contextElement;
}
const n3 = { x: 1, y: 1 };
function xl(t) {
  const e = t3(t);
  if (!Ur(e)) return n3;
  const n = e.getBoundingClientRect(), { width: i, height: r, fallback: s } = GA(e);
  let o = (s ? pp(n.width) : n.width) / i, a = (s ? pp(n.height) : n.height) / r;
  return o && Number.isFinite(o) || (o = 1), a && Number.isFinite(a) || (a = 1), { x: o, y: a };
}
function Pu(t, e, n, i) {
  var r, s;
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), a = t3(t);
  let l = n3;
  e && (i ? fo(i) && (l = xl(i)) : l = xl(t));
  const c = a ? Di(a) : window, u = !e3() && n;
  let d = (o.left + (u && ((r = c.visualViewport) == null ? void 0 : r.offsetLeft) || 0)) / l.x, h = (o.top + (u && ((s = c.visualViewport) == null ? void 0 : s.offsetTop) || 0)) / l.y, f = o.width / l.x, p = o.height / l.y;
  if (a) {
    const m = Di(a), g = i && fo(i) ? Di(i) : i;
    let b = m.frameElement;
    for (; b && i && g !== m; ) {
      const _ = xl(b), y = b.getBoundingClientRect(), O = getComputedStyle(b);
      y.x += (b.clientLeft + parseFloat(O.paddingLeft)) * _.x, y.y += (b.clientTop + parseFloat(O.paddingTop)) * _.y, d *= _.x, h *= _.y, f *= _.x, p *= _.y, d += y.x, h += y.y, b = Di(b).frameElement;
    }
  }
  return { width: f, height: p, top: h, right: d + f, bottom: h + p, left: d, x: d, y: h };
}
function po(t) {
  return ((JA(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function i0(t) {
  return fo(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function i3(t) {
  return Pu(po(t)).left + i0(t).scrollLeft;
}
function Ru(t) {
  if (So(t) === "html") return t;
  const e = t.assignedSlot || t.parentNode || uv(t) && t.host || po(t);
  return uv(e) ? e.host : e;
}
function r3(t) {
  const e = Ru(t);
  return Wy(e) ? e.ownerDocument.body : Ur(e) && n0(e) ? e : r3(e);
}
function mp(t, e) {
  var n;
  e === void 0 && (e = []);
  const i = r3(t), r = i === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Di(i);
  return r ? e.concat(s, s.visualViewport || [], n0(i) ? i : []) : e.concat(i, mp(i));
}
function dv(t, e, n) {
  return e === "viewport" ? ou(function(i, r) {
    const s = Di(i), o = po(i), a = s.visualViewport;
    let l = o.clientWidth, c = o.clientHeight, u = 0, d = 0;
    if (a) {
      l = a.width, c = a.height;
      const h = e3();
      (h || !h && r === "fixed") && (u = a.offsetLeft, d = a.offsetTop);
    }
    return { width: l, height: c, x: u, y: d };
  }(t, n)) : fo(e) ? ou(function(i, r) {
    const s = Pu(i, !0, r === "fixed"), o = s.top + i.clientTop, a = s.left + i.clientLeft, l = Ur(i) ? xl(i) : { x: 1, y: 1 };
    return { width: i.clientWidth * l.x, height: i.clientHeight * l.y, x: a * l.x, y: o * l.y };
  }(e, n)) : ou(function(i) {
    const r = po(i), s = i0(i), o = i.ownerDocument.body, a = au(r.scrollWidth, r.clientWidth, o.scrollWidth, o.clientWidth), l = au(r.scrollHeight, r.clientHeight, o.scrollHeight, o.clientHeight);
    let c = -s.scrollLeft + i3(i);
    const u = -s.scrollTop;
    return zr(o).direction === "rtl" && (c += au(r.clientWidth, o.clientWidth) - a), { width: a, height: l, x: c, y: u };
  }(po(t)));
}
function hv(t) {
  return Ur(t) && zr(t).position !== "fixed" ? t.offsetParent : null;
}
function fv(t) {
  const e = Di(t);
  let n = hv(t);
  for (; n && LD(n) && zr(n).position === "static"; ) n = hv(n);
  return n && (So(n) === "html" || So(n) === "body" && zr(n).position === "static" && !db(n)) ? e : n || function(i) {
    let r = Ru(i);
    for (; Ur(r) && !Wy(r); ) {
      if (db(r)) return r;
      r = Ru(r);
    }
    return null;
  }(t) || e;
}
function BD(t, e, n) {
  const i = Ur(e), r = po(e), s = Pu(t, !0, n === "fixed", e);
  let o = { scrollLeft: 0, scrollTop: 0 };
  const a = { x: 0, y: 0 };
  if (i || !i && n !== "fixed") if ((So(e) !== "body" || n0(r)) && (o = i0(e)), Ur(e)) {
    const l = Pu(e, !0);
    a.x = l.x + e.clientLeft, a.y = l.y + e.clientTop;
  } else r && (a.x = i3(r));
  return { x: s.left + o.scrollLeft - a.x, y: s.top + o.scrollTop - a.y, width: s.width, height: s.height };
}
const QD = { getClippingRect: function(t) {
  let { element: e, boundary: n, rootBoundary: i, strategy: r } = t;
  const s = n === "clippingAncestors" ? function(c, u) {
    const d = u.get(c);
    if (d) return d;
    let h = mp(c).filter((g) => fo(g) && So(g) !== "body"), f = null;
    const p = zr(c).position === "fixed";
    let m = p ? Ru(c) : c;
    for (; fo(m) && !Wy(m); ) {
      const g = zr(m), b = db(m);
      (p ? b || f : b || g.position !== "static" || !f || !["absolute", "fixed"].includes(f.position)) ? f = g : h = h.filter((_) => _ !== m), m = Ru(m);
    }
    return u.set(c, h), h;
  }(e, this._c) : [].concat(n), o = [...s, i], a = o[0], l = o.reduce((c, u) => {
    const d = dv(e, u, r);
    return c.top = au(d.top, c.top), c.right = cv(d.right, c.right), c.bottom = cv(d.bottom, c.bottom), c.left = au(d.left, c.left), c;
  }, dv(e, a, r));
  return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
  let { rect: e, offsetParent: n, strategy: i } = t;
  const r = Ur(n), s = po(n);
  if (n === s) return e;
  let o = { scrollLeft: 0, scrollTop: 0 }, a = { x: 1, y: 1 };
  const l = { x: 0, y: 0 };
  if ((r || !r && i !== "fixed") && ((So(n) !== "body" || n0(s)) && (o = i0(n)), Ur(n))) {
    const c = Pu(n);
    a = xl(n), l.x = c.x + n.clientLeft, l.y = c.y + n.clientTop;
  }
  return { width: e.width * a.x, height: e.height * a.y, x: e.x * a.x - o.scrollLeft * a.x + l.x, y: e.y * a.y - o.scrollTop * a.y + l.y };
}, isElement: fo, getDimensions: function(t) {
  return Ur(t) ? GA(t) : t.getBoundingClientRect();
}, getOffsetParent: fv, getDocumentElement: po, getScale: xl, async getElementRects(t) {
  let { reference: e, floating: n, strategy: i } = t;
  const r = this.getOffsetParent || fv, s = this.getDimensions;
  return { reference: BD(e, await r(n), i), floating: { x: 0, y: 0, ...await s(n) } };
}, getClientRects: (t) => Array.from(t.getClientRects()), isRTL: (t) => zr(t).direction === "rtl" }, FD = (t, e, n) => {
  const i = /* @__PURE__ */ new Map(), r = { platform: QD, ...n }, s = { ...r.platform, _c: i };
  return AD(t, e, { ...r, platform: s });
}, fa = {
  // Disable popper components
  disabled: !1,
  // Default position offset along main axis (px)
  distance: 5,
  // Default position offset along cross axis (px)
  skidding: 0,
  // Default container where the tooltip will be appended
  container: "body",
  // Element used to compute position and size boundaries
  boundary: void 0,
  // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.
  instantMove: !1,
  // Auto destroy tooltip DOM nodes (ms)
  disposeTimeout: 150,
  // Triggers on the popper itself
  popperTriggers: [],
  // Positioning strategy
  strategy: "absolute",
  // Prevent overflow
  preventOverflow: !0,
  // Flip to the opposite placement if needed
  flip: !0,
  // Shift on the cross axis to prevent the popper from overflowing
  shift: !0,
  // Overflow padding (px)
  overflowPadding: 0,
  // Arrow padding (px)
  arrowPadding: 0,
  // Compute arrow overflow (useful to hide it)
  arrowOverflow: !0,
  /**
   * By default, compute autohide on 'click'.
   */
  autoHideOnMousedown: !1,
  // Themes
  themes: {
    tooltip: {
      // Default tooltip placement relative to target element
      placement: "top",
      // Default events that trigger the tooltip
      triggers: ["hover", "focus", "touch"],
      // Close tooltip on click on tooltip target
      hideTriggers: (t) => [...t, "click"],
      // Delay (ms)
      delay: {
        show: 200,
        hide: 0
      },
      // Update popper on content resize
      handleResize: !1,
      // Enable HTML content in directive
      html: !1,
      // Displayed when tooltip content is loading
      loadingContent: "..."
    },
    dropdown: {
      // Default dropdown placement relative to target element
      placement: "bottom",
      // Default events that trigger the dropdown
      triggers: ["click"],
      // Delay (ms)
      delay: 0,
      // Update popper on content resize
      handleResize: !0,
      // Hide on clock outside
      autoHide: !0
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function $u(t, e) {
  let n = fa.themes[t] || {}, i;
  do
    i = n[e], typeof i > "u" ? n.$extend ? n = fa.themes[n.$extend] || {} : (n = null, i = fa[e]) : n = null;
  while (n);
  return i;
}
function zD(t) {
  const e = [t];
  let n = fa.themes[t] || {};
  do
    n.$extend && !n.$resetCss ? (e.push(n.$extend), n = fa.themes[n.$extend] || {}) : n = null;
  while (n);
  return e.map((i) => `v-popper--theme-${i}`);
}
function pv(t) {
  const e = [t];
  let n = fa.themes[t] || {};
  do
    n.$extend ? (e.push(n.$extend), n = fa.themes[n.$extend] || {}) : n = null;
  while (n);
  return e;
}
let Nu = !1;
if (typeof window < "u") {
  Nu = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get() {
        Nu = !0;
      }
    });
    window.addEventListener("test", null, t);
  } catch {
  }
}
let s3 = !1;
typeof window < "u" && typeof navigator < "u" && (s3 = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
const o3 = ["auto", "top", "bottom", "left", "right"].reduce((t, e) => t.concat([
  e,
  `${e}-start`,
  `${e}-end`
]), []), mv = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart",
  pointer: "pointerdown"
}, gv = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend",
  pointer: "pointerup"
};
function bv(t, e) {
  const n = t.indexOf(e);
  n !== -1 && t.splice(n, 1);
}
function dg() {
  return new Promise((t) => requestAnimationFrame(() => {
    requestAnimationFrame(t);
  }));
}
const ir = [];
let Vo = null;
const Ov = {};
function yv(t) {
  let e = Ov[t];
  return e || (e = Ov[t] = []), e;
}
let hb = function() {
};
typeof window < "u" && (hb = window.Element);
function He(t) {
  return function(e) {
    return $u(e.theme, t);
  };
}
const hg = "__floating-vue__popper", a3 = () => ke({
  name: "VPopper",
  provide() {
    return {
      [hg]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [hg]: { default: null }
  },
  props: {
    theme: {
      type: String,
      required: !0
    },
    targetNodes: {
      type: Function,
      required: !0
    },
    referenceNode: {
      type: Function,
      default: null
    },
    popperNode: {
      type: Function,
      required: !0
    },
    shown: {
      type: Boolean,
      default: !1
    },
    showGroup: {
      type: String,
      default: null
    },
    // eslint-disable-next-line vue/require-prop-types
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: He("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: He("positioningDisabled")
    },
    placement: {
      type: String,
      default: He("placement"),
      validator: (t) => o3.includes(t)
    },
    delay: {
      type: [String, Number, Object],
      default: He("delay")
    },
    distance: {
      type: [Number, String],
      default: He("distance")
    },
    skidding: {
      type: [Number, String],
      default: He("skidding")
    },
    triggers: {
      type: Array,
      default: He("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: He("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: He("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: He("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: He("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: He("popperHideTriggers")
    },
    container: {
      type: [String, Object, hb, Boolean],
      default: He("container")
    },
    boundary: {
      type: [String, hb],
      default: He("boundary")
    },
    strategy: {
      type: String,
      validator: (t) => ["absolute", "fixed"].includes(t),
      default: He("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: He("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: He("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: He("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: He("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: He("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: He("computeTransformOrigin")
    },
    /**
     * @deprecated
     */
    autoMinSize: {
      type: Boolean,
      default: He("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: He("autoSize")
    },
    /**
     * @deprecated
     */
    autoMaxSize: {
      type: Boolean,
      default: He("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: He("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: He("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: He("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: He("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: He("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: He("flip")
    },
    shift: {
      type: Boolean,
      default: He("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: He("shiftCrossAxis")
    },
    noAutoFocus: {
      type: Boolean,
      default: He("noAutoFocus")
    },
    disposeTimeout: {
      type: Number,
      default: He("disposeTimeout")
    }
  },
  emits: {
    show: () => !0,
    hide: () => !0,
    "update:shown": (t) => !0,
    "apply-show": () => !0,
    "apply-hide": () => !0,
    "close-group": () => !0,
    "close-directive": () => !0,
    "auto-hide": () => !0,
    resize: () => !0
  },
  data() {
    return {
      isShown: !1,
      isMounted: !1,
      skipTransition: !1,
      classes: {
        showFrom: !1,
        showTo: !1,
        hideFrom: !1,
        hideTo: !0
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      randomId: `popper_${[Math.random(), Date.now()].map((t) => t.toString(36).substring(2, 10)).join("_")}`,
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: !0,
      pendingHide: !1,
      containsGlobalTarget: !1,
      isDisposed: !0,
      mouseDownContains: !1
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide == "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: {
          ...this.classes,
          popperClass: this.popperClass
        },
        result: this.positioningDisabled ? null : this.result,
        attrs: this.$attrs
      };
    },
    parentPopper() {
      var t;
      return (t = this[hg]) == null ? void 0 : t.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var t, e;
      return ((t = this.popperTriggers) == null ? void 0 : t.includes("hover")) || ((e = this.popperShowTriggers) == null ? void 0 : e.includes("hover"));
    }
  },
  watch: {
    shown: "$_autoShowHide",
    disabled(t) {
      t ? this.dispose() : this.init();
    },
    async container() {
      this.isShown && (this.$_ensureTeleport(), await this.$_computePosition());
    },
    triggers: {
      handler: "$_refreshListeners",
      deep: !0
    },
    positioningDisabled: "$_refreshListeners",
    ...[
      "placement",
      "distance",
      "skidding",
      "boundary",
      "strategy",
      "overflowPadding",
      "arrowPadding",
      "preventOverflow",
      "shift",
      "shiftCrossAxis",
      "flip"
    ].reduce((t, e) => (t[e] = "$_computePosition", t), {})
  },
  created() {
    this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'), this.autoMaxSize && console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
  },
  mounted() {
    this.init(), this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event: t = null, skipDelay: e = !1, force: n = !1 } = {}) {
      var i, r;
      (i = this.parentPopper) != null && i.lockedChild && this.parentPopper.lockedChild !== this || (this.pendingHide = !1, (n || !this.disabled) && (((r = this.parentPopper) == null ? void 0 : r.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(t, e), this.$emit("show"), this.$_showFrameLocked = !0, requestAnimationFrame(() => {
        this.$_showFrameLocked = !1;
      })), this.$emit("update:shown", !0));
    },
    hide({ event: t = null, skipDelay: e = !1 } = {}) {
      var n;
      if (!this.$_hideInProgress) {
        if (this.shownChildren.size > 0) {
          this.pendingHide = !0;
          return;
        }
        if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
          this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {
            this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: e }), this.parentPopper.lockedChild = null);
          }, 1e3));
          return;
        }
        ((n = this.parentPopper) == null ? void 0 : n.lockedChild) === this && (this.parentPopper.lockedChild = null), this.pendingHide = !1, this.$_scheduleHide(t, e), this.$emit("hide"), this.$emit("update:shown", !1);
      }
    },
    init() {
      var t;
      this.isDisposed && (this.isDisposed = !1, this.isMounted = !1, this.$_events = [], this.$_preventShow = !1, this.$_referenceNode = ((t = this.referenceNode) == null ? void 0 : t.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter((e) => e.nodeType === e.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner"), this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container"), this.$_swapTargetAttrs("title", "data-original-title"), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());
    },
    dispose() {
      this.isDisposed || (this.isDisposed = !0, this.$_removeEventListeners(), this.hide({ skipDelay: !0 }), this.$_detachPopperNode(), this.isMounted = !1, this.isShown = !1, this.$_updateParentShownChildren(!1), this.$_swapTargetAttrs("data-original-title", "title"));
    },
    async onResize() {
      this.isShown && (await this.$_computePosition(), this.$emit("resize"));
    },
    async $_computePosition() {
      if (this.isDisposed || this.positioningDisabled)
        return;
      const t = {
        strategy: this.strategy,
        middleware: []
      };
      (this.distance || this.skidding) && t.middleware.push(ND({
        mainAxis: this.distance,
        crossAxis: this.skidding
      }));
      const e = this.placement.startsWith("auto");
      if (e ? t.middleware.push(PD({
        alignment: this.placement.split("-")[1] ?? ""
      })) : t.placement = this.placement, this.preventOverflow && (this.shift && t.middleware.push(DD({
        padding: this.overflowPadding,
        boundary: this.boundary,
        crossAxis: this.shiftCrossAxis
      })), !e && this.flip && t.middleware.push(RD({
        padding: this.overflowPadding,
        boundary: this.boundary
      }))), t.middleware.push(TD({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      })), this.arrowOverflow && t.middleware.push({
        name: "arrowOverflow",
        fn: ({ placement: i, rects: r, middlewareData: s }) => {
          let o;
          const { centerOffset: a } = s.arrow;
          return i.startsWith("top") || i.startsWith("bottom") ? o = Math.abs(a) > r.reference.width / 2 : o = Math.abs(a) > r.reference.height / 2, {
            data: {
              overflow: o
            }
          };
        }
      }), this.autoMinSize || this.autoSize) {
        const i = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        t.middleware.push({
          name: "autoSize",
          fn: ({ rects: r, placement: s, middlewareData: o }) => {
            var a;
            if ((a = o.autoSize) != null && a.skip)
              return {};
            let l, c;
            return s.startsWith("top") || s.startsWith("bottom") ? l = r.reference.width : c = r.reference.height, this.$_innerNode.style[i === "min" ? "minWidth" : i === "max" ? "maxWidth" : "width"] = l != null ? `${l}px` : null, this.$_innerNode.style[i === "min" ? "minHeight" : i === "max" ? "maxHeight" : "height"] = c != null ? `${c}px` : null, {
              data: {
                skip: !0
              },
              reset: {
                rects: !0
              }
            };
          }
        });
      }
      (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, t.middleware.push(ID({
        boundary: this.boundary,
        padding: this.overflowPadding,
        apply: ({ availableWidth: i, availableHeight: r }) => {
          this.$_innerNode.style.maxWidth = i != null ? `${i}px` : null, this.$_innerNode.style.maxHeight = r != null ? `${r}px` : null;
        }
      })));
      const n = await FD(this.$_referenceNode, this.$_popperNode, t);
      Object.assign(this.result, {
        x: n.x,
        y: n.y,
        placement: n.placement,
        strategy: n.strategy,
        arrow: {
          ...n.middlewareData.arrow,
          ...n.middlewareData.arrowOverflow
        }
      });
    },
    $_scheduleShow(t, e = !1) {
      if (this.$_updateParentShownChildren(!0), this.$_hideInProgress = !1, clearTimeout(this.$_scheduleTimer), Vo && this.instantMove && Vo.instantMove && Vo !== this.parentPopper) {
        Vo.$_applyHide(!0), this.$_applyShow(!0);
        return;
      }
      e ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
    },
    $_scheduleHide(t, e = !1) {
      if (this.shownChildren.size > 0) {
        this.pendingHide = !0;
        return;
      }
      this.$_updateParentShownChildren(!1), this.$_hideInProgress = !0, clearTimeout(this.$_scheduleTimer), this.isShown && (Vo = this), e ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
    },
    $_computeDelay(t) {
      const e = this.delay;
      return parseInt(e && e[t] || e || 0);
    },
    async $_applyShow(t = !1) {
      clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = t, !this.isShown && (this.$_ensureTeleport(), await dg(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([
        ...mp(this.$_referenceNode),
        ...mp(this.$_popperNode)
      ], "scroll", () => {
        this.$_computePosition();
      }));
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const e = this.$_referenceNode.getBoundingClientRect(), n = this.$_popperNode.querySelector(".v-popper__wrapper"), i = n.parentNode.getBoundingClientRect(), r = e.x + e.width / 2 - (i.left + n.offsetLeft), s = e.y + e.height / 2 - (i.top + n.offsetTop);
        this.result.transformOrigin = `${r}px ${s}px`;
      }
      this.isShown = !0, this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const t = this.showGroup;
      if (t) {
        let e;
        for (let n = 0; n < ir.length; n++)
          e = ir[n], e.showGroup !== t && (e.hide(), e.$emit("close-group"));
      }
      ir.push(this), document.body.classList.add("v-popper--some-open");
      for (const e of pv(this.theme))
        yv(e).push(this), document.body.classList.add(`v-popper--some-open--${e}`);
      this.$emit("apply-show"), this.classes.showFrom = !0, this.classes.showTo = !1, this.classes.hideFrom = !1, this.classes.hideTo = !1, await dg(), this.classes.showFrom = !1, this.classes.showTo = !0, this.noAutoFocus || this.$_popperNode.focus();
    },
    async $_applyHide(t = !1) {
      if (this.shownChildren.size > 0) {
        this.pendingHide = !0, this.$_hideInProgress = !1;
        return;
      }
      if (clearTimeout(this.$_scheduleTimer), !this.isShown)
        return;
      this.skipTransition = t, bv(ir, this), ir.length === 0 && document.body.classList.remove("v-popper--some-open");
      for (const n of pv(this.theme)) {
        const i = yv(n);
        bv(i, this), i.length === 0 && document.body.classList.remove(`v-popper--some-open--${n}`);
      }
      Vo === this && (Vo = null), this.isShown = !1, this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      }), clearTimeout(this.$_disposeTimer);
      const e = this.disposeTimeout;
      e !== null && (this.$_disposeTimer = setTimeout(() => {
        this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = !1);
      }, e)), this.$_removeEventListeners("scroll"), this.$emit("apply-hide"), this.classes.showFrom = !1, this.classes.showTo = !1, this.classes.hideFrom = !0, this.classes.hideTo = !1, await dg(), this.classes.hideFrom = !1, this.classes.hideTo = !0;
    },
    $_autoShowHide() {
      this.shown ? this.show() : this.hide();
    },
    $_ensureTeleport() {
      if (this.isDisposed)
        return;
      let t = this.container;
      if (typeof t == "string" ? t = window.document.querySelector(t) : t === !1 && (t = this.$_targetNodes[0].parentNode), !t)
        throw new Error("No container for popover: " + this.container);
      t.appendChild(this.$_popperNode), this.isMounted = !0;
    },
    $_addEventListeners() {
      const t = (n) => {
        this.isShown && !this.$_hideInProgress || (n.usedByTooltip = !0, !this.$_preventShow && this.show({ event: n }));
      };
      this.$_registerTriggerListeners(this.$_targetNodes, mv, this.triggers, this.showTriggers, t), this.$_registerTriggerListeners([this.$_popperNode], mv, this.popperTriggers, this.popperShowTriggers, t);
      const e = (n) => {
        n.usedByTooltip || this.hide({ event: n });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, gv, this.triggers, this.hideTriggers, e), this.$_registerTriggerListeners([this.$_popperNode], gv, this.popperTriggers, this.popperHideTriggers, e);
    },
    $_registerEventListeners(t, e, n) {
      this.$_events.push({ targetNodes: t, eventType: e, handler: n }), t.forEach((i) => i.addEventListener(e, n, Nu ? {
        passive: !0
      } : void 0));
    },
    $_registerTriggerListeners(t, e, n, i, r) {
      let s = n;
      i != null && (s = typeof i == "function" ? i(s) : i), s.forEach((o) => {
        const a = e[o];
        a && this.$_registerEventListeners(t, a, r);
      });
    },
    $_removeEventListeners(t) {
      const e = [];
      this.$_events.forEach((n) => {
        const { targetNodes: i, eventType: r, handler: s } = n;
        !t || t === r ? i.forEach((o) => o.removeEventListener(r, s)) : e.push(n);
      }), this.$_events = e;
    },
    $_refreshListeners() {
      this.isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());
    },
    $_handleGlobalClose(t, e = !1) {
      this.$_showFrameLocked || (this.hide({ event: t }), t.closePopover ? this.$emit("close-directive") : this.$emit("auto-hide"), e && (this.$_preventShow = !0, setTimeout(() => {
        this.$_preventShow = !1;
      }, 300)));
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(t, e) {
      for (const n of this.$_targetNodes) {
        const i = n.getAttribute(t);
        i && (n.removeAttribute(t), n.setAttribute(e, i));
      }
    },
    $_applyAttrsToTarget(t) {
      for (const e of this.$_targetNodes)
        for (const n in t) {
          const i = t[n];
          i == null ? e.removeAttribute(n) : e.setAttribute(n, i);
        }
    },
    $_updateParentShownChildren(t) {
      let e = this.parentPopper;
      for (; e; )
        t ? e.shownChildren.add(this.randomId) : (e.shownChildren.delete(this.randomId), e.pendingHide && e.hide()), e = e.parentPopper;
    },
    $_isAimingPopper() {
      const t = this.$_referenceNode.getBoundingClientRect();
      if (lu >= t.left && lu <= t.right && cu >= t.top && cu <= t.bottom) {
        const e = this.$_popperNode.getBoundingClientRect(), n = lu - Bs, i = cu - Qs, r = e.left + e.width / 2 - Bs + (e.top + e.height / 2) - Qs + e.width + e.height, s = Bs + n * r, o = Qs + i * r;
        return wh(Bs, Qs, s, o, e.left, e.top, e.left, e.bottom) || // Left edge
        wh(Bs, Qs, s, o, e.left, e.top, e.right, e.top) || // Top edge
        wh(Bs, Qs, s, o, e.right, e.top, e.right, e.bottom) || // Right edge
        wh(Bs, Qs, s, o, e.left, e.bottom, e.right, e.bottom);
      }
      return !1;
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
if (typeof document < "u" && typeof window < "u") {
  if (s3) {
    const t = Nu ? {
      passive: !0,
      capture: !0
    } : !0;
    document.addEventListener("touchstart", (e) => _v(e), t), document.addEventListener("touchend", (e) => vv(e, !0), t);
  } else
    window.addEventListener("mousedown", (t) => _v(t), !0), window.addEventListener("click", (t) => vv(t, !1), !0);
  window.addEventListener("resize", VD);
}
function _v(t, e) {
  for (let n = 0; n < ir.length; n++) {
    const i = ir[n];
    try {
      i.mouseDownContains = i.popperNode().contains(t.target);
    } catch {
    }
  }
}
function vv(t, e) {
  UD(t, e);
}
function UD(t, e) {
  const n = {};
  for (let i = ir.length - 1; i >= 0; i--) {
    const r = ir[i];
    try {
      const s = r.containsGlobalTarget = r.mouseDownContains || r.popperNode().contains(t.target);
      r.pendingHide = !1, requestAnimationFrame(() => {
        if (r.pendingHide = !1, !n[r.randomId] && xv(r, s, t)) {
          if (r.$_handleGlobalClose(t, e), !t.closeAllPopover && t.closePopover && s) {
            let a = r.parentPopper;
            for (; a; )
              n[a.randomId] = !0, a = a.parentPopper;
            return;
          }
          let o = r.parentPopper;
          for (; o && xv(o, o.containsGlobalTarget, t); )
            o.$_handleGlobalClose(t, e), o = o.parentPopper;
        }
      });
    } catch {
    }
  }
}
function xv(t, e, n) {
  return n.closeAllPopover || n.closePopover && e || WD(t, n) && !e;
}
function WD(t, e) {
  if (typeof t.autoHide == "function") {
    const n = t.autoHide(e);
    return t.lastAutoHide = n, n;
  }
  return t.autoHide;
}
function VD() {
  for (let t = 0; t < ir.length; t++)
    ir[t].$_computePosition();
}
let Bs = 0, Qs = 0, lu = 0, cu = 0;
typeof window < "u" && window.addEventListener("mousemove", (t) => {
  Bs = lu, Qs = cu, lu = t.clientX, cu = t.clientY;
}, Nu ? {
  passive: !0
} : void 0);
function wh(t, e, n, i, r, s, o, a) {
  const l = ((o - r) * (e - s) - (a - s) * (t - r)) / ((a - s) * (n - t) - (o - r) * (i - e)), c = ((n - t) * (e - s) - (i - e) * (t - r)) / ((a - s) * (n - t) - (o - r) * (i - e));
  return l >= 0 && l <= 1 && c >= 0 && c <= 1;
}
const ZD = {
  extends: a3()
}, r0 = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [i, r] of e)
    n[i] = r;
  return n;
};
function HD(t, e, n, i, r, s) {
  return P(), L("div", {
    ref: "reference",
    class: Ot(["v-popper", {
      "v-popper--shown": t.slotData.isShown
    }])
  }, [
    Wi(t.$slots, "default", By(Qy(t.slotData)))
  ], 2);
}
const qD = /* @__PURE__ */ r0(ZD, [["render", HD]]);
function XD() {
  var t = window.navigator.userAgent, e = t.indexOf("MSIE ");
  if (e > 0)
    return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
  var n = t.indexOf("Trident/");
  if (n > 0) {
    var i = t.indexOf("rv:");
    return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10);
  }
  var r = t.indexOf("Edge/");
  return r > 0 ? parseInt(t.substring(r + 5, t.indexOf(".", r)), 10) : -1;
}
let Ff;
function fb() {
  fb.init || (fb.init = !0, Ff = XD() !== -1);
}
var s0 = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: !1
    },
    ignoreWidth: {
      type: Boolean,
      default: !1
    },
    ignoreHeight: {
      type: Boolean,
      default: !1
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    fb(), Il(() => {
      this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();
    });
    const t = document.createElement("object");
    this._resizeObject = t, t.setAttribute("aria-hidden", "true"), t.setAttribute("tabindex", -1), t.onload = this.addResizeHandlers, t.type = "text/html", Ff && this.$el.appendChild(t), t.data = "about:blank", Ff || this.$el.appendChild(t);
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify();
    },
    removeResizeHandlers() {
      this._resizeObject && this._resizeObject.onload && (!Ff && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);
    }
  }
};
const jD = /* @__PURE__ */ sD("data-v-b329ee4c");
iD("data-v-b329ee4c");
const YD = {
  class: "resize-observer",
  tabindex: "-1"
};
rD();
const GD = /* @__PURE__ */ jD((t, e, n, i, r, s) => (P(), Re("div", YD)));
s0.render = GD;
s0.__scopeId = "data-v-b329ee4c";
s0.__file = "src/components/ResizeObserver.vue";
const l3 = (t = "theme") => ({
  computed: {
    themeClass() {
      return zD(this[t]);
    }
  }
}), KD = ke({
  name: "VPopperContent",
  components: {
    ResizeObserver: s0
  },
  mixins: [
    l3()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(t) {
      return t != null && !isNaN(t) ? `${t}px` : null;
    }
  }
}), JD = ["id", "aria-hidden", "tabindex", "data-popper-placement"], e8 = {
  ref: "inner",
  class: "v-popper__inner"
}, t8 = /* @__PURE__ */ A("div", { class: "v-popper__arrow-outer" }, null, -1), n8 = /* @__PURE__ */ A("div", { class: "v-popper__arrow-inner" }, null, -1), i8 = [
  t8,
  n8
];
function r8(t, e, n, i, r, s) {
  const o = nr("ResizeObserver");
  return P(), L("div", {
    id: t.popperId,
    ref: "popover",
    class: Ot(["v-popper__popper", [
      t.themeClass,
      t.classes.popperClass,
      {
        "v-popper__popper--shown": t.shown,
        "v-popper__popper--hidden": !t.shown,
        "v-popper__popper--show-from": t.classes.showFrom,
        "v-popper__popper--show-to": t.classes.showTo,
        "v-popper__popper--hide-from": t.classes.hideFrom,
        "v-popper__popper--hide-to": t.classes.hideTo,
        "v-popper__popper--skip-transition": t.skipTransition,
        "v-popper__popper--arrow-overflow": t.result && t.result.arrow.overflow,
        "v-popper__popper--no-positioning": !t.result
      }
    ]]),
    style: sn(t.result ? {
      position: t.result.strategy,
      transform: `translate3d(${Math.round(t.result.x)}px,${Math.round(t.result.y)}px,0)`
    } : void 0),
    "aria-hidden": t.shown ? "false" : "true",
    tabindex: t.autoHide ? 0 : void 0,
    "data-popper-placement": t.result ? t.result.placement : void 0,
    onKeyup: e[2] || (e[2] = Qf((a) => t.autoHide && t.$emit("hide"), ["esc"]))
  }, [
    A("div", {
      class: "v-popper__backdrop",
      onClick: e[0] || (e[0] = (a) => t.autoHide && t.$emit("hide"))
    }),
    A("div", {
      class: "v-popper__wrapper",
      style: sn(t.result ? {
        transformOrigin: t.result.transformOrigin
      } : void 0)
    }, [
      A("div", e8, [
        t.mounted ? (P(), L(Yt, { key: 0 }, [
          A("div", null, [
            Wi(t.$slots, "default")
          ]),
          t.handleResize ? (P(), Re(o, {
            key: 0,
            onNotify: e[1] || (e[1] = (a) => t.$emit("resize", a))
          })) : ei("", !0)
        ], 64)) : ei("", !0)
      ], 512),
      A("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: sn(t.result ? {
          left: t.toPx(t.result.arrow.x),
          top: t.toPx(t.result.arrow.y)
        } : void 0)
      }, i8, 4)
    ], 4)
  ], 46, JD);
}
const c3 = /* @__PURE__ */ r0(KD, [["render", r8]]), u3 = {
  methods: {
    show(...t) {
      return this.$refs.popper.show(...t);
    },
    hide(...t) {
      return this.$refs.popper.hide(...t);
    },
    dispose(...t) {
      return this.$refs.popper.dispose(...t);
    },
    onResize(...t) {
      return this.$refs.popper.onResize(...t);
    }
  }
};
let pb = function() {
};
typeof window < "u" && (pb = window.Element);
const s8 = ke({
  name: "VPopperWrapper",
  components: {
    Popper: qD,
    PopperContent: c3
  },
  mixins: [
    u3,
    l3("finalTheme")
  ],
  props: {
    theme: {
      type: String,
      default: null
    },
    referenceNode: {
      type: Function,
      default: null
    },
    shown: {
      type: Boolean,
      default: !1
    },
    showGroup: {
      type: String,
      default: null
    },
    // eslint-disable-next-line vue/require-prop-types
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    positioningDisabled: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String,
      default: void 0
    },
    delay: {
      type: [String, Number, Object],
      default: void 0
    },
    distance: {
      type: [Number, String],
      default: void 0
    },
    skidding: {
      type: [Number, String],
      default: void 0
    },
    triggers: {
      type: Array,
      default: void 0
    },
    showTriggers: {
      type: [Array, Function],
      default: void 0
    },
    hideTriggers: {
      type: [Array, Function],
      default: void 0
    },
    popperTriggers: {
      type: Array,
      default: void 0
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: void 0
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: void 0
    },
    container: {
      type: [String, Object, pb, Boolean],
      default: void 0
    },
    boundary: {
      type: [String, pb],
      default: void 0
    },
    strategy: {
      type: String,
      default: void 0
    },
    autoHide: {
      type: [Boolean, Function],
      default: void 0
    },
    handleResize: {
      type: Boolean,
      default: void 0
    },
    instantMove: {
      type: Boolean,
      default: void 0
    },
    eagerMount: {
      type: Boolean,
      default: void 0
    },
    popperClass: {
      type: [String, Array, Object],
      default: void 0
    },
    computeTransformOrigin: {
      type: Boolean,
      default: void 0
    },
    /**
     * @deprecated
     */
    autoMinSize: {
      type: Boolean,
      default: void 0
    },
    autoSize: {
      type: [Boolean, String],
      default: void 0
    },
    /**
     * @deprecated
     */
    autoMaxSize: {
      type: Boolean,
      default: void 0
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: void 0
    },
    preventOverflow: {
      type: Boolean,
      default: void 0
    },
    overflowPadding: {
      type: [Number, String],
      default: void 0
    },
    arrowPadding: {
      type: [Number, String],
      default: void 0
    },
    arrowOverflow: {
      type: Boolean,
      default: void 0
    },
    flip: {
      type: Boolean,
      default: void 0
    },
    shift: {
      type: Boolean,
      default: void 0
    },
    shiftCrossAxis: {
      type: Boolean,
      default: void 0
    },
    noAutoFocus: {
      type: Boolean,
      default: void 0
    },
    disposeTimeout: {
      type: Number,
      default: void 0
    }
  },
  emits: {
    show: () => !0,
    hide: () => !0,
    "update:shown": (t) => !0,
    "apply-show": () => !0,
    "apply-hide": () => !0,
    "close-group": () => !0,
    "close-directive": () => !0,
    "auto-hide": () => !0,
    resize: () => !0
  },
  computed: {
    finalTheme() {
      return this.theme ?? this.$options.vPopperTheme;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$el.children).filter((t) => t !== this.$refs.popperContent.$el);
    }
  }
});
function o8(t, e, n, i, r, s) {
  const o = nr("PopperContent"), a = nr("Popper");
  return P(), Re(a, sr({ ref: "popper" }, t.$props, {
    theme: t.finalTheme,
    "target-nodes": t.getTargetNodes,
    "popper-node": () => t.$refs.popperContent.$el,
    class: [
      t.themeClass
    ],
    onShow: e[0] || (e[0] = () => t.$emit("show")),
    onHide: e[1] || (e[1] = () => t.$emit("hide")),
    "onUpdate:shown": e[2] || (e[2] = (l) => t.$emit("update:shown", l)),
    onApplyShow: e[3] || (e[3] = () => t.$emit("apply-show")),
    onApplyHide: e[4] || (e[4] = () => t.$emit("apply-hide")),
    onCloseGroup: e[5] || (e[5] = () => t.$emit("close-group")),
    onCloseDirective: e[6] || (e[6] = () => t.$emit("close-directive")),
    onAutoHide: e[7] || (e[7] = () => t.$emit("auto-hide")),
    onResize: e[8] || (e[8] = () => t.$emit("resize"))
  }), {
    default: ze(({
      popperId: l,
      isShown: c,
      shouldMountContent: u,
      skipTransition: d,
      autoHide: h,
      show: f,
      hide: p,
      handleResize: m,
      onResize: g,
      classes: b,
      result: _
    }) => [
      Wi(t.$slots, "default", {
        shown: c,
        show: f,
        hide: p
      }),
      fe(o, {
        ref: "popperContent",
        "popper-id": l,
        theme: t.finalTheme,
        shown: c,
        mounted: u,
        "skip-transition": d,
        "auto-hide": h,
        "handle-resize": m,
        classes: b,
        result: _,
        onHide: p,
        onResize: g
      }, {
        default: ze(() => [
          Wi(t.$slots, "popper", {
            shown: c,
            hide: p
          })
        ]),
        _: 2
      }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 3
  }, 16, ["theme", "target-nodes", "popper-node", "class"]);
}
const Vy = /* @__PURE__ */ r0(s8, [["render", o8]]), a8 = {
  ...Vy,
  name: "VDropdown",
  vPopperTheme: "dropdown"
}, l8 = {
  ...Vy,
  name: "VMenu",
  vPopperTheme: "menu"
}, c8 = {
  ...Vy,
  name: "VTooltip",
  vPopperTheme: "tooltip"
}, u8 = ke({
  name: "VTooltipDirective",
  components: {
    Popper: a3(),
    PopperContent: c3
  },
  mixins: [
    u3
  ],
  inheritAttrs: !1,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (t) => $u(t.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (t) => $u(t.theme, "loadingContent")
    },
    targetNodes: {
      type: Function,
      required: !0
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content == "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(!0);
      },
      immediate: !0
    },
    async finalContent() {
      await this.$nextTick(), this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(t) {
      if (typeof this.content == "function" && this.$_isShown && (t || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null, this.$_loading = !0;
        const e = ++this.$_fetchId, n = this.content(this);
        n.then ? n.then((i) => this.onResult(e, i)) : this.onResult(e, n);
      }
    },
    onResult(t, e) {
      t === this.$_fetchId && (this.$_loading = !1, this.asyncContent = e);
    },
    onShow() {
      this.$_isShown = !0, this.fetchContent();
    },
    onHide() {
      this.$_isShown = !1;
    }
  }
}), d8 = ["innerHTML"], h8 = ["textContent"];
function f8(t, e, n, i, r, s) {
  const o = nr("PopperContent"), a = nr("Popper");
  return P(), Re(a, sr({ ref: "popper" }, t.$attrs, {
    theme: t.theme,
    "target-nodes": t.targetNodes,
    "popper-node": () => t.$refs.popperContent.$el,
    onApplyShow: t.onShow,
    onApplyHide: t.onHide
  }), {
    default: ze(({
      popperId: l,
      isShown: c,
      shouldMountContent: u,
      skipTransition: d,
      autoHide: h,
      hide: f,
      handleResize: p,
      onResize: m,
      classes: g,
      result: b
    }) => [
      fe(o, {
        ref: "popperContent",
        class: Ot({
          "v-popper--tooltip-loading": t.loading
        }),
        "popper-id": l,
        theme: t.theme,
        shown: c,
        mounted: u,
        "skip-transition": d,
        "auto-hide": h,
        "handle-resize": p,
        classes: g,
        result: b,
        onHide: f,
        onResize: m
      }, {
        default: ze(() => [
          t.html ? (P(), L("div", {
            key: 0,
            innerHTML: t.finalContent
          }, null, 8, d8)) : (P(), L("div", {
            key: 1,
            textContent: Ft(t.finalContent)
          }, null, 8, h8))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]);
}
const p8 = /* @__PURE__ */ r0(u8, [["render", f8]]), d3 = "v-popper--has-tooltip";
function m8(t, e) {
  let n = t.placement;
  if (!n && e)
    for (const i of o3)
      e[i] && (n = i);
  return n || (n = $u(t.theme || "tooltip", "placement")), n;
}
function h3(t, e, n) {
  let i;
  const r = typeof e;
  return r === "string" ? i = { content: e } : e && r === "object" ? i = e : i = { content: !1 }, i.placement = m8(i, n), i.targetNodes = () => [t], i.referenceNode = () => t, i;
}
let fg, Du, g8 = 0;
function b8() {
  if (fg)
    return;
  Du = pt([]), fg = oD({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives: Du
      };
    },
    render() {
      return this.directives.map((e) => li(p8, {
        ...e.options,
        shown: e.shown || e.options.shown,
        key: e.id
      }));
    },
    devtools: {
      hide: !0
    }
  });
  const t = document.createElement("div");
  document.body.appendChild(t), fg.mount(t);
}
function O8(t, e, n) {
  b8();
  const i = pt(h3(t, e, n)), r = pt(!1), s = {
    id: g8++,
    options: i,
    shown: r
  };
  return Du.value.push(s), t.classList && t.classList.add(d3), t.$_popper = {
    options: i,
    item: s,
    show() {
      r.value = !0;
    },
    hide() {
      r.value = !1;
    }
  };
}
function f3(t) {
  if (t.$_popper) {
    const e = Du.value.indexOf(t.$_popper.item);
    e !== -1 && Du.value.splice(e, 1), delete t.$_popper, delete t.$_popperOldShown, delete t.$_popperMountTarget;
  }
  t.classList && t.classList.remove(d3);
}
function wv(t, { value: e, modifiers: n }) {
  const i = h3(t, e, n);
  if (!i.content || $u(i.theme || "tooltip", "disabled"))
    f3(t);
  else {
    let r;
    t.$_popper ? (r = t.$_popper, r.options.value = i) : r = O8(t, e, n), typeof e.shown < "u" && e.shown !== t.$_popperOldShown && (t.$_popperOldShown = e.shown, e.shown ? r.show() : r.hide());
  }
}
const y8 = {
  beforeMount: wv,
  updated: wv,
  beforeUnmount(t) {
    f3(t);
  }
}, mo = y8, Iu = a8, _8 = l8, p3 = c8, Ol = /* @__PURE__ */ ke({
  __name: "BlockActionButton",
  props: {
    tooltip: { default: void 0 },
    selected: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, n) => ut((P(), L("div", {
      class: Ot(["editor-block__actions-button", {
        "editor-block__actions-button--selected": e.selected
      }])
    }, [
      Wi(e.$slots, "icon")
    ], 2)), [
      [Z(mo), e.tooltip]
    ]);
  }
}), Ll = /* @__PURE__ */ ke({
  __name: "BlockActionInput",
  props: {
    tooltip: { default: void 0 },
    modelValue: { default: "" }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, i = e, r = Be({
      get: () => n.modelValue || "",
      set: (s) => i("update:modelValue", s)
    });
    return (s, o) => ut((P(), L("input", {
      "onUpdate:modelValue": o[0] || (o[0] = (a) => r.value = a),
      class: "editor-block__actions-input"
    }, null, 512)), [
      [
        Fn,
        r.value,
        void 0,
        {
          lazy: !0,
          trim: !0
        }
      ],
      [Z(mo), s.tooltip]
    ]);
  }
}), m3 = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [i, r] of e)
    n[i] = r;
  return n;
}, v8 = {}, x8 = { class: "editor-block__actions-separator" };
function w8(t, e) {
  return P(), L("div", x8);
}
const Qt = /* @__PURE__ */ m3(v8, [["render", w8]]), S8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, k8 = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M14.12 10.47L12 12.59l-2.13-2.12l-1.41 1.41L10.59 14l-2.12 2.12l1.41 1.41L12 15.41l2.12 2.12l1.41-1.41L13.41 14l2.12-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4zM6 19a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7H6zM8 9h8v10H8z"
}, null, -1), E8 = [
  k8
];
function C8(t, e) {
  return P(), L("svg", S8, [...E8]);
}
const A8 = { name: "mdi-delete-forever-outline", render: C8 }, Ua = /* @__PURE__ */ ke({
  __name: "MdiDeleteForeverOutline",
  setup(t) {
    return (e, n) => (P(), Re(Z(A8), { class: "text-red-600" }));
  }
});
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const gp = typeof window < "u", Ro = (t, e = !1) => e ? Symbol.for(t) : Symbol(t), T8 = (t, e, n) => M8({ l: t, k: e, s: n }), M8 = (t) => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), nn = (t) => typeof t == "number" && isFinite(t), P8 = (t) => b3(t) === "[object Date]", bp = (t) => b3(t) === "[object RegExp]", o0 = (t) => qe(t) && Object.keys(t).length === 0, En = Object.assign;
let Sv;
const Zy = () => Sv || (Sv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function kv(t) {
  return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const R8 = Object.prototype.hasOwnProperty;
function Op(t, e) {
  return R8.call(t, e);
}
const jt = Array.isArray, Dt = (t) => typeof t == "function", pe = (t) => typeof t == "string", Rt = (t) => typeof t == "boolean", st = (t) => t !== null && typeof t == "object", $8 = (t) => st(t) && Dt(t.then) && Dt(t.catch), g3 = Object.prototype.toString, b3 = (t) => g3.call(t), qe = (t) => {
  if (!st(t))
    return !1;
  const e = Object.getPrototypeOf(t);
  return e === null || e.constructor === Object;
}, N8 = (t) => t == null ? "" : jt(t) || qe(t) && t.toString === g3 ? JSON.stringify(t, null, 2) : String(t);
function D8(t, e = "") {
  return t.reduce((n, i, r) => r === 0 ? n + i : n + e + i, "");
}
function a0(t) {
  let e = t;
  return () => ++e;
}
function I8(t, e) {
  typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack));
}
const Sh = (t) => !st(t) || jt(t);
function zf(t, e) {
  if (Sh(t) || Sh(e))
    throw new Error("Invalid value");
  const n = [{ src: t, des: e }];
  for (; n.length; ) {
    const { src: i, des: r } = n.pop();
    Object.keys(i).forEach((s) => {
      Sh(i[s]) || Sh(r[s]) ? r[s] = i[s] : n.push({ src: i[s], des: r[s] });
    });
  }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function L8(t, e, n) {
  return { line: t, column: e, offset: n };
}
function yp(t, e, n) {
  return { start: t, end: e };
}
const B8 = /\{([0-9a-zA-Z]+)\}/g;
function O3(t, ...e) {
  return e.length === 1 && Q8(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(B8, (n, i) => e.hasOwnProperty(i) ? e[i] : "");
}
const y3 = Object.assign, Ev = (t) => typeof t == "string", Q8 = (t) => t !== null && typeof t == "object";
function _3(t, e = "") {
  return t.reduce((n, i, r) => r === 0 ? n + i : n + e + i, "");
}
const Hy = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
}, F8 = {
  [Hy.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
};
function z8(t, e, ...n) {
  const i = O3(F8[t], ...n || []), r = { message: String(i), code: t };
  return e && (r.location = e), r;
}
const Se = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
}, U8 = {
  // tokenizer error messages
  [Se.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [Se.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [Se.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [Se.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [Se.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [Se.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [Se.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [Se.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [Se.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [Se.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [Se.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [Se.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [Se.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [Se.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [Se.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [Se.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function fc(t, e, n = {}) {
  const { domain: i, messages: r, args: s } = n, o = O3((r || U8)[t] || "", ...s || []), a = new SyntaxError(String(o));
  return a.code = t, e && (a.location = e), a.domain = i, a;
}
function W8(t) {
  throw t;
}
const ss = " ", V8 = "\r", Nn = `
`, Z8 = "\u2028", H8 = "\u2029";
function q8(t) {
  const e = t;
  let n = 0, i = 1, r = 1, s = 0;
  const o = (w) => e[w] === V8 && e[w + 1] === Nn, a = (w) => e[w] === Nn, l = (w) => e[w] === H8, c = (w) => e[w] === Z8, u = (w) => o(w) || a(w) || l(w) || c(w), d = () => n, h = () => i, f = () => r, p = () => s, m = (w) => o(w) || l(w) || c(w) ? Nn : e[w], g = () => m(n), b = () => m(n + s);
  function _() {
    return s = 0, u(n) && (i++, r = 0), o(n) && n++, n++, r++, e[n];
  }
  function y() {
    return o(n + s) && s++, s++, e[n + s];
  }
  function O() {
    n = 0, i = 1, r = 1, s = 0;
  }
  function x(w = 0) {
    s = w;
  }
  function v() {
    const w = n + s;
    for (; w !== n; )
      _();
    s = 0;
  }
  return {
    index: d,
    line: h,
    column: f,
    peekOffset: p,
    charAt: m,
    currentChar: g,
    currentPeek: b,
    next: _,
    peek: y,
    reset: O,
    resetPeek: x,
    skipToPeek: v
  };
}
const Ds = void 0, X8 = ".", Cv = "'", j8 = "tokenizer";
function Y8(t, e = {}) {
  const n = e.location !== !1, i = q8(t), r = () => i.index(), s = () => L8(i.line(), i.column(), i.index()), o = s(), a = r(), l = {
    currentType: 14,
    offset: a,
    startLoc: o,
    endLoc: o,
    lastType: 14,
    lastOffset: a,
    lastStartLoc: o,
    lastEndLoc: o,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, c = () => l, { onError: u } = e;
  function d(M, C, B, ...oe) {
    const Ce = c();
    if (C.column += B, C.offset += B, u) {
      const ye = n ? yp(Ce.startLoc, C) : null, U = fc(M, ye, {
        domain: j8,
        args: oe
      });
      u(U);
    }
  }
  function h(M, C, B) {
    M.endLoc = s(), M.currentType = C;
    const oe = { type: C };
    return n && (oe.loc = yp(M.startLoc, M.endLoc)), B != null && (oe.value = B), oe;
  }
  const f = (M) => h(
    M,
    14
    /* TokenTypes.EOF */
  );
  function p(M, C) {
    return M.currentChar() === C ? (M.next(), C) : (d(Se.EXPECTED_TOKEN, s(), 0, C), "");
  }
  function m(M) {
    let C = "";
    for (; M.currentPeek() === ss || M.currentPeek() === Nn; )
      C += M.currentPeek(), M.peek();
    return C;
  }
  function g(M) {
    const C = m(M);
    return M.skipToPeek(), C;
  }
  function b(M) {
    if (M === Ds)
      return !1;
    const C = M.charCodeAt(0);
    return C >= 97 && C <= 122 || // a-z
    C >= 65 && C <= 90 || // A-Z
    C === 95;
  }
  function _(M) {
    if (M === Ds)
      return !1;
    const C = M.charCodeAt(0);
    return C >= 48 && C <= 57;
  }
  function y(M, C) {
    const { currentType: B } = C;
    if (B !== 2)
      return !1;
    m(M);
    const oe = b(M.currentPeek());
    return M.resetPeek(), oe;
  }
  function O(M, C) {
    const { currentType: B } = C;
    if (B !== 2)
      return !1;
    m(M);
    const oe = M.currentPeek() === "-" ? M.peek() : M.currentPeek(), Ce = _(oe);
    return M.resetPeek(), Ce;
  }
  function x(M, C) {
    const { currentType: B } = C;
    if (B !== 2)
      return !1;
    m(M);
    const oe = M.currentPeek() === Cv;
    return M.resetPeek(), oe;
  }
  function v(M, C) {
    const { currentType: B } = C;
    if (B !== 8)
      return !1;
    m(M);
    const oe = M.currentPeek() === ".";
    return M.resetPeek(), oe;
  }
  function w(M, C) {
    const { currentType: B } = C;
    if (B !== 9)
      return !1;
    m(M);
    const oe = b(M.currentPeek());
    return M.resetPeek(), oe;
  }
  function T(M, C) {
    const { currentType: B } = C;
    if (!(B === 8 || B === 12))
      return !1;
    m(M);
    const oe = M.currentPeek() === ":";
    return M.resetPeek(), oe;
  }
  function S(M, C) {
    const { currentType: B } = C;
    if (B !== 10)
      return !1;
    const oe = () => {
      const ye = M.currentPeek();
      return ye === "{" ? b(M.peek()) : ye === "@" || ye === "%" || ye === "|" || ye === ":" || ye === "." || ye === ss || !ye ? !1 : ye === Nn ? (M.peek(), oe()) : F(M, !1);
    }, Ce = oe();
    return M.resetPeek(), Ce;
  }
  function $(M) {
    m(M);
    const C = M.currentPeek() === "|";
    return M.resetPeek(), C;
  }
  function I(M) {
    const C = m(M), B = M.currentPeek() === "%" && M.peek() === "{";
    return M.resetPeek(), {
      isModulo: B,
      hasSpace: C.length > 0
    };
  }
  function F(M, C = !0) {
    const B = (Ce = !1, ye = "", U = !1) => {
      const E = M.currentPeek();
      return E === "{" ? ye === "%" ? !1 : Ce : E === "@" || !E ? ye === "%" ? !0 : Ce : E === "%" ? (M.peek(), B(Ce, "%", !0)) : E === "|" ? ye === "%" || U ? !0 : !(ye === ss || ye === Nn) : E === ss ? (M.peek(), B(!0, ss, U)) : E === Nn ? (M.peek(), B(!0, Nn, U)) : !0;
    }, oe = B();
    return C && M.resetPeek(), oe;
  }
  function V(M, C) {
    const B = M.currentChar();
    return B === Ds ? Ds : C(B) ? (M.next(), B) : null;
  }
  function q(M) {
    const C = M.charCodeAt(0);
    return C >= 97 && C <= 122 || // a-z
    C >= 65 && C <= 90 || // A-Z
    C >= 48 && C <= 57 || // 0-9
    C === 95 || // _
    C === 36;
  }
  function K(M) {
    return V(M, q);
  }
  function ie(M) {
    const C = M.charCodeAt(0);
    return C >= 97 && C <= 122 || // a-z
    C >= 65 && C <= 90 || // A-Z
    C >= 48 && C <= 57 || // 0-9
    C === 95 || // _
    C === 36 || // $
    C === 45;
  }
  function k(M) {
    return V(M, ie);
  }
  function N(M) {
    const C = M.charCodeAt(0);
    return C >= 48 && C <= 57;
  }
  function W(M) {
    return V(M, N);
  }
  function X(M) {
    const C = M.charCodeAt(0);
    return C >= 48 && C <= 57 || // 0-9
    C >= 65 && C <= 70 || // A-F
    C >= 97 && C <= 102;
  }
  function ee(M) {
    return V(M, X);
  }
  function re(M) {
    let C = "", B = "";
    for (; C = W(M); )
      B += C;
    return B;
  }
  function xe(M) {
    g(M);
    const C = M.currentChar();
    return C !== "%" && d(Se.EXPECTED_TOKEN, s(), 0, C), M.next(), "%";
  }
  function $e(M) {
    let C = "";
    for (; ; ) {
      const B = M.currentChar();
      if (B === "{" || B === "}" || B === "@" || B === "|" || !B)
        break;
      if (B === "%")
        if (F(M))
          C += B, M.next();
        else
          break;
      else if (B === ss || B === Nn)
        if (F(M))
          C += B, M.next();
        else {
          if ($(M))
            break;
          C += B, M.next();
        }
      else
        C += B, M.next();
    }
    return C;
  }
  function be(M) {
    g(M);
    let C = "", B = "";
    for (; C = k(M); )
      B += C;
    return M.currentChar() === Ds && d(Se.UNTERMINATED_CLOSING_BRACE, s(), 0), B;
  }
  function we(M) {
    g(M);
    let C = "";
    return M.currentChar() === "-" ? (M.next(), C += `-${re(M)}`) : C += re(M), M.currentChar() === Ds && d(Se.UNTERMINATED_CLOSING_BRACE, s(), 0), C;
  }
  function St(M) {
    return M !== Cv && M !== Nn;
  }
  function it(M) {
    g(M), p(M, "'");
    let C = "", B = "";
    for (; C = V(M, St); )
      C === "\\" ? B += rt(M) : B += C;
    const oe = M.currentChar();
    return oe === Nn || oe === Ds ? (d(Se.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0), oe === Nn && (M.next(), p(M, "'")), B) : (p(M, "'"), B);
  }
  function rt(M) {
    const C = M.currentChar();
    switch (C) {
      case "\\":
      case "'":
        return M.next(), `\\${C}`;
      case "u":
        return et(M, C, 4);
      case "U":
        return et(M, C, 6);
      default:
        return d(Se.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, C), "";
    }
  }
  function et(M, C, B) {
    p(M, C);
    let oe = "";
    for (let Ce = 0; Ce < B; Ce++) {
      const ye = ee(M);
      if (!ye) {
        d(Se.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${C}${oe}${M.currentChar()}`);
        break;
      }
      oe += ye;
    }
    return `\\${C}${oe}`;
  }
  function It(M) {
    return M !== "{" && M !== "}" && M !== ss && M !== Nn;
  }
  function qt(M) {
    g(M);
    let C = "", B = "";
    for (; C = V(M, It); )
      B += C;
    return B;
  }
  function Te(M) {
    let C = "", B = "";
    for (; C = K(M); )
      B += C;
    return B;
  }
  function gt(M) {
    const C = (B) => {
      const oe = M.currentChar();
      return oe === "{" || oe === "%" || oe === "@" || oe === "|" || oe === "(" || oe === ")" || !oe || oe === ss ? B : (B += oe, M.next(), C(B));
    };
    return C("");
  }
  function kt(M) {
    g(M);
    const C = p(
      M,
      "|"
      /* TokenChars.Pipe */
    );
    return g(M), C;
  }
  function Qe(M, C) {
    let B = null;
    switch (M.currentChar()) {
      case "{":
        return C.braceNest >= 1 && d(Se.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0), M.next(), B = h(
          C,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), g(M), C.braceNest++, B;
      case "}":
        return C.braceNest > 0 && C.currentType === 2 && d(Se.EMPTY_PLACEHOLDER, s(), 0), M.next(), B = h(
          C,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), C.braceNest--, C.braceNest > 0 && g(M), C.inLinked && C.braceNest === 0 && (C.inLinked = !1), B;
      case "@":
        return C.braceNest > 0 && d(Se.UNTERMINATED_CLOSING_BRACE, s(), 0), B = yn(M, C) || f(C), C.braceNest = 0, B;
      default: {
        let Ce = !0, ye = !0, U = !0;
        if ($(M))
          return C.braceNest > 0 && d(Se.UNTERMINATED_CLOSING_BRACE, s(), 0), B = h(C, 1, kt(M)), C.braceNest = 0, C.inLinked = !1, B;
        if (C.braceNest > 0 && (C.currentType === 5 || C.currentType === 6 || C.currentType === 7))
          return d(Se.UNTERMINATED_CLOSING_BRACE, s(), 0), C.braceNest = 0, Gt(M, C);
        if (Ce = y(M, C))
          return B = h(C, 5, be(M)), g(M), B;
        if (ye = O(M, C))
          return B = h(C, 6, we(M)), g(M), B;
        if (U = x(M, C))
          return B = h(C, 7, it(M)), g(M), B;
        if (!Ce && !ye && !U)
          return B = h(C, 13, qt(M)), d(Se.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, B.value), g(M), B;
        break;
      }
    }
    return B;
  }
  function yn(M, C) {
    const { currentType: B } = C;
    let oe = null;
    const Ce = M.currentChar();
    switch ((B === 8 || B === 9 || B === 12 || B === 10) && (Ce === Nn || Ce === ss) && d(Se.INVALID_LINKED_FORMAT, s(), 0), Ce) {
      case "@":
        return M.next(), oe = h(
          C,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        ), C.inLinked = !0, oe;
      case ".":
        return g(M), M.next(), h(
          C,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return g(M), M.next(), h(
          C,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return $(M) ? (oe = h(C, 1, kt(M)), C.braceNest = 0, C.inLinked = !1, oe) : v(M, C) || T(M, C) ? (g(M), yn(M, C)) : w(M, C) ? (g(M), h(C, 12, Te(M))) : S(M, C) ? (g(M), Ce === "{" ? Qe(M, C) || oe : h(C, 11, gt(M))) : (B === 8 && d(Se.INVALID_LINKED_FORMAT, s(), 0), C.braceNest = 0, C.inLinked = !1, Gt(M, C));
    }
  }
  function Gt(M, C) {
    let B = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (C.braceNest > 0)
      return Qe(M, C) || f(C);
    if (C.inLinked)
      return yn(M, C) || f(C);
    switch (M.currentChar()) {
      case "{":
        return Qe(M, C) || f(C);
      case "}":
        return d(Se.UNBALANCED_CLOSING_BRACE, s(), 0), M.next(), h(
          C,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return yn(M, C) || f(C);
      default: {
        if ($(M))
          return B = h(C, 1, kt(M)), C.braceNest = 0, C.inLinked = !1, B;
        const { isModulo: Ce, hasSpace: ye } = I(M);
        if (Ce)
          return ye ? h(C, 0, $e(M)) : h(C, 4, xe(M));
        if (F(M))
          return h(C, 0, $e(M));
        break;
      }
    }
    return B;
  }
  function J() {
    const { currentType: M, offset: C, startLoc: B, endLoc: oe } = l;
    return l.lastType = M, l.lastOffset = C, l.lastStartLoc = B, l.lastEndLoc = oe, l.offset = r(), l.startLoc = s(), i.currentChar() === Ds ? h(
      l,
      14
      /* TokenTypes.EOF */
    ) : Gt(i, l);
  }
  return {
    nextToken: J,
    currentOffset: r,
    currentPosition: s,
    context: c
  };
}
const G8 = "parser", K8 = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function J8(t, e, n) {
  switch (t) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const i = parseInt(e || n, 16);
      return i <= 55295 || i >= 57344 ? String.fromCodePoint(i) : "";
    }
  }
}
function eI(t = {}) {
  const e = t.location !== !1, { onError: n, onWarn: i } = t;
  function r(y, O, x, v, ...w) {
    const T = y.currentPosition();
    if (T.offset += v, T.column += v, n) {
      const S = e ? yp(x, T) : null, $ = fc(O, S, {
        domain: G8,
        args: w
      });
      n($);
    }
  }
  function s(y, O, x, v, ...w) {
    const T = y.currentPosition();
    if (T.offset += v, T.column += v, i) {
      const S = e ? yp(x, T) : null;
      i(z8(O, S, w));
    }
  }
  function o(y, O, x) {
    const v = { type: y };
    return e && (v.start = O, v.end = O, v.loc = { start: x, end: x }), v;
  }
  function a(y, O, x, v) {
    e && (y.end = O, y.loc && (y.loc.end = x));
  }
  function l(y, O) {
    const x = y.context(), v = o(3, x.offset, x.startLoc);
    return v.value = O, a(v, y.currentOffset(), y.currentPosition()), v;
  }
  function c(y, O) {
    const x = y.context(), { lastOffset: v, lastStartLoc: w } = x, T = o(5, v, w);
    return T.index = parseInt(O, 10), y.nextToken(), a(T, y.currentOffset(), y.currentPosition()), T;
  }
  function u(y, O, x) {
    const v = y.context(), { lastOffset: w, lastStartLoc: T } = v, S = o(4, w, T);
    return S.key = O, x === !0 && (S.modulo = !0), y.nextToken(), a(S, y.currentOffset(), y.currentPosition()), S;
  }
  function d(y, O) {
    const x = y.context(), { lastOffset: v, lastStartLoc: w } = x, T = o(9, v, w);
    return T.value = O.replace(K8, J8), y.nextToken(), a(T, y.currentOffset(), y.currentPosition()), T;
  }
  function h(y) {
    const O = y.nextToken(), x = y.context(), { lastOffset: v, lastStartLoc: w } = x, T = o(8, v, w);
    return O.type !== 12 ? (r(y, Se.UNEXPECTED_EMPTY_LINKED_MODIFIER, x.lastStartLoc, 0), T.value = "", a(T, v, w), {
      nextConsumeToken: O,
      node: T
    }) : (O.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, Ji(O)), T.value = O.value || "", a(T, y.currentOffset(), y.currentPosition()), {
      node: T
    });
  }
  function f(y, O) {
    const x = y.context(), v = o(7, x.offset, x.startLoc);
    return v.value = O, a(v, y.currentOffset(), y.currentPosition()), v;
  }
  function p(y) {
    const O = y.context(), x = o(6, O.offset, O.startLoc);
    let v = y.nextToken();
    if (v.type === 9) {
      const w = h(y);
      x.modifier = w.node, v = w.nextConsumeToken || y.nextToken();
    }
    switch (v.type !== 10 && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(v)), v = y.nextToken(), v.type === 2 && (v = y.nextToken()), v.type) {
      case 11:
        v.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(v)), x.key = f(y, v.value || "");
        break;
      case 5:
        v.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(v)), x.key = u(y, v.value || "");
        break;
      case 6:
        v.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(v)), x.key = c(y, v.value || "");
        break;
      case 7:
        v.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(v)), x.key = d(y, v.value || "");
        break;
      default: {
        r(y, Se.UNEXPECTED_EMPTY_LINKED_KEY, O.lastStartLoc, 0);
        const w = y.context(), T = o(7, w.offset, w.startLoc);
        return T.value = "", a(T, w.offset, w.startLoc), x.key = T, a(x, w.offset, w.startLoc), {
          nextConsumeToken: v,
          node: x
        };
      }
    }
    return a(x, y.currentOffset(), y.currentPosition()), {
      node: x
    };
  }
  function m(y) {
    const O = y.context(), x = O.currentType === 1 ? y.currentOffset() : O.offset, v = O.currentType === 1 ? O.endLoc : O.startLoc, w = o(2, x, v);
    w.items = [];
    let T = null, S = null;
    do {
      const F = T || y.nextToken();
      switch (T = null, F.type) {
        case 0:
          F.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(F)), w.items.push(l(y, F.value || ""));
          break;
        case 6:
          F.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(F)), w.items.push(c(y, F.value || ""));
          break;
        case 4:
          S = !0;
          break;
        case 5:
          F.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(F)), w.items.push(u(y, F.value || "", !!S)), S && (s(y, Hy.USE_MODULO_SYNTAX, O.lastStartLoc, 0, Ji(F)), S = null);
          break;
        case 7:
          F.value == null && r(y, Se.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, Ji(F)), w.items.push(d(y, F.value || ""));
          break;
        case 8: {
          const V = p(y);
          w.items.push(V.node), T = V.nextConsumeToken || null;
          break;
        }
      }
    } while (O.currentType !== 14 && O.currentType !== 1);
    const $ = O.currentType === 1 ? O.lastOffset : y.currentOffset(), I = O.currentType === 1 ? O.lastEndLoc : y.currentPosition();
    return a(w, $, I), w;
  }
  function g(y, O, x, v) {
    const w = y.context();
    let T = v.items.length === 0;
    const S = o(1, O, x);
    S.cases = [], S.cases.push(v);
    do {
      const $ = m(y);
      T || (T = $.items.length === 0), S.cases.push($);
    } while (w.currentType !== 14);
    return T && r(y, Se.MUST_HAVE_MESSAGES_IN_PLURAL, x, 0), a(S, y.currentOffset(), y.currentPosition()), S;
  }
  function b(y) {
    const O = y.context(), { offset: x, startLoc: v } = O, w = m(y);
    return O.currentType === 14 ? w : g(y, x, v, w);
  }
  function _(y) {
    const O = Y8(y, y3({}, t)), x = O.context(), v = o(0, x.offset, x.startLoc);
    return e && v.loc && (v.loc.source = y), v.body = b(O), t.onCacheKey && (v.cacheKey = t.onCacheKey(y)), x.currentType !== 14 && r(O, Se.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, y[x.offset] || ""), a(v, O.currentOffset(), O.currentPosition()), v;
  }
  return { parse: _ };
}
function Ji(t) {
  if (t.type === 14)
    return "EOF";
  const e = (t.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "" : e;
}
function tI(t, e = {}) {
  const n = {
    ast: t,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (s) => (n.helpers.add(s), s) };
}
function Av(t, e) {
  for (let n = 0; n < t.length; n++)
    qy(t[n], e);
}
function qy(t, e) {
  switch (t.type) {
    case 1:
      Av(t.cases, e), e.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      Av(t.items, e);
      break;
    case 6: {
      qy(t.key, e), e.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), e.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function nI(t, e = {}) {
  const n = tI(t);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), t.body && qy(t.body, n);
  const i = n.context();
  t.helpers = Array.from(i.helpers);
}
function iI(t) {
  const e = t.body;
  return e.type === 2 ? Tv(e) : e.cases.forEach((n) => Tv(n)), t;
}
function Tv(t) {
  if (t.items.length === 1) {
    const e = t.items[0];
    (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value);
  } else {
    const e = [];
    for (let n = 0; n < t.items.length; n++) {
      const i = t.items[n];
      if (!(i.type === 3 || i.type === 9) || i.value == null)
        break;
      e.push(i.value);
    }
    if (e.length === t.items.length) {
      t.static = _3(e);
      for (let n = 0; n < t.items.length; n++) {
        const i = t.items[n];
        (i.type === 3 || i.type === 9) && delete i.value;
      }
    }
  }
}
const rI = "minifier";
function ll(t) {
  switch (t.t = t.type, t.type) {
    case 0: {
      const e = t;
      ll(e.body), e.b = e.body, delete e.body;
      break;
    }
    case 1: {
      const e = t, n = e.cases;
      for (let i = 0; i < n.length; i++)
        ll(n[i]);
      e.c = n, delete e.cases;
      break;
    }
    case 2: {
      const e = t, n = e.items;
      for (let i = 0; i < n.length; i++)
        ll(n[i]);
      e.i = n, delete e.items, e.static && (e.s = e.static, delete e.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = t;
      e.value && (e.v = e.value, delete e.value);
      break;
    }
    case 6: {
      const e = t;
      ll(e.key), e.k = e.key, delete e.key, e.modifier && (ll(e.modifier), e.m = e.modifier, delete e.modifier);
      break;
    }
    case 5: {
      const e = t;
      e.i = e.index, delete e.index;
      break;
    }
    case 4: {
      const e = t;
      e.k = e.key, delete e.key;
      break;
    }
    default:
      throw fc(Se.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: rI,
        args: [t.type]
      });
  }
  delete t.type;
}
const sI = "parser";
function oI(t, e) {
  const { sourceMap: n, filename: i, breakLineCode: r, needIndent: s } = e, o = e.location !== !1, a = {
    filename: i,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: r,
    needIndent: s,
    indentLevel: 0
  };
  o && t.loc && (a.source = t.loc.source);
  const l = () => a;
  function c(g, b) {
    a.code += g;
  }
  function u(g, b = !0) {
    const _ = b ? r : "";
    c(s ? _ + "  ".repeat(g) : _);
  }
  function d(g = !0) {
    const b = ++a.indentLevel;
    g && u(b);
  }
  function h(g = !0) {
    const b = --a.indentLevel;
    g && u(b);
  }
  function f() {
    u(a.indentLevel);
  }
  return {
    context: l,
    push: c,
    indent: d,
    deindent: h,
    newline: f,
    helper: (g) => `_${g}`,
    needIndent: () => a.needIndent
  };
}
function aI(t, e) {
  const { helper: n } = t;
  t.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), Bl(t, e.key), e.modifier ? (t.push(", "), Bl(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")");
}
function lI(t, e) {
  const { helper: n, needIndent: i } = t;
  t.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), t.indent(i());
  const r = e.items.length;
  for (let s = 0; s < r && (Bl(t, e.items[s]), s !== r - 1); s++)
    t.push(", ");
  t.deindent(i()), t.push("])");
}
function cI(t, e) {
  const { helper: n, needIndent: i } = t;
  if (e.cases.length > 1) {
    t.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), t.indent(i());
    const r = e.cases.length;
    for (let s = 0; s < r && (Bl(t, e.cases[s]), s !== r - 1); s++)
      t.push(", ");
    t.deindent(i()), t.push("])");
  }
}
function uI(t, e) {
  e.body ? Bl(t, e.body) : t.push("null");
}
function Bl(t, e) {
  const { helper: n } = t;
  switch (e.type) {
    case 0:
      uI(t, e);
      break;
    case 1:
      cI(t, e);
      break;
    case 2:
      lI(t, e);
      break;
    case 6:
      aI(t, e);
      break;
    case 8:
      t.push(JSON.stringify(e.value), e);
      break;
    case 7:
      t.push(JSON.stringify(e.value), e);
      break;
    case 5:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${e.index}))`, e);
      break;
    case 4:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(e.key)}))`, e);
      break;
    case 9:
      t.push(JSON.stringify(e.value), e);
      break;
    case 3:
      t.push(JSON.stringify(e.value), e);
      break;
    default:
      throw fc(Se.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: sI,
        args: [e.type]
      });
  }
}
const dI = (t, e = {}) => {
  const n = Ev(e.mode) ? e.mode : "normal", i = Ev(e.filename) ? e.filename : "message.intl", r = !!e.sourceMap, s = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`, o = e.needIndent ? e.needIndent : n !== "arrow", a = t.helpers || [], l = oI(t, {
    mode: n,
    filename: i,
    sourceMap: r,
    breakLineCode: s,
    needIndent: o
  });
  l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(o), a.length > 0 && (l.push(`const { ${_3(a.map((d) => `${d}: _${d}`), ", ")} } = ctx`), l.newline()), l.push("return "), Bl(l, t), l.deindent(o), l.push("}"), delete t.helpers;
  const { code: c, map: u } = l.context();
  return {
    ast: t,
    code: c,
    map: u ? u.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function hI(t, e = {}) {
  const n = y3({}, e), i = !!n.jit, r = !!n.minify, s = n.optimize == null ? !0 : n.optimize, a = eI(n).parse(t);
  return i ? (s && iI(a), r && ll(a), { ast: a, code: "" }) : (nI(a, n), dI(a, n));
}
var fI = { ALLUSERSPROFILE: "C:\\ProgramData", APPCODE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\appcode.vmoptions", APPDATA: "C:\\Users\\51923\\AppData\\Roaming", "asl.log": "Destination=file", CATALINA_HOME: "D:\\Program Files (x86)\\apache-tomcat-9.0.84-windows-x64\\apache-tomcat-9.0.84", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133657579525662721", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_3964_AJVANIKVVIFJLRUS", CLASSPATH: ".;D:\\Program Files\\Java\\jdk-17\\lib\\dt.jar;D:\\Program Files\\Java\\jdk-17\\lib\\tools.jar", CLION_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\clion.vmoptions", COLOR: "1", COLORTERM: "truecolor", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "INSPIRON5593", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DATAGRIP_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\datagrip.vmoptions", DATASPELL_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\dataspell.vmoptions", DEVECOSTUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\devecostudio.vmoptions", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GATEWAY_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\gateway.vmoptions", GIT_ASKPASS: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", GOLAND_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\goland.vmoptions", HOME: "C:\\Users\\51923", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\51923", IDEA_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\idea.vmoptions", INIT_CWD: "D:\\editor", "IntelliJ IDEA": "E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;", JAVA_HOME: "D:\\Program Files\\Java\\jdk-17", JETBRAINSCLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrainsclient.vmoptions", JETBRAINS_CLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrains_client.vmoptions", LANG: "zh_CN.UTF-8", LOCALAPPDATA: "C:\\Users\\51923\\AppData\\Local", LOGONSERVER: "\\\\INSPIRON5593", Maven_Home: "D:\\apache-maven-3.9.5", MAVEN_OPTS: "-Xms128m -Xmx512m", NODE: "E:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_PATH: "D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\bin\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules;D:\\editor\\node_modules\\.pnpm\\node_modules", npm_command: "run-script", npm_config_cache: "C:\\Users\\51923\\AppData\\Local\\npm-cache", npm_config_chromedriver_cdnurl: "https://npm.taobao.org/mirrors/chromedriver/", npm_config_electron_builder_binaries_mirror: "https://npm.taobao.org/mirrors/electron-builder-binaries/", npm_config_electron_mirror: "https://npm.taobao.org/mirrors/electron/", npm_config_fetch_retry_maxtimeout: "120000", npm_config_fetch_retry_mintimeout: "20000", npm_config_globalconfig: "E:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "E:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\51923\\.npm-init.js", npm_config_local_prefix: "D:\\editor", npm_config_node_gyp: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.8.2", npm_config_prefix: "E:\\Program Files\\nodejs", npm_config_registry: "https://registry.npmmirror.com", npm_config_userconfig: "C:\\Users\\51923\\.npmrc", npm_config_user_agent: "npm/10.8.2 node/v18.19.0 win32 x64 workspaces/false", npm_execpath: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build --config ./vite.lib.config.ts", npm_node_execpath: "E:\\Program Files\\nodejs\\node.exe", npm_package_json: "D:\\editor\\package.json", npm_package_name: "hf-richtext", npm_package_version: "1.1.0", NUMBER_OF_PROCESSORS: "8", NVM_HOME: "E:\\Program Files (x86)\\nvm", NVM_SYMLINK: "E:\\Program Files\\nodejs", OneDrive: "C:\\Users\\51923\\OneDrive", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", Path: "D:\\editor\\node_modules\\.bin;D:\\node_modules\\.bin;E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Common Files\\Oracle\\Java\\javapath;D:\\Program Files\\Java\\jdk-17\\bin;D:\\Program Files\\Java\\jdk-17\\jre\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;E:\\tomcat\\apache-tomcat-8.5.11\\bin;E:\\mysql-5.6\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\apache-maven-3.9.5\\bin\\;E:\\Program Files\\Git\\cmd;E:\\Program Files\\TortoiseGit\\bin;E:\\Program Files (x86)\\Tencent\\web\\dll;E:\\Program Files\\Redis\\;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;C:\\Program Files\\dotnet\\;C:\\Users\\51923\\AppData\\Local\\Yarn\\bin;D:\\apache-maven-3.9.5\\bin;C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin;%CATALIN A_HOM E%\\bin;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\Scripts\\;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\;E:\\Programs\\Python\\Python38-32\\Scripts\\;E:\\Programs\\Python\\Python38-32\\;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin\\;C:\\Users\\51923\\AppData\\Local\\Microsoft\\WindowsApps;E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;E:\\Programs\\Microsoft VS Code\\bin;C:\\Users\\51923\\AppData\\Roaming\\npm;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;E:\\Program Files\\JetBrains\\PyCharm 2023.2.1\\bin;E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\OpenSSL-Win64\\bin;", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.CPL", PHPSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\phpstorm.vmoptions", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 126 Stepping 5, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "7e05", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "D:\\360MoveData\\Users\\51923\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", PyCharm: "E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;", PYCHARM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\pycharm.vmoptions", RIDER_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rider.vmoptions", RUBYMINE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rubymine.vmoptions", SESSIONNAME: "Console", STUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\studio.vmoptions", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\51923\\AppData\\Local\\Temp", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.91.1", TMP: "C:\\Users\\51923\\AppData\\Local\\Temp", USERDOMAIN: "INSPIRON5593", USERDOMAIN_ROAMINGPROFILE: "INSPIRON5593", USERNAME: "51923", USERPROFILE: "C:\\Users\\51923", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "", VSCODE_GIT_ASKPASS_MAIN: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "E:\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-c773be81e1-sock", VSCODE_INJECTION: "1", WEBIDE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webide.vmoptions", WEBSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webstorm.vmoptions", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
function pI() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Zy().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const $o = [];
$o[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
$o[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
$o[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
$o[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
$o[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
$o[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
$o[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const mI = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function gI(t) {
  return mI.test(t);
}
function bI(t) {
  const e = t.charCodeAt(0), n = t.charCodeAt(t.length - 1);
  return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t;
}
function OI(t) {
  if (t == null)
    return "o";
  switch (t.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return t;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function yI(t) {
  const e = t.trim();
  return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : gI(e) ? bI(e) : "*" + e;
}
function _I(t) {
  const e = [];
  let n = -1, i = 0, r = 0, s, o, a, l, c, u, d;
  const h = [];
  h[
    0
    /* Actions.APPEND */
  ] = () => {
    o === void 0 ? o = a : o += a;
  }, h[
    1
    /* Actions.PUSH */
  ] = () => {
    o !== void 0 && (e.push(o), o = void 0);
  }, h[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    h[
      0
      /* Actions.APPEND */
    ](), r++;
  }, h[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (r > 0)
      r--, i = 4, h[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (r = 0, o === void 0 || (o = yI(o), o === !1))
        return !1;
      h[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function f() {
    const p = t[n + 1];
    if (i === 5 && p === "'" || i === 6 && p === '"')
      return n++, a = "\\" + p, h[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; i !== null; )
    if (n++, s = t[n], !(s === "\\" && f())) {
      if (l = OI(s), d = $o[i], c = d[l] || d.l || 8, c === 8 || (i = c[0], c[1] !== void 0 && (u = h[c[1]], u && (a = s, u() === !1))))
        return;
      if (i === 7)
        return e;
    }
}
const Mv = /* @__PURE__ */ new Map();
function vI(t, e) {
  return st(t) ? t[e] : null;
}
function xI(t, e) {
  if (!st(t))
    return null;
  let n = Mv.get(e);
  if (n || (n = _I(e), n && Mv.set(e, n)), !n)
    return null;
  const i = n.length;
  let r = t, s = 0;
  for (; s < i; ) {
    const o = r[n[s]];
    if (o === void 0 || Dt(r))
      return null;
    r = o, s++;
  }
  return r;
}
const wI = (t) => t, SI = (t) => "", kI = "text", EI = (t) => t.length === 0 ? "" : D8(t), CI = N8;
function Pv(t, e) {
  return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0;
}
function AI(t) {
  const e = nn(t.pluralIndex) ? t.pluralIndex : -1;
  return t.named && (nn(t.named.count) || nn(t.named.n)) ? nn(t.named.count) ? t.named.count : nn(t.named.n) ? t.named.n : e : e;
}
function TI(t, e) {
  e.count || (e.count = t), e.n || (e.n = t);
}
function MI(t = {}) {
  const e = t.locale, n = AI(t), i = st(t.pluralRules) && pe(e) && Dt(t.pluralRules[e]) ? t.pluralRules[e] : Pv, r = st(t.pluralRules) && pe(e) && Dt(t.pluralRules[e]) ? Pv : void 0, s = (b) => b[i(n, b.length, r)], o = t.list || [], a = (b) => o[b], l = t.named || {};
  nn(t.pluralIndex) && TI(n, l);
  const c = (b) => l[b];
  function u(b) {
    const _ = Dt(t.messages) ? t.messages(b) : st(t.messages) ? t.messages[b] : !1;
    return _ || (t.parent ? t.parent.message(b) : SI);
  }
  const d = (b) => t.modifiers ? t.modifiers[b] : wI, h = qe(t.processor) && Dt(t.processor.normalize) ? t.processor.normalize : EI, f = qe(t.processor) && Dt(t.processor.interpolate) ? t.processor.interpolate : CI, p = qe(t.processor) && pe(t.processor.type) ? t.processor.type : kI, g = {
    list: a,
    named: c,
    plural: s,
    linked: (b, ..._) => {
      const [y, O] = _;
      let x = "text", v = "";
      _.length === 1 ? st(y) ? (v = y.modifier || v, x = y.type || x) : pe(y) && (v = y || v) : _.length === 2 && (pe(y) && (v = y || v), pe(O) && (x = O || x));
      const w = u(b)(g), T = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        x === "vnode" && jt(w) && v ? w[0] : w
      );
      return v ? d(v)(T, x) : T;
    },
    message: u,
    type: p,
    interpolate: f,
    normalize: h,
    values: En({}, o, l)
  };
  return g;
}
let Lu = null;
function PI(t) {
  Lu = t;
}
function RI(t, e, n) {
  Lu && Lu.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: t,
    version: e,
    meta: n
  });
}
const $I = /* @__PURE__ */ NI(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function NI(t) {
  return (e) => Lu && Lu.emit(t, e);
}
const v3 = Hy.__EXTEND_POINT__, Zo = a0(v3), DI = {
  NOT_FOUND_KEY: v3,
  // 2
  FALLBACK_TO_TRANSLATE: Zo(),
  // 3
  CANNOT_FORMAT_NUMBER: Zo(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: Zo(),
  // 5
  CANNOT_FORMAT_DATE: Zo(),
  // 6
  FALLBACK_TO_DATE_FORMAT: Zo(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: Zo(),
  // 8
  __EXTEND_POINT__: Zo()
  // 9
}, x3 = Se.__EXTEND_POINT__, Ho = a0(x3), Nr = {
  INVALID_ARGUMENT: x3,
  // 17
  INVALID_DATE_ARGUMENT: Ho(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: Ho(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: Ho(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: Ho(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: Ho(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: Ho(),
  // 23
  __EXTEND_POINT__: Ho()
  // 24
};
function ys(t) {
  return fc(t, null, void 0);
}
function Xy(t, e) {
  return e.locale != null ? Rv(e.locale) : Rv(t.locale);
}
let pg;
function Rv(t) {
  if (pe(t))
    return t;
  if (Dt(t)) {
    if (t.resolvedOnce && pg != null)
      return pg;
    if (t.constructor.name === "Function") {
      const e = t();
      if ($8(e))
        throw ys(Nr.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return pg = e;
    } else
      throw ys(Nr.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw ys(Nr.NOT_SUPPORT_LOCALE_TYPE);
}
function II(t, e, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...jt(e) ? e : st(e) ? Object.keys(e) : pe(e) ? [e] : [n]
  ])];
}
function w3(t, e, n) {
  const i = pe(n) ? n : _p, r = t;
  r.__localeChainCache || (r.__localeChainCache = /* @__PURE__ */ new Map());
  let s = r.__localeChainCache.get(i);
  if (!s) {
    s = [];
    let o = [n];
    for (; jt(o); )
      o = $v(s, o, e);
    const a = jt(e) || !qe(e) ? e : e.default ? e.default : null;
    o = pe(a) ? [a] : a, jt(o) && $v(s, o, !1), r.__localeChainCache.set(i, s);
  }
  return s;
}
function $v(t, e, n) {
  let i = !0;
  for (let r = 0; r < e.length && Rt(i); r++) {
    const s = e[r];
    pe(s) && (i = LI(t, e[r], n));
  }
  return i;
}
function LI(t, e, n) {
  let i;
  const r = e.split("-");
  do {
    const s = r.join("-");
    i = BI(t, s, n), r.splice(-1, 1);
  } while (r.length && i === !0);
  return i;
}
function BI(t, e, n) {
  let i = !1;
  if (!t.includes(e) && (i = !0, e)) {
    i = e[e.length - 1] !== "!";
    const r = e.replace(/!/g, "");
    t.push(r), (jt(n) || qe(n)) && n[r] && (i = n[r]);
  }
  return i;
}
const QI = "9.13.1", l0 = -1, _p = "en-US", Nv = "", Dv = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
function FI() {
  return {
    upper: (t, e) => e === "text" && pe(t) ? t.toUpperCase() : e === "vnode" && st(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
    lower: (t, e) => e === "text" && pe(t) ? t.toLowerCase() : e === "vnode" && st(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
    capitalize: (t, e) => e === "text" && pe(t) ? Dv(t) : e === "vnode" && st(t) && "__v_isVNode" in t ? Dv(t.children) : t
  };
}
let S3;
function zI(t) {
  S3 = t;
}
let k3;
function UI(t) {
  k3 = t;
}
let E3;
function WI(t) {
  E3 = t;
}
let C3 = null;
const VI = /* @__NO_SIDE_EFFECTS__ */ (t) => {
  C3 = t;
}, ZI = /* @__NO_SIDE_EFFECTS__ */ () => C3;
let A3 = null;
const Iv = (t) => {
  A3 = t;
}, HI = () => A3;
let Lv = 0;
function qI(t = {}) {
  const e = Dt(t.onWarn) ? t.onWarn : I8, n = pe(t.version) ? t.version : QI, i = pe(t.locale) || Dt(t.locale) ? t.locale : _p, r = Dt(i) ? _p : i, s = jt(t.fallbackLocale) || qe(t.fallbackLocale) || pe(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : r, o = qe(t.messages) ? t.messages : { [r]: {} }, a = qe(t.datetimeFormats) ? t.datetimeFormats : { [r]: {} }, l = qe(t.numberFormats) ? t.numberFormats : { [r]: {} }, c = En({}, t.modifiers || {}, FI()), u = t.pluralRules || {}, d = Dt(t.missing) ? t.missing : null, h = Rt(t.missingWarn) || bp(t.missingWarn) ? t.missingWarn : !0, f = Rt(t.fallbackWarn) || bp(t.fallbackWarn) ? t.fallbackWarn : !0, p = !!t.fallbackFormat, m = !!t.unresolving, g = Dt(t.postTranslation) ? t.postTranslation : null, b = qe(t.processor) ? t.processor : null, _ = Rt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, y = !!t.escapeParameter, O = Dt(t.messageCompiler) ? t.messageCompiler : S3, x = Dt(t.messageResolver) ? t.messageResolver : k3 || vI, v = Dt(t.localeFallbacker) ? t.localeFallbacker : E3 || II, w = st(t.fallbackContext) ? t.fallbackContext : void 0, T = t, S = st(T.__datetimeFormatters) ? T.__datetimeFormatters : /* @__PURE__ */ new Map(), $ = st(T.__numberFormatters) ? T.__numberFormatters : /* @__PURE__ */ new Map(), I = st(T.__meta) ? T.__meta : {};
  Lv++;
  const F = {
    version: n,
    cid: Lv,
    locale: i,
    fallbackLocale: s,
    messages: o,
    modifiers: c,
    pluralRules: u,
    missing: d,
    missingWarn: h,
    fallbackWarn: f,
    fallbackFormat: p,
    unresolving: m,
    postTranslation: g,
    processor: b,
    warnHtmlMessage: _,
    escapeParameter: y,
    messageCompiler: O,
    messageResolver: x,
    localeFallbacker: v,
    fallbackContext: w,
    onWarn: e,
    __meta: I
  };
  return F.datetimeFormats = a, F.numberFormats = l, F.__datetimeFormatters = S, F.__numberFormatters = $, __INTLIFY_PROD_DEVTOOLS__ && RI(F, n, I), F;
}
function jy(t, e, n, i, r) {
  const { missing: s, onWarn: o } = t;
  if (s !== null) {
    const a = s(t, n, e, r);
    return pe(a) ? a : e;
  } else
    return e;
}
function Mc(t, e, n) {
  const i = t;
  i.__localeChainCache = /* @__PURE__ */ new Map(), t.localeFallbacker(t, n, e);
}
function XI(t, e) {
  return t === e ? !1 : t.split("-")[0] === e.split("-")[0];
}
function jI(t, e) {
  const n = e.indexOf(t);
  if (n === -1)
    return !1;
  for (let i = n + 1; i < e.length; i++)
    if (XI(t, e[i]))
      return !0;
  return !1;
}
function mg(t) {
  return (n) => YI(n, t);
}
function YI(t, e) {
  const n = e.b || e.body;
  if ((n.t || n.type) === 1) {
    const i = n, r = i.c || i.cases;
    return t.plural(r.reduce((s, o) => [
      ...s,
      Bv(t, o)
    ], []));
  } else
    return Bv(t, n);
}
function Bv(t, e) {
  const n = e.s || e.static;
  if (n)
    return t.type === "text" ? n : t.normalize([n]);
  {
    const i = (e.i || e.items).reduce((r, s) => [...r, mb(t, s)], []);
    return t.normalize(i);
  }
}
function mb(t, e) {
  const n = e.t || e.type;
  switch (n) {
    case 3: {
      const i = e;
      return i.v || i.value;
    }
    case 9: {
      const i = e;
      return i.v || i.value;
    }
    case 4: {
      const i = e;
      return t.interpolate(t.named(i.k || i.key));
    }
    case 5: {
      const i = e;
      return t.interpolate(t.list(i.i != null ? i.i : i.index));
    }
    case 6: {
      const i = e, r = i.m || i.modifier;
      return t.linked(mb(t, i.k || i.key), r ? mb(t, r) : void 0, t.type);
    }
    case 7: {
      const i = e;
      return i.v || i.value;
    }
    case 8: {
      const i = e;
      return i.v || i.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${n}`);
  }
}
const GI = (t) => t;
let kh = /* @__PURE__ */ Object.create(null);
const Ql = (t) => st(t) && (t.t === 0 || t.type === 0) && ("b" in t || "body" in t);
function KI(t, e = {}) {
  let n = !1;
  const i = e.onError || W8;
  return e.onError = (r) => {
    n = !0, i(r);
  }, { ...hI(t, e), detectError: n };
}
function JI(t, e) {
  if (pe(t)) {
    Rt(e.warnHtmlMessage) && e.warnHtmlMessage;
    const i = (e.onCacheKey || GI)(t), r = kh[i];
    if (r)
      return r;
    const { ast: s, detectError: o } = KI(t, {
      ...e,
      location: fI.NODE_ENV !== "production",
      jit: !0
    }), a = mg(s);
    return o ? a : kh[i] = a;
  } else {
    const n = t.cacheKey;
    if (n) {
      const i = kh[n];
      return i || (kh[n] = mg(t));
    } else
      return mg(t);
  }
}
const Qv = () => "", Mi = (t) => Dt(t);
function Fv(t, ...e) {
  const { fallbackFormat: n, postTranslation: i, unresolving: r, messageCompiler: s, fallbackLocale: o, messages: a } = t, [l, c] = gb(...e), u = Rt(c.missingWarn) ? c.missingWarn : t.missingWarn, d = Rt(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, h = Rt(c.escapeParameter) ? c.escapeParameter : t.escapeParameter, f = !!c.resolvedMessage, p = pe(c.default) || Rt(c.default) ? Rt(c.default) ? s ? l : () => l : c.default : n ? s ? l : () => l : "", m = n || p !== "", g = Xy(t, c);
  h && eL(c);
  let [b, _, y] = f ? [
    l,
    g,
    a[g] || {}
  ] : T3(t, l, g, o, d, u), O = b, x = l;
  if (!f && !(pe(O) || Ql(O) || Mi(O)) && m && (O = p, x = O), !f && (!(pe(O) || Ql(O) || Mi(O)) || !pe(_)))
    return r ? l0 : l;
  let v = !1;
  const w = () => {
    v = !0;
  }, T = Mi(O) ? O : M3(t, l, _, O, x, w);
  if (v)
    return O;
  const S = iL(t, _, y, c), $ = MI(S), I = tL(t, T, $), F = i ? i(I, l) : I;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const V = {
      timestamp: Date.now(),
      key: pe(l) ? l : Mi(O) ? O.key : "",
      locale: _ || (Mi(O) ? O.locale : ""),
      format: pe(O) ? O : Mi(O) ? O.source : "",
      message: F
    };
    V.meta = En({}, t.__meta, /* @__PURE__ */ ZI() || {}), $I(V);
  }
  return F;
}
function eL(t) {
  jt(t.list) ? t.list = t.list.map((e) => pe(e) ? kv(e) : e) : st(t.named) && Object.keys(t.named).forEach((e) => {
    pe(t.named[e]) && (t.named[e] = kv(t.named[e]));
  });
}
function T3(t, e, n, i, r, s) {
  const { messages: o, onWarn: a, messageResolver: l, localeFallbacker: c } = t, u = c(t, i, n);
  let d = {}, h, f = null;
  const p = "translate";
  for (let m = 0; m < u.length && (h = u[m], d = o[h] || {}, (f = l(d, e)) === null && (f = d[e]), !(pe(f) || Ql(f) || Mi(f))); m++)
    if (!jI(h, u)) {
      const g = jy(
        t,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        e,
        h,
        s,
        p
      );
      g !== e && (f = g);
    }
  return [f, h, d];
}
function M3(t, e, n, i, r, s) {
  const { messageCompiler: o, warnHtmlMessage: a } = t;
  if (Mi(i)) {
    const c = i;
    return c.locale = c.locale || n, c.key = c.key || e, c;
  }
  if (o == null) {
    const c = () => i;
    return c.locale = n, c.key = e, c;
  }
  const l = o(i, nL(t, n, r, i, a, s));
  return l.locale = n, l.key = e, l.source = i, l;
}
function tL(t, e, n) {
  return e(n);
}
function gb(...t) {
  const [e, n, i] = t, r = {};
  if (!pe(e) && !nn(e) && !Mi(e) && !Ql(e))
    throw ys(Nr.INVALID_ARGUMENT);
  const s = nn(e) ? String(e) : (Mi(e), e);
  return nn(n) ? r.plural = n : pe(n) ? r.default = n : qe(n) && !o0(n) ? r.named = n : jt(n) && (r.list = n), nn(i) ? r.plural = i : pe(i) ? r.default = i : qe(i) && En(r, i), [s, r];
}
function nL(t, e, n, i, r, s) {
  return {
    locale: e,
    key: n,
    warnHtmlMessage: r,
    onError: (o) => {
      throw s && s(o), o;
    },
    onCacheKey: (o) => T8(e, n, o)
  };
}
function iL(t, e, n, i) {
  const { modifiers: r, pluralRules: s, messageResolver: o, fallbackLocale: a, fallbackWarn: l, missingWarn: c, fallbackContext: u } = t, h = {
    locale: e,
    modifiers: r,
    pluralRules: s,
    messages: (f) => {
      let p = o(n, f);
      if (p == null && u) {
        const [, , m] = T3(u, f, e, a, l, c);
        p = o(m, f);
      }
      if (pe(p) || Ql(p)) {
        let m = !1;
        const b = M3(t, f, e, p, f, () => {
          m = !0;
        });
        return m ? Qv : b;
      } else return Mi(p) ? p : Qv;
    }
  };
  return t.processor && (h.processor = t.processor), i.list && (h.list = i.list), i.named && (h.named = i.named), nn(i.plural) && (h.pluralIndex = i.plural), h;
}
function zv(t, ...e) {
  const { datetimeFormats: n, unresolving: i, fallbackLocale: r, onWarn: s, localeFallbacker: o } = t, { __datetimeFormatters: a } = t, [l, c, u, d] = bb(...e), h = Rt(u.missingWarn) ? u.missingWarn : t.missingWarn;
  Rt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn;
  const f = !!u.part, p = Xy(t, u), m = o(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    p
  );
  if (!pe(l) || l === "")
    return new Intl.DateTimeFormat(p, d).format(c);
  let g = {}, b, _ = null;
  const y = "datetime format";
  for (let v = 0; v < m.length && (b = m[v], g = n[b] || {}, _ = g[l], !qe(_)); v++)
    jy(t, l, b, h, y);
  if (!qe(_) || !pe(b))
    return i ? l0 : l;
  let O = `${b}__${l}`;
  o0(d) || (O = `${O}__${JSON.stringify(d)}`);
  let x = a.get(O);
  return x || (x = new Intl.DateTimeFormat(b, En({}, _, d)), a.set(O, x)), f ? x.formatToParts(c) : x.format(c);
}
const P3 = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function bb(...t) {
  const [e, n, i, r] = t, s = {};
  let o = {}, a;
  if (pe(e)) {
    const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!l)
      throw ys(Nr.INVALID_ISO_DATE_ARGUMENT);
    const c = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
    a = new Date(c);
    try {
      a.toISOString();
    } catch {
      throw ys(Nr.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (P8(e)) {
    if (isNaN(e.getTime()))
      throw ys(Nr.INVALID_DATE_ARGUMENT);
    a = e;
  } else if (nn(e))
    a = e;
  else
    throw ys(Nr.INVALID_ARGUMENT);
  return pe(n) ? s.key = n : qe(n) && Object.keys(n).forEach((l) => {
    P3.includes(l) ? o[l] = n[l] : s[l] = n[l];
  }), pe(i) ? s.locale = i : qe(i) && (o = i), qe(r) && (o = r), [s.key || "", a, s, o];
}
function Uv(t, e, n) {
  const i = t;
  for (const r in n) {
    const s = `${e}__${r}`;
    i.__datetimeFormatters.has(s) && i.__datetimeFormatters.delete(s);
  }
}
function Wv(t, ...e) {
  const { numberFormats: n, unresolving: i, fallbackLocale: r, onWarn: s, localeFallbacker: o } = t, { __numberFormatters: a } = t, [l, c, u, d] = Ob(...e), h = Rt(u.missingWarn) ? u.missingWarn : t.missingWarn;
  Rt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn;
  const f = !!u.part, p = Xy(t, u), m = o(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    p
  );
  if (!pe(l) || l === "")
    return new Intl.NumberFormat(p, d).format(c);
  let g = {}, b, _ = null;
  const y = "number format";
  for (let v = 0; v < m.length && (b = m[v], g = n[b] || {}, _ = g[l], !qe(_)); v++)
    jy(t, l, b, h, y);
  if (!qe(_) || !pe(b))
    return i ? l0 : l;
  let O = `${b}__${l}`;
  o0(d) || (O = `${O}__${JSON.stringify(d)}`);
  let x = a.get(O);
  return x || (x = new Intl.NumberFormat(b, En({}, _, d)), a.set(O, x)), f ? x.formatToParts(c) : x.format(c);
}
const R3 = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function Ob(...t) {
  const [e, n, i, r] = t, s = {};
  let o = {};
  if (!nn(e))
    throw ys(Nr.INVALID_ARGUMENT);
  const a = e;
  return pe(n) ? s.key = n : qe(n) && Object.keys(n).forEach((l) => {
    R3.includes(l) ? o[l] = n[l] : s[l] = n[l];
  }), pe(i) ? s.locale = i : qe(i) && (o = i), qe(r) && (o = r), [s.key || "", a, s, o];
}
function Vv(t, e, n) {
  const i = t;
  for (const r in n) {
    const s = `${e}__${r}`;
    i.__numberFormatters.has(s) && i.__numberFormatters.delete(s);
  }
}
pI();
var rL = { ALLUSERSPROFILE: "C:\\ProgramData", APPCODE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\appcode.vmoptions", APPDATA: "C:\\Users\\51923\\AppData\\Roaming", "asl.log": "Destination=file", CATALINA_HOME: "D:\\Program Files (x86)\\apache-tomcat-9.0.84-windows-x64\\apache-tomcat-9.0.84", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133657579525662721", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_3964_AJVANIKVVIFJLRUS", CLASSPATH: ".;D:\\Program Files\\Java\\jdk-17\\lib\\dt.jar;D:\\Program Files\\Java\\jdk-17\\lib\\tools.jar", CLION_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\clion.vmoptions", COLOR: "1", COLORTERM: "truecolor", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "INSPIRON5593", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DATAGRIP_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\datagrip.vmoptions", DATASPELL_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\dataspell.vmoptions", DEVECOSTUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\devecostudio.vmoptions", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GATEWAY_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\gateway.vmoptions", GIT_ASKPASS: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", GOLAND_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\goland.vmoptions", HOME: "C:\\Users\\51923", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\51923", IDEA_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\idea.vmoptions", INIT_CWD: "D:\\editor", "IntelliJ IDEA": "E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;", JAVA_HOME: "D:\\Program Files\\Java\\jdk-17", JETBRAINSCLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrainsclient.vmoptions", JETBRAINS_CLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrains_client.vmoptions", LANG: "zh_CN.UTF-8", LOCALAPPDATA: "C:\\Users\\51923\\AppData\\Local", LOGONSERVER: "\\\\INSPIRON5593", Maven_Home: "D:\\apache-maven-3.9.5", MAVEN_OPTS: "-Xms128m -Xmx512m", NODE: "E:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_PATH: "D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\bin\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules;D:\\editor\\node_modules\\.pnpm\\node_modules", npm_command: "run-script", npm_config_cache: "C:\\Users\\51923\\AppData\\Local\\npm-cache", npm_config_chromedriver_cdnurl: "https://npm.taobao.org/mirrors/chromedriver/", npm_config_electron_builder_binaries_mirror: "https://npm.taobao.org/mirrors/electron-builder-binaries/", npm_config_electron_mirror: "https://npm.taobao.org/mirrors/electron/", npm_config_fetch_retry_maxtimeout: "120000", npm_config_fetch_retry_mintimeout: "20000", npm_config_globalconfig: "E:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "E:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\51923\\.npm-init.js", npm_config_local_prefix: "D:\\editor", npm_config_node_gyp: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.8.2", npm_config_prefix: "E:\\Program Files\\nodejs", npm_config_registry: "https://registry.npmmirror.com", npm_config_userconfig: "C:\\Users\\51923\\.npmrc", npm_config_user_agent: "npm/10.8.2 node/v18.19.0 win32 x64 workspaces/false", npm_execpath: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build --config ./vite.lib.config.ts", npm_node_execpath: "E:\\Program Files\\nodejs\\node.exe", npm_package_json: "D:\\editor\\package.json", npm_package_name: "hf-richtext", npm_package_version: "1.1.0", NUMBER_OF_PROCESSORS: "8", NVM_HOME: "E:\\Program Files (x86)\\nvm", NVM_SYMLINK: "E:\\Program Files\\nodejs", OneDrive: "C:\\Users\\51923\\OneDrive", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", Path: "D:\\editor\\node_modules\\.bin;D:\\node_modules\\.bin;E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Common Files\\Oracle\\Java\\javapath;D:\\Program Files\\Java\\jdk-17\\bin;D:\\Program Files\\Java\\jdk-17\\jre\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;E:\\tomcat\\apache-tomcat-8.5.11\\bin;E:\\mysql-5.6\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\apache-maven-3.9.5\\bin\\;E:\\Program Files\\Git\\cmd;E:\\Program Files\\TortoiseGit\\bin;E:\\Program Files (x86)\\Tencent\\web\\dll;E:\\Program Files\\Redis\\;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;C:\\Program Files\\dotnet\\;C:\\Users\\51923\\AppData\\Local\\Yarn\\bin;D:\\apache-maven-3.9.5\\bin;C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin;%CATALIN A_HOM E%\\bin;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\Scripts\\;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\;E:\\Programs\\Python\\Python38-32\\Scripts\\;E:\\Programs\\Python\\Python38-32\\;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin\\;C:\\Users\\51923\\AppData\\Local\\Microsoft\\WindowsApps;E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;E:\\Programs\\Microsoft VS Code\\bin;C:\\Users\\51923\\AppData\\Roaming\\npm;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;E:\\Program Files\\JetBrains\\PyCharm 2023.2.1\\bin;E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\OpenSSL-Win64\\bin;", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.CPL", PHPSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\phpstorm.vmoptions", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 126 Stepping 5, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "7e05", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "D:\\360MoveData\\Users\\51923\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", PyCharm: "E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;", PYCHARM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\pycharm.vmoptions", RIDER_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rider.vmoptions", RUBYMINE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rubymine.vmoptions", SESSIONNAME: "Console", STUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\studio.vmoptions", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\51923\\AppData\\Local\\Temp", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.91.1", TMP: "C:\\Users\\51923\\AppData\\Local\\Temp", USERDOMAIN: "INSPIRON5593", USERDOMAIN_ROAMINGPROFILE: "INSPIRON5593", USERNAME: "51923", USERPROFILE: "C:\\Users\\51923", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "", VSCODE_GIT_ASKPASS_MAIN: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "E:\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-c773be81e1-sock", VSCODE_INJECTION: "1", WEBIDE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webide.vmoptions", WEBSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webstorm.vmoptions", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
const sL = "9.13.1";
function oL() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Zy().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const $3 = DI.__EXTEND_POINT__, as = a0($3);
as(), as(), as(), as(), as(), as(), as(), as(), as();
const N3 = Nr.__EXTEND_POINT__, Vn = a0(N3), Vi = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: N3,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: Vn(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: Vn(),
  // 26
  NOT_INSTALLED: Vn(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: Vn(),
  // 28
  // directive module errors
  REQUIRED_VALUE: Vn(),
  // 29
  INVALID_VALUE: Vn(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Vn(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: Vn(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: Vn(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: Vn(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: Vn(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Vn(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Vn(),
  // 37
  // for enhancement
  __EXTEND_POINT__: Vn()
  // 38
};
function ur(t, ...e) {
  return fc(t, null, void 0);
}
const yb = /* @__PURE__ */ Ro("__translateVNode"), _b = /* @__PURE__ */ Ro("__datetimeParts"), vb = /* @__PURE__ */ Ro("__numberParts"), aL = Ro("__setPluralRules"), lL = /* @__PURE__ */ Ro("__injectWithOption"), xb = /* @__PURE__ */ Ro("__dispose");
function Bu(t) {
  if (!st(t))
    return t;
  for (const e in t)
    if (Op(t, e))
      if (!e.includes("."))
        st(t[e]) && Bu(t[e]);
      else {
        const n = e.split("."), i = n.length - 1;
        let r = t, s = !1;
        for (let o = 0; o < i; o++) {
          if (n[o] in r || (r[n[o]] = {}), !st(r[n[o]])) {
            s = !0;
            break;
          }
          r = r[n[o]];
        }
        s || (r[n[i]] = t[e], delete t[e]), st(r[n[i]]) && Bu(r[n[i]]);
      }
  return t;
}
function D3(t, e) {
  const { messages: n, __i18n: i, messageResolver: r, flatJson: s } = e, o = qe(n) ? n : jt(i) ? {} : { [t]: {} };
  if (jt(i) && i.forEach((a) => {
    if ("locale" in a && "resource" in a) {
      const { locale: l, resource: c } = a;
      l ? (o[l] = o[l] || {}, zf(c, o[l])) : zf(c, o);
    } else
      pe(a) && zf(JSON.parse(a), o);
  }), r == null && s)
    for (const a in o)
      Op(o, a) && Bu(o[a]);
  return o;
}
function I3(t) {
  return t.type;
}
function cL(t, e, n) {
  let i = st(e.messages) ? e.messages : {};
  "__i18nGlobal" in n && (i = D3(t.locale.value, {
    messages: i,
    __i18n: n.__i18nGlobal
  }));
  const r = Object.keys(i);
  r.length && r.forEach((s) => {
    t.mergeLocaleMessage(s, i[s]);
  });
  {
    if (st(e.datetimeFormats)) {
      const s = Object.keys(e.datetimeFormats);
      s.length && s.forEach((o) => {
        t.mergeDateTimeFormat(o, e.datetimeFormats[o]);
      });
    }
    if (st(e.numberFormats)) {
      const s = Object.keys(e.numberFormats);
      s.length && s.forEach((o) => {
        t.mergeNumberFormat(o, e.numberFormats[o]);
      });
    }
  }
}
function Zv(t) {
  return fe(uD, null, t, 0);
}
const Hv = "__INTLIFY_META__", qv = () => [], uL = () => !1;
let Xv = 0;
function jv(t) {
  return (e, n, i, r) => t(n, i, Bd() || void 0, r);
}
const dL = /* @__NO_SIDE_EFFECTS__ */ () => {
  const t = Bd();
  let e = null;
  return t && (e = I3(t)[Hv]) ? { [Hv]: e } : null;
};
function L3(t = {}, e) {
  const { __root: n, __injectWithOption: i } = t, r = n === void 0, s = t.flatJson, o = gp ? pt : ru, a = !!t.translateExistCompatible;
  let l = Rt(t.inheritLocale) ? t.inheritLocale : !0;
  const c = o(
    // prettier-ignore
    n && l ? n.locale.value : pe(t.locale) ? t.locale : _p
  ), u = o(
    // prettier-ignore
    n && l ? n.fallbackLocale.value : pe(t.fallbackLocale) || jt(t.fallbackLocale) || qe(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : c.value
  ), d = o(D3(c.value, t)), h = o(qe(t.datetimeFormats) ? t.datetimeFormats : { [c.value]: {} }), f = o(qe(t.numberFormats) ? t.numberFormats : { [c.value]: {} });
  let p = n ? n.missingWarn : Rt(t.missingWarn) || bp(t.missingWarn) ? t.missingWarn : !0, m = n ? n.fallbackWarn : Rt(t.fallbackWarn) || bp(t.fallbackWarn) ? t.fallbackWarn : !0, g = n ? n.fallbackRoot : Rt(t.fallbackRoot) ? t.fallbackRoot : !0, b = !!t.fallbackFormat, _ = Dt(t.missing) ? t.missing : null, y = Dt(t.missing) ? jv(t.missing) : null, O = Dt(t.postTranslation) ? t.postTranslation : null, x = n ? n.warnHtmlMessage : Rt(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, v = !!t.escapeParameter;
  const w = n ? n.modifiers : qe(t.modifiers) ? t.modifiers : {};
  let T = t.pluralRules || n && n.pluralRules, S;
  S = (() => {
    r && Iv(null);
    const U = {
      version: sL,
      locale: c.value,
      fallbackLocale: u.value,
      messages: d.value,
      modifiers: w,
      pluralRules: T,
      missing: y === null ? void 0 : y,
      missingWarn: p,
      fallbackWarn: m,
      fallbackFormat: b,
      unresolving: !0,
      postTranslation: O === null ? void 0 : O,
      warnHtmlMessage: x,
      escapeParameter: v,
      messageResolver: t.messageResolver,
      messageCompiler: t.messageCompiler,
      __meta: { framework: "vue" }
    };
    U.datetimeFormats = h.value, U.numberFormats = f.value, U.__datetimeFormatters = qe(S) ? S.__datetimeFormatters : void 0, U.__numberFormatters = qe(S) ? S.__numberFormatters : void 0;
    const E = qI(U);
    return r && Iv(E), E;
  })(), Mc(S, c.value, u.value);
  function I() {
    return [
      c.value,
      u.value,
      d.value,
      h.value,
      f.value
    ];
  }
  const F = Be({
    get: () => c.value,
    set: (U) => {
      c.value = U, S.locale = c.value;
    }
  }), V = Be({
    get: () => u.value,
    set: (U) => {
      u.value = U, S.fallbackLocale = u.value, Mc(S, c.value, U);
    }
  }), q = Be(() => d.value), K = /* @__PURE__ */ Be(() => h.value), ie = /* @__PURE__ */ Be(() => f.value);
  function k() {
    return Dt(O) ? O : null;
  }
  function N(U) {
    O = U, S.postTranslation = U;
  }
  function W() {
    return _;
  }
  function X(U) {
    U !== null && (y = jv(U)), _ = U, S.missing = y;
  }
  const ee = (U, E, z, G, le, Ie) => {
    I();
    let dt;
    try {
      rL.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = n ? HI() : void 0), dt = U(S);
    } finally {
      __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = void 0);
    }
    if (z !== "translate exists" && // for not `te` (e.g `t`)
    nn(dt) && dt === l0 || z === "translate exists" && !dt) {
      const [Uo, H] = E();
      return n && g ? G(n) : le(Uo);
    } else {
      if (Ie(dt))
        return dt;
      throw ur(Vi.UNEXPECTED_RETURN_TYPE);
    }
  };
  function re(...U) {
    return ee((E) => Reflect.apply(Fv, null, [E, ...U]), () => gb(...U), "translate", (E) => Reflect.apply(E.t, E, [...U]), (E) => E, (E) => pe(E));
  }
  function xe(...U) {
    const [E, z, G] = U;
    if (G && !st(G))
      throw ur(Vi.INVALID_ARGUMENT);
    return re(E, z, En({ resolvedMessage: !0 }, G || {}));
  }
  function $e(...U) {
    return ee((E) => Reflect.apply(zv, null, [E, ...U]), () => bb(...U), "datetime format", (E) => Reflect.apply(E.d, E, [...U]), () => Nv, (E) => pe(E));
  }
  function be(...U) {
    return ee((E) => Reflect.apply(Wv, null, [E, ...U]), () => Ob(...U), "number format", (E) => Reflect.apply(E.n, E, [...U]), () => Nv, (E) => pe(E));
  }
  function we(U) {
    return U.map((E) => pe(E) || nn(E) || Rt(E) ? Zv(String(E)) : E);
  }
  const it = {
    normalize: we,
    interpolate: (U) => U,
    type: "vnode"
  };
  function rt(...U) {
    return ee(
      (E) => {
        let z;
        const G = E;
        try {
          G.processor = it, z = Reflect.apply(Fv, null, [G, ...U]);
        } finally {
          G.processor = null;
        }
        return z;
      },
      () => gb(...U),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (E) => E[yb](...U),
      (E) => [Zv(E)],
      (E) => jt(E)
    );
  }
  function et(...U) {
    return ee(
      (E) => Reflect.apply(Wv, null, [E, ...U]),
      () => Ob(...U),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (E) => E[vb](...U),
      qv,
      (E) => pe(E) || jt(E)
    );
  }
  function It(...U) {
    return ee(
      (E) => Reflect.apply(zv, null, [E, ...U]),
      () => bb(...U),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (E) => E[_b](...U),
      qv,
      (E) => pe(E) || jt(E)
    );
  }
  function qt(U) {
    T = U, S.pluralRules = T;
  }
  function Te(U, E) {
    return ee(() => {
      if (!U)
        return !1;
      const z = pe(E) ? E : c.value, G = Qe(z), le = S.messageResolver(G, U);
      return a ? le != null : Ql(le) || Mi(le) || pe(le);
    }, () => [U], "translate exists", (z) => Reflect.apply(z.te, z, [U, E]), uL, (z) => Rt(z));
  }
  function gt(U) {
    let E = null;
    const z = w3(S, u.value, c.value);
    for (let G = 0; G < z.length; G++) {
      const le = d.value[z[G]] || {}, Ie = S.messageResolver(le, U);
      if (Ie != null) {
        E = Ie;
        break;
      }
    }
    return E;
  }
  function kt(U) {
    const E = gt(U);
    return E ?? (n ? n.tm(U) || {} : {});
  }
  function Qe(U) {
    return d.value[U] || {};
  }
  function yn(U, E) {
    if (s) {
      const z = { [U]: E };
      for (const G in z)
        Op(z, G) && Bu(z[G]);
      E = z[U];
    }
    d.value[U] = E, S.messages = d.value;
  }
  function Gt(U, E) {
    d.value[U] = d.value[U] || {};
    const z = { [U]: E };
    if (s)
      for (const G in z)
        Op(z, G) && Bu(z[G]);
    E = z[U], zf(E, d.value[U]), S.messages = d.value;
  }
  function J(U) {
    return h.value[U] || {};
  }
  function M(U, E) {
    h.value[U] = E, S.datetimeFormats = h.value, Uv(S, U, E);
  }
  function C(U, E) {
    h.value[U] = En(h.value[U] || {}, E), S.datetimeFormats = h.value, Uv(S, U, E);
  }
  function B(U) {
    return f.value[U] || {};
  }
  function oe(U, E) {
    f.value[U] = E, S.numberFormats = f.value, Vv(S, U, E);
  }
  function Ce(U, E) {
    f.value[U] = En(f.value[U] || {}, E), S.numberFormats = f.value, Vv(S, U, E);
  }
  Xv++, n && gp && (In(n.locale, (U) => {
    l && (c.value = U, S.locale = U, Mc(S, c.value, u.value));
  }), In(n.fallbackLocale, (U) => {
    l && (u.value = U, S.fallbackLocale = U, Mc(S, c.value, u.value));
  }));
  const ye = {
    id: Xv,
    locale: F,
    fallbackLocale: V,
    get inheritLocale() {
      return l;
    },
    set inheritLocale(U) {
      l = U, U && n && (c.value = n.locale.value, u.value = n.fallbackLocale.value, Mc(S, c.value, u.value));
    },
    get availableLocales() {
      return Object.keys(d.value).sort();
    },
    messages: q,
    get modifiers() {
      return w;
    },
    get pluralRules() {
      return T || {};
    },
    get isGlobal() {
      return r;
    },
    get missingWarn() {
      return p;
    },
    set missingWarn(U) {
      p = U, S.missingWarn = p;
    },
    get fallbackWarn() {
      return m;
    },
    set fallbackWarn(U) {
      m = U, S.fallbackWarn = m;
    },
    get fallbackRoot() {
      return g;
    },
    set fallbackRoot(U) {
      g = U;
    },
    get fallbackFormat() {
      return b;
    },
    set fallbackFormat(U) {
      b = U, S.fallbackFormat = b;
    },
    get warnHtmlMessage() {
      return x;
    },
    set warnHtmlMessage(U) {
      x = U, S.warnHtmlMessage = U;
    },
    get escapeParameter() {
      return v;
    },
    set escapeParameter(U) {
      v = U, S.escapeParameter = U;
    },
    t: re,
    getLocaleMessage: Qe,
    setLocaleMessage: yn,
    mergeLocaleMessage: Gt,
    getPostTranslationHandler: k,
    setPostTranslationHandler: N,
    getMissingHandler: W,
    setMissingHandler: X,
    [aL]: qt
  };
  return ye.datetimeFormats = K, ye.numberFormats = ie, ye.rt = xe, ye.te = Te, ye.tm = kt, ye.d = $e, ye.n = be, ye.getDateTimeFormat = J, ye.setDateTimeFormat = M, ye.mergeDateTimeFormat = C, ye.getNumberFormat = B, ye.setNumberFormat = oe, ye.mergeNumberFormat = Ce, ye[lL] = i, ye[yb] = rt, ye[_b] = It, ye[vb] = et, ye;
}
const Yy = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (t) => t === "parent" || t === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function hL({ slots: t }, e) {
  return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((i, r) => [
    ...i,
    // prettier-ignore
    ...r.type === Yt ? r.children : [r]
  ], []) : e.reduce((n, i) => {
    const r = t[i];
    return r && (n[i] = r()), n;
  }, {});
}
function B3(t) {
  return Yt;
}
const fL = /* @__PURE__ */ ke({
  /* eslint-disable */
  name: "i18n-t",
  props: En({
    keypath: {
      type: String,
      required: !0
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (t) => nn(t) || !isNaN(t)
    }
  }, Yy),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const { slots: n, attrs: i } = e, r = t.i18n || Gy({
      useScope: t.scope,
      __useComponent: !0
    });
    return () => {
      const s = Object.keys(n).filter((d) => d !== "_"), o = {};
      t.locale && (o.locale = t.locale), t.plural !== void 0 && (o.plural = pe(t.plural) ? +t.plural : t.plural);
      const a = hL(e, s), l = r[yb](t.keypath, a, o), c = En({}, i), u = pe(t.tag) || st(t.tag) ? t.tag : B3();
      return li(u, c, l);
    };
  }
}), Yv = fL;
function pL(t) {
  return jt(t) && !pe(t[0]);
}
function Q3(t, e, n, i) {
  const { slots: r, attrs: s } = e;
  return () => {
    const o = { part: !0 };
    let a = {};
    t.locale && (o.locale = t.locale), pe(t.format) ? o.key = t.format : st(t.format) && (pe(t.format.key) && (o.key = t.format.key), a = Object.keys(t.format).reduce((h, f) => n.includes(f) ? En({}, h, { [f]: t.format[f] }) : h, {}));
    const l = i(t.value, o, a);
    let c = [o.key];
    jt(l) ? c = l.map((h, f) => {
      const p = r[h.type], m = p ? p({ [h.type]: h.value, index: f, parts: l }) : [h.value];
      return pL(m) && (m[0].key = `${h.type}-${f}`), m;
    }) : pe(l) && (c = [l]);
    const u = En({}, s), d = pe(t.tag) || st(t.tag) ? t.tag : B3();
    return li(d, u, c);
  };
}
const mL = /* @__PURE__ */ ke({
  /* eslint-disable */
  name: "i18n-n",
  props: En({
    value: {
      type: Number,
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, Yy),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const n = t.i18n || Gy({
      useScope: t.scope,
      __useComponent: !0
    });
    return Q3(t, e, R3, (...i) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[vb](...i)
    ));
  }
}), Gv = mL, gL = /* @__PURE__ */ ke({
  /* eslint-disable */
  name: "i18n-d",
  props: En({
    value: {
      type: [Number, Date],
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, Yy),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const n = t.i18n || Gy({
      useScope: t.scope,
      __useComponent: !0
    });
    return Q3(t, e, P3, (...i) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[_b](...i)
    ));
  }
}), Kv = gL;
function bL(t, e) {
  const n = t;
  if (t.mode === "composition")
    return n.__getInstance(e) || t.global;
  {
    const i = n.__getInstance(e);
    return i != null ? i.__composer : t.global.__composer;
  }
}
function OL(t) {
  const e = (o) => {
    const { instance: a, modifiers: l, value: c } = o;
    if (!a || !a.$)
      throw ur(Vi.UNEXPECTED_ERROR);
    const u = bL(t, a.$), d = Jv(c);
    return [
      Reflect.apply(u.t, u, [...ex(d)]),
      u
    ];
  };
  return {
    created: (o, a) => {
      const [l, c] = e(a);
      gp && t.global === c && (o.__i18nWatcher = In(c.locale, () => {
        a.instance && a.instance.$forceUpdate();
      })), o.__composer = c, o.textContent = l;
    },
    unmounted: (o) => {
      gp && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer);
    },
    beforeUpdate: (o, { value: a }) => {
      if (o.__composer) {
        const l = o.__composer, c = Jv(a);
        o.textContent = Reflect.apply(l.t, l, [
          ...ex(c)
        ]);
      }
    },
    getSSRProps: (o) => {
      const [a] = e(o);
      return { textContent: a };
    }
  };
}
function Jv(t) {
  if (pe(t))
    return { path: t };
  if (qe(t)) {
    if (!("path" in t))
      throw ur(Vi.REQUIRED_VALUE, "path");
    return t;
  } else
    throw ur(Vi.INVALID_VALUE);
}
function ex(t) {
  const { path: e, locale: n, args: i, choice: r, plural: s } = t, o = {}, a = i || {};
  return pe(n) && (o.locale = n), nn(r) && (o.plural = r), nn(s) && (o.plural = s), [e, a, o];
}
function yL(t, e, ...n) {
  const i = qe(n[0]) ? n[0] : {}, r = !!i.useI18nComponentName;
  (Rt(i.globalInstall) ? i.globalInstall : !0) && ([r ? "i18n" : Yv.name, "I18nT"].forEach((o) => t.component(o, Yv)), [Gv.name, "I18nN"].forEach((o) => t.component(o, Gv)), [Kv.name, "I18nD"].forEach((o) => t.component(o, Kv))), t.directive("t", OL(e));
}
const _L = /* @__PURE__ */ Ro("global-vue-i18n");
function vL(t = {}, e) {
  const n = Rt(t.globalInjection) ? t.globalInjection : !0, i = !0, r = /* @__PURE__ */ new Map(), [s, o] = xL(t), a = /* @__PURE__ */ Ro("");
  function l(d) {
    return r.get(d) || null;
  }
  function c(d, h) {
    r.set(d, h);
  }
  function u(d) {
    r.delete(d);
  }
  {
    const d = {
      // mode
      get mode() {
        return "composition";
      },
      // allowComposition
      get allowComposition() {
        return i;
      },
      // install plugin
      async install(h, ...f) {
        if (h.__VUE_I18N_SYMBOL__ = a, h.provide(h.__VUE_I18N_SYMBOL__, d), qe(f[0])) {
          const g = f[0];
          d.__composerExtend = g.__composerExtend, d.__vueI18nExtend = g.__vueI18nExtend;
        }
        let p = null;
        n && (p = ML(h, d.global)), yL(h, d, ...f);
        const m = h.unmount;
        h.unmount = () => {
          p && p(), d.dispose(), m();
        };
      },
      // global accessor
      get global() {
        return o;
      },
      dispose() {
        s.stop();
      },
      // @internal
      __instances: r,
      // @internal
      __getInstance: l,
      // @internal
      __setInstance: c,
      // @internal
      __deleteInstance: u
    };
    return d;
  }
}
function Gy(t = {}) {
  const e = Bd();
  if (e == null)
    throw ur(Vi.MUST_BE_CALL_SETUP_TOP);
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw ur(Vi.NOT_INSTALLED);
  const n = wL(e), i = kL(n), r = I3(e), s = SL(t, r);
  if (s === "global")
    return cL(i, t, r), i;
  if (s === "parent") {
    let l = EL(n, e, t.__useComponent);
    return l == null && (l = i), l;
  }
  const o = n;
  let a = o.__getInstance(e);
  if (a == null) {
    const l = En({}, t);
    "__i18n" in r && (l.__i18n = r.__i18n), i && (l.__root = i), a = L3(l), o.__composerExtend && (a[xb] = o.__composerExtend(a)), AL(o, e, a), o.__setInstance(e, a);
  }
  return a;
}
function xL(t, e, n) {
  const i = aD();
  {
    const r = i.run(() => L3(t));
    if (r == null)
      throw ur(Vi.UNEXPECTED_ERROR);
    return [i, r];
  }
}
function wL(t) {
  {
    const e = lD(t.isCE ? _L : t.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e)
      throw ur(t.isCE ? Vi.NOT_INSTALLED_WITH_PROVIDE : Vi.UNEXPECTED_ERROR);
    return e;
  }
}
function SL(t, e) {
  return o0(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local";
}
function kL(t) {
  return t.mode === "composition" ? t.global : t.global.__composer;
}
function EL(t, e, n = !1) {
  let i = null;
  const r = e.root;
  let s = CL(e, n);
  for (; s != null; ) {
    const o = t;
    if (t.mode === "composition" && (i = o.__getInstance(s)), i != null || r === s)
      break;
    s = s.parent;
  }
  return i;
}
function CL(t, e = !1) {
  return t == null ? null : e && t.vnode.ctx || t.parent;
}
function AL(t, e, n) {
  Gi(() => {
  }, e), Fy(() => {
    const i = n;
    t.__deleteInstance(e);
    const r = i[xb];
    r && (r(), delete i[xb]);
  }, e);
}
const TL = [
  "locale",
  "fallbackLocale",
  "availableLocales"
], tx = ["t", "rt", "d", "n", "tm", "te"];
function ML(t, e) {
  const n = /* @__PURE__ */ Object.create(null);
  return TL.forEach((r) => {
    const s = Object.getOwnPropertyDescriptor(e, r);
    if (!s)
      throw ur(Vi.UNEXPECTED_ERROR);
    const o = cD(s.value) ? {
      get() {
        return s.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(a) {
        s.value.value = a;
      }
    } : {
      get() {
        return s.get && s.get();
      }
    };
    Object.defineProperty(n, r, o);
  }), t.config.globalProperties.$i18n = n, tx.forEach((r) => {
    const s = Object.getOwnPropertyDescriptor(e, r);
    if (!s || !s.value)
      throw ur(Vi.UNEXPECTED_ERROR);
    Object.defineProperty(t.config.globalProperties, `$${r}`, s);
  }), () => {
    delete t.config.globalProperties.$i18n, tx.forEach((r) => {
      delete t.config.globalProperties[`$${r}`];
    });
  };
}
oL();
zI(JI);
UI(xI);
WI(w3);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const t = Zy();
  t.__INTLIFY__ = !0, PI(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
const nx = {
  editor: {
    menus: {
      undo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Undo" } },
      redo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Redo" } },
      table: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Table" } },
        add: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add table" } },
        add_column_before: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add column before" } },
        add_column_after: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add column after" } },
        delete_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete column" } },
        add_row_before: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add row before" } },
        add_row_after: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add row after" } },
        toggle_header_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Set/Unset First Column Header" } },
        toggle_header_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Set/Unset First Row Header" } },
        toggle_header_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Set/Unset Current Cell as Header" } },
        delete_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete row" } },
        merge_cells: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Merge cells" } },
        split_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Split cell" } },
        delete_table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete table" } }
      }
    },
    extensions: {
      commands_menu: {
        columns: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Column Card" } },
        iframe: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Iframe" } },
        image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "image" } },
        video: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Video" } },
        audio: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Audio" } },
        table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Table" } },
        no_results: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No results" } },
        placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enter / to select input type" } }
      },
      link: {
        add_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add link" } },
        edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
        placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Link address" } },
        open_in_new_window: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Open in new window" } },
        cancel_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cancel link" } }
      },
      audio: {
        disable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable auto play" } },
        enable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enable auto play" } },
        disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable loop" } },
        enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable loop" } }
      },
      iframe: {
        disable_frameborder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hide frameborder" } },
        enable_frameborder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Show frameborder" } },
        phone_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mobile phone size" } },
        tablet_vertical_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tablet portrait size" } },
        tablet_horizontal_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tablet landscape size" } },
        desktop_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desktop size" } }
      },
      image: {
        small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Small size" } },
        medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Medium size" } },
        large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Large size" } },
        restore_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Restore original size" } },
        edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
        edit_alt: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit alt" } },
        edit_href: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit the image hyperlink" } }
      },
      video: {
        disable_controls: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hide controls" } },
        enable_controls: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Show controls" } },
        disable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable auto play" } },
        enable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enable auto play" } },
        disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Disable loop" } },
        enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enable loop" } },
        small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Small size" } },
        medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Medium size" } },
        large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Large size" } }
      },
      highlight: {
        unset: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Unset" } }
      },
      columns: {
        add_column_before: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add column before" } },
        add_column_after: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add column after" } },
        delete_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete column" } }
      },
      search_and_replace: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Search and Replace" } },
        search_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Search" } },
        not_found: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Not Found" } },
        occurrence_found: { t: 0, b: { t: 2, i: [{ t: 4, k: "index" }, { t: 3, v: " of " }, { t: 4, k: "total" }, { t: 3, v: " occurrences" }] } },
        find_previous: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Find Previous" } },
        find_next: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Find Next" } },
        replace_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Replace" } },
        replace: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Replace" } },
        replace_all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Replace All" } },
        case_sensitive: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Case Sensitive" } },
        match_word: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Match Whole Word" } },
        use_regex: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Use Regular Expression" } },
        close: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Close" } }
      },
      format_brush: {
        toolbar_item: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Format Brush" } },
          cancel: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cancel Format Brush" } }
        }
      }
    },
    components: {
      color_picker: {
        more_color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "More" } }
      }
    },
    common: {
      align_method: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align method" } },
      align_left: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align left" } },
      align_center: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align center" } },
      align_right: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align right" } },
      align_justify: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Align justify" } },
      bold: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Bold" } },
      italic: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Italic" } },
      underline: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Underline" } },
      strike: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Strike" } },
      quote: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quote" } },
      code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Code" } },
      superscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Super Script" } },
      subscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sub Script" } },
      codeblock: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Code block" } },
        copy_code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Copy code" } },
        copy_code_success: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Copy success" } }
      },
      image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Image" } },
      heading: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Text type" } },
        paragraph: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Paragraph" } },
        header1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 1" } },
        header2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 2" } },
        header3: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 3" } },
        header4: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 4" } },
        header5: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 5" } },
        header6: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Header 6" } }
      },
      bullet_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Bullet list" } },
      ordered_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ordered list" } },
      task_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Task list" } },
      highlight: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Highlight" } },
      color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Color" } },
      tooltip: {
        custom_width_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Custom width, press Enter to take effect" } },
        custom_height_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Customize height, press Enter to take effect" } },
        open_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Open link" } }
      },
      placeholder: {
        link_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enter the link and press enter to confirm." } },
        alt_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enter the image alt and press enter to confirm." } },
        alt_href: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Enter the image hyperlink and press enter to confirm." } }
      },
      button: {
        new_line: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "New line" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete" } },
        edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Edit link" } },
        refresh: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Refresh" } },
        restore_default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Restore default" } }
      },
      text: {
        default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Default" } }
      },
      line_height: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Line height" } },
      clear_format: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Clear format" } }
    }
  }
}, ix = {
  editor: {
    menus: {
      undo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      redo: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      table: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        add: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        add_column_before: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        add_column_after: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        delete_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        add_row_before: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        add_row_after: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        toggle_header_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "/" } },
        toggle_header_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "/" } },
        toggle_header_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "/" } },
        delete_row: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        merge_cells: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        split_cell: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        delete_table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      }
    },
    extensions: {
      commands_menu: {
        columns: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        iframe: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        video: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        audio: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        table: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        no_results: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: " / " } }
      },
      link: {
        add_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        open_in_new_window: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        cancel_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      audio: {
        disable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        enable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      iframe: {
        disable_frameborder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        enable_frameborder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        phone_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        tablet_vertical_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        tablet_horizontal_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        desktop_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      image: {
        small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        restore_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        edit_alt: { t: 0, b: { t: 2, i: [{ t: 3 }], s: " alt " } },
        edit_href: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      video: {
        disable_controls: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        enable_controls: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        disable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        enable_autoplay: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        disable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        enable_loop: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        small_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        medium_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        large_size: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      highlight: {
        unset: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      columns: {
        add_column_before: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        add_column_after: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        delete_column: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      search_and_replace: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        search_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        not_found: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        occurrence_found: { t: 0, b: { t: 2, i: [{ t: 3, v: " " }, { t: 4, k: "index" }, { t: 3, v: "  " }, { t: 4, k: "total" }, { t: 3, v: " " }] } },
        find_previous: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        find_next: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        replace_placeholder: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        replace: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        replace_all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        case_sensitive: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        match_word: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        use_regex: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        close: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      format_brush: {
        toolbar_item: {
          title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
          cancel: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
        }
      }
    },
    components: {
      color_picker: {
        more_color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      }
    },
    common: {
      align_method: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      align_left: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      align_center: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      align_right: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      align_justify: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      bold: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      italic: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      underline: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      strike: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      quote: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      superscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      subscript: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      codeblock: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        copy_code: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        copy_code_success: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      image: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      heading: {
        title: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        paragraph: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        header1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        header2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        header3: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        header4: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        header5: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        header6: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      bullet_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      ordered_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      task_list: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      highlight: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      color: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      tooltip: {
        custom_width_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        custom_height_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        open_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      placeholder: {
        link_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        alt_input: { t: 0, b: { t: 2, i: [{ t: 3 }], s: " alt " } },
        alt_href: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      button: {
        new_line: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        edit_link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        refresh: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
        restore_default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      text: {
        default: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
      },
      line_height: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } },
      clear_format: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "" } }
    }
  }
}, PL = {
  en: nx,
  zh: ix,
  "en-US": nx,
  "zh-CN": ix
}, Q = vL({
  legacy: !1,
  locale: "en",
  fallbackLocale: "zh-CN",
  messages: PL
}), RL = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, $L = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M20 10.5a6.5 6.5 0 0 1-6.5 6.5H7.83l3.09 3.09L9.5 21.5L4 16l5.5-5.5l1.41 1.41L7.83 15h5.67c2.5 0 4.5-2 4.5-4.5S16 6 13.5 6H6V4h7.5a6.5 6.5 0 0 1 6.5 6.5"
}, null, -1), NL = [
  $L
];
function DL(t, e) {
  return P(), L("svg", RL, [...NL]);
}
const IL = { name: "mdi-arrow-u-left-bottom", render: DL }, LL = { class: "editor-block__content" }, BL = { class: "editor-block__actions" }, V_e = /* @__PURE__ */ ke({
  __name: "BlockCard",
  props: {
    selected: { type: Boolean, default: !1 },
    editor: {},
    getPos: {},
    deleteNode: {}
  },
  setup(t) {
    const e = t;
    function n() {
      e.editor.commands.insertContentAt(
        e.getPos() + 1,
        [{ type: "paragraph", content: "" }],
        {
          updateSelection: !0
        }
      ), e.editor.commands.focus(e.getPos() + 2, {
        scrollIntoView: !0
      });
    }
    return (i, r) => (P(), L("section", {
      class: Ot(["editor-block group", { "editor-block--selected": i.selected }])
    }, [
      A("div", LL, [
        Wi(i.$slots, "content")
      ]),
      A("div", {
        class: Ot(["invisible group-hover:visible pb-2 absolute -top-12 right-0", { "!visible": i.selected }])
      }, [
        A("div", BL, [
          Wi(i.$slots, "actions"),
          fe(Ol, {
            tooltip: Z(Q).global.t("editor.common.button.new_line"),
            onClick: n
          }, {
            icon: ze(() => [
              fe(Z(IL))
            ]),
            _: 1
          }, 8, ["tooltip"]),
          fe(Qt),
          fe(Ol, {
            tooltip: Z(Q).global.t("editor.common.button.delete"),
            onClick: i.deleteNode
          }, {
            icon: ze(() => [
              fe(Ua)
            ]),
            _: 1
          }, 8, ["tooltip", "onClick"])
        ])
      ], 2)
    ], 2));
  }
}), QL = ["title"], FL = { class: "relative rounded-md bg-white overflow-hidden drop-shadow w-96 p-1 max-h-72 overflow-y-auto" }, Ky = /* @__PURE__ */ ke({
  __name: "BubbleItem",
  props: {
    editor: {},
    isActive: { type: Function, default: () => !1 },
    visible: { type: Function, default: () => !0 },
    icon: { default: void 0 },
    iconStyle: { default: void 0 },
    title: { default: void 0 },
    action: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t, n = pt(), i = (r) => {
      var o;
      if (!e.action)
        return;
      const s = (o = e.action) == null ? void 0 : o.call(e, { editor: r });
      typeof s == "object" && (n.value ? n.value = void 0 : n.value = s);
    };
    return (r, s) => (P(), Re(Z(Iu), {
      class: "inline-flex",
      triggers: [],
      "auto-hide": !0,
      shown: !!n.value,
      distance: 10
    }, {
      popper: ze(() => [
        A("div", FL, [
          (P(), Re(dD, null, [
            (P(), Re(Ni(n.value), By(Qy(e)), null, 16))
          ], 1024))
        ])
      ]),
      default: ze(() => [
        r.visible({ editor: r.editor }) ? ut((P(), L("button", {
          key: 0,
          class: Ot([{ "bg-gray-200 !text-black": r.isActive({ editor: r.editor }) }, "text-gray-600 text-lg hover:bg-gray-100 p-2 rounded-md"]),
          title: r.title,
          onClick: s[0] || (s[0] = (o) => i(r.editor))
        }, [
          (P(), Re(Ni(r.icon), {
            style: sn(r.iconStyle),
            class: "w-5 h-5"
          }, null, 8, ["style"]))
        ], 10, QL)), [
          [Z(mo), {
            content: r.title,
            distance: 8,
            delay: {
              show: 0
            }
          }]
        ]) : ei("", !0)
      ]),
      _: 1
    }, 8, ["shown"]));
  }
});
function wb(t, e, n, i) {
  for (let r = 0, s = 0; r < t.childCount; r++) {
    let o = t.child(r), a = s + o.nodeSize, l = Math.max(s, e), c = Math.min(a, n);
    if (l < c)
      if (o.isText)
        for (let u = l; u < c; u++)
          i.push(o.text.charCodeAt(u - s));
      else o.isLeaf ? i.push(o.type.name) : (l == s && i.push(o.type.name), wb(o.content, Math.max(s + 1, l) - s - 1, Math.min(a - 1, c) - s - 1, i), c == a && i.push(-1));
    s = a;
  }
  return i;
}
const zL = 5e3;
function UL(t, e) {
  return Math.min(15, Math.max(2, Math.floor(Math.max(t, e) / 10)));
}
function F3(t, e, n) {
  let i = wb(t, n.fromA, n.toA, []), r = wb(e, n.fromB, n.toB, []), s = 0, o = i.length, a = r.length;
  for (; s < i.length && s < r.length && i[s] === r[s]; )
    s++;
  if (s == i.length && s == r.length)
    return [];
  for (; o > s && a > s && i[o - 1] === r[a - 1]; )
    o--, a--;
  if (o == s || a == s || o == a && o == s + 1)
    return [n.slice(s, o, s, a)];
  let l = o - s, c = a - s, u = Math.min(zL, l + c), d = u + 1, h = [], f = [];
  for (let p = d * 2, m = 0; m < p; m++)
    f[m] = -1;
  for (let p = 0; p <= u; p++) {
    for (let m = -p; m <= p; m += 2) {
      let g = f[m + 1 + u], b = f[m - 1 + u], _ = g < b ? b : g + 1, y = _ + m;
      for (; _ < l && y < c && i[s + _] === r[s + y]; )
        _++, y++;
      if (f[m + u] = _, _ >= l && y >= c) {
        let O = [], x = UL(o - s, a - s), v = -1, w = -1, T = -1, S = -1, $ = (I, F, V, q) => {
          v > -1 && v < F + x ? (v = I, T = V) : (v > -1 && O.push(n.slice(v, w, T, S)), v = I, w = F, T = V, S = q);
        };
        for (let I = p - 1; I >= 0; I--) {
          let F = f[m + 1 + u], V = f[m - 1 + u];
          F < V ? (m--, _ = V + s, y = _ + m, $(_, _, y, y + 1)) : (m++, _ = F + s, y = _ + m, $(_, _ + 1, y, y)), f = h[I >> 1];
        }
        return v > -1 && O.push(n.slice(v, w, T, S)), O.reverse();
      }
    }
    p % 2 == 0 && h.push(f.slice());
  }
  return [n.slice(s, o, s, a)];
}
class ct {
  /**
  @internal
  */
  constructor(e, n) {
    this.length = e, this.data = n;
  }
  /**
  @internal
  */
  cut(e) {
    return e == this.length ? this : new ct(e, this.data);
  }
  /**
  @internal
  */
  static slice(e, n, i) {
    if (n == i)
      return ct.none;
    if (n == 0 && i == ct.len(e))
      return e;
    let r = [];
    for (let s = 0, o = 0; o < i; s++) {
      let a = e[s], l = o + a.length, c = Math.min(i, l) - Math.max(n, o);
      c > 0 && r.push(a.cut(c)), o = l;
    }
    return r;
  }
  /**
  @internal
  */
  static join(e, n, i) {
    if (e.length == 0)
      return n;
    if (n.length == 0)
      return e;
    let r = i(e[e.length - 1].data, n[0].data);
    if (r == null)
      return e.concat(n);
    let s = e.slice(0, e.length - 1);
    s.push(new ct(e[e.length - 1].length + n[0].length, r));
    for (let o = 1; o < n.length; o++)
      s.push(n[o]);
    return s;
  }
  /**
  @internal
  */
  static len(e) {
    let n = 0;
    for (let i = 0; i < e.length; i++)
      n += e[i].length;
    return n;
  }
}
ct.none = [];
class or {
  /**
  @internal
  */
  constructor(e, n, i, r, s, o) {
    this.fromA = e, this.toA = n, this.fromB = i, this.toB = r, this.deleted = s, this.inserted = o;
  }
  /**
  @internal
  */
  get lenA() {
    return this.toA - this.fromA;
  }
  /**
  @internal
  */
  get lenB() {
    return this.toB - this.fromB;
  }
  /**
  @internal
  */
  slice(e, n, i, r) {
    return e == 0 && i == 0 && n == this.toA - this.fromA && r == this.toB - this.fromB ? this : new or(this.fromA + e, this.fromA + n, this.fromB + i, this.fromB + r, ct.slice(this.deleted, e, n), ct.slice(this.inserted, i, r));
  }
  /**
  This merges two changesets (the end document of x should be the
  start document of y) into a single one spanning the start of x to
  the end of y.
  */
  static merge(e, n, i) {
    if (e.length == 0)
      return n;
    if (n.length == 0)
      return e;
    let r = [];
    for (let s = 0, o = 0, a = e[0], l = n[0]; ; ) {
      if (!a && !l)
        return r;
      if (a && (!l || a.toB < l.fromA)) {
        let c = o ? n[o - 1].toB - n[o - 1].toA : 0;
        r.push(c == 0 ? a : new or(a.fromA, a.toA, a.fromB + c, a.toB + c, a.deleted, a.inserted)), a = s++ == e.length ? null : e[s];
      } else if (l && (!a || l.toA < a.fromB)) {
        let c = s ? e[s - 1].toB - e[s - 1].toA : 0;
        r.push(c == 0 ? l : new or(l.fromA - c, l.toA - c, l.fromB, l.toB, l.deleted, l.inserted)), l = o++ == n.length ? null : n[o];
      } else {
        let c = Math.min(a.fromB, l.fromA), u = Math.min(a.fromA, l.fromA - (s ? e[s - 1].toB - e[s - 1].toA : 0)), d = u, h = Math.min(l.fromB, a.fromB + (o ? n[o - 1].toB - n[o - 1].toA : 0)), f = h, p = ct.none, m = ct.none, g = !1, b = !1;
        for (; ; ) {
          let _ = a ? c >= a.fromB ? a.toB : a.fromB : 2e8, y = l ? c >= l.fromA ? l.toA : l.fromA : 2e8, O = Math.min(_, y), x = a && c >= a.fromB, v = l && c >= l.fromA;
          if (!x && !v)
            break;
          x && c == a.fromB && !g && (p = ct.join(p, a.deleted, i), d += a.lenA, g = !0), x && !v && (m = ct.join(m, ct.slice(a.inserted, c - a.fromB, O - a.fromB), i), f += O - c), v && c == l.fromA && !b && (m = ct.join(m, l.inserted, i), f += l.lenB, b = !0), v && !x && (p = ct.join(p, ct.slice(l.deleted, c - l.fromA, O - l.fromA), i), d += O - c), x && O == a.toB && (a = s++ == e.length ? null : e[s], g = !1), v && O == l.toA && (l = o++ == n.length ? null : n[o], b = !1), c = O;
        }
        (u < d || h < f) && r.push(new or(u, d, h, f, p, m));
      }
    }
  }
}
let Sb;
try {
  Sb = new RegExp("[\\p{Alphabetic}_]", "u");
} catch {
}
const WL = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function Ga(t) {
  if (t < 128)
    return t >= 48 && t <= 57 || t >= 65 && t <= 90 || t >= 79 && t <= 122;
  let e = String.fromCharCode(t);
  return Sb ? Sb.test(e) : e.toUpperCase() != e.toLowerCase() || WL.test(e);
}
function VL(t, e, n) {
  let i = "";
  function r(s, o, a) {
    for (let l = 0, c = 0; l < s.childCount; l++) {
      let u = s.child(l), d = c + u.nodeSize, h = Math.max(c, o), f = Math.min(d, a);
      h < f && (u.isText ? i += u.text.slice(Math.max(0, o - c), Math.min(u.text.length, a - c)) : u.isLeaf ? i += " " : (h == c && (i += " "), r(u.content, Math.max(0, h - c - 1), Math.min(u.content.size, a - c)), f == d && (i += " "))), c = d;
    }
  }
  return r(t, e, n), i;
}
const kb = 30;
function Z_e(t, e) {
  let n = [];
  for (let i = 0; i < t.length; i++) {
    let r = t[i].toB, s = i;
    for (; i < t.length - 1 && t[i + 1].fromB <= r + kb; )
      r = t[++i].toB;
    ZL(t, s, i + 1, e, n);
  }
  return n;
}
function ZL(t, e, n, i, r) {
  let s = Math.max(0, t[e].fromB - kb), o = Math.min(i.content.size, t[n - 1].toB + kb), a = VL(i.content, s, o);
  for (let l = e; l < n; l++) {
    let c = l, u = t[l], d = u.lenA, h = u.lenB;
    for (; l < n - 1; ) {
      let f = t[l + 1], p = !1, m = u.toB == o ? !1 : Ga(a.charCodeAt(u.toB - 1 - s));
      for (let g = u.toB; !p && g < f.fromB; g++) {
        let b = g == o ? !1 : Ga(a.charCodeAt(g - s));
        (!m || !b) && g != t[c].fromB && (p = !0), m = b;
      }
      if (p)
        break;
      d += f.lenA, h += f.lenB, u = f, l++;
    }
    if (h > 0 && d > 0 && !(h == 1 && d == 1)) {
      let f = t[c].fromB, p = t[l].toB;
      if (f < o && Ga(a.charCodeAt(f - s)))
        for (; f > s && Ga(a.charCodeAt(f - 1 - s)); )
          f--;
      if (p > s && Ga(a.charCodeAt(p - 1 - s)))
        for (; p < o && Ga(a.charCodeAt(p - s)); )
          p++;
      let m = HL(t.slice(c, l + 1), f, p), g = r.length ? r[r.length - 1] : null;
      g && g.toA == m.fromA ? r[r.length - 1] = new or(g.fromA, m.toA, g.fromB, m.toB, g.deleted.concat(m.deleted), g.inserted.concat(m.inserted)) : r.push(m);
    } else
      for (let f = c; f <= l; f++)
        r.push(t[f]);
  }
  return t;
}
function Eh(t, e) {
  return t === e ? t : null;
}
function HL(t, e, n) {
  let i = t[0].fromA - (t[0].fromB - e), r = t[t.length - 1], s = r.toA + (n - r.toB), o = ct.none, a = ct.none, l = (t[0].deleted.length ? t[0].deleted : t[0].inserted)[0].data, c = (t[0].inserted.length ? t[0].inserted : t[0].deleted)[0].data;
  for (let u = i, d = e, h = 0; ; h++) {
    let f = h == t.length ? null : t[h], p = f ? f.fromA : s, m = f ? f.fromB : n;
    if (p > u && (o = ct.join(o, [new ct(p - u, l)], Eh)), m > d && (a = ct.join(a, [new ct(m - d, c)], Eh)), !f)
      break;
    o = ct.join(o, f.deleted, Eh), a = ct.join(a, f.inserted, Eh), o.length && (l = o[o.length - 1].data), a.length && (c = a[a.length - 1].data), u = f.toA, d = f.toB;
  }
  return new or(i, s, e, n, o, a);
}
let qL = class Uf {
  /**
  @internal
  */
  constructor(e, n) {
    this.config = e, this.changes = n;
  }
  /**
  Computes a new changeset by adding the given step maps and
  metadata (either as an array, per-map, or as a single value to be
  associated with all maps) to the current set. Will not mutate the
  old set.
  
  Note that due to simplification that happens after each add,
  incrementally adding steps might create a different final set
  than adding all those changes at once, since different document
  tokens might be matched during simplification depending on the
  boundaries of the current changed ranges.
  */
  addSteps(e, n, i) {
    let r = [];
    for (let l = 0; l < n.length; l++) {
      let c = Array.isArray(i) ? i[l] : i, u = 0;
      n[l].forEach((d, h, f, p) => {
        r.push(new or(d + u, h + u, f, p, d == h ? ct.none : [new ct(h - d, c)], f == p ? ct.none : [new ct(p - f, c)])), u = p - f - (h - d);
      });
    }
    if (r.length == 0)
      return this;
    let s = Eb(r, this.config.combine), o = or.merge(this.changes, s, this.config.combine), a = o;
    for (let l = 0; l < a.length; l++) {
      let c = a[l];
      if (c.fromA == c.toA || c.fromB == c.toB || // Only look at changes that touch newly added changed ranges
      !s.some((d) => d.toB > c.fromB && d.fromB < c.toB))
        continue;
      let u = F3(this.config.doc.content, e.content, c);
      u.length == 1 && u[0].fromB == 0 && u[0].toB == c.toB - c.fromB || (a == o && (a = o.slice()), u.length == 1 ? a[l] = u[0] : (a.splice(l, 1, ...u), l += u.length - 1));
    }
    return new Uf(this.config, a);
  }
  /**
  The starting document of the change set.
  */
  get startDoc() {
    return this.config.doc;
  }
  /**
  Map the span's data values in the given set through a function
  and construct a new set with the resulting data.
  */
  map(e) {
    let n = (i) => {
      let r = e(i);
      return r === i.data ? i : new ct(i.length, r);
    };
    return new Uf(this.config, this.changes.map((i) => new or(i.fromA, i.toA, i.fromB, i.toB, i.deleted.map(n), i.inserted.map(n))));
  }
  /**
  Compare two changesets and return the range in which they are
  changed, if any. If the document changed between the maps, pass
  the maps for the steps that changed it as second argument, and
  make sure the method is called on the old set and passed the new
  set. The returned positions will be in new document coordinates.
  */
  changedRange(e, n) {
    if (e == this)
      return null;
    let i = n && XL(n), r = i ? i.toB - i.fromB - (i.toA - i.fromA) : 0;
    function s(d) {
      return !i || d <= i.fromA ? d : d + r;
    }
    let o = i ? i.fromB : 2e8, a = i ? i.toB : -2e8;
    function l(d, h = d) {
      o = Math.min(d, o), a = Math.max(h, a);
    }
    let c = this.changes, u = e.changes;
    for (let d = 0, h = 0; d < c.length && h < u.length; ) {
      let f = c[d], p = u[h];
      f && p && jL(f, p, s) ? (d++, h++) : p && (!f || s(f.fromB) >= p.fromB) ? (l(p.fromB, p.toB), h++) : (l(s(f.fromB), s(f.toB)), d++);
    }
    return o <= a ? { from: o, to: a } : null;
  }
  /**
  Create a changeset with the given base object and configuration.
  The `combine` function is used to compare and combine metadatait
  should return null when metadata isn't compatible, and a combined
  version for a merged range when it is.
  */
  static create(e, n = (i, r) => i === r ? i : null) {
    return new Uf({ combine: n, doc: e }, []);
  }
};
qL.computeDiff = F3;
function Eb(t, e, n = 0, i = t.length) {
  if (i == n + 1)
    return [t[n]];
  let r = n + i >> 1;
  return or.merge(Eb(t, e, n, r), Eb(t, e, r, i), e);
}
function rx(t) {
  let e = 2e8, n = -2e8;
  for (let i = 0; i < t.length; i++) {
    let r = t[i];
    e != 2e8 && (e = r.map(e, -1), n = r.map(n, 1)), r.forEach((s, o, a, l) => {
      e = Math.min(e, a), n = Math.max(n, l);
    });
  }
  return e == 2e8 ? null : { from: e, to: n };
}
function XL(t) {
  let e = rx(t);
  if (!e)
    return null;
  let n = rx(t.map((i) => i.invert()).reverse());
  return { fromA: n.from, toA: n.to, fromB: e.from, toB: e.to };
}
function jL(t, e, n) {
  return n(t.fromB) == e.fromB && n(t.toB) == e.toB && sx(t.deleted, e.deleted) && sx(t.inserted, e.inserted);
}
function sx(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n].length != e[n].length || t[n].data !== e[n].data)
      return !1;
  return !0;
}
function cn(t) {
  this.content = t;
}
cn.prototype = {
  constructor: cn,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var i = n && n != t ? this.remove(n) : this, r = i.find(t), s = i.content.slice();
    return r == -1 ? s.push(n || t, e) : (s[r + 1] = e, n && (s[r] = n)), new cn(s);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new cn(n);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new cn([t, e].concat(this.remove(t).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new cn(n);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var i = this.remove(e), r = i.content.slice(), s = i.find(t);
    return r.splice(s == -1 ? r.length : s, 0, e, n), new cn(r);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = cn.from(t), t.size ? new cn(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = cn.from(t), t.size ? new cn(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = cn.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
cn.from = function(t) {
  if (t instanceof cn) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new cn(e);
};
function z3(t, e, n) {
  for (let i = 0; ; i++) {
    if (i == t.childCount || i == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let r = t.child(i), s = e.child(i);
    if (r == s) {
      n += r.nodeSize;
      continue;
    }
    if (!r.sameMarkup(s))
      return n;
    if (r.isText && r.text != s.text) {
      for (let o = 0; r.text[o] == s.text[o]; o++)
        n++;
      return n;
    }
    if (r.content.size || s.content.size) {
      let o = z3(r.content, s.content, n + 1);
      if (o != null)
        return o;
    }
    n += r.nodeSize;
  }
}
function U3(t, e, n, i) {
  for (let r = t.childCount, s = e.childCount; ; ) {
    if (r == 0 || s == 0)
      return r == s ? null : { a: n, b: i };
    let o = t.child(--r), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      n -= l, i -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: n, b: i };
    if (o.isText && o.text != a.text) {
      let c = 0, u = Math.min(o.text.length, a.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, i--;
      return { a: n, b: i };
    }
    if (o.content.size || a.content.size) {
      let c = U3(o.content, a.content, n - 1, i - 1);
      if (c)
        return c;
    }
    n -= l, i -= l;
  }
}
class Y {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let i = 0; i < e.length; i++)
        this.size += e[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, i, r = 0, s) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o], c = a + l.nodeSize;
      if (c > e && i(l, r + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), i, r + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, i, r) {
    let s = "", o = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? r ? typeof r == "function" ? r(a) : r : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && i && (o ? o = !1 : s += i), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, i = e.firstChild, r = this.content.slice(), s = 0;
    for (n.isText && n.sameMarkup(i) && (r[r.length - 1] = n.withText(n.text + i.text), s = 1); s < e.content.length; s++)
      r.push(e.content[s]);
    return new Y(r, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let i = [], r = 0;
    if (n > e)
      for (let s = 0, o = 0; o < n; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))), i.push(a), r += a.nodeSize), o = l;
      }
    return new Y(i, r);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? Y.empty : e == 0 && n == this.content.length ? this : new Y(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let i = this.content[e];
    if (i == n)
      return this;
    let r = this.content.slice(), s = this.size + n.nodeSize - i.nodeSize;
    return r[e] = n, new Y(r, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Y([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Y(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, i = 0; n < this.content.length; n++) {
      let r = this.content[n];
      e(r, i, n), i += r.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return z3(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, i = e.size) {
    return U3(this, e, n, i);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return Ch(0, e);
    if (e == this.size)
      return Ch(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let i = 0, r = 0; ; i++) {
      let s = this.child(i), o = r + s.nodeSize;
      if (o >= e)
        return o == e || n > 0 ? Ch(i + 1, o) : Ch(i, r);
      r = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Y.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Y(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Y.empty;
    let n, i = 0;
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      i += s.nodeSize, r && s.isText && e[r - 1].sameMarkup(s) ? (n || (n = e.slice(0, r)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s);
    }
    return new Y(n || e, i);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Y.empty;
    if (e instanceof Y)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Y([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Y.empty = new Y([], 0);
const gg = { index: 0, offset: 0 };
function Ch(t, e) {
  return gg.index = t, gg.offset = e, gg;
}
function vp(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++)
      if (!vp(t[i], e[i]))
        return !1;
  } else {
    for (let i in t)
      if (!(i in e) || !vp(t[i], e[i]))
        return !1;
    for (let i in e)
      if (!(i in t))
        return !1;
  }
  return !0;
}
let nt = class Cb {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, i = !1;
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        n || (n = e.slice(0, r));
      else {
        if (s.type.excludes(this.type))
          return e;
        !i && s.type.rank > this.type.rank && (n || (n = e.slice(0, r)), n.push(this), i = !0), n && n.push(s);
      }
    }
    return n || (n = e.slice()), i || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && vp(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let i = e.marks[n.type];
    if (!i)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let r = i.create(n.attrs);
    return i.checkAttrs(r.attrs), r;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let i = 0; i < e.length; i++)
      if (!e[i].eq(n[i]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Cb.none;
    if (e instanceof Cb)
      return [e];
    let n = e.slice();
    return n.sort((i, r) => i.type.rank - r.type.rank), n;
  }
};
nt.none = [];
class xp extends Error {
}
class ne {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, i) {
    this.content = e, this.openStart = n, this.openEnd = i;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let i = V3(this.content, e + this.openStart, n);
    return i && new ne(i, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new ne(W3(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return ne.empty;
    let i = n.openStart || 0, r = n.openEnd || 0;
    if (typeof i != "number" || typeof r != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ne(Y.fromJSON(e, n.content), i, r);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let i = 0, r = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
      i++;
    for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
      r++;
    return new ne(e, i, r);
  }
}
ne.empty = new ne(Y.empty, 0, 0);
function W3(t, e, n) {
  let { index: i, offset: r } = t.findIndex(e), s = t.maybeChild(i), { index: o, offset: a } = t.findIndex(n);
  if (r == e || s.isText) {
    if (a != n && !t.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (i != o)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(i, s.copy(W3(s.content, e - r - 1, n - r - 1)));
}
function V3(t, e, n, i) {
  let { index: r, offset: s } = t.findIndex(e), o = t.maybeChild(r);
  if (s == e || o.isText)
    return t.cut(0, e).append(n).append(t.cut(e));
  let a = V3(o.content, e - s - 1, n);
  return a && t.replaceChild(r, o.copy(a));
}
function YL(t, e, n) {
  if (n.openStart > t.depth)
    throw new xp("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new xp("Inconsistent open depths");
  return Z3(t, e, n, 0);
}
function Z3(t, e, n, i) {
  let r = t.index(i), s = t.node(i);
  if (r == e.index(i) && i < t.depth - n.openStart) {
    let o = Z3(t, e, n, i + 1);
    return s.copy(s.content.replaceChild(r, o));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == i && e.depth == i) {
      let o = t.parent, a = o.content;
      return ma(o, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = GL(n, t);
      return ma(s, q3(t, o, a, e, i));
    }
  else return ma(s, wp(t, e, i));
}
function H3(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new xp("Cannot join " + e.type.name + " onto " + t.type.name);
}
function Ab(t, e, n) {
  let i = t.node(n);
  return H3(i, e.node(n)), i;
}
function pa(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function uu(t, e, n, i) {
  let r = (e || t).node(n), s = 0, o = e ? e.index(n) : r.childCount;
  t && (s = t.index(n), t.depth > n ? s++ : t.textOffset && (pa(t.nodeAfter, i), s++));
  for (let a = s; a < o; a++)
    pa(r.child(a), i);
  e && e.depth == n && e.textOffset && pa(e.nodeBefore, i);
}
function ma(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function q3(t, e, n, i, r) {
  let s = t.depth > r && Ab(t, e, r + 1), o = i.depth > r && Ab(n, i, r + 1), a = [];
  return uu(null, t, r, a), s && o && e.index(r) == n.index(r) ? (H3(s, o), pa(ma(s, q3(t, e, n, i, r + 1)), a)) : (s && pa(ma(s, wp(t, e, r + 1)), a), uu(e, n, r, a), o && pa(ma(o, wp(n, i, r + 1)), a)), uu(i, null, r, a), new Y(a);
}
function wp(t, e, n) {
  let i = [];
  if (uu(null, t, n, i), t.depth > n) {
    let r = Ab(t, e, n + 1);
    pa(ma(r, wp(t, e, n + 1)), i);
  }
  return uu(e, null, n, i), new Y(i);
}
function GL(t, e) {
  let n = e.depth - t.openStart, r = e.node(n).copy(t.content);
  for (let s = n - 1; s >= 0; s--)
    r = e.node(s).copy(Y.from(r));
  return {
    start: r.resolveNoCache(t.openStart + n),
    end: r.resolveNoCache(r.content.size - t.openEnd - n)
  };
}
class Qu {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.pos = e, this.path = n, this.parentOffset = i, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let i = this.pos - this.path[this.path.length - 1], r = e.child(n);
    return i ? e.child(n).cut(i) : r;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let i = this.path[n * 3], r = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      r += i.child(s).nodeSize;
    return r;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return nt.none;
    if (this.textOffset)
      return e.child(n).marks;
    let i = e.maybeChild(n - 1), r = e.maybeChild(n);
    if (!i) {
      let a = i;
      i = r, r = a;
    }
    let s = i.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!r || !s[o].isInSet(r.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let i = n.marks, r = e.parent.maybeChild(e.index());
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 && (!r || !i[s].isInSet(r.marks)) && (i = i[s--].removeFromSet(i));
    return i;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let i = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); i >= 0; i--)
      if (e.pos <= this.end(i) && (!n || n(this.node(i))))
        return new Sp(this, e, i);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let i = [], r = 0, s = n;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s), c = s - l;
      if (i.push(o, a, r + l), !c || (o = o.child(a), o.isText))
        break;
      s = c - 1, r += l + 1;
    }
    return new Qu(n, i, s);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let i = ox.get(e);
    if (i)
      for (let s = 0; s < i.elts.length; s++) {
        let o = i.elts[s];
        if (o.pos == n)
          return o;
      }
    else
      ox.set(e, i = new KL());
    let r = i.elts[i.i] = Qu.resolve(e, n);
    return i.i = (i.i + 1) % JL, r;
  }
}
class KL {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const JL = 12, ox = /* @__PURE__ */ new WeakMap();
class Sp {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, i) {
    this.$from = e, this.$to = n, this.depth = i;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const e9 = /* @__PURE__ */ Object.create(null);
let Wr = class Tb {
  /**
  @internal
  */
  constructor(e, n, i, r = nt.none) {
    this.type = e, this.attrs = n, this.marks = r, this.content = i || Y.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, i, r = 0) {
    this.content.nodesBetween(e, n, i, r, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, i, r) {
    return this.content.textBetween(e, n, i, r);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, i) {
    return this.type == e && vp(this.attrs, n || e.defaultAttrs || e9) && nt.sameSet(this.marks, i || nt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Tb(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Tb(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, i = !1) {
    if (e == n)
      return ne.empty;
    let r = this.resolve(e), s = this.resolve(n), o = i ? 0 : r.sharedDepth(n), a = r.start(o), c = r.node(o).content.cut(r.pos - a, s.pos - a);
    return new ne(c, r.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, i) {
    return YL(this.resolve(e), this.resolve(n), i);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: i, offset: r } = n.content.findIndex(e);
      if (n = n.maybeChild(i), !n)
        return null;
      if (r == e || n.isText)
        return n;
      e -= r + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: i } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: i };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: i } = this.content.findIndex(e);
    if (i < e)
      return { node: this.content.child(n), index: n, offset: i };
    let r = this.content.child(n - 1);
    return { node: r, index: n - 1, offset: i - r.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Qu.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Qu.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, i) {
    let r = !1;
    return n > e && this.nodesBetween(e, n, (s) => (i.isInSet(s.marks) && (r = !0), !r)), r;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), X3(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, i = Y.empty, r = 0, s = i.childCount) {
    let o = this.contentMatchAt(e).matchFragment(i, r, s), a = o && o.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = r; l < s; l++)
      if (!this.type.allowsMarks(i.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, i, r) {
    if (r && !this.type.allowsMarks(r))
      return !1;
    let s = this.contentMatchAt(e).matchType(i), o = s && s.matchFragment(this.content, n);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = nt.none;
    for (let n = 0; n < this.marks.length; n++) {
      let i = this.marks[n];
      i.type.checkAttrs(i.attrs), e = i.addToSet(e);
    }
    if (!nt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let i;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      i = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, i);
    }
    let r = Y.fromJSON(e, n.content), s = e.nodeType(n.type).create(n.attrs, r, i);
    return s.type.checkAttrs(s.attrs), s;
  }
};
Wr.prototype.text = void 0;
let t9 = class Mb extends Wr {
  /**
  @internal
  */
  constructor(e, n, i, r) {
    if (super(e, n, null, r), !i)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = i;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : X3(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Mb(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Mb(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function X3(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class Sa {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let i = new n9(e, n);
    if (i.next == null)
      return Sa.empty;
    let r = j3(i);
    i.next && i.err("Unexpected trailing text");
    let s = c9(l9(r));
    return u9(s, i), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, i = e.childCount) {
    let r = this;
    for (let s = n; r && s < i; s++)
      r = r.matchType(e.child(s).type);
    return r;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let i = 0; i < e.next.length; i++)
        if (this.next[n].type == e.next[i].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, i = 0) {
    let r = [this];
    function s(o, a) {
      let l = o.matchFragment(e, i);
      if (l && (!n || l.validEnd))
        return Y.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: d } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && r.indexOf(d) == -1) {
          r.push(d);
          let h = s(d, a.concat(u));
          if (h)
            return h;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == e)
        return this.wrapCache[i + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), i = [{ match: this, type: null, via: null }];
    for (; i.length; ) {
      let r = i.shift(), s = r.match;
      if (s.matchType(e)) {
        let o = [];
        for (let a = r; a.type; a = a.via)
          o.push(a.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!r.type || l.validEnd) && (i.push({ match: a.contentMatch, type: a, via: r }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(i) {
      e.push(i);
      for (let r = 0; r < i.next.length; r++)
        e.indexOf(i.next[r].next) == -1 && n(i.next[r].next);
    }
    return n(this), e.map((i, r) => {
      let s = r + (i.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < i.next.length; o++)
        s += (o ? ", " : "") + i.next[o].type.name + "->" + e.indexOf(i.next[o].next);
      return s;
    }).join(`
`);
  }
}
Sa.empty = new Sa(!0);
class n9 {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function j3(t) {
  let e = [];
  do
    e.push(i9(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function i9(t) {
  let e = [];
  do
    e.push(r9(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function r9(t) {
  let e = a9(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = s9(t, e);
    else
      break;
  return e;
}
function ax(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function s9(t, e) {
  let n = ax(t), i = n;
  return t.eat(",") && (t.next != "}" ? i = ax(t) : i = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: i, expr: e };
}
function o9(t, e) {
  let n = t.nodeTypes, i = n[e];
  if (i)
    return [i];
  let r = [];
  for (let s in n) {
    let o = n[s];
    o.groups.indexOf(e) > -1 && r.push(o);
  }
  return r.length == 0 && t.err("No node type or group '" + e + "' found"), r;
}
function a9(t) {
  if (t.eat("(")) {
    let e = j3(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = o9(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function l9(t) {
  let e = [[]];
  return r(s(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function i(o, a, l) {
    let c = { term: l, to: a };
    return e[o].push(c), c;
  }
  function r(o, a) {
    o.forEach((l) => l.to = a);
  }
  function s(o, a) {
    if (o.type == "choice")
      return o.exprs.reduce((l, c) => l.concat(s(c, a)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let c = s(o.exprs[l], a);
        if (l == o.exprs.length - 1)
          return c;
        r(c, a = n());
      }
    else if (o.type == "star") {
      let l = n();
      return i(a, l), r(s(o.expr, l), l), [i(l)];
    } else if (o.type == "plus") {
      let l = n();
      return r(s(o.expr, a), l), r(s(o.expr, l), l), [i(l)];
    } else {
      if (o.type == "opt")
        return [i(a)].concat(s(o.expr, a));
      if (o.type == "range") {
        let l = a;
        for (let c = 0; c < o.min; c++) {
          let u = n();
          r(s(o.expr, l), u), l = u;
        }
        if (o.max == -1)
          r(s(o.expr, l), l);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = n();
            i(l, u), r(s(o.expr, l), u), l = u;
          }
        return [i(l)];
      } else {
        if (o.type == "name")
          return [i(a, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function Y3(t, e) {
  return e - t;
}
function lx(t, e) {
  let n = [];
  return i(e), n.sort(Y3);
  function i(r) {
    let s = t[r];
    if (s.length == 1 && !s[0].term)
      return i(s[0].to);
    n.push(r);
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o];
      !a && n.indexOf(l) == -1 && i(l);
    }
  }
}
function c9(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(lx(t, 0));
  function n(i) {
    let r = [];
    i.forEach((o) => {
      t[o].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let u = 0; u < r.length; u++)
          r[u][0] == a && (c = r[u][1]);
        lx(t, l).forEach((u) => {
          c || r.push([a, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[i.join(",")] = new Sa(i.indexOf(t.length - 1) > -1);
    for (let o = 0; o < r.length; o++) {
      let a = r[o][1].sort(Y3);
      s.next.push({ type: r[o][0], next: e[a.join(",")] || n(a) });
    }
    return s;
  }
}
function u9(t, e) {
  for (let n = 0, i = [t]; n < i.length; n++) {
    let r = i[n], s = !r.validEnd, o = [];
    for (let a = 0; a < r.next.length; a++) {
      let { type: l, next: c } = r.next[a];
      o.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), i.indexOf(c) == -1 && i.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function G3(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let i = t[n];
    if (!i.hasDefault)
      return null;
    e[n] = i.default;
  }
  return e;
}
function K3(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i in t) {
    let r = e && e[i];
    if (r === void 0) {
      let s = t[i];
      if (s.hasDefault)
        r = s.default;
      else
        throw new RangeError("No value supplied for attribute " + i);
    }
    n[i] = r;
  }
  return n;
}
function J3(t, e, n, i) {
  for (let r in e)
    if (!(r in t))
      throw new RangeError(`Unsupported attribute ${r} for ${n} of type ${r}`);
  for (let r in t) {
    let s = t[r];
    s.validate && s.validate(e[r]);
  }
}
function eT(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let i in e)
      n[i] = new h9(t, i, e[i]);
  return n;
}
let cx = class tT {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.name = e, this.schema = n, this.spec = i, this.markSet = null, this.groups = i.group ? i.group.split(" ") : [], this.attrs = eT(e, i.attrs), this.defaultAttrs = G3(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(i.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Sa.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : K3(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, i) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Wr(this, this.computeAttrs(e), Y.from(n), nt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, i) {
    return n = Y.from(n), this.checkContent(n), new Wr(this, this.computeAttrs(e), n, nt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, i) {
    if (e = this.computeAttrs(e), n = Y.from(n), n.size) {
      let o = this.contentMatch.fillBefore(n);
      if (!o)
        return null;
      n = o.append(n);
    }
    let r = this.contentMatch.matchFragment(n), s = r && r.fillBefore(Y.empty, !0);
    return s ? new Wr(this, e, n.append(s), nt.setFrom(i)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let i = 0; i < e.childCount; i++)
      if (!this.allowsMarks(e.child(i).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    J3(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let i = 0; i < e.length; i++)
      this.allowsMarkType(e[i].type) ? n && n.push(e[i]) : n || (n = e.slice(0, i));
    return n ? n.length ? n : nt.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let i = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => i[s] = new tT(s, n, o));
    let r = n.spec.topNode || "doc";
    if (!i[r])
      throw new RangeError("Schema is missing its top node type ('" + r + "')");
    if (!i.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in i.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return i;
  }
};
function d9(t, e, n) {
  let i = n.split("|");
  return (r) => {
    let s = r === null ? "null" : typeof r;
    if (i.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${i} for attribute ${e} on type ${t}, got ${s}`);
  };
}
let h9 = class {
  constructor(e, n, i) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(i, "default"), this.default = i.default, this.validate = typeof i.validate == "string" ? d9(e, n, i.validate) : i.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
class c0 {
  /**
  @internal
  */
  constructor(e, n, i, r) {
    this.name = e, this.rank = n, this.schema = i, this.spec = r, this.attrs = eT(e, r.attrs), this.excluded = null;
    let s = G3(this.attrs);
    this.instance = s ? new nt(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new nt(this, K3(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let i = /* @__PURE__ */ Object.create(null), r = 0;
    return e.forEach((s, o) => i[s] = new c0(s, r++, n, o)), i;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    J3(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
let u0 = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let r in e)
      n[r] = e[r];
    n.nodes = cn.from(e.nodes), n.marks = cn.from(e.marks || {}), this.nodes = cx.compile(this.spec.nodes, this), this.marks = c0.compile(this.spec.marks, this);
    let i = /* @__PURE__ */ Object.create(null);
    for (let r in this.nodes) {
      if (r in this.marks)
        throw new RangeError(r + " can not be both a node and a mark");
      let s = this.nodes[r], o = s.spec.content || "", a = s.spec.marks;
      if (s.contentMatch = i[o] || (i[o] = Sa.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = a == "_" ? null : a ? ux(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
    }
    for (let r in this.marks) {
      let s = this.marks[r], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : ux(this, o.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, i, r) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof cx) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, i, r);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let i = this.nodes.text;
    return new t9(i, i.defaultAttrs, e, nt.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Wr.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return nt.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
};
function ux(t, e) {
  let n = [];
  for (let i = 0; i < e.length; i++) {
    let r = e[i], s = t.marks[r], o = s;
    if (s)
      n.push(s);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (r == "_" || l.spec.group && l.spec.group.split(" ").indexOf(r) > -1) && n.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[i] + "'");
  }
  return n;
}
function f9(t) {
  return t.tag != null;
}
function p9(t) {
  return t.style != null;
}
class ws {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let i = this.matchedStyles = [];
    n.forEach((r) => {
      if (f9(r))
        this.tags.push(r);
      else if (p9(r)) {
        let s = /[^=]*/.exec(r.style)[0];
        i.indexOf(s) < 0 && i.push(s), this.styles.push(r);
      }
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let s = e.nodes[r.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let i = new hx(this, n, !1);
    return i.addAll(e, n.from, n.to), i.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let i = new hx(this, n, !0);
    return i.addAll(e, n.from, n.to), ne.maxOpen(i.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, i) {
    for (let r = i ? this.tags.indexOf(i) + 1 : 0; r < this.tags.length; r++) {
      let s = this.tags[r];
      if (b9(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, i, r) {
    for (let s = r ? this.styles.indexOf(r) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !i.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (o.getAttrs) {
          let l = o.getAttrs(n);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function i(r) {
      let s = r.priority == null ? 50 : r.priority, o = 0;
      for (; o < n.length; o++) {
        let a = n[o];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      n.splice(o, 0, r);
    }
    for (let r in e.marks) {
      let s = e.marks[r].spec.parseDOM;
      s && s.forEach((o) => {
        i(o = fx(o)), o.mark || o.ignore || o.clearMark || (o.mark = r);
      });
    }
    for (let r in e.nodes) {
      let s = e.nodes[r].spec.parseDOM;
      s && s.forEach((o) => {
        i(o = fx(o)), o.node || o.ignore || o.mark || (o.node = r);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new ws(e, ws.schemaRules(e)));
  }
}
const nT = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, m9 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, iT = { ol: !0, ul: !0 }, kp = 1, Ep = 2, du = 4;
function dx(t, e, n) {
  return e != null ? (e ? kp : 0) | (e === "full" ? Ep : 0) : t && t.whitespace == "pre" ? kp | Ep : n & ~du;
}
class Ah {
  constructor(e, n, i, r, s, o, a) {
    this.type = e, this.attrs = n, this.marks = i, this.pendingMarks = r, this.solid = s, this.options = a, this.content = [], this.activeMarks = nt.none, this.stashMarks = [], this.match = o || (a & du ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(Y.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let i = this.type.contentMatch, r;
        return (r = i.findWrapping(e.type)) ? (this.match = i, r) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & kp)) {
      let i = this.content[this.content.length - 1], r;
      if (i && i.isText && (r = /[ \t\r\n\u000c]+$/.exec(i.text))) {
        let s = i;
        i.text.length == r[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - r[0].length));
      }
    }
    let n = Y.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(Y.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  popFromStashMark(e) {
    for (let n = this.stashMarks.length - 1; n >= 0; n--)
      if (e.eq(this.stashMarks[n]))
        return this.stashMarks.splice(n, 1)[0];
  }
  applyPending(e) {
    for (let n = 0, i = this.pendingMarks; n < i.length; n++) {
      let r = i[n];
      (this.type ? this.type.allowsMarkType(r.type) : O9(r.type, e)) && !r.isInSet(this.activeMarks) && (this.activeMarks = r.addToSet(this.activeMarks), this.pendingMarks = r.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !nT.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
let hx = class {
  constructor(e, n, i) {
    this.parser = e, this.options = n, this.isOpen = i, this.open = 0;
    let r = n.topNode, s, o = dx(null, n.preserveWhitespace, 0) | (i ? du : 0);
    r ? s = new Ah(r.type, r.attrs, nt.none, nt.none, !0, n.topMatch || r.type.contentMatch, o) : i ? s = new Ah(null, null, nt.none, nt.none, !0, null, o) : s = new Ah(e.schema.topNodeType, null, nt.none, nt.none, !0, null, o), this.nodes = [s], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e) {
    e.nodeType == 3 ? this.addTextNode(e) : e.nodeType == 1 && this.addElement(e);
  }
  withStyleRules(e, n) {
    let i = e.style;
    if (!i || !i.length)
      return n();
    let r = this.readStyles(e.style);
    if (!r)
      return;
    let [s, o] = r, a = this.top;
    for (let l = 0; l < o.length; l++)
      this.removePendingMark(o[l], a);
    for (let l = 0; l < s.length; l++)
      this.addPendingMark(s[l]);
    n();
    for (let l = 0; l < s.length; l++)
      this.removePendingMark(s[l], a);
    for (let l = 0; l < o.length; l++)
      this.addPendingMark(o[l]);
  }
  addTextNode(e) {
    let n = e.nodeValue, i = this.top;
    if (i.options & Ep || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
      if (i.options & kp)
        i.options & Ep ? n = n.replace(/\r\n?/g, `
`) : n = n.replace(/\r?\n|\r/g, " ");
      else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
        let r = i.content[i.content.length - 1], s = e.previousSibling;
        (!r || s && s.nodeName == "BR" || r.isText && /[ \t\r\n\u000c]$/.test(r.text)) && (n = n.slice(1));
      }
      n && this.insertNode(this.parser.schema.text(n)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n) {
    let i = e.nodeName.toLowerCase(), r;
    iT.hasOwnProperty(i) && this.parser.normalizeLists && g9(e);
    let s = this.options.ruleFromNode && this.options.ruleFromNode(e) || (r = this.parser.matchTag(e, this, n));
    if (s ? s.ignore : m9.hasOwnProperty(i))
      this.findInside(e), this.ignoreFallback(e);
    else if (!s || s.skip || s.closeParent) {
      s && s.closeParent ? this.open = Math.max(0, this.open - 1) : s && s.skip.nodeType && (e = s.skip);
      let o, a = this.top, l = this.needsBlock;
      if (nT.hasOwnProperty(i))
        a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), o = !0, a.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e);
        return;
      }
      s && s.skip ? this.addAll(e) : this.withStyleRules(e, () => this.addAll(e)), o && this.sync(a), this.needsBlock = l;
    } else
      this.withStyleRules(e, () => {
        this.addElementByRule(e, s, s.consuming === !1 ? r : void 0);
      });
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`));
  }
  // Called for ignored nodes
  ignoreFallback(e) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(e) {
    let n = nt.none, i = nt.none;
    if (e.length)
      for (let r = 0; r < this.parser.matchedStyles.length; r++) {
        let s = this.parser.matchedStyles[r], o = e.getPropertyValue(s);
        if (o)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(s, o, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? this.top.pendingMarks.concat(this.top.activeMarks).forEach((c) => {
              l.clearMark(c) && (i = c.addToSet(i));
            }) : n = this.parser.schema.marks[l.mark].create(l.attrs).addToSet(n), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return [n, i];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, i) {
    let r, s, o;
    n.node ? (s = this.parser.schema.nodes[n.node], s.isLeaf ? this.insertNode(s.create(n.attrs)) || this.leafFallback(e) : r = this.enter(s, n.attrs || null, n.preserveWhitespace)) : (o = this.parser.schema.marks[n.mark].create(n.attrs), this.addPendingMark(o));
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, i);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l);
    }
    r && this.sync(a) && this.open--, o && this.removePendingMark(o, a);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, i) {
    let r = n || 0;
    for (let s = n ? e.childNodes[n] : e.firstChild, o = i == null ? null : e.childNodes[i]; s != o; s = s.nextSibling, ++r)
      this.findAtPoint(e, r), this.addDOM(s);
    this.findAtPoint(e, r);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e) {
    let n, i;
    for (let r = this.open; r >= 0; r--) {
      let s = this.nodes[r], o = s.findWrapping(e);
      if (o && (!n || n.length > o.length) && (n = o, i = s, !o.length) || s.solid)
        break;
    }
    if (!n)
      return !1;
    this.sync(i);
    for (let r = 0; r < n.length; r++)
      this.enterInner(n[r], null, !1);
    return !0;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let n = this.textblockFromContext();
      n && this.enterInner(n);
    }
    if (this.findPlace(e)) {
      this.closeExtra();
      let n = this.top;
      n.applyPending(e.type), n.match && (n.match = n.match.matchType(e.type));
      let i = n.activeMarks;
      for (let r = 0; r < e.marks.length; r++)
        (!n.type || n.type.allowsMarkType(e.marks[r].type)) && (i = e.marks[r].addToSet(i));
      return n.content.push(e.mark(i)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, i) {
    let r = this.findPlace(e.create(n));
    return r && this.enterInner(e, n, !0, i), r;
  }
  // Open a node of the given type
  enterInner(e, n = null, i = !1, r) {
    this.closeExtra();
    let s = this.top;
    s.applyPending(e), s.match = s.match && s.match.matchType(e);
    let o = dx(e, r, s.options);
    s.options & du && s.content.length == 0 && (o |= du), this.nodes.push(new Ah(e, n, s.activeMarks, s.pendingMarks, i, null, o)), this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--)
      if (this.nodes[n] == e)
        return this.open = n, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let i = this.nodes[n].content;
      for (let r = i.length - 1; r >= 0; r--)
        e += i[r].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].node == e && this.find[i].offset == n && (this.find[i].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, i) {
    if (e != n && this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node) && n.compareDocumentPosition(this.find[r].node) & (i ? 2 : 4) && (this.find[r].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), i = this.options.context, r = !this.isOpen && (!i || i.parent.type == this.nodes[0].type), s = -(i ? i.depth + 1 : 0) + (r ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (o(a - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && r ? this.nodes[l].type : i && l >= s ? i.node(l - s).type : null;
          if (!u || u.name != c && u.groups.indexOf(c) == -1)
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let i = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (i && i.isTextblock && i.defaultAttrs)
          return i;
      }
    for (let n in this.parser.schema.nodes) {
      let i = this.parser.schema.nodes[n];
      if (i.isTextblock && i.defaultAttrs)
        return i;
    }
  }
  addPendingMark(e) {
    let n = y9(e, this.top.pendingMarks);
    n && this.top.stashMarks.push(n), this.top.pendingMarks = e.addToSet(this.top.pendingMarks);
  }
  removePendingMark(e, n) {
    for (let i = this.open; i >= 0; i--) {
      let r = this.nodes[i];
      if (r.pendingMarks.lastIndexOf(e) > -1)
        r.pendingMarks = e.removeFromSet(r.pendingMarks);
      else {
        r.activeMarks = e.removeFromSet(r.activeMarks);
        let o = r.popFromStashMark(e);
        o && r.type && r.type.allowsMarkType(o.type) && (r.activeMarks = o.addToSet(r.activeMarks));
      }
      if (r == n)
        break;
    }
  }
};
function g9(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let i = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    i && iT.hasOwnProperty(i) && n ? (n.appendChild(e), e = n) : i == "li" ? n = e : i && (n = null);
  }
}
function b9(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function fx(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function O9(t, e) {
  let n = e.schema.nodes;
  for (let i in n) {
    let r = n[i];
    if (!r.allowsMarkType(t))
      continue;
    let s = [], o = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(r.contentMatch))
      return !0;
  }
}
function y9(t, e) {
  for (let n = 0; n < e.length; n++)
    if (t.eq(e[n]))
      return e[n];
}
class Wa {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, i) {
    i || (i = bg(n).createDocumentFragment());
    let r = i, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < o.marks.length; ) {
          let c = o.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(s[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          r = s.pop()[1];
        for (; l < o.marks.length; ) {
          let c = o.marks[l++], u = this.serializeMark(c, o.isInline, n);
          u && (s.push([c, r]), r.appendChild(u.dom), r = u.contentDOM || u.dom);
        }
      }
      r.appendChild(this.serializeNodeInner(o, n));
    }), i;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: i, contentDOM: r } = Wf(bg(n), this.nodes[e.type.name](e), null, e.attrs);
    if (r) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, r);
    }
    return i;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let i = this.serializeNodeInner(e, n);
    for (let r = e.marks.length - 1; r >= 0; r--) {
      let s = this.serializeMark(e.marks[r], e.isInline, n);
      s && ((s.contentDOM || s.dom).appendChild(i), i = s.dom);
    }
    return i;
  }
  /**
  @internal
  */
  serializeMark(e, n, i = {}) {
    let r = this.marks[e.type.name];
    return r && Wf(bg(i), r(e, n), null, e.attrs);
  }
  static renderSpec(e, n, i = null, r) {
    return Wf(e, n, i, r);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Wa(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = px(e.nodes);
    return n.text || (n.text = (i) => i.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return px(e.marks);
  }
}
function px(t) {
  let e = {};
  for (let n in t) {
    let i = t[n].spec.toDOM;
    i && (e[n] = i);
  }
  return e;
}
function bg(t) {
  return t.document || window.document;
}
const mx = /* @__PURE__ */ new WeakMap();
function _9(t) {
  let e = mx.get(t);
  return e === void 0 && mx.set(t, e = v9(t)), e;
}
function v9(t) {
  let e = null;
  function n(i) {
    if (i && typeof i == "object")
      if (Array.isArray(i))
        if (typeof i[0] == "string")
          e || (e = []), e.push(i);
        else
          for (let r = 0; r < i.length; r++)
            n(i[r]);
      else
        for (let r in i)
          n(i[r]);
  }
  return n(t), e;
}
function Wf(t, e, n, i) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let r = e[0], s;
  if (typeof r != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (i && (s = _9(i)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = r.indexOf(" ");
  o > 0 && (n = r.slice(0, o), r = r.slice(o + 1));
  let a, l = n ? t.createElementNS(n, r) : t.createElement(r), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let h = d.indexOf(" ");
        h > 0 ? l.setAttributeNS(d.slice(0, h), d.slice(h + 1), c[d]) : l.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let h = e[d];
    if (h === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: f, contentDOM: p } = Wf(t, h, n, i);
      if (l.appendChild(f), p) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = p;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const rT = 65535, sT = Math.pow(2, 16);
function x9(t, e) {
  return t + e * sT;
}
function gx(t) {
  return t & rT;
}
function w9(t) {
  return (t - (t & rT)) / sT;
}
const oT = 1, aT = 2, Vf = 4, lT = 8;
class Pb {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.pos = e, this.delInfo = n, this.recover = i;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & lT) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (oT | Vf)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (aT | Vf)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Vf) > 0;
  }
}
class Oi {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Oi.empty)
      return Oi.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, i = gx(e);
    if (!this.inverted)
      for (let r = 0; r < i; r++)
        n += this.ranges[r * 3 + 2] - this.ranges[r * 3 + 1];
    return this.ranges[i * 3] + n + w9(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, i) {
    let r = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = this.ranges[a + o], d = l + c;
      if (e <= d) {
        let h = c ? e == l ? -1 : e == d ? 1 : n : n, f = l + r + (h < 0 ? 0 : u);
        if (i)
          return f;
        let p = e == (n < 0 ? l : d) ? null : x9(a / 3, e - l), m = e == l ? aT : e == d ? oT : Vf;
        return (n < 0 ? e != l : e != d) && (m |= lT), new Pb(f, m, p);
      }
      r += u - c;
    }
    return i ? e + r : new Pb(e + r, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let i = 0, r = gx(n), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = l + c;
      if (e <= u && a == r * 3)
        return !0;
      i += this.ranges[a + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let r = 0, s = 0; r < this.ranges.length; r += 3) {
      let o = this.ranges[r], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), c = this.ranges[r + n], u = this.ranges[r + i];
      e(a, a + c, l, l + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Oi(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Oi.empty : new Oi(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Oi.empty = new Oi([]);
class wl {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, i = 0, r = e.length) {
    this.maps = e, this.mirror = n, this.from = i, this.to = r;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new wl(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new wl(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, i = this.maps.length; n < e.maps.length; n++) {
      let r = e.getMirror(n);
      this.appendMap(e.maps[n], r != null && r < n ? i + r : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, i = this.maps.length + e.maps.length; n >= 0; n--) {
      let r = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), r != null && r > n ? i - r - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new wl();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let i = this.from; i < this.to; i++)
      e = this.maps[i].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, i) {
    let r = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this.maps[s], a = o.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      r |= a.delInfo, e = a.pos;
    }
    return i ? e : new Pb(e, r, null);
  }
}
const Og = /* @__PURE__ */ Object.create(null);
class Pn {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Oi.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let i = Og[n.stepType];
    if (!i)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return i.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in Og)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Og[e] = n, n.prototype.jsonID = e, n;
  }
}
class Wt {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Wt(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Wt(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, i, r) {
    try {
      return Wt.ok(e.replace(n, i, r));
    } catch (s) {
      if (s instanceof xp)
        return Wt.fail(s.message);
      throw s;
    }
  }
}
function Jy(t, e, n) {
  let i = [];
  for (let r = 0; r < t.childCount; r++) {
    let s = t.child(r);
    s.content.size && (s = s.copy(Jy(s.content, e, s))), s.isInline && (s = e(s, n, r)), i.push(s);
  }
  return Y.fromArray(i);
}
class _s extends Pn {
  /**
  Create a mark step.
  */
  constructor(e, n, i) {
    super(), this.from = e, this.to = n, this.mark = i;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), i = e.resolve(this.from), r = i.node(i.sharedDepth(this.to)), s = new ne(Jy(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), r), n.openStart, n.openEnd);
    return Wt.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new ar(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deleted && i.deleted || n.pos >= i.pos ? null : new _s(n.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof _s && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new _s(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _s(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Pn.jsonID("addMark", _s);
class ar extends Pn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, i) {
    super(), this.from = e, this.to = n, this.mark = i;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), i = new ne(Jy(n.content, (r) => r.mark(this.mark.removeFromSet(r.marks)), e), n.openStart, n.openEnd);
    return Wt.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new _s(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deleted && i.deleted || n.pos >= i.pos ? null : new ar(n.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof ar && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ar(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ar(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Pn.jsonID("removeMark", ar);
class no extends Pn {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Wt.fail("No node at mark step's position");
    let i = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Wt.fromReplace(e, this.pos, this.pos + 1, new ne(Y.from(i), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let i = this.mark.addToSet(n.marks);
      if (i.length == n.marks.length) {
        for (let r = 0; r < n.marks.length; r++)
          if (!n.marks[r].isInSet(i))
            return new no(this.pos, n.marks[r]);
        return new no(this.pos, this.mark);
      }
    }
    return new Fl(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new no(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new no(n.pos, e.markFromJSON(n.mark));
  }
}
Pn.jsonID("addNodeMark", no);
class Fl extends Pn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Wt.fail("No node at mark step's position");
    let i = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Wt.fromReplace(e, this.pos, this.pos + 1, new ne(Y.from(i), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new no(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Fl(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Fl(n.pos, e.markFromJSON(n.mark));
  }
}
Pn.jsonID("removeNodeMark", Fl);
class tn extends Pn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, i, r = !1) {
    super(), this.from = e, this.to = n, this.slice = i, this.structure = r;
  }
  apply(e) {
    return this.structure && Rb(e, this.from, this.to) ? Wt.fail("Structure replace would overwrite content") : Wt.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Oi([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new tn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deletedAcross && i.deletedAcross ? null : new tn(n.pos, Math.max(n.pos, i.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof tn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? ne.empty : new ne(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new tn(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? ne.empty : new ne(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new tn(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new tn(n.from, n.to, ne.fromJSON(e, n.slice), !!n.structure);
  }
}
Pn.jsonID("replace", tn);
class on extends Pn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, i, r, s, o, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = i, this.gapTo = r, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Rb(e, this.from, this.gapFrom) || Rb(e, this.gapTo, this.to)))
      return Wt.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Wt.fail("Gap is not a flat range");
    let i = this.slice.insertAt(this.insert, n.content);
    return i ? Wt.fromReplace(e, this.from, this.to, i) : Wt.fail("Content does not fit in gap");
  }
  getMap() {
    return new Oi([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new on(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1), r = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? i.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && i.deletedAcross || r < n.pos || s > i.pos ? null : new on(n.pos, i.pos, r, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new on(n.from, n.to, n.gapFrom, n.gapTo, ne.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Pn.jsonID("replaceAround", on);
function Rb(t, e, n) {
  let i = t.resolve(e), r = n - e, s = i.depth;
  for (; r > 0 && s > 0 && i.indexAfter(s) == i.node(s).childCount; )
    s--, r--;
  if (r > 0) {
    let o = i.node(s).maybeChild(i.indexAfter(s));
    for (; r > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, r--;
    }
  }
  return !1;
}
function S9(t, e, n, i) {
  let r = [], s = [], o, a;
  t.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!i.isInSet(d) && u.type.allowsMarkType(i.type)) {
      let h = Math.max(c, e), f = Math.min(c + l.nodeSize, n), p = i.addToSet(d);
      for (let m = 0; m < d.length; m++)
        d[m].isInSet(p) || (o && o.to == h && o.mark.eq(d[m]) ? o.to = f : r.push(o = new ar(h, f, d[m])));
      a && a.to == h ? a.to = f : s.push(a = new _s(h, f, i));
    }
  }), r.forEach((l) => t.step(l)), s.forEach((l) => t.step(l));
}
function k9(t, e, n, i) {
  let r = [], s = 0;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (!o.isInline)
      return;
    s++;
    let l = null;
    if (i instanceof c0) {
      let c = o.marks, u;
      for (; u = i.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else i ? i.isInSet(o.marks) && (l = [i]) : l = o.marks;
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, n);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], h;
        for (let f = 0; f < r.length; f++) {
          let p = r[f];
          p.step == s - 1 && d.eq(r[f].style) && (h = p);
        }
        h ? (h.to = c, h.step = s) : r.push({ style: d, from: Math.max(a, e), to: c, step: s });
      }
    }
  }), r.forEach((o) => t.step(new ar(o.from, o.to, o.style)));
}
function cT(t, e, n, i = n.contentMatch, r = !0) {
  let s = t.doc.nodeAt(e), o = [], a = e + 1;
  for (let l = 0; l < s.childCount; l++) {
    let c = s.child(l), u = a + c.nodeSize, d = i.matchType(c.type);
    if (!d)
      o.push(new tn(a, u, ne.empty));
    else {
      i = d;
      for (let h = 0; h < c.marks.length; h++)
        n.allowsMarkType(c.marks[h].type) || t.step(new ar(a, u, c.marks[h]));
      if (r && c.isText && n.whitespace != "pre") {
        let h, f = /\r?\n|\r/g, p;
        for (; h = f.exec(c.text); )
          p || (p = new ne(Y.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), o.push(new tn(a + h.index, a + h.index + h[0].length, p));
      }
    }
    a = u;
  }
  if (!i.validEnd) {
    let l = i.fillBefore(Y.empty, !0);
    t.replace(a, a, new ne(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    t.step(o[l]);
}
function E9(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function pc(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let i = t.depth; ; --i) {
    let r = t.$from.node(i), s = t.$from.index(i), o = t.$to.indexAfter(i);
    if (i < t.depth && r.canReplace(s, o, n))
      return i;
    if (i == 0 || r.type.spec.isolating || !E9(r, s, o))
      break;
  }
  return null;
}
function C9(t, e, n) {
  let { $from: i, $to: r, depth: s } = e, o = i.before(s + 1), a = r.after(s + 1), l = o, c = a, u = Y.empty, d = 0;
  for (let p = s, m = !1; p > n; p--)
    m || i.index(p) > 0 ? (m = !0, u = Y.from(i.node(p).copy(u)), d++) : l--;
  let h = Y.empty, f = 0;
  for (let p = s, m = !1; p > n; p--)
    m || r.after(p + 1) < r.end(p) ? (m = !0, h = Y.from(r.node(p).copy(h)), f++) : c++;
  t.step(new on(l, c, o, a, new ne(u.append(h), d, f), u.size - d, !0));
}
function d0(t, e, n = null, i = t) {
  let r = A9(t, e), s = r && T9(i, e);
  return s ? r.map(bx).concat({ type: e, attrs: n }).concat(s.map(bx)) : null;
}
function bx(t) {
  return { type: t, attrs: null };
}
function A9(t, e) {
  let { parent: n, startIndex: i, endIndex: r } = t, s = n.contentMatchAt(i).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return n.canReplaceWith(i, r, o) ? s : null;
}
function T9(t, e) {
  let { parent: n, startIndex: i, endIndex: r } = t, s = n.child(i), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = i; l && c < r; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : o;
}
function M9(t, e, n) {
  let i = Y.empty;
  for (let o = n.length - 1; o >= 0; o--) {
    if (i.size) {
      let a = n[o].type.contentMatch.matchFragment(i);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    i = Y.from(n[o].type.create(n[o].attrs, i));
  }
  let r = e.start, s = e.end;
  t.step(new on(r, s, r, s, new ne(i, 0, 0), n.length, !0));
}
function P9(t, e, n, i, r) {
  if (!i.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = t.steps.length;
  t.doc.nodesBetween(e, n, (o, a) => {
    if (o.isTextblock && !o.hasMarkup(i, r) && N9(t.doc, t.mapping.slice(s).map(a), i)) {
      let l = null;
      if (i.schema.linebreakReplacement) {
        let h = i.whitespace == "pre", f = !!i.contentMatch.matchType(i.schema.linebreakReplacement);
        h && !f ? l = !1 : !h && f && (l = !0);
      }
      l === !1 && $9(t, o, a, s), cT(t, t.mapping.slice(s).map(a, 1), i, void 0, l === null);
      let c = t.mapping.slice(s), u = c.map(a, 1), d = c.map(a + o.nodeSize, 1);
      return t.step(new on(u, d, u + 1, d - 1, new ne(Y.from(i.create(r, null, o.marks)), 0, 0), 1, !0)), l === !0 && R9(t, o, a, s), !1;
    }
  });
}
function R9(t, e, n, i) {
  e.forEach((r, s) => {
    if (r.isText) {
      let o, a = /\r?\n|\r/g;
      for (; o = a.exec(r.text); ) {
        let l = t.mapping.slice(i).map(n + 1 + s + o.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function $9(t, e, n, i) {
  e.forEach((r, s) => {
    if (r.type == r.type.schema.linebreakReplacement) {
      let o = t.mapping.slice(i).map(n + 1 + s);
      t.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function N9(t, e, n) {
  let i = t.resolve(e), r = i.index();
  return i.parent.canReplaceWith(r, r + 1, n);
}
function D9(t, e, n, i, r) {
  let s = t.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  n || (n = s.type);
  let o = n.create(i, null, r || s.marks);
  if (s.isLeaf)
    return t.replaceWith(e, e + s.nodeSize, o);
  if (!n.validContent(s.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new on(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new ne(Y.from(o), 0, 0), 1, !0));
}
function Vr(t, e, n = 1, i) {
  let r = t.resolve(e), s = r.depth - n, o = i && i[i.length - 1] || r.parent;
  if (s < 0 || r.parent.type.spec.isolating || !r.parent.canReplace(r.index(), r.parent.childCount) || !o.type.validContent(r.parent.content.cutByIndex(r.index(), r.parent.childCount)))
    return !1;
  for (let c = r.depth - 1, u = n - 2; c > s; c--, u--) {
    let d = r.node(c), h = r.index(c);
    if (d.type.spec.isolating)
      return !1;
    let f = d.content.cutByIndex(h, d.childCount), p = i && i[u + 1];
    p && (f = f.replaceChild(0, p.type.create(p.attrs)));
    let m = i && i[u] || d;
    if (!d.canReplace(h + 1, d.childCount) || !m.type.validContent(f))
      return !1;
  }
  let a = r.indexAfter(s), l = i && i[0];
  return r.node(s).canReplaceWith(a, a, l ? l.type : r.node(s + 1).type);
}
function I9(t, e, n = 1, i) {
  let r = t.doc.resolve(e), s = Y.empty, o = Y.empty;
  for (let a = r.depth, l = r.depth - n, c = n - 1; a > l; a--, c--) {
    s = Y.from(r.node(a).copy(s));
    let u = i && i[c];
    o = Y.from(u ? u.type.create(u.attrs, o) : r.node(a).copy(o));
  }
  t.step(new tn(e, e, new ne(s.append(o), n, n), !0));
}
function es(t, e) {
  let n = t.resolve(e), i = n.index();
  return uT(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(i, i + 1);
}
function uT(t, e) {
  return !!(t && e && !t.isLeaf && t.canAppend(e));
}
function h0(t, e, n = -1) {
  let i = t.resolve(e);
  for (let r = i.depth; ; r--) {
    let s, o, a = i.index(r);
    if (r == i.depth ? (s = i.nodeBefore, o = i.nodeAfter) : n > 0 ? (s = i.node(r + 1), a++, o = i.node(r).maybeChild(a)) : (s = i.node(r).maybeChild(a - 1), o = i.node(r + 1)), s && !s.isTextblock && uT(s, o) && i.node(r).canReplace(a, a + 1))
      return e;
    if (r == 0)
      break;
    e = n < 0 ? i.before(r) : i.after(r);
  }
}
function L9(t, e, n) {
  let i = new tn(e - n, e + n, ne.empty, !0);
  t.step(i);
}
function B9(t, e, n) {
  let i = t.resolve(e);
  if (i.parent.canReplaceWith(i.index(), i.index(), n))
    return e;
  if (i.parentOffset == 0)
    for (let r = i.depth - 1; r >= 0; r--) {
      let s = i.index(r);
      if (i.node(r).canReplaceWith(s, s, n))
        return i.before(r + 1);
      if (s > 0)
        return null;
    }
  if (i.parentOffset == i.parent.content.size)
    for (let r = i.depth - 1; r >= 0; r--) {
      let s = i.indexAfter(r);
      if (i.node(r).canReplaceWith(s, s, n))
        return i.after(r + 1);
      if (s < i.node(r).childCount)
        return null;
    }
  return null;
}
function dT(t, e, n) {
  let i = t.resolve(e);
  if (!n.content.size)
    return e;
  let r = n.content;
  for (let s = 0; s < n.openStart; s++)
    r = r.firstChild.content;
  for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
    for (let o = i.depth; o >= 0; o--) {
      let a = o == i.depth ? 0 : i.pos <= (i.start(o + 1) + i.end(o + 1)) / 2 ? -1 : 1, l = i.index(o) + (a > 0 ? 1 : 0), c = i.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(l, l, r);
      else {
        let d = c.contentMatchAt(l).findWrapping(r.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return a == 0 ? i.pos : a < 0 ? i.before(o + 1) : i.after(o + 1);
    }
  return null;
}
function f0(t, e, n = e, i = ne.empty) {
  if (e == n && !i.size)
    return null;
  let r = t.resolve(e), s = t.resolve(n);
  return hT(r, s, i) ? new tn(e, n, i) : new Q9(r, s, i).fit();
}
function hT(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class Q9 {
  constructor(e, n, i) {
    this.$from = e, this.$to = n, this.unplaced = i, this.frontier = [], this.placed = Y.empty;
    for (let r = 0; r <= e.depth; r++) {
      let s = e.node(r);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(r))
      });
    }
    for (let r = e.depth; r > 0; r--)
      this.placed = Y.from(e.node(r).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, i = this.$from, r = this.close(e < 0 ? this.$to : i.doc.resolve(e));
    if (!r)
      return null;
    let s = this.placed, o = i.depth, a = r.depth;
    for (; o && a && s.childCount == 1; )
      s = s.firstChild.content, o--, a--;
    let l = new ne(s, o, a);
    return e > -1 ? new on(i.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || i.pos != this.$to.pos ? new tn(i.pos, r.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, i = 0, r = this.unplaced.openEnd; i < e; i++) {
      let s = n.firstChild;
      if (n.childCount > 1 && (r = 0), s.type.spec.isolating && r <= i) {
        e = i;
        break;
      }
      n = s.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let i = n == 1 ? e : this.unplaced.openStart; i >= 0; i--) {
        let r, s = null;
        i ? (s = yg(this.unplaced.content, i - 1).firstChild, r = s.content) : r = this.unplaced.content;
        let o = r.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, d = null;
          if (n == 1 && (o ? c.matchType(o.type) || (d = c.fillBefore(Y.from(o), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: i, frontierDepth: a, parent: s, inject: d };
          if (n == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: i, frontierDepth: a, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: i } = this.unplaced, r = yg(e, n);
    return !r.childCount || r.firstChild.isLeaf ? !1 : (this.unplaced = new ne(e, n + 1, Math.max(i, r.size + n >= e.size - i ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: i } = this.unplaced, r = yg(e, n);
    if (r.childCount <= 1 && n > 0) {
      let s = e.size - n <= n + r.size;
      this.unplaced = new ne(Wc(e, n - 1, 1), n - 1, s ? n - 1 : i);
    } else
      this.unplaced = new ne(Wc(e, n, 1), n, i);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: i, inject: r, wrap: s }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (s)
      for (let m = 0; m < s.length; m++)
        this.openFrontierNode(s[m]);
    let o = this.unplaced, a = i ? i.content : o.content, l = o.openStart - e, c = 0, u = [], { match: d, type: h } = this.frontier[n];
    if (r) {
      for (let m = 0; m < r.childCount; m++)
        u.push(r.child(m));
      d = d.matchFragment(r);
    }
    let f = a.size + e - (o.content.size - o.openEnd);
    for (; c < a.childCount; ) {
      let m = a.child(c), g = d.matchType(m.type);
      if (!g)
        break;
      c++, (c > 1 || l == 0 || m.content.size) && (d = g, u.push(fT(m.mark(h.allowedMarks(m.marks)), c == 1 ? l : 0, c == a.childCount ? f : -1)));
    }
    let p = c == a.childCount;
    p || (f = -1), this.placed = Vc(this.placed, n, Y.from(u)), this.frontier[n].match = d, p && f < 0 && i && i.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = a; m < f; m++) {
      let b = g.lastChild;
      this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
    }
    this.unplaced = p ? e == 0 ? ne.empty : new ne(Wc(o.content, e - 1, 1), e - 1, f < 0 ? o.openEnd : e - 1) : new ne(Wc(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !_g(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: i } = this.$to, r = this.$to.after(i);
    for (; i > 1 && r == this.$to.end(--i); )
      ++r;
    return r;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: i, type: r } = this.frontier[n], s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), o = _g(e, n, r, i, s);
      if (o) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a], u = _g(e, a, c, l, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: n, fit: o, move: s ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Vc(this.placed, n.depth, n.fit)), e = n.move;
    for (let i = n.depth + 1; i <= e.depth; i++) {
      let r = e.node(i), s = r.type.contentMatch.fillBefore(r.content, !0, e.index(i));
      this.openFrontierNode(r.type, r.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, n = null, i) {
    let r = this.frontier[this.depth];
    r.match = r.match.matchType(e), this.placed = Vc(this.placed, this.depth, Y.from(e.create(n, i))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(Y.empty, !0);
    n.childCount && (this.placed = Vc(this.placed, this.frontier.length, n));
  }
}
function Wc(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Wc(t.firstChild.content, e - 1, n)));
}
function Vc(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Vc(t.lastChild.content, e - 1, n)));
}
function yg(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function fT(t, e, n) {
  if (e <= 0)
    return t;
  let i = t.content;
  return e > 1 && (i = i.replaceChild(0, fT(i.firstChild, e - 1, i.childCount == 1 ? n - 1 : 0))), e > 0 && (i = t.type.contentMatch.fillBefore(i).append(i), n <= 0 && (i = i.append(t.type.contentMatch.matchFragment(i).fillBefore(Y.empty, !0)))), t.copy(i);
}
function _g(t, e, n, i, r) {
  let s = t.node(e), o = r ? t.indexAfter(e) : t.index(e);
  if (o == s.childCount && !n.compatibleContent(s.type))
    return null;
  let a = i.fillBefore(s.content, !0, o);
  return a && !F9(n, s.content, o) ? a : null;
}
function F9(t, e, n) {
  for (let i = n; i < e.childCount; i++)
    if (!t.allowsMarks(e.child(i).marks))
      return !0;
  return !1;
}
function z9(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function U9(t, e, n, i) {
  if (!i.size)
    return t.deleteRange(e, n);
  let r = t.doc.resolve(e), s = t.doc.resolve(n);
  if (hT(r, s, i))
    return t.step(new tn(e, n, i));
  let o = mT(r, t.doc.resolve(n));
  o[o.length - 1] == 0 && o.pop();
  let a = -(r.depth + 1);
  o.unshift(a);
  for (let h = r.depth, f = r.pos - 1; h > 0; h--, f--) {
    let p = r.node(h).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(h) > -1 ? a = h : r.before(h) == f && o.splice(1, 0, -h);
  }
  let l = o.indexOf(a), c = [], u = i.openStart;
  for (let h = i.content, f = 0; ; f++) {
    let p = h.firstChild;
    if (c.push(p), f == i.openStart)
      break;
    h = p.content;
  }
  for (let h = u - 1; h >= 0; h--) {
    let f = c[h], p = z9(f.type);
    if (p && !f.sameMarkup(r.node(Math.abs(a) - 1)))
      u = h;
    else if (p || !f.type.isTextblock)
      break;
  }
  for (let h = i.openStart; h >= 0; h--) {
    let f = (h + u + 1) % (i.openStart + 1), p = c[f];
    if (p)
      for (let m = 0; m < o.length; m++) {
        let g = o[(m + l) % o.length], b = !0;
        g < 0 && (b = !1, g = -g);
        let _ = r.node(g - 1), y = r.index(g - 1);
        if (_.canReplaceWith(y, y, p.type, p.marks))
          return t.replace(r.before(g), b ? s.after(g) : n, new ne(pT(i.content, 0, i.openStart, f), f, i.openEnd));
      }
  }
  let d = t.steps.length;
  for (let h = o.length - 1; h >= 0 && (t.replace(e, n, i), !(t.steps.length > d)); h--) {
    let f = o[h];
    f < 0 || (e = r.before(f), n = s.after(f));
  }
}
function pT(t, e, n, i, r) {
  if (e < n) {
    let s = t.firstChild;
    t = t.replaceChild(0, s.copy(pT(s.content, e + 1, n, i, s)));
  }
  if (e > i) {
    let s = r.contentMatchAt(0), o = s.fillBefore(t).append(t);
    t = o.append(s.matchFragment(o).fillBefore(Y.empty, !0));
  }
  return t;
}
function W9(t, e, n, i) {
  if (!i.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let r = B9(t.doc, e, i.type);
    r != null && (e = n = r);
  }
  t.replaceRange(e, n, new ne(Y.from(i), 0, 0));
}
function V9(t, e, n) {
  let i = t.doc.resolve(e), r = t.doc.resolve(n), s = mT(i, r);
  for (let o = 0; o < s.length; o++) {
    let a = s[o], l = o == s.length - 1;
    if (l && a == 0 || i.node(a).type.contentMatch.validEnd)
      return t.delete(i.start(a), r.end(a));
    if (a > 0 && (l || i.node(a - 1).canReplace(i.index(a - 1), r.indexAfter(a - 1))))
      return t.delete(i.before(a), r.after(a));
  }
  for (let o = 1; o <= i.depth && o <= r.depth; o++)
    if (e - i.start(o) == i.depth - o && n > i.end(o) && r.end(o) - n != r.depth - o)
      return t.delete(i.before(o), n);
  t.delete(e, n);
}
function mT(t, e) {
  let n = [], i = Math.min(t.depth, e.depth);
  for (let r = i; r >= 0; r--) {
    let s = t.start(r);
    if (s < t.pos - (t.depth - r) || e.end(r) > e.pos + (e.depth - r) || t.node(r).type.spec.isolating || e.node(r).type.spec.isolating)
      break;
    (s == e.start(r) || r == t.depth && r == e.depth && t.parent.inlineContent && e.parent.inlineContent && r && e.start(r - 1) == s - 1) && n.push(r);
  }
  return n;
}
class ga extends Pn {
  /**
  Construct an attribute step.
  */
  constructor(e, n, i) {
    super(), this.pos = e, this.attr = n, this.value = i;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Wt.fail("No node at attribute step's position");
    let i = /* @__PURE__ */ Object.create(null);
    for (let s in n.attrs)
      i[s] = n.attrs[s];
    i[this.attr] = this.value;
    let r = n.type.create(i, null, n.marks);
    return Wt.fromReplace(e, this.pos, this.pos + 1, new ne(Y.from(r), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Oi.empty;
  }
  invert(e) {
    return new ga(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ga(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new ga(n.pos, n.attr, n.value);
  }
}
Pn.jsonID("attr", ga);
class Fu extends Pn {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e.attrs)
      n[r] = e.attrs[r];
    n[this.attr] = this.value;
    let i = e.type.create(n, e.content, e.marks);
    return Wt.ok(i);
  }
  getMap() {
    return Oi.empty;
  }
  invert(e) {
    return new Fu(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Fu(n.attr, n.value);
  }
}
Pn.jsonID("docAttr", Fu);
let zl = class extends Error {
};
zl = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
zl.prototype = Object.create(Error.prototype);
zl.prototype.constructor = zl;
zl.prototype.name = "TransformError";
class e2 {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new wl();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new zl(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, i = ne.empty) {
    let r = f0(this.doc, e, n, i);
    return r && this.step(r), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, i) {
    return this.replace(e, n, new ne(Y.from(i), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, ne.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, i) {
    return U9(this, e, n, i), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, i) {
    return W9(this, e, n, i), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return V9(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return C9(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return L9(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return M9(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, i, r = null) {
    return P9(this, e, n, i, r), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, i = null, r) {
    return D9(this, e, n, i, r), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, i) {
    return this.step(new ga(e, n, i)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new Fu(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new no(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof nt)) {
      let i = this.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(i.marks), !n)
        return this;
    }
    return this.step(new Fl(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, i) {
    return I9(this, e, n, i), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, i) {
    return S9(this, e, n, i), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, i) {
    return k9(this, e, n, i), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, i) {
    return cT(this, e, n, i), this;
  }
}
const vg = /* @__PURE__ */ Object.create(null);
class _e {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, i) {
    this.$anchor = e, this.$head = n, this.ranges = i || [new Cp(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = ne.empty) {
    let i = n.content.lastChild, r = null;
    for (let a = 0; a < n.openEnd; a++)
      r = i, i = i.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: c } = o[a], u = e.mapping.slice(s);
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? ne.empty : n), a == 0 && _x(e, s, (i ? i.isInline : r && r.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let i = e.steps.length, r = this.ranges;
    for (let s = 0; s < r.length; s++) {
      let { $from: o, $to: a } = r[s], l = e.mapping.slice(i), c = l.map(o.pos), u = l.map(a.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), _x(e, i, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, i = !1) {
    let r = e.parent.inlineContent ? new ce(e) : cl(e.node(0), e.parent, e.pos, e.index(), n, i);
    if (r)
      return r;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = n < 0 ? cl(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, i) : cl(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, i);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new ri(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return cl(e, e, 0, 0, 1) || new ri(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return cl(e, e, e.content.size, e.childCount, -1) || new ri(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let i = vg[n.type];
    if (!i)
      throw new RangeError(`No selection type ${n.type} defined`);
    return i.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in vg)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return vg[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ce.between(this.$anchor, this.$head).getBookmark();
  }
}
_e.prototype.visible = !0;
let Cp = class {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}, Ox = !1;
function yx(t) {
  !Ox && !t.parent.inlineContent && (Ox = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class ce extends _e {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    yx(e), yx(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let i = e.resolve(n.map(this.head));
    if (!i.parent.inlineContent)
      return _e.near(i);
    let r = e.resolve(n.map(this.anchor));
    return new ce(r.parent.inlineContent ? r : i, i);
  }
  replace(e, n = ne.empty) {
    if (super.replace(e, n), n == ne.empty) {
      let i = this.$from.marksAcross(this.$to);
      i && e.ensureMarks(i);
    }
  }
  eq(e) {
    return e instanceof ce && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new p0(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ce(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, i = n) {
    let r = e.resolve(n);
    return new this(r, i == n ? r : e.resolve(i));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, i) {
    let r = e.pos - n.pos;
    if ((!i || r) && (i = r >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let s = _e.findFrom(n, i, !0) || _e.findFrom(n, -i, !0);
      if (s)
        n = s.$head;
      else
        return _e.near(n, i);
    }
    return e.parent.inlineContent || (r == 0 ? e = n : (e = (_e.findFrom(e, -i, !0) || _e.findFrom(e, i, !0)).$anchor, e.pos < n.pos != r < 0 && (e = n))), new ce(e, n);
  }
}
_e.jsonID("text", ce);
class p0 {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new p0(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ce.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ge extends _e {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, i = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, i), this.node = n;
  }
  map(e, n) {
    let { deleted: i, pos: r } = n.mapResult(this.anchor), s = e.resolve(r);
    return i ? _e.near(s) : new ge(s);
  }
  content() {
    return new ne(Y.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ge && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new t2(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ge(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new ge(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ge.prototype.visible = !1;
_e.jsonID("node", ge);
class t2 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: i } = e.mapResult(this.anchor);
    return n ? new p0(i, i) : new t2(i);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), i = n.nodeAfter;
    return i && ge.isSelectable(i) ? new ge(n) : _e.near(n);
  }
}
class ri extends _e {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = ne.empty) {
    if (n == ne.empty) {
      e.delete(0, e.doc.content.size);
      let i = _e.atStart(e.doc);
      i.eq(e.selection) || e.setSelection(i);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new ri(e);
  }
  map(e) {
    return new ri(e);
  }
  eq(e) {
    return e instanceof ri;
  }
  getBookmark() {
    return Z9;
  }
}
_e.jsonID("all", ri);
const Z9 = {
  map() {
    return this;
  },
  resolve(t) {
    return new ri(t);
  }
};
function cl(t, e, n, i, r, s = !1) {
  if (e.inlineContent)
    return ce.create(t, n);
  for (let o = i - (r > 0 ? 0 : 1); r > 0 ? o < e.childCount : o >= 0; o += r) {
    let a = e.child(o);
    if (a.isAtom) {
      if (!s && ge.isSelectable(a))
        return ge.create(t, n - (r < 0 ? a.nodeSize : 0));
    } else {
      let l = cl(t, a, n + r, r < 0 ? a.childCount : 0, r, s);
      if (l)
        return l;
    }
    n += a.nodeSize * r;
  }
  return null;
}
function _x(t, e, n) {
  let i = t.steps.length - 1;
  if (i < e)
    return;
  let r = t.steps[i];
  if (!(r instanceof tn || r instanceof on))
    return;
  let s = t.mapping.maps[i], o;
  s.forEach((a, l, c, u) => {
    o == null && (o = u);
  }), t.setSelection(_e.near(t.doc.resolve(o), n));
}
const vx = 1, Th = 2, xx = 4;
let H9 = class extends e2 {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | vx) & ~Th, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & vx) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Th, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return nt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Th) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~Th, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let i = this.selection;
    return n && (e = e.mark(this.storedMarks || (i.empty ? i.$from.marks() : i.$from.marksAcross(i.$to) || nt.none))), i.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, i) {
    let r = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection();
    {
      if (i == null && (i = n), i = i ?? n, !e)
        return this.deleteRange(n, i);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(n);
        s = i == n ? o.marks() : o.marksAcross(this.doc.resolve(i));
      }
      return this.replaceRangeWith(n, i, r.text(e, s)), this.selection.empty || this.setSelection(_e.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= xx, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & xx) > 0;
  }
};
function wx(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Zc {
  constructor(e, n, i) {
    this.name = e, this.init = wx(n.init, i), this.apply = wx(n.apply, i);
  }
}
const q9 = [
  new Zc("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new Zc("selection", {
    init(t, e) {
      return t.selection || _e.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new Zc("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, i) {
      return i.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new Zc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
let xg = class {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = q9.slice(), n && n.forEach((i) => {
      if (this.pluginsByKey[i.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + i.key + ")");
      this.plugins.push(i), this.pluginsByKey[i.key] = i, i.spec.state && this.fields.push(new Zc(i.key, i.spec.state, i));
    });
  }
}, X9 = class Hc {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != n) {
        let r = this.config.plugins[i];
        if (r.spec.filterTransaction && !r.spec.filterTransaction.call(r, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], i = this.applyInner(e), r = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o];
        if (a.spec.appendTransaction) {
          let l = r ? r[o].n : 0, c = r ? r[o].state : this, u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, i);
          if (u && i.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !r) {
              r = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                r.push(d < o ? { state: i, n: n.length } : { state: this, n: 0 });
            }
            n.push(u), i = i.applyInner(u), s = !0;
          }
          r && (r[o] = { state: i, n: n.length });
        }
      }
      if (!s)
        return { state: i, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Hc(this.config), i = this.config.fields;
    for (let r = 0; r < i.length; r++) {
      let s = i[r];
      n[s.name] = s.apply(e, this[s.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new H9(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new xg(e.doc ? e.doc.type.schema : e.schema, e.plugins), i = new Hc(n);
    for (let r = 0; r < n.fields.length; r++)
      i[n.fields[r].name] = n.fields[r].init(e, i);
    return i;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new xg(this.schema, e.plugins), i = n.fields, r = new Hc(n);
    for (let s = 0; s < i.length; s++) {
      let o = i[s].name;
      r[o] = this.hasOwnProperty(o) ? this[o] : i[s].init(e, r);
    }
    return r;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((i) => i.toJSON())), e && typeof e == "object")
      for (let i in e) {
        if (i == "doc" || i == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let r = e[i], s = r.spec.state;
        s && s.toJSON && (n[i] = s.toJSON.call(r, this[r.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, i) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let r = new xg(e.schema, e.plugins), s = new Hc(r);
    return r.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = Wr.fromJSON(e.schema, n.doc);
      else if (o.name == "selection")
        s.selection = _e.fromJSON(s.doc, n.selection);
      else if (o.name == "storedMarks")
        n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (i)
          for (let a in i) {
            let l = i[a], c = l.spec.state;
            if (l.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              s[o.name] = c.fromJSON.call(l, e, n[a], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
};
function gT(t, e, n) {
  for (let i in t) {
    let r = t[i];
    r instanceof Function ? r = r.bind(e) : i == "handleDOMEvents" && (r = gT(r, e, {})), n[i] = r;
  }
  return n;
}
class Ue {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && gT(e.props, this, this.props), this.key = e.key ? e.key.key : bT("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const wg = /* @__PURE__ */ Object.create(null);
function bT(t) {
  return t in wg ? t + "$" + ++wg[t] : (wg[t] = 0, t + "$");
}
class Ke {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = bT(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
class OT {
  constructor(e, n, i) {
    this.step = e, this.inverted = n, this.origin = i;
  }
}
function j9(t, e, n) {
  for (let r = t.length - 1; r >= 0; r--)
    n.step(t[r].inverted);
  for (let r = 0; r < e.length; r++)
    n.step(e[r]);
  let i = [];
  for (let r = 0, s = t.length; r < t.length; r++) {
    let o = t[r].step.map(n.mapping.slice(s));
    s--, o && !n.maybeStep(o).failed && (n.mapping.setMirror(s, n.steps.length - 1), i.push(new OT(o, o.invert(n.docs[n.docs.length - 1]), t[r].origin)));
  }
  return i;
}
class Ap {
  constructor(e, n) {
    this.version = e, this.unconfirmed = n;
  }
}
function Y9(t) {
  let e = [];
  for (let n = 0; n < t.steps.length; n++)
    e.push(new OT(t.steps[n], t.steps[n].invert(t.docs[n]), t));
  return e;
}
const vs = new Ke("collab");
function K_e(t = {}) {
  let e = {
    version: t.version || 0,
    clientID: t.clientID == null ? Math.floor(Math.random() * 4294967295) : t.clientID
  };
  return new Ue({
    key: vs,
    state: {
      init: () => new Ap(e.version, []),
      apply(n, i) {
        let r = n.getMeta(vs);
        return r || (n.docChanged ? new Ap(i.version, i.unconfirmed.concat(Y9(n))) : i);
      }
    },
    config: e,
    // This is used to notify the history plugin to not merge steps,
    // so that the history can be rebased.
    historyPreserveItems: !0
  });
}
function J_e(t, e, n, i = {}) {
  let r = vs.getState(t), s = r.version + e.length, o = vs.get(t).spec.config.clientID, a = 0;
  for (; a < n.length && n[a] == o; )
    ++a;
  let l = r.unconfirmed.slice(a);
  if (e = a ? e.slice(a) : e, !e.length)
    return t.tr.setMeta(vs, new Ap(s, l));
  let c = l.length, u = t.tr;
  if (c)
    l = j9(l, e, u);
  else {
    for (let h = 0; h < e.length; h++)
      u.step(e[h]);
    l = [];
  }
  let d = new Ap(s, l);
  return i && i.mapSelectionBackward && t.selection instanceof ce && (u.setSelection(ce.between(u.doc.resolve(u.mapping.map(t.selection.anchor, -1)), u.doc.resolve(u.mapping.map(t.selection.head, -1)), -1)), u.updated &= -2), u.setMeta("rebased", c).setMeta("addToHistory", !1).setMeta(vs, d);
}
function eve(t) {
  let e = vs.getState(t);
  return e.unconfirmed.length == 0 ? null : {
    version: e.version,
    steps: e.unconfirmed.map((n) => n.step),
    clientID: vs.get(t).spec.config.clientID,
    get origins() {
      return this._origins || (this._origins = e.unconfirmed.map((n) => n.origin));
    }
  };
}
function tve(t) {
  return vs.getState(t).version;
}
const n2 = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function yT(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const _T = (t, e, n) => {
  let i = yT(t, n);
  if (!i)
    return !1;
  let r = i2(i);
  if (!r) {
    let o = i.blockRange(), a = o && pc(o);
    return a == null ? !1 : (e && e(t.tr.lift(o, a).scrollIntoView()), !0);
  }
  let s = r.nodeBefore;
  if (PT(t, r, e, -1))
    return !0;
  if (i.parent.content.size == 0 && (Ul(s, "end") || ge.isSelectable(s)))
    for (let o = i.depth; ; o--) {
      let a = f0(t.doc, i.before(o), i.after(o), ne.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(Ul(s, "end") ? _e.findFrom(l.doc.resolve(l.mapping.map(r.pos, -1)), -1) : ge.create(l.doc, r.pos - s.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || i.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && r.depth == i.depth - 1 ? (e && e(t.tr.delete(r.pos - s.nodeSize, r.pos).scrollIntoView()), !0) : !1;
}, G9 = (t, e, n) => {
  let i = yT(t, n);
  if (!i)
    return !1;
  let r = i2(i);
  return r ? vT(t, r, e) : !1;
}, K9 = (t, e, n) => {
  let i = wT(t, n);
  if (!i)
    return !1;
  let r = r2(i);
  return r ? vT(t, r, e) : !1;
};
function vT(t, e, n) {
  let i = e.nodeBefore, r = i, s = e.pos - 1;
  for (; !r.isTextblock; s--) {
    if (r.type.spec.isolating)
      return !1;
    let u = r.lastChild;
    if (!u)
      return !1;
    r = u;
  }
  let o = e.nodeAfter, a = o, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let u = a.firstChild;
    if (!u)
      return !1;
    a = u;
  }
  let c = f0(t.doc, s, l, ne.empty);
  if (!c || c.from != s || c instanceof tn && c.slice.size >= l - s)
    return !1;
  if (n) {
    let u = t.tr.step(c);
    u.setSelection(ce.create(u.doc, s)), n(u.scrollIntoView());
  }
  return !0;
}
function Ul(t, e, n = !1) {
  for (let i = t; i; i = e == "start" ? i.firstChild : i.lastChild) {
    if (i.isTextblock)
      return !0;
    if (n && i.childCount != 1)
      return !1;
  }
  return !1;
}
const xT = (t, e, n) => {
  let { $head: i, empty: r } = t.selection, s = i;
  if (!r)
    return !1;
  if (i.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : i.parentOffset > 0)
      return !1;
    s = i2(i);
  }
  let o = s && s.nodeBefore;
  return !o || !ge.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ge.create(t.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function i2(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function wT(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const ST = (t, e, n) => {
  let i = wT(t, n);
  if (!i)
    return !1;
  let r = r2(i);
  if (!r)
    return !1;
  let s = r.nodeAfter;
  if (PT(t, r, e, 1))
    return !0;
  if (i.parent.content.size == 0 && (Ul(s, "start") || ge.isSelectable(s))) {
    let o = f0(t.doc, i.before(), i.after(), ne.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = t.tr.step(o);
        a.setSelection(Ul(s, "start") ? _e.findFrom(a.doc.resolve(a.mapping.map(r.pos)), 1) : ge.create(a.doc, a.mapping.map(r.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && r.depth == i.depth - 1 ? (e && e(t.tr.delete(r.pos, r.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, kT = (t, e, n) => {
  let { $head: i, empty: r } = t.selection, s = i;
  if (!r)
    return !1;
  if (i.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : i.parentOffset < i.parent.content.size)
      return !1;
    s = r2(i);
  }
  let o = s && s.nodeAfter;
  return !o || !ge.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(ge.create(t.doc, s.pos)).scrollIntoView()), !0);
};
function r2(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const $b = (t, e) => {
  let n = t.selection, i = n instanceof ge, r;
  if (i) {
    if (n.node.isTextblock || !es(t.doc, n.from))
      return !1;
    r = n.from;
  } else if (r = h0(t.doc, n.from, -1), r == null)
    return !1;
  if (e) {
    let s = t.tr.join(r);
    i && s.setSelection(ge.create(s.doc, r - t.doc.resolve(r).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, J9 = (t, e) => {
  let n = t.selection, i;
  if (n instanceof ge) {
    if (n.node.isTextblock || !es(t.doc, n.to))
      return !1;
    i = n.to;
  } else if (i = h0(t.doc, n.to, 1), i == null)
    return !1;
  return e && e(t.tr.join(i).scrollIntoView()), !0;
}, Nb = (t, e) => {
  let { $from: n, $to: i } = t.selection, r = n.blockRange(i), s = r && pc(r);
  return s == null ? !1 : (e && e(t.tr.lift(r, s).scrollIntoView()), !0);
}, ET = (t, e) => {
  let { $head: n, $anchor: i } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(i) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function s2(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const CT = (t, e) => {
  let { $head: n, $anchor: i } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(i))
    return !1;
  let r = n.node(-1), s = n.indexAfter(-1), o = s2(r.contentMatchAt(s));
  if (!o || !r.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, o.createAndFill());
    l.setSelection(_e.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, AT = (t, e) => {
  let n = t.selection, { $from: i, $to: r } = n;
  if (n instanceof ri || i.parent.inlineContent || r.parent.inlineContent)
    return !1;
  let s = s2(r.parent.contentMatchAt(r.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!i.parentOffset && r.index() < r.parent.childCount ? i : r).pos, a = t.tr.insert(o, s.createAndFill());
    a.setSelection(ce.create(a.doc, o + 1)), e(a.scrollIntoView());
  }
  return !0;
}, TT = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let s = n.before();
    if (Vr(t.doc, s))
      return e && e(t.tr.split(s).scrollIntoView()), !0;
  }
  let i = n.blockRange(), r = i && pc(i);
  return r == null ? !1 : (e && e(t.tr.lift(i, r).scrollIntoView()), !0);
};
function e7(t) {
  return (e, n) => {
    let { $from: i, $to: r } = e.selection;
    if (e.selection instanceof ge && e.selection.node.isBlock)
      return !i.parentOffset || !Vr(e.doc, i.pos) ? !1 : (n && n(e.tr.split(i.pos).scrollIntoView()), !0);
    if (!i.parent.isBlock)
      return !1;
    if (n) {
      let s = r.parentOffset == r.parent.content.size, o = e.tr;
      (e.selection instanceof ce || e.selection instanceof ri) && o.deleteSelection();
      let a = i.depth == 0 ? null : s2(i.node(-1).contentMatchAt(i.indexAfter(-1))), l = t && t(r.parent, s, i), c = l ? [l] : s && a ? [{ type: a }] : void 0, u = Vr(o.doc, o.mapping.map(i.pos), 1, c);
      if (!c && !u && Vr(o.doc, o.mapping.map(i.pos), 1, a ? [{ type: a }] : void 0) && (a && (c = [{ type: a }]), u = !0), u && (o.split(o.mapping.map(i.pos), 1, c), !s && !i.parentOffset && i.parent.type != a)) {
        let d = o.mapping.map(i.before()), h = o.doc.resolve(d);
        a && i.node(-1).canReplaceWith(h.index(), h.index() + 1, a) && o.setNodeMarkup(o.mapping.map(i.before()), a);
      }
      n(o.scrollIntoView());
    }
    return !0;
  };
}
const MT = e7(), nve = (t, e) => MT(t, e && ((n) => {
  let i = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  i && n.ensureMarks(i), e(n);
})), Db = (t, e) => {
  let { $from: n, to: i } = t.selection, r, s = n.sharedDepth(i);
  return s == 0 ? !1 : (r = n.before(s), e && e(t.tr.setSelection(ge.create(t.doc, r))), !0);
}, t7 = (t, e) => (e && e(t.tr.setSelection(new ri(t.doc))), !0);
function n7(t, e, n) {
  let i = e.nodeBefore, r = e.nodeAfter, s = e.index();
  return !i || !r || !i.type.compatibleContent(r.type) ? !1 : !i.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t.tr.delete(e.pos - i.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(r.isTextblock || es(t.doc, e.pos)) ? !1 : (n && n(t.tr.clearIncompatible(e.pos, i.type, i.contentMatchAt(i.childCount)).join(e.pos).scrollIntoView()), !0);
}
function PT(t, e, n, i) {
  let r = e.nodeBefore, s = e.nodeAfter, o, a, l = r.type.spec.isolating || s.type.spec.isolating;
  if (!l && n7(t, e, n))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (a = r.contentMatchAt(r.childCount)).findWrapping(s.type)) && a.matchType(o[0] || s.type).validEnd) {
    if (n) {
      let f = e.pos + s.nodeSize, p = Y.empty;
      for (let b = o.length - 1; b >= 0; b--)
        p = Y.from(o[b].create(null, p));
      p = Y.from(r.copy(p));
      let m = t.tr.step(new on(e.pos - 1, f, e.pos, f, new ne(p, 1, 0), o.length, !0)), g = f + 2 * o.length;
      es(m.doc, g) && m.join(g), n(m.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || i > 0 && l ? null : _e.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), h = d && pc(d);
  if (h != null && h >= e.depth)
    return n && n(t.tr.lift(d, h).scrollIntoView()), !0;
  if (c && Ul(s, "start", !0) && Ul(r, "end")) {
    let f = r, p = [];
    for (; p.push(f), !f.isTextblock; )
      f = f.lastChild;
    let m = s, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (f.canReplace(f.childCount, f.childCount, m.content)) {
      if (n) {
        let b = Y.empty;
        for (let y = p.length - 1; y >= 0; y--)
          b = Y.from(p[y].copy(b));
        let _ = t.tr.step(new on(e.pos - p.length, e.pos + s.nodeSize, e.pos + g, e.pos + s.nodeSize - g, new ne(b, p.length, 0), 0, !0));
        n(_.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function RT(t) {
  return function(e, n) {
    let i = e.selection, r = t < 0 ? i.$from : i.$to, s = r.depth;
    for (; r.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return r.node(s).isTextblock ? (n && n(e.tr.setSelection(ce.create(e.doc, t < 0 ? r.start(s) : r.end(s)))), !0) : !1;
  };
}
const $T = RT(-1), NT = RT(1);
function Ib(t, e = null) {
  return function(n, i) {
    let { $from: r, $to: s } = n.selection, o = r.blockRange(s), a = o && d0(o, t, e);
    return a ? (i && i(n.tr.wrap(o, a).scrollIntoView()), !0) : !1;
  };
}
function Lb(t, e = null) {
  return function(n, i) {
    let r = !1;
    for (let s = 0; s < n.selection.ranges.length && !r; s++) {
      let { $from: { pos: o }, $to: { pos: a } } = n.selection.ranges[s];
      n.doc.nodesBetween(o, a, (l, c) => {
        if (r)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            r = !0;
          else {
            let u = n.doc.resolve(c), d = u.index();
            r = u.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!r)
      return !1;
    if (i) {
      let s = n.tr;
      for (let o = 0; o < n.selection.ranges.length; o++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[o];
        s.setBlockType(a, l, t, e);
      }
      i(s.scrollIntoView());
    }
    return !0;
  };
}
function i7(t, e, n, i) {
  for (let r = 0; r < e.length; r++) {
    let { $from: s, $to: o } = e[r], a = s.depth == 0 ? t.inlineContent && t.type.allowsMarkType(n) : !1;
    if (t.nodesBetween(s.pos, o.pos, (l, c) => {
      if (a || !i && l.isAtom && l.isInline && c >= s.pos && c + l.nodeSize <= o.pos)
        return !1;
      a = l.inlineContent && l.type.allowsMarkType(n);
    }), a)
      return !0;
  }
  return !1;
}
function r7(t) {
  let e = [];
  for (let n = 0; n < t.length; n++) {
    let { $from: i, $to: r } = t[n];
    i.doc.nodesBetween(i.pos, r.pos, (s, o) => {
      if (s.isAtom && s.content.size && s.isInline && o >= i.pos && o + s.nodeSize <= r.pos)
        return o + 1 > i.pos && e.push(new Cp(i, i.doc.resolve(o + 1))), i = i.doc.resolve(o + 1 + s.content.size), !1;
    }), i.pos < r.pos && e.push(new Cp(i, r));
  }
  return e;
}
function ive(t, e = null, n) {
  let i = (n && n.removeWhenPresent) !== !1, r = (n && n.enterInlineAtoms) !== !1;
  return function(s, o) {
    let { empty: a, $cursor: l, ranges: c } = s.selection;
    if (a && !l || !i7(s.doc, c, t, r))
      return !1;
    if (o)
      if (l)
        t.isInSet(s.storedMarks || l.marks()) ? o(s.tr.removeStoredMark(t)) : o(s.tr.addStoredMark(t.create(e)));
      else {
        let u, d = s.tr;
        r || (c = r7(c)), i ? u = !c.some((h) => s.doc.rangeHasMark(h.$from.pos, h.$to.pos, t)) : u = !c.every((h) => {
          let f = !1;
          return d.doc.nodesBetween(h.$from.pos, h.$to.pos, (p, m, g) => {
            if (f)
              return !1;
            f = !t.isInSet(p.marks) && !!g && g.type.allowsMarkType(t) && !(p.isText && /^\s*$/.test(p.textBetween(Math.max(0, h.$from.pos - m), Math.min(p.nodeSize, h.$to.pos - m))));
          }), !f;
        });
        for (let h = 0; h < c.length; h++) {
          let { $from: f, $to: p } = c[h];
          if (!u)
            d.removeMark(f.pos, p.pos, t);
          else {
            let m = f.pos, g = p.pos, b = f.nodeAfter, _ = p.nodeBefore, y = b && b.isText ? /^\s*/.exec(b.text)[0].length : 0, O = _ && _.isText ? /\s*$/.exec(_.text)[0].length : 0;
            m + y < g && (m += y, g -= O), d.addMark(m, g, t.create(e));
          }
        }
        o(d.scrollIntoView());
      }
    return !0;
  };
}
function s7(t, e) {
  return (n) => {
    if (!n.isGeneric)
      return t(n);
    let i = [];
    for (let s = 0; s < n.mapping.maps.length; s++) {
      let o = n.mapping.maps[s];
      for (let a = 0; a < i.length; a++)
        i[a] = o.map(i[a]);
      o.forEach((a, l, c, u) => i.push(c, u));
    }
    let r = [];
    for (let s = 0; s < i.length; s += 2) {
      let o = i[s], a = i[s + 1], l = n.doc.resolve(o), c = l.sharedDepth(a), u = l.node(c);
      for (let d = l.indexAfter(c), h = l.after(c + 1); h <= a; ++d) {
        let f = u.maybeChild(d);
        if (!f)
          break;
        if (d && r.indexOf(h) == -1) {
          let p = u.child(d - 1);
          p.type == f.type && e(p, f) && r.push(h);
        }
        h += f.nodeSize;
      }
    }
    r.sort((s, o) => s - o);
    for (let s = r.length - 1; s >= 0; s--)
      es(n.doc, r[s]) && n.join(r[s]);
    t(n);
  };
}
function rve(t, e) {
  let n = Array.isArray(e) ? (i) => e.indexOf(i.type.name) > -1 : e;
  return (i, r, s) => t(i, r && s7(r, n), s);
}
function o2(...t) {
  return function(e, n, i) {
    for (let r = 0; r < t.length; r++)
      if (t[r](e, n, i))
        return !0;
    return !1;
  };
}
let Sg = o2(n2, _T, xT), Sx = o2(n2, ST, kT);
const ms = {
  Enter: o2(ET, AT, TT, MT),
  "Mod-Enter": CT,
  Backspace: Sg,
  "Mod-Backspace": Sg,
  "Shift-Backspace": Sg,
  Delete: Sx,
  "Mod-Delete": Sx,
  "Mod-a": t7
}, DT = {
  "Ctrl-h": ms.Backspace,
  "Alt-Backspace": ms["Mod-Backspace"],
  "Ctrl-d": ms.Delete,
  "Ctrl-Alt-Backspace": ms["Mod-Delete"],
  "Alt-Delete": ms["Mod-Delete"],
  "Alt-d": ms["Mod-Delete"],
  "Ctrl-a": $T,
  "Ctrl-e": NT
};
for (let t in ms)
  DT[t] = ms[t];
const o7 = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, sve = o7 ? DT : ms;
function a7(t = {}) {
  return new Ue({
    view(e) {
      return new l7(e, t);
    }
  });
}
class l7 {
  constructor(e, n) {
    var i;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (i = n.width) !== null && i !== void 0 ? i : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((r) => {
      let s = (o) => {
        this[r](o);
      };
      return e.dom.addEventListener(r, s), { name: r, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, i;
    if (n) {
      let a = e.nodeBefore, l = e.nodeAfter;
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (c) {
          let u = c.getBoundingClientRect(), d = a ? u.bottom : u.top;
          a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), i = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
        }
      }
    }
    if (!i) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      i = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let r = this.editorView.dom.offsetParent;
    this.element || (this.element = r.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let s, o;
    if (!r || r == document.body && getComputedStyle(r).position == "static")
      s = -pageXOffset, o = -pageYOffset;
    else {
      let a = r.getBoundingClientRect();
      s = a.left - r.scrollLeft, o = a.top - r.scrollTop;
    }
    this.element.style.left = i.left - s + "px", this.element.style.top = i.top - o + "px", this.element.style.width = i.right - i.left + "px", this.element.style.height = i.bottom - i.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), i = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), r = i && i.type.spec.disableDropCursor, s = typeof r == "function" ? r(this.editorView, n, e) : r;
    if (n && !s) {
      let o = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = dT(this.editorView.state.doc, o, this.editorView.dragging.slice);
        a != null && (o = a);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
var As = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, zu = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, c7 = typeof navigator < "u" && /Mac/.test(navigator.platform), u7 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var hn = 0; hn < 10; hn++) As[48 + hn] = As[96 + hn] = String(hn);
for (var hn = 1; hn <= 24; hn++) As[hn + 111] = "F" + hn;
for (var hn = 65; hn <= 90; hn++)
  As[hn] = String.fromCharCode(hn + 32), zu[hn] = String.fromCharCode(hn);
for (var kg in As) zu.hasOwnProperty(kg) || (zu[kg] = As[kg]);
function IT(t) {
  var e = c7 && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || u7 && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? zu : As)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const d7 = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function h7(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let i, r, s, o;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      d7 ? o = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return i && (n = "Alt-" + n), r && (n = "Ctrl-" + n), o && (n = "Meta-" + n), s && (n = "Shift-" + n), n;
}
function f7(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[h7(n)] = t[n];
  return e;
}
function Eg(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function p7(t) {
  return new Ue({ props: { handleKeyDown: m0(t) } });
}
function m0(t) {
  let e = f7(t);
  return function(n, i) {
    let r = IT(i), s, o = e[Eg(r, i)];
    if (o && o(n.state, n.dispatch, n))
      return !0;
    if (r.length == 1 && r != " ") {
      if (i.shiftKey) {
        let a = e[Eg(r, i, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((i.shiftKey || i.altKey || i.metaKey || r.charCodeAt(0) > 127) && (s = As[i.keyCode]) && s != r) {
        let a = e[Eg(s, i)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const fn = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, Uu = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Bb = null;
const ps = function(t, e, n) {
  let i = Bb || (Bb = document.createRange());
  return i.setEnd(t, n ?? t.nodeValue.length), i.setStart(t, e || 0), i;
}, m7 = function() {
  Bb = null;
}, ka = function(t, e, n, i) {
  return n && (kx(t, e, n, i, -1) || kx(t, e, n, i, 1));
}, g7 = /^(img|br|input|textarea|hr)$/i;
function kx(t, e, n, i, r) {
  for (; ; ) {
    if (t == n && e == i)
      return !0;
    if (e == (r < 0 ? 0 : Mr(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || Qd(t) || g7.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = fn(t) + (r < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = r < 0 ? Mr(t) : 0;
    } else
      return !1;
  }
}
function Mr(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function b7(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = Mr(t);
    } else if (t.parentNode && !Qd(t))
      e = fn(t), t = t.parentNode;
    else
      return null;
  }
}
function O7(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !Qd(t))
      e = fn(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function y7(t, e, n) {
  for (let i = e == 0, r = e == Mr(t); i || r; ) {
    if (t == n)
      return !0;
    let s = fn(t);
    if (t = t.parentNode, !t)
      return !1;
    i = i && s == 0, r = r && s == Mr(t);
  }
}
function Qd(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const g0 = function(t) {
  return t.focusNode && ka(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Go(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function _7(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function v7(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let i = t.caretPositionFromPoint(e, n);
      if (i)
        return { node: i.offsetNode, offset: i.offset };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let i = t.caretRangeFromPoint(e, n);
    if (i)
      return { node: i.startContainer, offset: i.startOffset };
  }
}
const Gr = typeof navigator < "u" ? navigator : null, Ex = typeof document < "u" ? document : null, No = Gr && Gr.userAgent || "", Qb = /Edge\/(\d+)/.exec(No), LT = /MSIE \d/.exec(No), Fb = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(No), si = !!(LT || Fb || Qb), go = LT ? document.documentMode : Fb ? +Fb[1] : Qb ? +Qb[1] : 0, dr = !si && /gecko\/(\d+)/i.test(No);
dr && +(/Firefox\/(\d+)/.exec(No) || [0, 0])[1];
const zb = !si && /Chrome\/(\d+)/.exec(No), kn = !!zb, BT = zb ? +zb[1] : 0, zn = !si && !!Gr && /Apple Computer/.test(Gr.vendor), Wl = zn && (/Mobile\/\w+/.test(No) || !!Gr && Gr.maxTouchPoints > 2), Ti = Wl || (Gr ? /Mac/.test(Gr.platform) : !1), x7 = Gr ? /Win/.test(Gr.platform) : !1, tr = /Android \d/.test(No), Fd = !!Ex && "webkitFontSmoothing" in Ex.documentElement.style, w7 = Fd ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function S7(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function ls(t, e) {
  return typeof t == "number" ? t : t[e];
}
function k7(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, i = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * i
  };
}
function Cx(t, e, n) {
  let i = t.someProp("scrollThreshold") || 0, r = t.someProp("scrollMargin") || 5, s = t.dom.ownerDocument;
  for (let o = n || t.dom; o; o = Uu(o)) {
    if (o.nodeType != 1)
      continue;
    let a = o, l = a == s.body, c = l ? S7(s) : k7(a), u = 0, d = 0;
    if (e.top < c.top + ls(i, "top") ? d = -(c.top - e.top + ls(r, "top")) : e.bottom > c.bottom - ls(i, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + ls(r, "top") - c.top : e.bottom - c.bottom + ls(r, "bottom")), e.left < c.left + ls(i, "left") ? u = -(c.left - e.left + ls(r, "left")) : e.right > c.right - ls(i, "right") && (u = e.right - c.right + ls(r, "right")), u || d)
      if (l)
        s.defaultView.scrollBy(u, d);
      else {
        let h = a.scrollLeft, f = a.scrollTop;
        d && (a.scrollTop += d), u && (a.scrollLeft += u);
        let p = a.scrollLeft - h, m = a.scrollTop - f;
        e = { left: e.left - p, top: e.top - m, right: e.right - p, bottom: e.bottom - m };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(o).position))
      break;
  }
}
function E7(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), i, r;
  for (let s = (e.left + e.right) / 2, o = n + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = t.root.elementFromPoint(s, o);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      i = a, r = l.top;
      break;
    }
  }
  return { refDOM: i, refTop: r, stack: QT(t.dom) };
}
function QT(t) {
  let e = [], n = t.ownerDocument;
  for (let i = t; i && (e.push({ dom: i, top: i.scrollTop, left: i.scrollLeft }), t != n); i = Uu(i))
    ;
  return e;
}
function C7({ refDOM: t, refTop: e, stack: n }) {
  let i = t ? t.getBoundingClientRect().top : 0;
  FT(n, i == 0 ? 0 : i - e);
}
function FT(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: i, top: r, left: s } = t[n];
    i.scrollTop != r + e && (i.scrollTop = r + e), i.scrollLeft != s && (i.scrollLeft = s);
  }
}
let Ka = null;
function A7(t) {
  if (t.setActive)
    return t.setActive();
  if (Ka)
    return t.focus(Ka);
  let e = QT(t);
  t.focus(Ka == null ? {
    get preventScroll() {
      return Ka = { preventScroll: !0 }, !0;
    }
  } : void 0), Ka || (Ka = !1, FT(e, 0));
}
function zT(t, e) {
  let n, i = 2e8, r, s = 0, o = e.top, a = e.top, l, c;
  for (let u = t.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let h;
    if (u.nodeType == 1)
      h = u.getClientRects();
    else if (u.nodeType == 3)
      h = ps(u).getClientRects();
    else
      continue;
    for (let f = 0; f < h.length; f++) {
      let p = h[f];
      if (p.top <= o && p.bottom >= a) {
        o = Math.max(p.bottom, o), a = Math.min(p.top, a);
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (m < i) {
          n = u, i = m, r = m && n.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && m && (s = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !l && p.left <= e.left && p.right >= e.left && (l = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !n && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = d + 1);
    }
  }
  return !n && l && (n = l, r = c, i = 0), n && n.nodeType == 3 ? T7(n, r) : !n || i && n.nodeType == 1 ? { node: t, offset: s } : zT(n, r);
}
function T7(t, e) {
  let n = t.nodeValue.length, i = document.createRange();
  for (let r = 0; r < n; r++) {
    i.setEnd(t, r + 1), i.setStart(t, r);
    let s = Fs(i, 1);
    if (s.top != s.bottom && a2(e, s))
      return { node: t, offset: r + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function a2(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function M7(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function P7(t, e, n) {
  let { node: i, offset: r } = zT(e, n), s = -1;
  if (i.nodeType == 1 && !i.firstChild) {
    let o = i.getBoundingClientRect();
    s = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(i, r, s);
}
function R7(t, e, n, i) {
  let r = -1;
  for (let s = e, o = !1; s != t.dom; ) {
    let a = t.docView.nearestDesc(s, !0);
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM)) {
      let l = a.dom.getBoundingClientRect();
      if (a.node.isBlock && a.parent && (!o && l.left > i.left || l.top > i.top ? r = a.posBefore : (!o && l.right < i.left || l.bottom < i.top) && (r = a.posAfter), o = !0), !a.contentDOM && r < 0 && !a.node.isText)
        return (a.node.isBlock ? i.top < (l.top + l.bottom) / 2 : i.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    }
    s = a.dom.parentNode;
  }
  return r > -1 ? r : t.docView.posFromDOM(e, n, -1);
}
function UT(t, e, n) {
  let i = t.childNodes.length;
  if (i && n.top < n.bottom)
    for (let r = Math.max(0, Math.min(i - 1, Math.floor(i * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = r; ; ) {
      let o = t.childNodes[s];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (a2(e, c))
            return UT(o, e, c);
        }
      }
      if ((s = (s + 1) % i) == r)
        break;
    }
  return t;
}
function $7(t, e) {
  let n = t.dom.ownerDocument, i, r = 0, s = v7(n, e.left, e.top);
  s && ({ node: i, offset: r } = s);
  let o = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!o || !t.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = t.dom.getBoundingClientRect();
    if (!a2(e, c) || (o = UT(t.dom, e, c), !o))
      return null;
  }
  if (zn)
    for (let c = o; i && c; c = Uu(c))
      c.draggable && (i = void 0);
  if (o = M7(o, e), i) {
    if (dr && i.nodeType == 1 && (r = Math.min(r, i.childNodes.length), r < i.childNodes.length)) {
      let u = i.childNodes[r], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && r++;
    }
    let c;
    Fd && r && i.nodeType == 1 && (c = i.childNodes[r - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && r--, i == t.dom && r == i.childNodes.length - 1 && i.lastChild.nodeType == 1 && e.top > i.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (r == 0 || i.nodeType != 1 || i.childNodes[r - 1].nodeName != "BR") && (a = R7(t, i, r, e));
  }
  a == null && (a = P7(t, o, e));
  let l = t.docView.nearestDesc(o, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function Ax(t) {
  return t.top < t.bottom || t.left < t.right;
}
function Fs(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let i = n[e < 0 ? 0 : n.length - 1];
    if (Ax(i))
      return i;
  }
  return Array.prototype.find.call(n, Ax) || t.getBoundingClientRect();
}
const N7 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function WT(t, e, n) {
  let { node: i, offset: r, atom: s } = t.docView.domFromPos(e, n < 0 ? -1 : 1), o = Fd || dr;
  if (i.nodeType == 3)
    if (o && (N7.test(i.nodeValue) || (n < 0 ? !r : r == i.nodeValue.length))) {
      let l = Fs(ps(i, r, r), n);
      if (dr && r && /\s/.test(i.nodeValue[r - 1]) && r < i.nodeValue.length) {
        let c = Fs(ps(i, r - 1, r - 1), -1);
        if (c.top == l.top) {
          let u = Fs(ps(i, r, r + 1), -1);
          if (u.top != l.top)
            return Pc(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = r, c = r, u = n < 0 ? 1 : -1;
      return n < 0 && !r ? (c++, u = -1) : n >= 0 && r == i.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c++, Pc(Fs(ps(i, l, c), u), u < 0);
    }
  if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && r && (n < 0 || r == Mr(i))) {
      let l = i.childNodes[r - 1];
      if (l.nodeType == 1)
        return Cg(l.getBoundingClientRect(), !1);
    }
    if (s == null && r < Mr(i)) {
      let l = i.childNodes[r];
      if (l.nodeType == 1)
        return Cg(l.getBoundingClientRect(), !0);
    }
    return Cg(i.getBoundingClientRect(), n >= 0);
  }
  if (s == null && r && (n < 0 || r == Mr(i))) {
    let l = i.childNodes[r - 1], c = l.nodeType == 3 ? ps(l, Mr(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return Pc(Fs(c, 1), !1);
  }
  if (s == null && r < Mr(i)) {
    let l = i.childNodes[r];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? ps(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return Pc(Fs(c, -1), !0);
  }
  return Pc(Fs(i.nodeType == 3 ? ps(i) : i, -n), n >= 0);
}
function Pc(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function Cg(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function VT(t, e, n) {
  let i = t.state, r = t.root.activeElement;
  i != e && t.updateState(e), r != t.dom && t.focus();
  try {
    return n();
  } finally {
    i != e && t.updateState(i), r != t.dom && r && r.focus();
  }
}
function D7(t, e, n) {
  let i = e.selection, r = n == "up" ? i.$from : i.$to;
  return VT(t, e, () => {
    let { node: s } = t.docView.domFromPos(r.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(s, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom;
        break;
      }
      s = a.dom.parentNode;
    }
    let o = WT(t, r.pos, 1);
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = ps(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (n == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const I7 = /[\u0590-\u08ac]/;
function L7(t, e, n) {
  let { $head: i } = e.selection;
  if (!i.parent.isTextblock)
    return !1;
  let r = i.parentOffset, s = !r, o = r == i.parent.content.size, a = t.domSelection();
  return !I7.test(i.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? s : o : VT(t, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = t.domSelectionRange(), h = a.caretBidiLevel;
    a.modify("move", n, "character");
    let f = i.depth ? t.docView.domAfterPos(i.before()) : t.dom, { focusNode: p, focusOffset: m } = t.domSelectionRange(), g = p && !f.contains(p.nodeType == 1 ? p : p.parentNode) || l == p && c == m;
    try {
      a.collapse(u, d), l && (l != u || c != d) && a.extend && a.extend(l, c);
    } catch {
    }
    return h != null && (a.caretBidiLevel = h), g;
  });
}
let Tx = null, Mx = null, Px = !1;
function B7(t, e, n) {
  return Tx == e && Mx == n ? Px : (Tx = e, Mx = n, Px = n == "up" || n == "down" ? D7(t, e, n) : L7(t, e, n));
}
const Qi = 0, Rx = 1, na = 2, Kr = 3;
class zd {
  constructor(e, n, i, r) {
    this.parent = e, this.children = n, this.dom = i, this.contentDOM = r, this.dirty = Qi, i.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, i) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, i = this.posAtStart; ; n++) {
      let r = this.children[n];
      if (r == e)
        return i;
      i += r.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, i) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (i < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let r;
    if (e == this.dom && this.contentDOM)
      r = n > fn(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      r = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            r = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (r == null && n == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            r = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return r ?? i > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let i = !0, r = e; r; r = r.parentNode) {
      let s = this.getDesc(r), o;
      if (s && (!n || s.node))
        if (i && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          i = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let i = n; i; i = i.parent)
      if (i == this)
        return n;
  }
  posFromDOM(e, n, i) {
    for (let r = e; r; r = r.parentNode) {
      let s = this.getDesc(r);
      if (s)
        return s.localPosFromDOM(e, n, i);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, i = 0; n < this.children.length; n++) {
      let r = this.children[n], s = i + r.size;
      if (i == e && s != i) {
        for (; !r.border && r.children.length; )
          r = r.children[0];
        return r;
      }
      if (e < s)
        return r.descAt(e - i - r.border);
      i = s;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let i = 0, r = 0;
    for (let s = 0; i < this.children.length; i++) {
      let o = this.children[i], a = s + o.size;
      if (a > e || o instanceof HT) {
        r = e - s;
        break;
      }
      s = a;
    }
    if (r)
      return this.children[i].domFromPos(r - this.children[i].border, n);
    for (let s; i && !(s = this.children[i - 1]).size && s instanceof ZT && s.side >= 0; i--)
      ;
    if (n <= 0) {
      let s, o = !0;
      for (; s = i ? this.children[i - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); i--, o = !1)
        ;
      return s && n && o && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : { node: this.contentDOM, offset: s ? fn(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = i < this.children.length ? this.children[i] : null, !(!s || s.dom.parentNode == this.contentDOM); i++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, n) : { node: this.contentDOM, offset: s ? fn(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, i = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let r = -1, s = -1;
    for (let o = i, a = 0; ; a++) {
      let l = this.children[a], c = o + l.size;
      if (r == -1 && e <= c) {
        let u = o + l.border;
        if (e >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, u);
        e = o;
        for (let d = a; d > 0; d--) {
          let h = this.children[d - 1];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(1)) {
            r = fn(h.dom) + 1;
            break;
          }
          e -= h.size;
        }
        r == -1 && (r = 0);
      }
      if (r > -1 && (c > n || a == this.children.length - 1)) {
        n = c;
        for (let u = a + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            s = fn(d.dom);
            break;
          }
          n += d.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: r, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: i } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || i == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[i];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, i, r = !1) {
    let s = Math.min(e, n), o = Math.max(e, n);
    for (let h = 0, f = 0; h < this.children.length; h++) {
      let p = this.children[h], m = f + p.size;
      if (s > f && o < m)
        return p.setSelection(e - f - p.border, n - f - p.border, i, r);
      f = m;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c = i.getSelection(), u = !1;
    if ((dr || zn) && e == n) {
      let { node: h, offset: f } = a;
      if (h.nodeType == 3) {
        if (u = !!(f && h.nodeValue[f - 1] == `
`), u && f == h.nodeValue.length)
          for (let p = h, m; p; p = p.parentNode) {
            if (m = p.nextSibling) {
              m.nodeName == "BR" && (a = l = { node: m.parentNode, offset: fn(m) + 1 });
              break;
            }
            let g = p.pmViewDesc;
            if (g && g.node && g.node.isBlock)
              break;
          }
      } else {
        let p = h.childNodes[f - 1];
        u = p && (p.nodeName == "BR" || p.contentEditable == "false");
      }
    }
    if (dr && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
      let h = c.focusNode.childNodes[c.focusOffset];
      h && h.contentEditable == "false" && (r = !0);
    }
    if (!(r || u && zn) && ka(a.node, a.offset, c.anchorNode, c.anchorOffset) && ka(l.node, l.offset, c.focusNode, c.focusOffset))
      return;
    let d = !1;
    if ((c.extend || e == n) && !u) {
      c.collapse(a.node, a.offset);
      try {
        e != n && c.extend(l.node, l.offset), d = !0;
      } catch {
      }
    }
    if (!d) {
      if (e > n) {
        let f = a;
        a = l, l = f;
      }
      let h = document.createRange();
      h.setEnd(l.node, l.offset), h.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(h);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let i = 0, r = 0; r < this.children.length; r++) {
      let s = this.children[r], o = i + s.size;
      if (i == o ? e <= o && n >= i : e < o && n > i) {
        let a = i + s.border, l = o - s.border;
        if (e >= a && n <= l) {
          this.dirty = e == i || n == o ? na : Rx, e == a && n == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Kr : s.markDirty(e - a, n - a);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? na : Kr;
      }
      i = o;
    }
    this.dirty = na;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let i = e == 1 ? na : Rx;
      n.dirty < i && (n.dirty = i);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class ZT extends zd {
  constructor(e, n, i, r) {
    let s, o = n.type.toDOM;
    if (typeof o == "function" && (o = o(i, () => {
      if (!s)
        return r;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !n.type.spec.raw) {
      if (o.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(o), o = a;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = n, this.widget = n, s = this;
  }
  matchesWidget(e) {
    return this.dirty == Qi && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class Q7 extends zd {
  constructor(e, n, i, r) {
    super(e, [], n, null), this.textDOM = i, this.text = r;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Ea extends zd {
  constructor(e, n, i, r) {
    super(e, [], i, r), this.mark = n;
  }
  static create(e, n, i, r) {
    let s = r.nodeViews[n.type.name], o = s && s(n, r, i);
    return (!o || !o.dom) && (o = Wa.renderSpec(document, n.type.spec.toDOM(n, i), null, n.attrs)), new Ea(e, n, o.dom, o.contentDOM || o.dom);
  }
  parseRule() {
    return this.dirty & Kr || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Kr && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != Qi) {
      let i = this.parent;
      for (; !i.node; )
        i = i.parent;
      i.dirty < this.dirty && (i.dirty = this.dirty), this.dirty = Qi;
    }
  }
  slice(e, n, i) {
    let r = Ea.create(this.parent, this.mark, !0, i), s = this.children, o = this.size;
    n < o && (s = Vb(s, n, o, i)), e > 0 && (s = Vb(s, 0, e, i));
    for (let a = 0; a < s.length; a++)
      s[a].parent = r;
    return r.children = s, r;
  }
}
class bo extends zd {
  constructor(e, n, i, r, s, o, a, l, c) {
    super(e, [], s, o), this.node = n, this.outerDeco = i, this.innerDeco = r, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, i, r, s, o) {
    let a = s.nodeViews[n.type.name], l, c = a && a(n, s, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, i, r), u = c && c.dom, d = c && c.contentDOM;
    if (n.isText) {
      if (!u)
        u = document.createTextNode(n.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: d } = Wa.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = !0));
    let h = u;
    return u = jT(u, i, n), c ? l = new F7(e, n, i, r, u, d || null, h, c, s, o + 1) : n.isText ? new b0(e, n, i, r, u, h, s) : new bo(e, n, i, r, u, d || null, h, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let i = this.children[n];
        if (this.dom.contains(i.dom.parentNode)) {
          e.contentElement = i.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => Y.empty);
    }
    return e;
  }
  matchesNode(e, n, i) {
    return this.dirty == Qi && e.eq(this.node) && Wb(n, this.outerDeco) && i.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let i = this.node.inlineContent, r = n, s = e.composing ? this.localCompositionInfo(e, n) : null, o = s && s.pos > -1 ? s : null, a = s && s.pos < 0, l = new U7(this, o && o.node, e);
    Z7(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, i, e) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? nt.none : this.node.child(u).marks, i, e), l.placeWidget(c, e, r);
    }, (c, u, d, h) => {
      l.syncToMarks(c.marks, i, e);
      let f;
      l.findNodeMatch(c, u, d, h) || a && e.state.selection.from > r && e.state.selection.to < r + c.nodeSize && (f = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(c, u, d, f, e) || l.updateNextNode(c, u, d, e, h, r) || l.addNode(c, u, d, e, r), r += c.nodeSize;
    }), l.syncToMarks([], i, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == na) && (o && this.protectLocalComposition(e, o), qT(this.contentDOM, this.children, e), Wl && H7(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: i, to: r } = e.state.selection;
    if (!(e.state.selection instanceof ce) || i < n || r > n + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, a = q7(this.node.content, o, i - n, r - n);
      return a < 0 ? null : { node: s, pos: a, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: i, text: r }) {
    if (this.getDesc(n))
      return;
    let s = n;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new Q7(this, s, n, r);
    e.input.compositionNodes.push(o), this.children = Vb(this.children, i, i + r.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, i, r) {
    return this.dirty == Kr || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, i, r), !0);
  }
  updateInner(e, n, i, r) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = i, this.contentDOM && this.updateChildren(r, this.posAtStart), this.dirty = Qi;
  }
  updateOuterDeco(e) {
    if (Wb(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, i = this.dom;
    this.dom = XT(this.dom, this.nodeDOM, Ub(this.outerDeco, this.node, n), Ub(e, this.node, n)), this.dom != i && (i.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function $x(t, e, n, i, r) {
  jT(i, e, t);
  let s = new bo(void 0, t, e, n, i, i, i, r, 0);
  return s.contentDOM && s.updateChildren(r, 0), s;
}
class b0 extends bo {
  constructor(e, n, i, r, s, o, a) {
    super(e, n, i, r, s, null, o, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, i, r) {
    return this.dirty == Kr || this.dirty != Qi && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Qi || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = Qi, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, i) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, i);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, i) {
    let r = this.node.cut(e, n), s = document.createTextNode(r.text);
    return new b0(this.parent, r, this.outerDeco, this.innerDeco, s, s, i);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Kr);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class HT extends zd {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Qi && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class F7 extends bo {
  constructor(e, n, i, r, s, o, a, l, c, u) {
    super(e, n, i, r, s, o, a, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, i, r) {
    if (this.dirty == Kr)
      return !1;
    if (this.spec.update) {
      let s = this.spec.update(e, n, i);
      return s && this.updateInner(e, n, i, r), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, i, r);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, i, r) {
    this.spec.setSelection ? this.spec.setSelection(e, n, i) : super.setSelection(e, n, i, r);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function qT(t, e, n) {
  let i = t.firstChild, r = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], a = o.dom;
    if (a.parentNode == t) {
      for (; a != i; )
        i = Nx(i), r = !0;
      i = i.nextSibling;
    } else
      r = !0, t.insertBefore(a, i);
    if (o instanceof Ea) {
      let l = i ? i.previousSibling : t.lastChild;
      qT(o.contentDOM, o.children, n), i = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; i; )
    i = Nx(i), r = !0;
  r && n.trackWrites == t && (n.trackWrites = null);
}
const hu = function(t) {
  t && (this.nodeName = t);
};
hu.prototype = /* @__PURE__ */ Object.create(null);
const ia = [new hu()];
function Ub(t, e, n) {
  if (t.length == 0)
    return ia;
  let i = n ? ia[0] : new hu(), r = [i];
  for (let s = 0; s < t.length; s++) {
    let o = t[s].type.attrs;
    if (o) {
      o.nodeName && r.push(i = new hu(o.nodeName));
      for (let a in o) {
        let l = o[a];
        l != null && (n && r.length == 1 && r.push(i = new hu(e.isInline ? "span" : "div")), a == "class" ? i.class = (i.class ? i.class + " " : "") + l : a == "style" ? i.style = (i.style ? i.style + ";" : "") + l : a != "nodeName" && (i[a] = l));
      }
    }
  }
  return r;
}
function XT(t, e, n, i) {
  if (n == ia && i == ia)
    return e;
  let r = e;
  for (let s = 0; s < i.length; s++) {
    let o = i[s], a = n[s];
    if (s) {
      let l;
      a && a.nodeName == o.nodeName && r != t && (l = r.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(r), a = ia[0]), r = l;
    }
    z7(r, a || ia[0], o);
  }
  return r;
}
function z7(t, e, n) {
  for (let i in e)
    i != "class" && i != "style" && i != "nodeName" && !(i in n) && t.removeAttribute(i);
  for (let i in n)
    i != "class" && i != "style" && i != "nodeName" && n[i] != e[i] && t.setAttribute(i, n[i]);
  if (e.class != n.class) {
    let i = e.class ? e.class.split(" ").filter(Boolean) : [], r = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && t.classList.remove(i[s]);
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && t.classList.add(r[s]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let i = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, r;
      for (; r = i.exec(e.style); )
        t.style.removeProperty(r[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function jT(t, e, n) {
  return XT(t, t, ia, Ub(e, n, t.nodeType != 1));
}
function Wb(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function Nx(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class U7 {
  constructor(e, n, i) {
    this.lock = n, this.view = i, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = W7(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let i = e; i < n; i++)
        this.top.children[i].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, i) {
    let r = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; r < o && (r == s - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && e[r].type.spec.spanning !== !1; )
      r++;
    for (; r < s; )
      this.destroyRest(), this.top.dirty = Qi, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = Ea.create(this.top, e[s], n, i);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, i, r) {
    let s = -1, o;
    if (r >= this.preMatch.index && (o = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && o.matchesNode(e, n, i))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, n, i) && !this.preMatch.matched.has(c)) {
          s = a;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, n, i, r, s) {
    let o = this.top.children[r];
    return o.dirty == Kr && o.dom == o.contentDOM && (o.dirty = na), o.update(e, n, i, s) ? (this.destroyBetween(this.index, r), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let i = e.pmViewDesc;
        if (i) {
          for (let r = this.index; r < this.top.children.length; r++)
            if (this.top.children[r] == i)
              return r;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, i, r, s, o) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof bo) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != s)
          return !1;
        let u = l.dom, d, h = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Kr && Wb(n, l.outerDeco));
        if (!h && l.update(e, n, i, r))
          return this.destroyBetween(this.index, a), l.dom != u && (this.changed = !0), this.index++, !0;
        if (!h && (d = this.recreateWrapper(l, e, n, i, r, o)))
          return this.top.children[this.index] = d, d.contentDOM && (d.dirty = na, d.updateChildren(r, o + 1), d.dirty = Qi), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, i, r, s, o) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content))
      return null;
    let a = bo.create(this.top, n, i, r, s, o);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, i, r, s) {
    let o = bo.create(this.top, e, n, i, r, s);
    o.contentDOM && o.updateChildren(r, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, n, i) {
    let r = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (r && r.matchesWidget(e) && (e == r.widget || !r.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new ZT(this.top, e, n, i);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Ea; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof b0) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((zn || kn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let i = document.createElement(e);
      e == "IMG" && (i.className = "ProseMirror-separator", i.alt = ""), e == "BR" && (i.className = "ProseMirror-trailingBreak");
      let r = new HT(this.top, [], i, null);
      n != this.top ? n.children.push(r) : n.children.splice(this.index++, 0, r), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function W7(t, e) {
  let n = e, i = n.children.length, r = t.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e: for (; r > 0; ) {
    let a;
    for (; ; )
      if (i) {
        let c = n.children[i - 1];
        if (c instanceof Ea)
          n = c, i = c.children.length;
        else {
          a = c, i--;
          break;
        }
      } else {
        if (n == e)
          break e;
        i = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = a.node;
    if (l) {
      if (l != t.child(r - 1))
        break;
      --r, s.set(a, r), o.push(a);
    }
  }
  return { index: r, matched: s, matches: o.reverse() };
}
function V7(t, e) {
  return t.type.side - e.type.side;
}
function Z7(t, e, n, i) {
  let r = e.locals(t), s = 0;
  if (r.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let u = t.child(c);
      i(u, r, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; o < r.length && r[o].to == s; ) {
      let g = r[o++];
      g.widget && (u ? (d || (d = [u])).push(g) : u = g);
    }
    if (u)
      if (d) {
        d.sort(V7);
        for (let g = 0; g < d.length; g++)
          n(d[g], c, !!l);
      } else
        n(u, c, !!l);
    let h, f;
    if (l)
      f = -1, h = l, l = null;
    else if (c < t.childCount)
      f = c, h = t.child(c++);
    else
      break;
    for (let g = 0; g < a.length; g++)
      a[g].to <= s && a.splice(g--, 1);
    for (; o < r.length && r[o].from <= s && r[o].to > s; )
      a.push(r[o++]);
    let p = s + h.nodeSize;
    if (h.isText) {
      let g = p;
      o < r.length && r[o].from < g && (g = r[o].from);
      for (let b = 0; b < a.length; b++)
        a[b].to < g && (g = a[b].to);
      g < p && (l = h.cut(g - s), h = h.cut(0, g - s), p = g, f = -1);
    } else
      for (; o < r.length && r[o].to < p; )
        o++;
    let m = h.isInline && !h.isLeaf ? a.filter((g) => !g.inline) : a.slice();
    i(h, m, e.forChild(s, h), f), s = p;
  }
}
function H7(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function q7(t, e, n, i) {
  for (let r = 0, s = 0; r < t.childCount && s <= i; ) {
    let o = t.child(r++), a = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; r < t.childCount; ) {
      let c = t.child(r++);
      if (s += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (s >= n) {
      if (s >= i && l.slice(i - e.length - a, i - a) == e)
        return i - e.length;
      let c = a < i ? l.lastIndexOf(e, i - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= n)
        return a + c;
      if (n == i && l.length >= i + e.length - a && l.slice(i - a, i - a + e.length) == e)
        return i;
    }
  }
  return -1;
}
function Vb(t, e, n, i, r) {
  let s = [];
  for (let o = 0, a = 0; o < t.length; o++) {
    let l = t[o], c = a, u = a += l.size;
    c >= n || u <= e ? s.push(l) : (c < e && s.push(l.slice(0, e - c, i)), r && (s.push(r), r = void 0), u > n && s.push(l.slice(n - c, l.size, i)));
  }
  return s;
}
function l2(t, e = null) {
  let n = t.domSelectionRange(), i = t.state.doc;
  if (!n.focusNode)
    return null;
  let r = t.docView.nearestDesc(n.focusNode), s = r && r.size == 0, o = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (o < 0)
    return null;
  let a = i.resolve(o), l, c;
  if (g0(n)) {
    for (l = a; r && !r.node; )
      r = r.parent;
    let u = r.node;
    if (r && u.isAtom && ge.isSelectable(u) && r.parent && !(u.isInline && y7(n.focusNode, n.focusOffset, r.dom))) {
      let d = r.posBefore;
      c = new ge(o == d ? a : i.resolve(d));
    }
  } else {
    let u = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (u < 0)
      return null;
    l = i.resolve(u);
  }
  if (!c) {
    let u = e == "pointer" || t.state.selection.head < a.pos && !s ? 1 : -1;
    c = c2(t, l, a, u);
  }
  return c;
}
function YT(t) {
  return t.editable ? t.hasFocus() : KT(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Ss(t, e = !1) {
  let n = t.state.selection;
  if (GT(t, n), !!YT(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && kn) {
      let i = t.domSelectionRange(), r = t.domObserver.currentSelection;
      if (i.anchorNode && r.anchorNode && ka(i.anchorNode, i.anchorOffset, r.anchorNode, r.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      j7(t);
    else {
      let { anchor: i, head: r } = n, s, o;
      Dx && !(n instanceof ce) && (n.$from.parent.inlineContent || (s = Ix(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (o = Ix(t, n.to))), t.docView.setSelection(i, r, t.root, e), Dx && (s && Lx(s), o && Lx(o)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && X7(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const Dx = zn || kn && BT < 63;
function Ix(t, e) {
  let { node: n, offset: i } = t.docView.domFromPos(e, 0), r = i < n.childNodes.length ? n.childNodes[i] : null, s = i ? n.childNodes[i - 1] : null;
  if (zn && r && r.contentEditable == "false")
    return Ag(r);
  if ((!r || r.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (r)
      return Ag(r);
    if (s)
      return Ag(s);
  }
}
function Ag(t) {
  return t.contentEditable = "true", zn && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function Lx(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function X7(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), i = n.anchorNode, r = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != i || n.anchorOffset != r) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!YT(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function j7(t) {
  let e = t.domSelection(), n = document.createRange(), i = t.cursorWrapper.dom, r = i.nodeName == "IMG";
  r ? n.setEnd(i.parentNode, fn(i) + 1) : n.setEnd(i, 0), n.collapse(!1), e.removeAllRanges(), e.addRange(n), !r && !t.state.selection.visible && si && go <= 11 && (i.disabled = !0, i.disabled = !1);
}
function GT(t, e) {
  if (e instanceof ge) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (Bx(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    Bx(t);
}
function Bx(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function c2(t, e, n, i) {
  return t.someProp("createSelectionBetween", (r) => r(t, e, n)) || ce.between(e, n, i);
}
function Qx(t) {
  return t.editable && !t.hasFocus() ? !1 : KT(t);
}
function KT(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function Y7(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return ka(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Zb(t, e) {
  let { $anchor: n, $head: i } = t.selection, r = e > 0 ? n.max(i) : n.min(i), s = r.parent.inlineContent ? r.depth ? t.doc.resolve(e > 0 ? r.after() : r.before()) : null : r;
  return s && _e.findFrom(s, e);
}
function Us(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Fx(t, e, n) {
  let i = t.state.selection;
  if (i instanceof ce)
    if (n.indexOf("s") > -1) {
      let { $head: r } = i, s = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = t.state.doc.resolve(r.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Us(t, new ce(i.$anchor, o));
    } else if (i.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let r = Zb(t.state, e);
        return r && r instanceof ge ? Us(t, r) : !1;
      } else if (!(Ti && n.indexOf("m") > -1)) {
        let r = i.$head, s = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let a = e < 0 ? r.pos - s.nodeSize : r.pos;
        return s.isAtom || (o = t.docView.descAt(a)) && !o.contentDOM ? ge.isSelectable(s) ? Us(t, new ge(e < 0 ? t.state.doc.resolve(r.pos - s.nodeSize) : r)) : Fd ? Us(t, new ce(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (i instanceof ge && i.node.isInline)
      return Us(t, new ce(e > 0 ? i.$to : i.$from));
    {
      let r = Zb(t.state, e);
      return r ? Us(t, r) : !1;
    }
  }
}
function Tp(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function fu(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Ja(t, e) {
  return e < 0 ? G7(t) : K7(t);
}
function G7(t) {
  let e = t.domSelectionRange(), n = e.focusNode, i = e.focusOffset;
  if (!n)
    return;
  let r, s, o = !1;
  for (dr && n.nodeType == 1 && i < Tp(n) && fu(n.childNodes[i], -1) && (o = !0); ; )
    if (i > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[i - 1];
        if (fu(a, -1))
          r = n, s = --i;
        else if (a.nodeType == 3)
          n = a, i = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (JT(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && fu(a, -1); )
          r = n.parentNode, s = fn(a), a = a.previousSibling;
        if (a)
          n = a, i = Tp(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          i = 0;
        }
      }
    }
  o ? Hb(t, n, i) : r && Hb(t, r, s);
}
function K7(t) {
  let e = t.domSelectionRange(), n = e.focusNode, i = e.focusOffset;
  if (!n)
    return;
  let r = Tp(n), s, o;
  for (; ; )
    if (i < r) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[i];
      if (fu(a, 1))
        s = n, o = ++i;
      else
        break;
    } else {
      if (JT(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && fu(a, 1); )
          s = a.parentNode, o = fn(a) + 1, a = a.nextSibling;
        if (a)
          n = a, i = 0, r = Tp(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          i = r = 0;
        }
      }
    }
  s && Hb(t, s, o);
}
function JT(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function J7(t, e) {
  for (; t && e == t.childNodes.length && !Qd(t); )
    e = fn(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function eB(t, e) {
  for (; t && !e && !Qd(t); )
    e = fn(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function Hb(t, e, n) {
  if (e.nodeType != 3) {
    let s, o;
    (o = J7(e, n)) ? (e = o, n = 0) : (s = eB(e, n)) && (e = s, n = s.nodeValue.length);
  }
  let i = t.domSelection();
  if (g0(i)) {
    let s = document.createRange();
    s.setEnd(e, n), s.setStart(e, n), i.removeAllRanges(), i.addRange(s);
  } else i.extend && i.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: r } = t;
  setTimeout(() => {
    t.state == r && Ss(t);
  }, 50);
}
function zx(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(kn || x7) && n.parent.inlineContent) {
    let r = t.coordsAtPos(e);
    if (e > n.start()) {
      let s = t.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > r.top && o < r.bottom && Math.abs(s.left - r.left) > 1)
        return s.left < r.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let s = t.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > r.top && o < r.bottom && Math.abs(s.left - r.left) > 1)
        return s.left > r.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Ux(t, e, n) {
  let i = t.state.selection;
  if (i instanceof ce && !i.empty || n.indexOf("s") > -1 || Ti && n.indexOf("m") > -1)
    return !1;
  let { $from: r, $to: s } = i;
  if (!r.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Zb(t.state, e);
    if (o && o instanceof ge)
      return Us(t, o);
  }
  if (!r.parent.inlineContent) {
    let o = e < 0 ? r : s, a = i instanceof ri ? _e.near(o, e) : _e.findFrom(o, e);
    return a ? Us(t, a) : !1;
  }
  return !1;
}
function Wx(t, e) {
  if (!(t.state.selection instanceof ce))
    return !0;
  let { $head: n, $anchor: i, empty: r } = t.state.selection;
  if (!n.sameParent(i))
    return !0;
  if (!r)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (s && !s.isText) {
    let o = t.state.tr;
    return e < 0 ? o.delete(n.pos - s.nodeSize, n.pos) : o.delete(n.pos, n.pos + s.nodeSize), t.dispatch(o), !0;
  }
  return !1;
}
function Vx(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function tB(t) {
  if (!zn || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let i = e.firstChild;
    Vx(t, i, "true"), setTimeout(() => Vx(t, i, "false"), 20);
  }
  return !1;
}
function nB(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function iB(t, e) {
  let n = e.keyCode, i = nB(e);
  if (n == 8 || Ti && n == 72 && i == "c")
    return Wx(t, -1) || Ja(t, -1);
  if (n == 46 && !e.shiftKey || Ti && n == 68 && i == "c")
    return Wx(t, 1) || Ja(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || Ti && n == 66 && i == "c") {
    let r = n == 37 ? zx(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Fx(t, r, i) || Ja(t, r);
  } else if (n == 39 || Ti && n == 70 && i == "c") {
    let r = n == 39 ? zx(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Fx(t, r, i) || Ja(t, r);
  } else {
    if (n == 38 || Ti && n == 80 && i == "c")
      return Ux(t, -1, i) || Ja(t, -1);
    if (n == 40 || Ti && n == 78 && i == "c")
      return tB(t) || Ux(t, 1, i) || Ja(t, 1);
    if (i == (Ti ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function u2(t, e) {
  t.someProp("transformCopied", (f) => {
    e = f(e, t);
  });
  let n = [], { content: i, openStart: r, openEnd: s } = e;
  for (; r > 1 && s > 1 && i.childCount == 1 && i.firstChild.childCount == 1; ) {
    r--, s--;
    let f = i.firstChild;
    n.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null), i = f.content;
  }
  let o = t.someProp("clipboardSerializer") || Wa.fromSchema(t.state.schema), a = rM(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(i, { document: a }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = iM[c.nodeName.toLowerCase()]); ) {
    for (let f = u.length - 1; f >= 0; f--) {
      let p = a.createElement(u[f]);
      for (; l.firstChild; )
        p.appendChild(l.firstChild);
      l.appendChild(p), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${r} ${s}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let h = t.someProp("clipboardTextSerializer", (f) => f(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: h, slice: e };
}
function d2(t, e, n, i, r) {
  let s = r.parent.type.spec.code, o, a;
  if (!n && !e)
    return null;
  let l = e && (i || s || !n);
  if (l) {
    if (t.someProp("transformPastedText", (h) => {
      e = h(e, s || i, t);
    }), s)
      return e ? new ne(Y.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ne.empty;
    let d = t.someProp("clipboardTextParser", (h) => h(e, r, i, t));
    if (d)
      a = d;
    else {
      let h = r.marks(), { schema: f } = t.state, p = Wa.fromSchema(f);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = o.appendChild(document.createElement("p"));
        m && g.appendChild(p.serializeNode(f.text(m, h)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), o = oB(n), Fd && aB(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let h = o.firstChild;
      for (; h && h.nodeType != 1; )
        h = h.nextSibling;
      if (!h)
        break;
      o = h;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || ws.fromSchema(t.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || u),
    context: r,
    ruleFromNode(h) {
      return h.nodeName == "BR" && !h.nextSibling && h.parentNode && !rB.test(h.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    a = lB(Zx(a, +u[1], +u[2]), u[4]);
  else if (a = ne.maxOpen(sB(a.content, r), !0), a.openStart || a.openEnd) {
    let d = 0, h = 0;
    for (let f = a.content.firstChild; d < a.openStart && !f.type.spec.isolating; d++, f = f.firstChild)
      ;
    for (let f = a.content.lastChild; h < a.openEnd && !f.type.spec.isolating; h++, f = f.lastChild)
      ;
    a = Zx(a, d, h);
  }
  return t.someProp("transformPasted", (d) => {
    a = d(a, t);
  }), a;
}
const rB = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function sB(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let r = e.node(n).contentMatchAt(e.index(n)), s, o = [];
    if (t.forEach((a) => {
      if (!o)
        return;
      let l = r.findWrapping(a.type), c;
      if (!l)
        return o = null;
      if (c = o.length && s.length && tM(l, s, a, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = nM(o[o.length - 1], s.length));
        let u = eM(a, l);
        o.push(u), r = r.matchType(u.type), s = l;
      }
    }), o)
      return Y.from(o);
  }
  return t;
}
function eM(t, e, n = 0) {
  for (let i = e.length - 1; i >= n; i--)
    t = e[i].create(null, Y.from(t));
  return t;
}
function tM(t, e, n, i, r) {
  if (r < t.length && r < e.length && t[r] == e[r]) {
    let s = tM(t, e, n, i.lastChild, r + 1);
    if (s)
      return i.copy(i.content.replaceChild(i.childCount - 1, s));
    if (i.contentMatchAt(i.childCount).matchType(r == t.length - 1 ? n.type : t[r + 1]))
      return i.copy(i.content.append(Y.from(eM(n, t, r + 1))));
  }
}
function nM(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, nM(t.lastChild, e - 1)), i = t.contentMatchAt(t.childCount).fillBefore(Y.empty, !0);
  return t.copy(n.append(i));
}
function qb(t, e, n, i, r, s) {
  let o = e < 0 ? t.firstChild : t.lastChild, a = o.content;
  return t.childCount > 1 && (s = 0), r < i - 1 && (a = qb(a, e, n, i, r + 1, s)), r >= n && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, s <= r).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(Y.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, o.copy(a));
}
function Zx(t, e, n) {
  return e < t.openStart && (t = new ne(qb(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new ne(qb(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const iM = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Hx = null;
function rM() {
  return Hx || (Hx = document.implementation.createHTMLDocument("title"));
}
function oB(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = rM().createElement("div"), i = /<([a-z][^>\s]+)/i.exec(t), r;
  if ((r = i && iM[i[1].toLowerCase()]) && (t = r.map((s) => "<" + s + ">").join("") + t + r.map((s) => "</" + s + ">").reverse().join("")), n.innerHTML = t, r)
    for (let s = 0; s < r.length; s++)
      n = n.querySelector(r[s]) || n;
  return n;
}
function aB(t) {
  let e = t.querySelectorAll(kn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    i.childNodes.length == 1 && i.textContent == "" && i.parentNode && i.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), i);
  }
}
function lB(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, i;
  try {
    i = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: r, openStart: s, openEnd: o } = t;
  for (let a = i.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[i[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    r = Y.from(l.create(i[a + 1], r)), s++, o++;
  }
  return new ne(r, s, o);
}
const Un = {}, Wn = {}, cB = { touchstart: !0, touchmove: !0 };
let uB = class {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
};
function dB(t) {
  for (let e in Un) {
    let n = Un[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (i) => {
      fB(t, i) && !h2(t, i) && (t.editable || !(i.type in Wn)) && n(t, i);
    }, cB[e] ? { passive: !0 } : void 0);
  }
  zn && t.dom.addEventListener("input", () => null), Xb(t);
}
function io(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function hB(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Xb(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (i) => h2(t, i));
  });
}
function h2(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let i = n[e.type];
    return i ? i(t, e) || e.defaultPrevented : !1;
  });
}
function fB(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function pB(t, e) {
  !h2(t, e) && Un[e.type] && (t.editable || !(e.type in Wn)) && Un[e.type](t, e);
}
Wn.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !oM(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(tr && kn && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), Wl && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let i = Date.now();
      t.input.lastIOSEnter = i, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == i && (t.someProp("handleKeyDown", (r) => r(t, Go(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (i) => i(t, n)) || iB(t, n) ? n.preventDefault() : io(t, "key");
};
Wn.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Wn.keypress = (t, e) => {
  let n = e;
  if (oM(t, n) || !n.charCode || n.ctrlKey && !n.altKey || Ti && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (r) => r(t, n))) {
    n.preventDefault();
    return;
  }
  let i = t.state.selection;
  if (!(i instanceof ce) || !i.$from.sameParent(i.$to)) {
    let r = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(r) && !t.someProp("handleTextInput", (s) => s(t, i.$from.pos, i.$to.pos, r)) && t.dispatch(t.state.tr.insertText(r).scrollIntoView()), n.preventDefault();
  }
};
function O0(t) {
  return { left: t.clientX, top: t.clientY };
}
function mB(t, e) {
  let n = e.x - t.clientX, i = e.y - t.clientY;
  return n * n + i * i < 100;
}
function f2(t, e, n, i, r) {
  if (i == -1)
    return !1;
  let s = t.state.doc.resolve(i);
  for (let o = s.depth + 1; o > 0; o--)
    if (t.someProp(e, (a) => o > s.depth ? a(t, n, s.nodeAfter, s.before(o), r, !0) : a(t, n, s.node(o), s.before(o), r, !1)))
      return !0;
  return !1;
}
function Sl(t, e, n) {
  t.focused || t.focus();
  let i = t.state.tr.setSelection(e);
  i.setMeta("pointer", !0), t.dispatch(i);
}
function gB(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), i = n.nodeAfter;
  return i && i.isAtom && ge.isSelectable(i) ? (Sl(t, new ge(n)), !0) : !1;
}
function bB(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, i, r;
  n instanceof ge && (i = n.node);
  let s = t.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o);
    if (ge.isSelectable(a)) {
      i && n.$from.depth > 0 && o >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? r = s.before(n.$from.depth) : r = s.before(o);
      break;
    }
  }
  return r != null ? (Sl(t, ge.create(t.state.doc, r)), !0) : !1;
}
function OB(t, e, n, i, r) {
  return f2(t, "handleClickOn", e, n, i) || t.someProp("handleClick", (s) => s(t, e, i)) || (r ? bB(t, n) : gB(t, n));
}
function yB(t, e, n, i) {
  return f2(t, "handleDoubleClickOn", e, n, i) || t.someProp("handleDoubleClick", (r) => r(t, e, i));
}
function _B(t, e, n, i) {
  return f2(t, "handleTripleClickOn", e, n, i) || t.someProp("handleTripleClick", (r) => r(t, e, i)) || vB(t, n, i);
}
function vB(t, e, n) {
  if (n.button != 0)
    return !1;
  let i = t.state.doc;
  if (e == -1)
    return i.inlineContent ? (Sl(t, ce.create(i, 0, i.content.size)), !0) : !1;
  let r = i.resolve(e);
  for (let s = r.depth + 1; s > 0; s--) {
    let o = s > r.depth ? r.nodeAfter : r.node(s), a = r.before(s);
    if (o.inlineContent)
      Sl(t, ce.create(i, a + 1, a + 1 + o.content.size));
    else if (ge.isSelectable(o))
      Sl(t, ge.create(i, a));
    else
      continue;
    return !0;
  }
}
function p2(t) {
  return Wu(t);
}
const sM = Ti ? "metaKey" : "ctrlKey";
Un.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let i = p2(t), r = Date.now(), s = "singleClick";
  r - t.input.lastClick.time < 500 && mB(n, t.input.lastClick) && !n[sM] && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t.input.lastClick = { time: r, x: n.clientX, y: n.clientY, type: s };
  let o = t.posAtCoords(O0(n));
  o && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new xB(t, o, n, !!i)) : (s == "doubleClick" ? yB : _B)(t, o.pos, o.inside, n) ? n.preventDefault() : io(t, "pointer"));
};
class xB {
  constructor(e, n, i, r) {
    this.view = e, this.pos = n, this.event = i, this.flushed = r, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!i[sM], this.allowDefault = i.shiftKey;
    let s, o;
    if (n.inside > -1)
      s = e.state.doc.nodeAt(n.inside), o = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const a = r ? null : i.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (i.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof ge && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && dr && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), io(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Ss(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(O0(e))), this.updateAllowDefault(e), this.allowDefault || !n ? io(this.view, "pointer") : OB(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    zn && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    kn && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Sl(this.view, _e.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : io(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), io(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Un.touchstart = (t) => {
  t.input.lastTouch = Date.now(), p2(t), io(t, "pointer");
};
Un.touchmove = (t) => {
  t.input.lastTouch = Date.now(), io(t, "pointer");
};
Un.contextmenu = (t) => p2(t);
function oM(t, e) {
  return t.composing ? !0 : zn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const wB = tr ? 5e3 : -1;
Wn.compositionstart = Wn.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$from;
    if (e.selection.empty && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((i) => i.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Wu(t, !0), t.markCursor = null;
    else if (Wu(t), dr && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let i = t.domSelectionRange();
      for (let r = i.focusNode, s = i.focusOffset; r && r.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? r.lastChild : r.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          t.domSelection().collapse(o, o.nodeValue.length);
          break;
        } else
          r = o, s = -1;
      }
    }
    t.input.composing = !0;
  }
  aM(t, wB);
};
Wn.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, aM(t, 20));
};
function aM(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Wu(t), e));
}
function lM(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = kB()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function SB(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = b7(e.focusNode, e.focusOffset), i = O7(e.focusNode, e.focusOffset);
  if (n && i && n != i) {
    let r = i.pmViewDesc, s = t.domObserver.lastChangedTextNode;
    if (n == s || i == s)
      return s;
    if (!r || !r.isText(i.nodeValue))
      return i;
    if (t.input.compositionNode == i) {
      let o = n.pmViewDesc;
      if (!(!o || !o.isText(n.nodeValue)))
        return i;
    }
  }
  return n || i;
}
function kB() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Wu(t, e = !1) {
  if (!(tr && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), lM(t), e || t.docView && t.docView.dirty) {
      let n = l2(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function EB(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let i = getSelection(), r = document.createRange();
  r.selectNodeContents(e), t.dom.blur(), i.removeAllRanges(), i.addRange(r), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const Vu = si && go < 15 || Wl && w7 < 604;
Un.copy = Wn.cut = (t, e) => {
  let n = e, i = t.state.selection, r = n.type == "cut";
  if (i.empty)
    return;
  let s = Vu ? null : n.clipboardData, o = i.content(), { dom: a, text: l } = u2(t, o);
  s ? (n.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : EB(t, a), r && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function CB(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function AB(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, i = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (i.contentEditable = "true"), i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.focus();
  let r = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), i.parentNode && i.parentNode.removeChild(i), n ? Zu(t, i.value, null, r, e) : Zu(t, i.textContent, i.innerHTML, r, e);
  }, 50);
}
function Zu(t, e, n, i, r) {
  let s = d2(t, e, n, i, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, r, s || ne.empty)))
    return !0;
  if (!s)
    return !1;
  let o = CB(s), a = o ? t.state.tr.replaceSelectionWith(o, i) : t.state.tr.replaceSelection(s);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function cM(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Wn.paste = (t, e) => {
  let n = e;
  if (t.composing && !tr)
    return;
  let i = Vu ? null : n.clipboardData, r = t.input.shiftKey && t.input.lastKeyCode != 45;
  i && Zu(t, cM(i), i.getData("text/html"), r, n) ? n.preventDefault() : AB(t, n);
};
class uM {
  constructor(e, n, i) {
    this.slice = e, this.move = n, this.node = i;
  }
}
const dM = Ti ? "altKey" : "ctrlKey";
Un.dragstart = (t, e) => {
  let n = e, i = t.input.mouseDown;
  if (i && i.done(), !n.dataTransfer)
    return;
  let r = t.state.selection, s = r.empty ? null : t.posAtCoords(O0(n)), o;
  if (!(s && s.pos >= r.from && s.pos <= (r instanceof ge ? r.to - 1 : r.to))) {
    if (i && i.mightDrag)
      o = ge.create(t.state.doc, i.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (o = ge.create(t.state.doc, d.posBefore));
    }
  }
  let a = (o || t.state.selection).content(), { dom: l, text: c, slice: u } = u2(t, a);
  (!n.dataTransfer.files.length || !kn || BT > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Vu ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Vu || n.dataTransfer.setData("text/plain", c), t.dragging = new uM(u, !n[dM], o);
};
Un.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Wn.dragover = Wn.dragenter = (t, e) => e.preventDefault();
Wn.drop = (t, e) => {
  let n = e, i = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let r = t.posAtCoords(O0(n));
  if (!r)
    return;
  let s = t.state.doc.resolve(r.pos), o = i && i.slice;
  o ? t.someProp("transformPasted", (p) => {
    o = p(o, t);
  }) : o = d2(t, cM(n.dataTransfer), Vu ? null : n.dataTransfer.getData("text/html"), !1, s);
  let a = !!(i && !n[dM]);
  if (t.someProp("handleDrop", (p) => p(t, n, o || ne.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!o)
    return;
  n.preventDefault();
  let l = o ? dT(t.state.doc, s.pos, o) : s.pos;
  l == null && (l = s.pos);
  let c = t.state.tr;
  if (a) {
    let { node: p } = i;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, h = c.doc;
  if (d ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(h))
    return;
  let f = c.doc.resolve(u);
  if (d && ge.isSelectable(o.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ge(f));
  else {
    let p = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, b, _) => p = _), c.setSelection(c2(t, f, c.doc.resolve(p)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
Un.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Ss(t);
  }, 20));
};
Un.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
Un.beforeinput = (t, e) => {
  if (kn && tr && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: i } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != i || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (s) => s(t, Go(8, "Backspace")))))
        return;
      let { $cursor: r } = t.state.selection;
      r && r.pos > 0 && t.dispatch(t.state.tr.delete(r.pos - 1, r.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Wn)
  Un[t] = Wn[t];
function Hu(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
let qx = class hM {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || ba, this.side = this.spec.side || 0;
  }
  map(e, n, i, r) {
    let { pos: s, deleted: o } = e.mapResult(n.from + r, this.side < 0 ? -1 : 1);
    return o ? null : new zt(s - i, s - i, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof hM && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Hu(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
};
class Oo {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ba;
  }
  map(e, n, i, r) {
    let s = e.map(n.from + r, this.spec.inclusiveStart ? -1 : 1) - i, o = e.map(n.to + r, this.spec.inclusiveEnd ? 1 : -1) - i;
    return s >= o ? null : new zt(s, o, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Oo && Hu(this.attrs, e.attrs) && Hu(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Oo;
  }
  destroy() {
  }
}
let TB = class fM {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ba;
  }
  map(e, n, i, r) {
    let s = e.mapResult(n.from + r, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(n.to + r, -1);
    return o.deleted || o.pos <= s.pos ? null : new zt(s.pos - i, o.pos - i, this);
  }
  valid(e, n) {
    let { index: i, offset: r } = e.content.findIndex(n.from), s;
    return r == n.from && !(s = e.child(i)).isText && r + s.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof fM && Hu(this.attrs, e.attrs) && Hu(this.spec, e.spec);
  }
  destroy() {
  }
}, zt = class qc {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.from = e, this.to = n, this.type = i;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new qc(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, i) {
    return this.type.map(e, this, n, i);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, i) {
    return new qc(e, e, new qx(n, i));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, i, r) {
    return new qc(e, n, new Oo(i, r));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, i, r) {
    return new qc(e, n, new TB(i, r));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Oo;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof qx;
  }
};
const ul = [], ba = {};
class We {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : ul, this.children = n.length ? n : ul;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? Mp(n, e, 0, ba) : vn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, i) {
    let r = [];
    return this.findInner(e ?? 0, n ?? 1e9, r, 0, i), r;
  }
  findInner(e, n, i, r, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= n && a.to >= e && (!s || s(a.spec)) && i.push(a.copy(a.from + r, a.to + r));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < n && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, n - a, i, r + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, i) {
    return this == vn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, i || ba);
  }
  /**
  @internal
  */
  mapInner(e, n, i, r, s) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, i, r);
      l && l.type.valid(n, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? MB(this.children, o || [], e, n, i, r, s) : o ? new We(o.sort(Oa), ul) : vn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == vn ? We.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, i) {
    let r, s = 0;
    e.forEach((a, l) => {
      let c = l + i, u;
      if (u = mM(n, a, c)) {
        for (r || (r = this.children.slice()); s < r.length && r[s] < l; )
          s += 3;
        r[s] == l ? r[s + 2] = r[s + 2].addInner(a, u, c + 1) : r.splice(s, 0, l, l + a.nodeSize, Mp(u, a, c + 1, ba)), s += 3;
      }
    });
    let o = pM(s ? gM(n) : n, -i);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new We(o.length ? this.local.concat(o).sort(Oa) : this.local, r || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == vn ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let i = this.children, r = this.local;
    for (let s = 0; s < i.length; s += 3) {
      let o, a = i[s] + n, l = i[s + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (o || (o = [])).push(d));
      if (!o)
        continue;
      i == this.children && (i = this.children.slice());
      let c = i[s + 2].removeInner(o, a + 1);
      c != vn ? i[s + 2] = c : (i.splice(s, 3), s -= 3);
    }
    if (r.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let a = 0; a < r.length; a++)
            r[a].eq(o, n) && (r == this.local && (r = this.local.slice()), r.splice(a--, 1));
    }
    return i == this.children && r == this.local ? this : r.length || i.length ? new We(r, i) : vn;
  }
  forChild(e, n) {
    if (this == vn)
      return this;
    if (n.isLeaf)
      return We.empty;
    let i, r;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (i = this.children[a + 2]);
        break;
      }
    let s = e + 1, o = s + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > s && l.type instanceof Oo) {
        let c = Math.max(s, l.from) - s, u = Math.min(o, l.to) - s;
        c < u && (r || (r = [])).push(l.copy(c, u));
      }
    }
    if (r) {
      let a = new We(r.sort(Oa), ul);
      return i ? new js([a, i]) : a;
    }
    return i || vn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof We) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return m2(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == vn)
      return ul;
    if (e.inlineContent || !this.local.some(Oo.is))
      return this.local;
    let n = [];
    for (let i = 0; i < this.local.length; i++)
      this.local[i].type instanceof Oo || n.push(this.local[i]);
    return n;
  }
}
We.empty = new We([], []);
We.removeOverlap = m2;
const vn = We.empty;
class js {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const i = this.members.map((r) => r.map(e, n, ba));
    return js.from(i);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return We.empty;
    let i = [];
    for (let r = 0; r < this.members.length; r++) {
      let s = this.members[r].forChild(e, n);
      s != vn && (s instanceof js ? i = i.concat(s.members) : i.push(s));
    }
    return js.from(i);
  }
  eq(e) {
    if (!(e instanceof js) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, i = !0;
    for (let r = 0; r < this.members.length; r++) {
      let s = this.members[r].localsInner(e);
      if (s.length)
        if (!n)
          n = s;
        else {
          i && (n = n.slice(), i = !1);
          for (let o = 0; o < s.length; o++)
            n.push(s[o]);
        }
    }
    return n ? m2(i ? n : n.sort(Oa)) : ul;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return vn;
      case 1:
        return e[0];
      default:
        return new js(e.every((n) => n instanceof We) ? e : e.reduce((n, i) => n.concat(i instanceof We ? i : i.members), []));
    }
  }
}
function MB(t, e, n, i, r, s, o) {
  let a = t.slice();
  for (let c = 0, u = s; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((h, f, p, m) => {
      let g = m - p - (f - h);
      for (let b = 0; b < a.length; b += 3) {
        let _ = a[b + 1];
        if (_ < 0 || h > _ + u - d)
          continue;
        let y = a[b] + u - d;
        f >= y ? a[b + 1] = h <= y ? -2 : -1 : h >= u && g && (a[b] += g, a[b + 1] += g);
      }
      d += g;
    }), u = n.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let u = n.map(t[c] + s), d = u - r;
      if (d < 0 || d >= i.content.size) {
        l = !0;
        continue;
      }
      let h = n.map(t[c + 1] + s, -1), f = h - r, { index: p, offset: m } = i.content.findIndex(d), g = i.maybeChild(p);
      if (g && m == d && m + g.nodeSize == f) {
        let b = a[c + 2].mapInner(n, g, u + 1, t[c] + s + 1, o);
        b != vn ? (a[c] = d, a[c + 1] = f, a[c + 2] = b) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = PB(a, t, e, n, r, s, o), u = Mp(c, i, 0, o);
    e = u.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, h = 0; d < u.children.length; d += 3) {
      let f = u.children[d];
      for (; h < a.length && a[h] < f; )
        h += 3;
      a.splice(h, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new We(e.sort(Oa), a);
}
function pM(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let i = 0; i < t.length; i++) {
    let r = t[i];
    n.push(new zt(r.from + e, r.to + e, r.type));
  }
  return n;
}
function PB(t, e, n, i, r, s, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(i, r, c);
      d ? n.push(d) : o.onRemove && o.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1);
  return n;
}
function mM(t, e, n) {
  if (e.isLeaf)
    return null;
  let i = n + e.nodeSize, r = null;
  for (let s = 0, o; s < t.length; s++)
    (o = t[s]) && o.from > n && o.to < i && ((r || (r = [])).push(o), t[s] = null);
  return r;
}
function gM(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function Mp(t, e, n, i) {
  let r = [], s = !1;
  e.forEach((a, l) => {
    let c = mM(t, a, l + n);
    if (c) {
      s = !0;
      let u = Mp(c, a, n + l + 1, i);
      u != vn && r.push(l, l + a.nodeSize, u);
    }
  });
  let o = pM(s ? gM(t) : t, -n).sort(Oa);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (i.onRemove && i.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || r.length ? new We(o, r) : vn;
}
function Oa(t, e) {
  return t.from - e.from || t.to - e.to;
}
function m2(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let i = e[n];
    if (i.from != i.to)
      for (let r = n + 1; r < e.length; r++) {
        let s = e[r];
        if (s.from == i.from) {
          s.to != i.to && (e == t && (e = t.slice()), e[r] = s.copy(s.from, i.to), Xx(e, r + 1, s.copy(i.to, s.to)));
          continue;
        } else {
          s.from < i.to && (e == t && (e = t.slice()), e[n] = i.copy(i.from, s.from), Xx(e, r, i.copy(s.from, i.to)));
          break;
        }
      }
  }
  return e;
}
function Xx(t, e, n) {
  for (; e < t.length && Oa(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function Tg(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let i = n(t.state);
    i && i != vn && e.push(i);
  }), t.cursorWrapper && e.push(We.create(t.state.doc, [t.cursorWrapper.deco])), js.from(e);
}
const RB = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, $B = si && go <= 11;
class NB {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
let DB = class {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new NB(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((i) => {
      for (let r = 0; r < i.length; r++)
        this.queue.push(i[r]);
      si && go <= 11 && i.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), $B && (this.onCharData = (i) => {
      this.queue.push({ target: i.target, type: "characterData", oldValue: i.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, RB)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Qx(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Ss(this.view);
      if (si && go <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && ka(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), i;
    for (let s = e.focusNode; s; s = Uu(s))
      n.add(s);
    for (let s = e.anchorNode; s; s = Uu(s))
      if (n.has(s)) {
        i = s;
        break;
      }
    let r = i && this.view.docView.nearestDesc(i);
    if (r && r.ignoreMutation({
      type: "selection",
      target: i.nodeType == 3 ? i.parentNode : i
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let i = e.domSelectionRange(), r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(i) && Qx(e) && !this.ignoreSelectionChange(i), s = -1, o = -1, a = !1, l = [];
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], l);
        d && (s = s < 0 ? d.from : Math.min(d.from, s), o = o < 0 ? d.to : Math.max(d.to, o), d.typeOver && (a = !0));
      }
    if (dr && l.length) {
      let u = l.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, h] = u;
        d.parentNode && d.parentNode.parentNode == h.parentNode ? h.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let h of u) {
          let f = h.parentNode;
          f && f.nodeName == "LI" && (!d || BB(e, d) != f) && h.remove();
        }
      }
    }
    let c = null;
    s < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && g0(i) && (c = l2(e)) && c.eq(_e.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Ss(e), this.currentSelection.set(i), e.scrollToSelection()) : (s > -1 || r) && (s > -1 && (e.docView.markDirty(s, o), IB(e)), this.handleDOMChange(s, o, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(i) || Ss(e), this.currentSelection.set(i));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let i = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (i == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !i || i.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (i.contentDOM && i.contentDOM != i.dom && !i.contentDOM.contains(e.target))
        return { from: i.posBefore, to: i.posAfter };
      let r = e.previousSibling, s = e.nextSibling;
      if (si && go <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: h } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (r = d), (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (s = h);
        }
      let o = r && r.parentNode == e.target ? fn(r) + 1 : 0, a = i.localPosFromDOM(e.target, o, -1), l = s && s.parentNode == e.target ? fn(s) : e.target.childNodes.length, c = i.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else return e.type == "attributes" ? { from: i.posAtStart - i.border, to: i.posAtEnd + i.border } : (this.lastChangedTextNode = e.target, {
      from: i.posAtStart,
      to: i.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}, jx = /* @__PURE__ */ new WeakMap(), Yx = !1;
function IB(t) {
  if (!jx.has(t) && (jx.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = dr, Yx)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Yx = !0;
  }
}
function Gx(t, e) {
  let n = e.startContainer, i = e.startOffset, r = e.endContainer, s = e.endOffset, o = t.domAtPos(t.state.selection.anchor);
  return ka(o.node, o.offset, r, s) && ([n, i, r, s] = [r, s, n, i]), { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: s };
}
function LB(t, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(t.root)[0];
    if (r)
      return Gx(t, r);
  }
  let n;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), n = r.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", i, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", i, !0), n ? Gx(t, n) : null;
}
function BB(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let i = t.docView.nearestDesc(n, !0);
    if (i && i.node.isBlock)
      return n;
  }
  return null;
}
function QB(t, e, n) {
  let { node: i, fromOffset: r, toOffset: s, from: o, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, u = l.anchorNode;
  if (u && t.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], g0(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), kn && t.input.lastKeyCode === 8)
    for (let g = s; g > r; g--) {
      let b = i.childNodes[g - 1], _ = b.pmViewDesc;
      if (b.nodeName == "BR" && !_) {
        s = g;
        break;
      }
      if (!_ || _.size)
        break;
    }
  let d = t.state.doc, h = t.someProp("domParser") || ws.fromSchema(t.state.schema), f = d.resolve(o), p = null, m = h.parse(i, {
    topNode: f.parent,
    topMatch: f.parent.contentMatchAt(f.index()),
    topOpen: !0,
    from: r,
    to: s,
    preserveWhitespace: f.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: FB,
    context: f
  });
  if (c && c[0].pos != null) {
    let g = c[0].pos, b = c[1] && c[1].pos;
    b == null && (b = g), p = { anchor: g + o, head: b + o };
  }
  return { doc: m, sel: p, from: o, to: a };
}
function FB(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (zn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || zn && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const zB = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function UB(t, e, n, i, r) {
  let s = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let S = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, $ = l2(t, S);
    if ($ && !t.state.selection.eq($)) {
      if (kn && tr && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (F) => F(t, Go(13, "Enter"))))
        return;
      let I = t.state.tr.setSelection($);
      S == "pointer" ? I.setMeta("pointer", !0) : S == "key" && I.scrollIntoView(), s && I.setMeta("composition", s), t.dispatch(I);
    }
    return;
  }
  let o = t.state.doc.resolve(e), a = o.sharedDepth(n);
  e = o.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let l = t.state.selection, c = QB(t, e, n), u = t.state.doc, d = u.slice(c.from, c.to), h, f;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (h = t.state.selection.to, f = "end") : (h = t.state.selection.from, f = "start"), t.input.lastKeyCode = null;
  let p = ZB(d.content, c.doc.content, c.from, h, f);
  if ((Wl && t.input.lastIOSEnter > Date.now() - 225 || tr) && r.some((S) => S.nodeType == 1 && !zB.test(S.nodeName)) && (!p || p.endA >= p.endB) && t.someProp("handleKeyDown", (S) => S(t, Go(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (i && l instanceof ce && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let S = Kx(t, t.state.doc, c.sel);
        if (S && !S.eq(t.state.selection)) {
          let $ = t.state.tr.setSelection(S);
          s && $.setMeta("composition", s), t.dispatch($);
        }
      }
      return;
    }
  t.input.domChangeCount++, t.state.selection.from < t.state.selection.to && p.start == p.endB && t.state.selection instanceof ce && (p.start > t.state.selection.from && p.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? p.start = t.state.selection.from : p.endA < t.state.selection.to && p.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (p.endB += t.state.selection.to - p.endA, p.endA = t.state.selection.to)), si && go <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == " " && (p.start--, p.endA--, p.endB--);
  let m = c.doc.resolveNoCache(p.start - c.from), g = c.doc.resolveNoCache(p.endB - c.from), b = u.resolve(p.start), _ = m.sameParent(g) && m.parent.inlineContent && b.end() >= p.endA, y;
  if ((Wl && t.input.lastIOSEnter > Date.now() - 225 && (!_ || r.some((S) => S.nodeName == "DIV" || S.nodeName == "P")) || !_ && m.pos < c.doc.content.size && !m.sameParent(g) && (y = _e.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) && y.head == g.pos) && t.someProp("handleKeyDown", (S) => S(t, Go(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > p.start && VB(u, p.start, p.endA, m, g) && t.someProp("handleKeyDown", (S) => S(t, Go(8, "Backspace")))) {
    tr && kn && t.domObserver.suppressSelectionUpdates();
    return;
  }
  kn && tr && p.endB == p.start && (t.input.lastAndroidDelete = Date.now()), tr && !_ && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, g = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(S) {
      return S(t, Go(13, "Enter"));
    });
  }, 20));
  let O = p.start, x = p.endA, v, w, T;
  if (_) {
    if (m.pos == g.pos)
      si && go <= 11 && m.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Ss(t), 20)), v = t.state.tr.delete(O, x), w = u.resolve(p.start).marksAcross(u.resolve(p.endA));
    else if (
      // Adding or removing a mark
      p.endA == p.endB && (T = WB(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, p.endA - b.start())))
    )
      v = t.state.tr, T.type == "add" ? v.addMark(O, x, T.mark) : v.removeMark(O, x, T.mark);
    else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let S = m.parent.textBetween(m.parentOffset, g.parentOffset);
      if (t.someProp("handleTextInput", ($) => $(t, O, x, S)))
        return;
      v = t.state.tr.insertText(S, O, x);
    }
  }
  if (v || (v = t.state.tr.replace(O, x, c.doc.slice(p.start - c.from, p.endB - c.from))), c.sel) {
    let S = Kx(t, v.doc, c.sel);
    S && !(kn && tr && t.composing && S.empty && (p.start != p.endB || t.input.lastAndroidDelete < Date.now() - 100) && (S.head == O || S.head == v.mapping.map(x) - 1) || si && S.empty && S.head == O) && v.setSelection(S);
  }
  w && v.ensureMarks(w), s && v.setMeta("composition", s), t.dispatch(v.scrollIntoView());
}
function Kx(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : c2(t, e.resolve(n.anchor), e.resolve(n.head));
}
function WB(t, e) {
  let n = t.firstChild.marks, i = e.firstChild.marks, r = n, s = i, o, a, l;
  for (let u = 0; u < i.length; u++)
    r = i[u].removeFromSet(r);
  for (let u = 0; u < n.length; u++)
    s = n[u].removeFromSet(s);
  if (r.length == 1 && s.length == 0)
    a = r[0], o = "add", l = (u) => u.mark(a.addToSet(u.marks));
  else if (r.length == 0 && s.length == 1)
    a = s[0], o = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if (Y.from(c).eq(t))
    return { mark: a, type: o };
}
function VB(t, e, n, i, r) {
  if (
    // The content must have shrunk
    n - e <= r.pos - i.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Mg(i, !0, !1) < r.pos
  )
    return !1;
  let s = t.resolve(e);
  if (!i.parent.isTextblock) {
    let a = s.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = t.resolve(Mg(s, !0, !0));
  return !o.parent.isTextblock || o.pos > n || Mg(o, !0, !1) < n ? !1 : i.parent.content.cut(i.parentOffset).eq(o.parent.content);
}
function Mg(t, e, n) {
  let i = t.depth, r = e ? t.end() : t.pos;
  for (; i > 0 && (e || t.indexAfter(i) == t.node(i).childCount); )
    i--, r++, e = !1;
  if (n) {
    let s = t.node(i).maybeChild(t.indexAfter(i));
    for (; s && !s.isLeaf; )
      s = s.firstChild, r++;
  }
  return r;
}
function ZB(t, e, n, i, r) {
  let s = t.findDiffStart(e, n);
  if (s == null)
    return null;
  let { a: o, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (r == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    i -= o + l - s;
  }
  if (o < s && t.size < e.size) {
    let l = i <= s && i >= o ? s - i : 0;
    s -= l, s && s < e.size && Jx(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), a = s + (a - o), o = s;
  } else if (a < s) {
    let l = i <= s && i >= a ? s - i : 0;
    s -= l, s && s < t.size && Jx(t.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), o = s + (o - a), a = s;
  }
  return { start: s, endA: o, endB: a };
}
function Jx(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
const HB = u2, lve = d2, cve = Wu;
let qB = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new uB(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(rw), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = nw(this), tw(this), this.nodeViews = iw(this), this.docView = $x(this.state.doc, ew(this), Tg(this), this.dom, this), this.domObserver = new DB(this, (i, r, s, o) => UB(this, i, r, s, o)), this.domObserver.start(), dB(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Xb(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(rw), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let i in this._props)
      n[i] = this._props[i];
    n.state = this.state;
    for (let i in e)
      n[i] = e[i];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var i;
    let r = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (lM(this), o = !0), this.state = e;
    let a = r.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let f = iw(this);
      jB(f, this.nodeViews) && (this.nodeViews = f, s = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Xb(this), this.editable = nw(this), tw(this);
    let l = Tg(this), c = ew(this), u = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", d = s || !this.docView.matchesNode(e.doc, c, l);
    (d || !e.selection.eq(r.selection)) && (o = !0);
    let h = u == "preserve" && o && this.dom.style.overflowAnchor == null && E7(this);
    if (o) {
      this.domObserver.stop();
      let f = d && (si || kn) && !this.composing && !r.selection.empty && !e.selection.empty && XB(r.selection, e.selection);
      if (d) {
        let p = kn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = SB(this)), (s || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = $x(e.doc, c, l, this.dom, this)), p && !this.trackWrites && (f = !0);
      }
      f || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Y7(this)) ? Ss(this, f) : (GT(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), !((i = this.dragging) === null || i === void 0) && i.node && !r.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, r), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : h && C7(h);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof ge) {
      let n = this.docView.domAfterPos(this.state.selection.from);
      n.nodeType == 1 && Cx(this, n.getBoundingClientRect(), e);
    } else
      Cx(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let i = this.directPlugins[n];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let i = this.state.plugins[n];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let i = this.pluginViews[n];
        i.update && i.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let i = e.node, r = -1;
    if (this.state.doc.nodeAt(i.from) == i.node)
      r = i.from;
    else {
      let s = i.from + (this.state.doc.content.size - n.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == i.node && (r = s);
    }
    this.dragging = new uM(e.slice, e.move, r < 0 ? void 0 : ge.create(this.state.doc, r));
  }
  someProp(e, n) {
    let i = this._props && this._props[e], r;
    if (i != null && (r = n ? n(i) : i))
      return r;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e];
      if (a != null && (r = n ? n(a) : a))
        return r;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e];
        if (a != null && (r = n ? n(a) : a))
          return r;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (si) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && A7(this.dom), Ss(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return $7(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return WT(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, i = -1) {
    let r = this.docView.posFromDOM(e, n, i);
    if (r == null)
      throw new RangeError("DOM position not inside the editor");
    return r;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return B7(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return Zu(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return Zu(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (hB(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Tg(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, m7());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return pB(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return zn && this.root.nodeType === 11 && _7(this.dom.ownerDocument) == this.dom && LB(this, e) || e;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function ew(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let i in n)
        i == "class" ? e.class += " " + n[i] : i == "style" ? e.style = (e.style ? e.style + ";" : "") + n[i] : !e[i] && i != "contenteditable" && i != "nodeName" && (e[i] = String(n[i]));
  }), e.translate || (e.translate = "no"), [zt.node(0, t.state.doc.content.size, e)];
}
function tw(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: zt.widget(t.state.selection.head, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function nw(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function XB(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function iw(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(i) {
    for (let r in i)
      Object.prototype.hasOwnProperty.call(e, r) || (e[r] = i[r]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function jB(t, e) {
  let n = 0, i = 0;
  for (let r in t) {
    if (t[r] != e[r])
      return !0;
    n++;
  }
  for (let r in e)
    i++;
  return n != i;
}
function rw(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
let ci = class zs extends _e {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let i = e.resolve(n.map(this.head));
    return zs.valid(i) ? new zs(i) : _e.near(i);
  }
  content() {
    return ne.empty;
  }
  eq(e) {
    return e instanceof zs && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new zs(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new YB(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !GB(e) || !KB(e))
      return !1;
    let i = n.type.spec.allowGapCursor;
    if (i != null)
      return i;
    let r = n.contentMatchAt(e.index()).defaultType;
    return r && r.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, i = !1) {
    e: for (; ; ) {
      if (!i && zs.valid(e))
        return e;
      let r = e.pos, s = null;
      for (let o = e.depth; ; o--) {
        let a = e.node(o);
        if (n > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
          s = a.child(n > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        r += n;
        let l = e.doc.resolve(r);
        if (zs.valid(l))
          return l;
      }
      for (; ; ) {
        let o = n > 0 ? s.firstChild : s.lastChild;
        if (!o) {
          if (s.isAtom && !s.isText && !ge.isSelectable(s)) {
            e = e.doc.resolve(r + s.nodeSize * n), i = !1;
            continue e;
          }
          break;
        }
        s = o, r += n;
        let a = e.doc.resolve(r);
        if (zs.valid(a))
          return a;
      }
      return null;
    }
  }
};
ci.prototype.visible = !1;
ci.findFrom = ci.findGapCursorFrom;
_e.jsonID("gapcursor", ci);
let YB = class bM {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new bM(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return ci.valid(n) ? new ci(n) : _e.near(n);
  }
};
function GB(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), i = t.node(e);
    if (n == 0) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = i.child(n - 1); ; r = r.lastChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function KB(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), i = t.node(e);
    if (n == i.childCount) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = i.child(n); ; r = r.firstChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function dve() {
  return new Ue({
    props: {
      decorations: nQ,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && ci.valid(n) ? new ci(n) : null;
      },
      handleClick: eQ,
      handleKeyDown: JB,
      handleDOMEvents: { beforeinput: tQ }
    }
  });
}
const JB = m0({
  ArrowLeft: Mh("horiz", -1),
  ArrowRight: Mh("horiz", 1),
  ArrowUp: Mh("vert", -1),
  ArrowDown: Mh("vert", 1)
});
function Mh(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(i, r, s) {
    let o = i.selection, a = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof ce) {
      if (!s.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = i.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = ci.findGapCursorFrom(a, e, l);
    return c ? (r && r(i.tr.setSelection(new ci(c))), !0) : !1;
  };
}
function eQ(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let i = t.state.doc.resolve(e);
  if (!ci.valid(i))
    return !1;
  let r = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return r && r.inside > -1 && ge.isSelectable(t.state.doc.nodeAt(r.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new ci(i))), !0);
}
function tQ(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof ci))
    return !1;
  let { $from: n } = t.state.selection, i = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!i)
    return !1;
  let r = Y.empty;
  for (let o = i.length - 1; o >= 0; o--)
    r = Y.from(i[o].createAndFill(null, r));
  let s = t.state.tr.replace(n.pos, n.pos, new ne(r, 0, 0));
  return s.setSelection(ce.near(s.doc.resolve(n.pos + 1))), t.dispatch(s), !1;
}
function nQ(t) {
  if (!(t.selection instanceof ci))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", We.create(t.doc, [zt.widget(t.selection.head, e, { key: "gapcursor" })]);
}
var Pp = 200, an = function() {
};
an.prototype.append = function(e) {
  return e.length ? (e = an.from(e), !this.length && e || e.length < Pp && this.leafAppend(e) || this.length < Pp && e.leafPrepend(this) || this.appendInner(e)) : this;
};
an.prototype.prepend = function(e) {
  return e.length ? an.from(e).append(this) : this;
};
an.prototype.appendInner = function(e) {
  return new iQ(this, e);
};
an.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? an.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
an.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
an.prototype.forEach = function(e, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = this.length), n <= i ? this.forEachInner(e, n, i, 0) : this.forEachInvertedInner(e, n, i, 0);
};
an.prototype.map = function(e, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = this.length);
  var r = [];
  return this.forEach(function(s, o) {
    return r.push(e(s, o));
  }, n, i), r;
};
an.from = function(e) {
  return e instanceof an ? e : e && e.length ? new OM(e) : an.empty;
};
var OM = /* @__PURE__ */ function(t) {
  function e(i) {
    t.call(this), this.values = i;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(r, s) {
    return r == 0 && s == this.length ? this : new e(this.values.slice(r, s));
  }, e.prototype.getInner = function(r) {
    return this.values[r];
  }, e.prototype.forEachInner = function(r, s, o, a) {
    for (var l = s; l < o; l++)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(r, s, o, a) {
    for (var l = s - 1; l >= o; l--)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(r) {
    if (this.length + r.length <= Pp)
      return new e(this.values.concat(r.flatten()));
  }, e.prototype.leafPrepend = function(r) {
    if (this.length + r.length <= Pp)
      return new e(r.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(an);
an.empty = new OM([]);
var iQ = /* @__PURE__ */ function(t) {
  function e(n, i) {
    t.call(this), this.left = n, this.right = i, this.length = n.length + i.length, this.depth = Math.max(n.depth, i.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  }, e.prototype.forEachInner = function(i, r, s, o) {
    var a = this.left.length;
    if (r < a && this.left.forEachInner(i, r, Math.min(s, a), o) === !1 || s > a && this.right.forEachInner(i, Math.max(r - a, 0), Math.min(this.length, s) - a, o + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(i, r, s, o) {
    var a = this.left.length;
    if (r > a && this.right.forEachInvertedInner(i, r - a, Math.max(s, a) - a, o + a) === !1 || s < a && this.left.forEachInvertedInner(i, Math.min(r, a), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(i, r) {
    if (i == 0 && r == this.length)
      return this;
    var s = this.left.length;
    return r <= s ? this.left.slice(i, r) : i >= s ? this.right.slice(i - s, r - s) : this.left.slice(i, s).append(this.right.slice(0, r - s));
  }, e.prototype.leafAppend = function(i) {
    var r = this.right.leafAppend(i);
    if (r)
      return new e(this.left, r);
  }, e.prototype.leafPrepend = function(i) {
    var r = this.left.leafPrepend(i);
    if (r)
      return new e(r, this.right);
  }, e.prototype.appendInner = function(i) {
    return this.left.depth >= Math.max(this.right.depth, i.depth) + 1 ? new e(this.left, new e(this.right, i)) : new e(this, i);
  }, e;
}(an);
const rQ = 500;
class rr {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let i = this.items.length;
    for (; ; i--)
      if (this.items.get(i - 1).selection) {
        --i;
        break;
      }
    let r, s;
    n && (r = this.remapping(i, this.items.length), s = r.maps.length);
    let o = e.tr, a, l, c = [], u = [];
    return this.items.forEach((d, h) => {
      if (!d.step) {
        r || (r = this.remapping(i, h + 1), s = r.maps.length), s--, u.push(d);
        return;
      }
      if (r) {
        u.push(new Sr(d.map));
        let f = d.step.map(r.slice(s)), p;
        f && o.maybeStep(f).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new Sr(p, void 0, void 0, c.length + u.length))), s--, p && r.appendMap(p, s);
      } else
        o.maybeStep(d.step);
      if (d.selection)
        return a = r ? d.selection.map(r.slice(s)) : d.selection, l = new rr(this.items.slice(0, i).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: o, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, i, r) {
    let s = [], o = this.eventCount, a = this.items, l = !r && a.length ? a.get(a.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), h = new Sr(e.mapping.maps[u], d, n), f;
      (f = l && l.merge(h)) && (h = f, u ? s.pop() : a = a.slice(0, a.length - 1)), s.push(h), n && (o++, n = void 0), r || (l = h);
    }
    let c = o - i.depth;
    return c > oQ && (a = sQ(a, c), o -= c), new rr(a.append(s), o);
  }
  remapping(e, n) {
    let i = new wl();
    return this.items.forEach((r, s) => {
      let o = r.mirrorOffset != null && s - r.mirrorOffset >= e ? i.maps.length - r.mirrorOffset : void 0;
      i.appendMap(r.map, o);
    }, e, n), i;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new rr(this.items.append(e.map((n) => new Sr(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let i = [], r = Math.max(0, this.items.length - n), s = e.mapping, o = e.steps.length, a = this.eventCount;
    this.items.forEach((h) => {
      h.selection && a--;
    }, r);
    let l = n;
    this.items.forEach((h) => {
      let f = s.getMirror(--l);
      if (f == null)
        return;
      o = Math.min(o, f);
      let p = s.maps[f];
      if (h.step) {
        let m = e.steps[f].invert(e.docs[f]), g = h.selection && h.selection.map(s.slice(l + 1, f));
        g && a++, i.push(new Sr(p, m, g));
      } else
        i.push(new Sr(p));
    }, r);
    let c = [];
    for (let h = n; h < o; h++)
      c.push(new Sr(s.maps[h]));
    let u = this.items.slice(0, r).append(c).append(i), d = new rr(u, a);
    return d.emptyItemCount() > rQ && (d = d.compress(this.items.length - i.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), i = n.maps.length, r = [], s = 0;
    return this.items.forEach((o, a) => {
      if (a >= e)
        r.push(o), o.selection && s++;
      else if (o.step) {
        let l = o.step.map(n.slice(i)), c = l && l.getMap();
        if (i--, c && n.appendMap(c, i), l) {
          let u = o.selection && o.selection.map(n.slice(i));
          u && s++;
          let d = new Sr(c.invert(), l, u), h, f = r.length - 1;
          (h = r.length && r[f].merge(d)) ? r[f] = h : r.push(d);
        }
      } else o.map && i--;
    }, this.items.length, 0), new rr(an.from(r.reverse()), s);
  }
}
rr.empty = new rr(an.empty, 0);
function sQ(t, e) {
  let n;
  return t.forEach((i, r) => {
    if (i.selection && e-- == 0)
      return n = r, !1;
  }), t.slice(n);
}
class Sr {
  constructor(e, n, i, r) {
    this.map = e, this.step = n, this.selection = i, this.mirrorOffset = r;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Sr(n.getMap().invert(), n, this.selection);
    }
  }
}
let Ws = class {
  constructor(e, n, i, r, s) {
    this.done = e, this.undone = n, this.prevRanges = i, this.prevTime = r, this.prevComposition = s;
  }
};
const oQ = 20;
function aQ(t, e, n, i) {
  let r = n.getMeta(ks), s;
  if (r)
    return r.historyState;
  n.getMeta(yM) && (t = new Ws(t.done, t.undone, null, 0, -1));
  let o = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (o && o.getMeta(ks))
    return o.getMeta(ks).redo ? new Ws(t.done.addTransform(n, void 0, i, Zf(e)), t.undone, sw(n.mapping.maps), t.prevTime, t.prevComposition) : new Ws(t.done, t.undone.addTransform(n, void 0, i, Zf(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = t.prevTime == 0 || !o && t.prevComposition != a && (t.prevTime < (n.time || 0) - i.newGroupDelay || !lQ(n, t.prevRanges)), c = o ? Pg(t.prevRanges, n.mapping) : sw(n.mapping.maps);
    return new Ws(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, i, Zf(e)), rr.empty, c, n.time, a ?? t.prevComposition);
  } else return (s = n.getMeta("rebased")) ? new Ws(t.done.rebased(n, s), t.undone.rebased(n, s), Pg(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new Ws(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), Pg(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function lQ(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((i, r) => {
    for (let s = 0; s < e.length; s += 2)
      i <= e[s + 1] && r >= e[s] && (n = !0);
  }), n;
}
function sw(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((i, r, s, o) => e.push(s, o));
  return e;
}
function Pg(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let i = 0; i < t.length; i += 2) {
    let r = e.map(t[i], 1), s = e.map(t[i + 1], -1);
    r <= s && n.push(r, s);
  }
  return n;
}
function cQ(t, e, n) {
  let i = Zf(e), r = ks.get(e).spec.config, s = (n ? t.undone : t.done).popEvent(e, i);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), a = (n ? t.done : t.undone).addTransform(s.transform, e.selection.getBookmark(), r, i), l = new Ws(n ? a : s.remaining, n ? s.remaining : a, null, 0, -1);
  return s.transform.setSelection(o).setMeta(ks, { redo: n, historyState: l });
}
let Rg = !1, ow = null;
function Zf(t) {
  let e = t.plugins;
  if (ow != e) {
    Rg = !1, ow = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        Rg = !0;
        break;
      }
  }
  return Rg;
}
function fve(t) {
  return t.setMeta(yM, !0);
}
const ks = new Ke("history"), yM = new Ke("closeHistory");
function uQ(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Ue({
    key: ks,
    state: {
      init() {
        return new Ws(rr.empty, rr.empty, null, 0, -1);
      },
      apply(e, n, i) {
        return aQ(n, i, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let i = n.inputType, r = i == "historyUndo" ? Rp : i == "historyRedo" ? $p : null;
          return r ? (n.preventDefault(), r(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function y0(t, e) {
  return (n, i) => {
    let r = ks.getState(n);
    if (!r || (t ? r.undone : r.done).eventCount == 0)
      return !1;
    if (i) {
      let s = cQ(r, n, t);
      s && i(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const Rp = y0(!1, !0), $p = y0(!0, !0), pve = y0(!1, !1), mve = y0(!0, !1);
function gve(t) {
  let e = ks.getState(t);
  return e ? e.done.eventCount : 0;
}
function bve(t) {
  let e = ks.getState(t);
  return e ? e.undone.eventCount : 0;
}
let Do = class {
  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number)  ?Transaction>)
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, n, i = {}) {
    this.match = e, this.match = e, this.handler = typeof n == "string" ? dQ(n) : n, this.undoable = i.undoable !== !1, this.inCode = i.inCode || !1;
  }
};
function dQ(t) {
  return function(e, n, i, r) {
    let s = t;
    if (n[1]) {
      let o = n[0].lastIndexOf(n[1]);
      s += n[0].slice(o + n[1].length), i += o;
      let a = i - r;
      a > 0 && (s = n[0].slice(o - a, o) + s, i = r);
    }
    return e.tr.insertText(s, i, r);
  };
}
const hQ = 500;
function yve({ rules: t }) {
  let e = new Ue({
    state: {
      init() {
        return null;
      },
      apply(n, i) {
        let r = n.getMeta(this);
        return r || (n.selectionSet || n.docChanged ? null : i);
      }
    },
    props: {
      handleTextInput(n, i, r, s) {
        return aw(n, i, r, s, t, e);
      },
      handleDOMEvents: {
        compositionend: (n) => {
          setTimeout(() => {
            let { $cursor: i } = n.state.selection;
            i && aw(n, i.pos, i.pos, "", t, e);
          });
        }
      }
    },
    isInputRules: !0
  });
  return e;
}
function aw(t, e, n, i, r, s) {
  if (t.composing)
    return !1;
  let o = t.state, a = o.doc.resolve(e), l = a.parent.textBetween(Math.max(0, a.parentOffset - hQ), a.parentOffset, null, "") + i;
  for (let c = 0; c < r.length; c++) {
    let u = r[c];
    if (a.parent.type.spec.code) {
      if (!u.inCode)
        continue;
    } else if (u.inCode === "only")
      continue;
    let d = u.match.exec(l), h = d && u.handler(o, d, e - (d[0].length - i.length), n);
    if (h)
      return u.undoable && h.setMeta(s, { transform: h, from: e, to: n, text: i }), t.dispatch(h), !0;
  }
  return !1;
}
const _ve = (t, e) => {
  let n = t.plugins;
  for (let i = 0; i < n.length; i++) {
    let r = n[i], s;
    if (r.spec.isInputRules && (s = r.getState(t))) {
      if (e) {
        let o = t.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l--)
          o.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          let l = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, t.schema.text(s.text, l));
        } else
          o.delete(s.from, s.to);
        e(o);
      }
      return !0;
    }
  }
  return !1;
}, vve = new Do(/--$/, ""), xve = new Do(/\.\.\.$/, ""), fQ = new Do(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, ""), pQ = new Do(/"$/, ""), mQ = new Do(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, ""), gQ = new Do(/'$/, ""), wve = [fQ, pQ, mQ, gQ];
function Sve(t, e, n = null, i) {
  return new Do(t, (r, s, o, a) => {
    let l = n instanceof Function ? n(s) : n, c = r.tr.delete(o, a), u = c.doc.resolve(o), d = u.blockRange(), h = d && d0(d, e, l);
    if (!h)
      return null;
    c.wrap(d, h);
    let f = c.doc.resolve(o - 1).nodeBefore;
    return f && f.type == e && es(c.doc, o - 1) && (!i || i(s, f)) && c.join(o - 1), c;
  });
}
function kve(t, e, n = null) {
  return new Do(t, (i, r, s, o) => {
    let a = i.doc.resolve(s), l = n instanceof Function ? n(r) : n;
    return a.node(-1).canReplaceWith(a.index(-1), a.indexAfter(-1), e) ? i.tr.delete(s, o).setBlockType(s, s, e, l) : null;
  });
}
const lw = {};
function bQ(t) {
  let e = lw[t];
  if (e)
    return e;
  e = lw[t] = [];
  for (let n = 0; n < 128; n++) {
    const i = String.fromCharCode(n);
    e.push(i);
  }
  for (let n = 0; n < t.length; n++) {
    const i = t.charCodeAt(n);
    e[i] = "%" + ("0" + i.toString(16).toUpperCase()).slice(-2);
  }
  return e;
}
function Vl(t, e) {
  typeof e != "string" && (e = Vl.defaultChars);
  const n = bQ(e);
  return t.replace(/(%[a-f0-9]{2})+/gi, function(i) {
    let r = "";
    for (let s = 0, o = i.length; s < o; s += 3) {
      const a = parseInt(i.slice(s + 1, s + 3), 16);
      if (a < 128) {
        r += n[a];
        continue;
      }
      if ((a & 224) === 192 && s + 3 < o) {
        const l = parseInt(i.slice(s + 4, s + 6), 16);
        if ((l & 192) === 128) {
          const c = a << 6 & 1984 | l & 63;
          c < 128 ? r += "" : r += String.fromCharCode(c), s += 3;
          continue;
        }
      }
      if ((a & 240) === 224 && s + 6 < o) {
        const l = parseInt(i.slice(s + 4, s + 6), 16), c = parseInt(i.slice(s + 7, s + 9), 16);
        if ((l & 192) === 128 && (c & 192) === 128) {
          const u = a << 12 & 61440 | l << 6 & 4032 | c & 63;
          u < 2048 || u >= 55296 && u <= 57343 ? r += "" : r += String.fromCharCode(u), s += 6;
          continue;
        }
      }
      if ((a & 248) === 240 && s + 9 < o) {
        const l = parseInt(i.slice(s + 4, s + 6), 16), c = parseInt(i.slice(s + 7, s + 9), 16), u = parseInt(i.slice(s + 10, s + 12), 16);
        if ((l & 192) === 128 && (c & 192) === 128 && (u & 192) === 128) {
          let d = a << 18 & 1835008 | l << 12 & 258048 | c << 6 & 4032 | u & 63;
          d < 65536 || d > 1114111 ? r += "" : (d -= 65536, r += String.fromCharCode(55296 + (d >> 10), 56320 + (d & 1023))), s += 9;
          continue;
        }
      }
      r += "";
    }
    return r;
  });
}
Vl.defaultChars = ";/?:@&=+$,#";
Vl.componentChars = "";
const cw = {};
function OQ(t) {
  let e = cw[t];
  if (e)
    return e;
  e = cw[t] = [];
  for (let n = 0; n < 128; n++) {
    const i = String.fromCharCode(n);
    /^[0-9a-z]$/i.test(i) ? e.push(i) : e.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
  }
  for (let n = 0; n < t.length; n++)
    e[t.charCodeAt(n)] = t[n];
  return e;
}
function Ud(t, e, n) {
  typeof e != "string" && (n = e, e = Ud.defaultChars), typeof n > "u" && (n = !0);
  const i = OQ(e);
  let r = "";
  for (let s = 0, o = t.length; s < o; s++) {
    const a = t.charCodeAt(s);
    if (n && a === 37 && s + 2 < o && /^[0-9a-f]{2}$/i.test(t.slice(s + 1, s + 3))) {
      r += t.slice(s, s + 3), s += 2;
      continue;
    }
    if (a < 128) {
      r += i[a];
      continue;
    }
    if (a >= 55296 && a <= 57343) {
      if (a >= 55296 && a <= 56319 && s + 1 < o) {
        const l = t.charCodeAt(s + 1);
        if (l >= 56320 && l <= 57343) {
          r += encodeURIComponent(t[s] + t[s + 1]), s++;
          continue;
        }
      }
      r += "%EF%BF%BD";
      continue;
    }
    r += encodeURIComponent(t[s]);
  }
  return r;
}
Ud.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Ud.componentChars = "-_.!~*'()";
function g2(t) {
  let e = "";
  return e += t.protocol || "", e += t.slashes ? "//" : "", e += t.auth ? t.auth + "@" : "", t.hostname && t.hostname.indexOf(":") !== -1 ? e += "[" + t.hostname + "]" : e += t.hostname || "", e += t.port ? ":" + t.port : "", e += t.pathname || "", e += t.search || "", e += t.hash || "", e;
}
function Np() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const yQ = /^([a-z0-9.+-]+:)/i, _Q = /:[0-9]*$/, vQ = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, xQ = ["<", ">", '"', "`", " ", "\r", `
`, "	"], wQ = ["{", "}", "|", "\\", "^", "`"].concat(xQ), SQ = ["'"].concat(wQ), uw = ["%", "/", "?", ";", "#"].concat(SQ), dw = ["/", "?", "#"], kQ = 255, hw = /^[+a-z0-9A-Z_-]{0,63}$/, EQ = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, fw = {
  javascript: !0,
  "javascript:": !0
}, pw = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function b2(t, e) {
  if (t && t instanceof Np) return t;
  const n = new Np();
  return n.parse(t, e), n;
}
Np.prototype.parse = function(t, e) {
  let n, i, r, s = t;
  if (s = s.trim(), !e && t.split("#").length === 1) {
    const c = vQ.exec(s);
    if (c)
      return this.pathname = c[1], c[2] && (this.search = c[2]), this;
  }
  let o = yQ.exec(s);
  if (o && (o = o[0], n = o.toLowerCase(), this.protocol = o, s = s.substr(o.length)), (e || o || s.match(/^\/\/[^@\/]+@[^@\/]+/)) && (r = s.substr(0, 2) === "//", r && !(o && fw[o]) && (s = s.substr(2), this.slashes = !0)), !fw[o] && (r || o && !pw[o])) {
    let c = -1;
    for (let p = 0; p < dw.length; p++)
      i = s.indexOf(dw[p]), i !== -1 && (c === -1 || i < c) && (c = i);
    let u, d;
    c === -1 ? d = s.lastIndexOf("@") : d = s.lastIndexOf("@", c), d !== -1 && (u = s.slice(0, d), s = s.slice(d + 1), this.auth = u), c = -1;
    for (let p = 0; p < uw.length; p++)
      i = s.indexOf(uw[p]), i !== -1 && (c === -1 || i < c) && (c = i);
    c === -1 && (c = s.length), s[c - 1] === ":" && c--;
    const h = s.slice(0, c);
    s = s.slice(c), this.parseHost(h), this.hostname = this.hostname || "";
    const f = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!f) {
      const p = this.hostname.split(/\./);
      for (let m = 0, g = p.length; m < g; m++) {
        const b = p[m];
        if (b && !b.match(hw)) {
          let _ = "";
          for (let y = 0, O = b.length; y < O; y++)
            b.charCodeAt(y) > 127 ? _ += "x" : _ += b[y];
          if (!_.match(hw)) {
            const y = p.slice(0, m), O = p.slice(m + 1), x = b.match(EQ);
            x && (y.push(x[1]), O.unshift(x[2])), O.length && (s = O.join(".") + s), this.hostname = y.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > kQ && (this.hostname = ""), f && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const a = s.indexOf("#");
  a !== -1 && (this.hash = s.substr(a), s = s.slice(0, a));
  const l = s.indexOf("?");
  return l !== -1 && (this.search = s.substr(l), s = s.slice(0, l)), s && (this.pathname = s), pw[n] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Np.prototype.parseHost = function(t) {
  let e = _Q.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
const CQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Vl,
  encode: Ud,
  format: g2,
  parse: b2
}, Symbol.toStringTag, { value: "Module" })), _M = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, vM = /[\0-\x1F\x7F-\x9F]/, AQ = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, O2 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, xM = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, wM = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, TQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any: _M,
  Cc: vM,
  Cf: AQ,
  P: O2,
  S: xM,
  Z: wM
}, Symbol.toStringTag, { value: "Module" })), MQ = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((t) => t.charCodeAt(0))
), PQ = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((t) => t.charCodeAt(0))
);
var $g;
const RQ = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), $Q = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  ($g = String.fromCodePoint) !== null && $g !== void 0 ? $g : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function NQ(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = RQ.get(t)) !== null && e !== void 0 ? e : t;
}
var rn;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(rn || (rn = {}));
const DQ = 32;
var ro;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(ro || (ro = {}));
function jb(t) {
  return t >= rn.ZERO && t <= rn.NINE;
}
function IQ(t) {
  return t >= rn.UPPER_A && t <= rn.UPPER_F || t >= rn.LOWER_A && t <= rn.LOWER_F;
}
function LQ(t) {
  return t >= rn.UPPER_A && t <= rn.UPPER_Z || t >= rn.LOWER_A && t <= rn.LOWER_Z || jb(t);
}
function BQ(t) {
  return t === rn.EQUALS || LQ(t);
}
var Kt;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(Kt || (Kt = {}));
var Ys;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(Ys || (Ys = {}));
class QQ {
  constructor(e, n, i) {
    this.decodeTree = e, this.emitCodePoint = n, this.errors = i, this.state = Kt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Ys.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = Kt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, n) {
    switch (this.state) {
      case Kt.EntityStart:
        return e.charCodeAt(n) === rn.NUM ? (this.state = Kt.NumericStart, this.consumed += 1, this.stateNumericStart(e, n + 1)) : (this.state = Kt.NamedEntity, this.stateNamedEntity(e, n));
      case Kt.NumericStart:
        return this.stateNumericStart(e, n);
      case Kt.NumericDecimal:
        return this.stateNumericDecimal(e, n);
      case Kt.NumericHex:
        return this.stateNumericHex(e, n);
      case Kt.NamedEntity:
        return this.stateNamedEntity(e, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, n) {
    return n >= e.length ? -1 : (e.charCodeAt(n) | DQ) === rn.LOWER_X ? (this.state = Kt.NumericHex, this.consumed += 1, this.stateNumericHex(e, n + 1)) : (this.state = Kt.NumericDecimal, this.stateNumericDecimal(e, n));
  }
  addToNumericResult(e, n, i, r) {
    if (n !== i) {
      const s = i - n;
      this.result = this.result * Math.pow(r, s) + parseInt(e.substr(n, s), r), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, n) {
    const i = n;
    for (; n < e.length; ) {
      const r = e.charCodeAt(n);
      if (jb(r) || IQ(r))
        n += 1;
      else
        return this.addToNumericResult(e, i, n, 16), this.emitNumericEntity(r, 3);
    }
    return this.addToNumericResult(e, i, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, n) {
    const i = n;
    for (; n < e.length; ) {
      const r = e.charCodeAt(n);
      if (jb(r))
        n += 1;
      else
        return this.addToNumericResult(e, i, n, 10), this.emitNumericEntity(r, 2);
    }
    return this.addToNumericResult(e, i, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, n) {
    var i;
    if (this.consumed <= n)
      return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === rn.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Ys.Strict)
      return 0;
    return this.emitCodePoint(NQ(this.result), this.consumed), this.errors && (e !== rn.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, n) {
    const { decodeTree: i } = this;
    let r = i[this.treeIndex], s = (r & ro.VALUE_LENGTH) >> 14;
    for (; n < e.length; n++, this.excess++) {
      const o = e.charCodeAt(n);
      if (this.treeIndex = FQ(i, r, this.treeIndex + Math.max(1, s), o), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Ys.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        BQ(o)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (r = i[this.treeIndex], s = (r & ro.VALUE_LENGTH) >> 14, s !== 0) {
        if (o === rn.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== Ys.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: n, decodeTree: i } = this, r = (i[n] & ro.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, r, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, n, i) {
    const { decodeTree: r } = this;
    return this.emitCodePoint(n === 1 ? r[e] & ~ro.VALUE_LENGTH : r[e + 1], i), n === 3 && this.emitCodePoint(r[e + 2], i), i;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case Kt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Ys.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case Kt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Kt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Kt.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Kt.EntityStart:
        return 0;
    }
  }
}
function SM(t) {
  let e = "";
  const n = new QQ(t, (i) => e += $Q(i));
  return function(r, s) {
    let o = 0, a = 0;
    for (; (a = r.indexOf("&", a)) >= 0; ) {
      e += r.slice(o, a), n.startEntity(s);
      const c = n.write(
        r,
        // Skip the "&"
        a + 1
      );
      if (c < 0) {
        o = a + n.end();
        break;
      }
      o = a + c, a = c === 0 ? o + 1 : o;
    }
    const l = e + r.slice(o);
    return e = "", l;
  };
}
function FQ(t, e, n, i) {
  const r = (e & ro.BRANCH_LENGTH) >> 7, s = e & ro.JUMP_TABLE;
  if (r === 0)
    return s !== 0 && i === s ? n : -1;
  if (s) {
    const l = i - s;
    return l < 0 || l >= r ? -1 : t[n + l] - 1;
  }
  let o = n, a = o + r - 1;
  for (; o <= a; ) {
    const l = o + a >>> 1, c = t[l];
    if (c < i)
      o = l + 1;
    else if (c > i)
      a = l - 1;
    else
      return t[l + r];
  }
  return -1;
}
const zQ = SM(MQ);
SM(PQ);
function kM(t, e = Ys.Legacy) {
  return zQ(t, e);
}
function UQ(t) {
  return Object.prototype.toString.call(t);
}
function y2(t) {
  return UQ(t) === "[object String]";
}
const WQ = Object.prototype.hasOwnProperty;
function VQ(t, e) {
  return WQ.call(t, e);
}
function _0(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be object");
      Object.keys(n).forEach(function(i) {
        t[i] = n[i];
      });
    }
  }), t;
}
function EM(t, e, n) {
  return [].concat(t.slice(0, e), n, t.slice(e + 1));
}
function _2(t) {
  return !(t >= 55296 && t <= 57343 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534 || t >= 0 && t <= 8 || t === 11 || t >= 14 && t <= 31 || t >= 127 && t <= 159 || t > 1114111);
}
function Dp(t) {
  if (t > 65535) {
    t -= 65536;
    const e = 55296 + (t >> 10), n = 56320 + (t & 1023);
    return String.fromCharCode(e, n);
  }
  return String.fromCharCode(t);
}
const CM = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, ZQ = /&([a-z#][a-z0-9]{1,31});/gi, HQ = new RegExp(CM.source + "|" + ZQ.source, "gi"), qQ = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function XQ(t, e) {
  if (e.charCodeAt(0) === 35 && qQ.test(e)) {
    const i = e[1].toLowerCase() === "x" ? parseInt(e.slice(2), 16) : parseInt(e.slice(1), 10);
    return _2(i) ? Dp(i) : t;
  }
  const n = kM(t);
  return n !== t ? n : t;
}
function jQ(t) {
  return t.indexOf("\\") < 0 ? t : t.replace(CM, "$1");
}
function Zl(t) {
  return t.indexOf("\\") < 0 && t.indexOf("&") < 0 ? t : t.replace(HQ, function(e, n, i) {
    return n || XQ(e, i);
  });
}
const YQ = /[&<>"]/, GQ = /[&<>"]/g, KQ = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function JQ(t) {
  return KQ[t];
}
function ko(t) {
  return YQ.test(t) ? t.replace(GQ, JQ) : t;
}
const eF = /[.?*+^$[\]\\(){}|-]/g;
function tF(t) {
  return t.replace(eF, "\\$&");
}
function xt(t) {
  switch (t) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function qu(t) {
  if (t >= 8192 && t <= 8202)
    return !0;
  switch (t) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function Xu(t) {
  return O2.test(t) || xM.test(t);
}
function ju(t) {
  switch (t) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function v0(t) {
  return t = t.trim().replace(/\s+/g, " "), "".toLowerCase() === "" && (t = t.replace(//g, "")), t.toLowerCase().toUpperCase();
}
const nF = { mdurl: CQ, ucmicro: TQ }, iF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: EM,
  assign: _0,
  escapeHtml: ko,
  escapeRE: tF,
  fromCodePoint: Dp,
  has: VQ,
  isMdAsciiPunct: ju,
  isPunctChar: Xu,
  isSpace: xt,
  isString: y2,
  isValidEntityCode: _2,
  isWhiteSpace: qu,
  lib: nF,
  normalizeReference: v0,
  unescapeAll: Zl,
  unescapeMd: jQ
}, Symbol.toStringTag, { value: "Module" }));
function rF(t, e, n) {
  let i, r, s, o;
  const a = t.posMax, l = t.pos;
  for (t.pos = e + 1, i = 1; t.pos < a; ) {
    if (s = t.src.charCodeAt(t.pos), s === 93 && (i--, i === 0)) {
      r = !0;
      break;
    }
    if (o = t.pos, t.md.inline.skipToken(t), s === 91) {
      if (o === t.pos - 1)
        i++;
      else if (n)
        return t.pos = l, -1;
    }
  }
  let c = -1;
  return r && (c = t.pos), t.pos = l, c;
}
function sF(t, e, n) {
  let i, r = e;
  const s = {
    ok: !1,
    pos: 0,
    str: ""
  };
  if (t.charCodeAt(r) === 60) {
    for (r++; r < n; ) {
      if (i = t.charCodeAt(r), i === 10 || i === 60)
        return s;
      if (i === 62)
        return s.pos = r + 1, s.str = Zl(t.slice(e + 1, r)), s.ok = !0, s;
      if (i === 92 && r + 1 < n) {
        r += 2;
        continue;
      }
      r++;
    }
    return s;
  }
  let o = 0;
  for (; r < n && (i = t.charCodeAt(r), !(i === 32 || i < 32 || i === 127)); ) {
    if (i === 92 && r + 1 < n) {
      if (t.charCodeAt(r + 1) === 32)
        break;
      r += 2;
      continue;
    }
    if (i === 40 && (o++, o > 32))
      return s;
    if (i === 41) {
      if (o === 0)
        break;
      o--;
    }
    r++;
  }
  return e === r || o !== 0 || (s.str = Zl(t.slice(e, r)), s.pos = r, s.ok = !0), s;
}
function oF(t, e, n, i) {
  let r, s = e;
  const o = {
    // if `true`, this is a valid link title
    ok: !1,
    // if `true`, this link can be continued on the next line
    can_continue: !1,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (i)
    o.str = i.str, o.marker = i.marker;
  else {
    if (s >= n)
      return o;
    let a = t.charCodeAt(s);
    if (a !== 34 && a !== 39 && a !== 40)
      return o;
    e++, s++, a === 40 && (a = 41), o.marker = a;
  }
  for (; s < n; ) {
    if (r = t.charCodeAt(s), r === o.marker)
      return o.pos = s + 1, o.str += Zl(t.slice(e, s)), o.ok = !0, o;
    if (r === 40 && o.marker === 41)
      return o;
    r === 92 && s + 1 < n && s++, s++;
  }
  return o.can_continue = !0, o.str += Zl(t.slice(e, s)), o;
}
const aF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination: sF,
  parseLinkLabel: rF,
  parseLinkTitle: oF
}, Symbol.toStringTag, { value: "Module" })), ts = {};
ts.code_inline = function(t, e, n, i, r) {
  const s = t[e];
  return "<code" + r.renderAttrs(s) + ">" + ko(s.content) + "</code>";
};
ts.code_block = function(t, e, n, i, r) {
  const s = t[e];
  return "<pre" + r.renderAttrs(s) + "><code>" + ko(t[e].content) + `</code></pre>
`;
};
ts.fence = function(t, e, n, i, r) {
  const s = t[e], o = s.info ? Zl(s.info).trim() : "";
  let a = "", l = "";
  if (o) {
    const u = o.split(/(\s+)/g);
    a = u[0], l = u.slice(2).join("");
  }
  let c;
  if (n.highlight ? c = n.highlight(s.content, a, l) || ko(s.content) : c = ko(s.content), c.indexOf("<pre") === 0)
    return c + `
`;
  if (o) {
    const u = s.attrIndex("class"), d = s.attrs ? s.attrs.slice() : [];
    u < 0 ? d.push(["class", n.langPrefix + a]) : (d[u] = d[u].slice(), d[u][1] += " " + n.langPrefix + a);
    const h = {
      attrs: d
    };
    return `<pre><code${r.renderAttrs(h)}>${c}</code></pre>
`;
  }
  return `<pre><code${r.renderAttrs(s)}>${c}</code></pre>
`;
};
ts.image = function(t, e, n, i, r) {
  const s = t[e];
  return s.attrs[s.attrIndex("alt")][1] = r.renderInlineAsText(s.children, n, i), r.renderToken(t, e, n);
};
ts.hardbreak = function(t, e, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
ts.softbreak = function(t, e, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ts.text = function(t, e) {
  return ko(t[e].content);
};
ts.html_block = function(t, e) {
  return t[e].content;
};
ts.html_inline = function(t, e) {
  return t[e].content;
};
function mc() {
  this.rules = _0({}, ts);
}
mc.prototype.renderAttrs = function(e) {
  let n, i, r;
  if (!e.attrs)
    return "";
  for (r = "", n = 0, i = e.attrs.length; n < i; n++)
    r += " " + ko(e.attrs[n][0]) + '="' + ko(e.attrs[n][1]) + '"';
  return r;
};
mc.prototype.renderToken = function(e, n, i) {
  const r = e[n];
  let s = "";
  if (r.hidden)
    return "";
  r.block && r.nesting !== -1 && n && e[n - 1].hidden && (s += `
`), s += (r.nesting === -1 ? "</" : "<") + r.tag, s += this.renderAttrs(r), r.nesting === 0 && i.xhtmlOut && (s += " /");
  let o = !1;
  if (r.block && (o = !0, r.nesting === 1 && n + 1 < e.length)) {
    const a = e[n + 1];
    (a.type === "inline" || a.hidden || a.nesting === -1 && a.tag === r.tag) && (o = !1);
  }
  return s += o ? `>
` : ">", s;
};
mc.prototype.renderInline = function(t, e, n) {
  let i = "";
  const r = this.rules;
  for (let s = 0, o = t.length; s < o; s++) {
    const a = t[s].type;
    typeof r[a] < "u" ? i += r[a](t, s, e, n, this) : i += this.renderToken(t, s, e);
  }
  return i;
};
mc.prototype.renderInlineAsText = function(t, e, n) {
  let i = "";
  for (let r = 0, s = t.length; r < s; r++)
    switch (t[r].type) {
      case "text":
        i += t[r].content;
        break;
      case "image":
        i += this.renderInlineAsText(t[r].children, e, n);
        break;
      case "html_inline":
      case "html_block":
        i += t[r].content;
        break;
      case "softbreak":
      case "hardbreak":
        i += `
`;
        break;
    }
  return i;
};
mc.prototype.render = function(t, e, n) {
  let i = "";
  const r = this.rules;
  for (let s = 0, o = t.length; s < o; s++) {
    const a = t[s].type;
    a === "inline" ? i += this.renderInline(t[s].children, e, n) : typeof r[a] < "u" ? i += r[a](t, s, e, n, this) : i += this.renderToken(t, s, e, n);
  }
  return i;
};
function ui() {
  this.__rules__ = [], this.__cache__ = null;
}
ui.prototype.__find__ = function(t) {
  for (let e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t)
      return e;
  return -1;
};
ui.prototype.__compile__ = function() {
  const t = this, e = [""];
  t.__rules__.forEach(function(n) {
    n.enabled && n.alt.forEach(function(i) {
      e.indexOf(i) < 0 && e.push(i);
    });
  }), t.__cache__ = {}, e.forEach(function(n) {
    t.__cache__[n] = [], t.__rules__.forEach(function(i) {
      i.enabled && (n && i.alt.indexOf(n) < 0 || t.__cache__[n].push(i.fn));
    });
  });
};
ui.prototype.at = function(t, e, n) {
  const i = this.__find__(t), r = n || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__[i].fn = e, this.__rules__[i].alt = r.alt || [], this.__cache__ = null;
};
ui.prototype.before = function(t, e, n, i) {
  const r = this.__find__(t), s = i || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(r, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
ui.prototype.after = function(t, e, n, i) {
  const r = this.__find__(t), s = i || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(r + 1, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
ui.prototype.push = function(t, e, n) {
  const i = n || {};
  this.__rules__.push({
    name: t,
    enabled: !0,
    fn: e,
    alt: i.alt || []
  }), this.__cache__ = null;
};
ui.prototype.enable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const n = [];
  return t.forEach(function(i) {
    const r = this.__find__(i);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + i);
    }
    this.__rules__[r].enabled = !0, n.push(i);
  }, this), this.__cache__ = null, n;
};
ui.prototype.enableOnly = function(t, e) {
  Array.isArray(t) || (t = [t]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(t, e);
};
ui.prototype.disable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  const n = [];
  return t.forEach(function(i) {
    const r = this.__find__(i);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + i);
    }
    this.__rules__[r].enabled = !1, n.push(i);
  }, this), this.__cache__ = null, n;
};
ui.prototype.getRules = function(t) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [];
};
function pr(t, e, n) {
  this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
pr.prototype.attrIndex = function(e) {
  if (!this.attrs)
    return -1;
  const n = this.attrs;
  for (let i = 0, r = n.length; i < r; i++)
    if (n[i][0] === e)
      return i;
  return -1;
};
pr.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
pr.prototype.attrSet = function(e, n) {
  const i = this.attrIndex(e), r = [e, n];
  i < 0 ? this.attrPush(r) : this.attrs[i] = r;
};
pr.prototype.attrGet = function(e) {
  const n = this.attrIndex(e);
  let i = null;
  return n >= 0 && (i = this.attrs[n][1]), i;
};
pr.prototype.attrJoin = function(e, n) {
  const i = this.attrIndex(e);
  i < 0 ? this.attrPush([e, n]) : this.attrs[i][1] = this.attrs[i][1] + " " + n;
};
function AM(t, e, n) {
  this.src = t, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = e;
}
AM.prototype.Token = pr;
const lF = /\r\n?|\n/g, cF = /\0/g;
function uF(t) {
  let e;
  e = t.src.replace(lF, `
`), e = e.replace(cF, ""), t.src = e;
}
function dF(t) {
  let e;
  t.inlineMode ? (e = new t.Token("inline", "", 0), e.content = t.src, e.map = [0, 1], e.children = [], t.tokens.push(e)) : t.md.block.parse(t.src, t.md, t.env, t.tokens);
}
function hF(t) {
  const e = t.tokens;
  for (let n = 0, i = e.length; n < i; n++) {
    const r = e[n];
    r.type === "inline" && t.md.inline.parse(r.content, t.md, t.env, r.children);
  }
}
function fF(t) {
  return /^<a[>\s]/i.test(t);
}
function pF(t) {
  return /^<\/a\s*>/i.test(t);
}
function mF(t) {
  const e = t.tokens;
  if (t.md.options.linkify)
    for (let n = 0, i = e.length; n < i; n++) {
      if (e[n].type !== "inline" || !t.md.linkify.pretest(e[n].content))
        continue;
      let r = e[n].children, s = 0;
      for (let o = r.length - 1; o >= 0; o--) {
        const a = r[o];
        if (a.type === "link_close") {
          for (o--; r[o].level !== a.level && r[o].type !== "link_open"; )
            o--;
          continue;
        }
        if (a.type === "html_inline" && (fF(a.content) && s > 0 && s--, pF(a.content) && s++), !(s > 0) && a.type === "text" && t.md.linkify.test(a.content)) {
          const l = a.content;
          let c = t.md.linkify.match(l);
          const u = [];
          let d = a.level, h = 0;
          c.length > 0 && c[0].index === 0 && o > 0 && r[o - 1].type === "text_special" && (c = c.slice(1));
          for (let f = 0; f < c.length; f++) {
            const p = c[f].url, m = t.md.normalizeLink(p);
            if (!t.md.validateLink(m))
              continue;
            let g = c[f].text;
            c[f].schema ? c[f].schema === "mailto:" && !/^mailto:/i.test(g) ? g = t.md.normalizeLinkText("mailto:" + g).replace(/^mailto:/, "") : g = t.md.normalizeLinkText(g) : g = t.md.normalizeLinkText("http://" + g).replace(/^http:\/\//, "");
            const b = c[f].index;
            if (b > h) {
              const x = new t.Token("text", "", 0);
              x.content = l.slice(h, b), x.level = d, u.push(x);
            }
            const _ = new t.Token("link_open", "a", 1);
            _.attrs = [["href", m]], _.level = d++, _.markup = "linkify", _.info = "auto", u.push(_);
            const y = new t.Token("text", "", 0);
            y.content = g, y.level = d, u.push(y);
            const O = new t.Token("link_close", "a", -1);
            O.level = --d, O.markup = "linkify", O.info = "auto", u.push(O), h = c[f].lastIndex;
          }
          if (h < l.length) {
            const f = new t.Token("text", "", 0);
            f.content = l.slice(h), f.level = d, u.push(f);
          }
          e[n].children = r = EM(r, o, u);
        }
      }
    }
}
const TM = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, gF = /\((c|tm|r)\)/i, bF = /\((c|tm|r)\)/ig, OF = {
  c: "",
  r: "",
  tm: ""
};
function yF(t, e) {
  return OF[e.toLowerCase()];
}
function _F(t) {
  let e = 0;
  for (let n = t.length - 1; n >= 0; n--) {
    const i = t[n];
    i.type === "text" && !e && (i.content = i.content.replace(bF, yF)), i.type === "link_open" && i.info === "auto" && e--, i.type === "link_close" && i.info === "auto" && e++;
  }
}
function vF(t) {
  let e = 0;
  for (let n = t.length - 1; n >= 0; n--) {
    const i = t[n];
    i.type === "text" && !e && TM.test(i.content) && (i.content = i.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1").replace(/(^|\s)--(?=\s|$)/mg, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1")), i.type === "link_open" && i.info === "auto" && e--, i.type === "link_close" && i.info === "auto" && e++;
  }
}
function xF(t) {
  let e;
  if (t.md.options.typographer)
    for (e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type === "inline" && (gF.test(t.tokens[e].content) && _F(t.tokens[e].children), TM.test(t.tokens[e].content) && vF(t.tokens[e].children));
}
const wF = /['"]/, mw = /['"]/g, gw = "";
function Ph(t, e, n) {
  return t.slice(0, e) + n + t.slice(e + 1);
}
function SF(t, e) {
  let n;
  const i = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r], o = t[r].level;
    for (n = i.length - 1; n >= 0 && !(i[n].level <= o); n--)
      ;
    if (i.length = n + 1, s.type !== "text")
      continue;
    let a = s.content, l = 0, c = a.length;
    e:
      for (; l < c; ) {
        mw.lastIndex = l;
        const u = mw.exec(a);
        if (!u)
          break;
        let d = !0, h = !0;
        l = u.index + 1;
        const f = u[0] === "'";
        let p = 32;
        if (u.index - 1 >= 0)
          p = a.charCodeAt(u.index - 1);
        else
          for (n = r - 1; n >= 0 && !(t[n].type === "softbreak" || t[n].type === "hardbreak"); n--)
            if (t[n].content) {
              p = t[n].content.charCodeAt(t[n].content.length - 1);
              break;
            }
        let m = 32;
        if (l < c)
          m = a.charCodeAt(l);
        else
          for (n = r + 1; n < t.length && !(t[n].type === "softbreak" || t[n].type === "hardbreak"); n++)
            if (t[n].content) {
              m = t[n].content.charCodeAt(0);
              break;
            }
        const g = ju(p) || Xu(String.fromCharCode(p)), b = ju(m) || Xu(String.fromCharCode(m)), _ = qu(p), y = qu(m);
        if (y ? d = !1 : b && (_ || g || (d = !1)), _ ? h = !1 : g && (y || b || (h = !1)), m === 34 && u[0] === '"' && p >= 48 && p <= 57 && (h = d = !1), d && h && (d = g, h = b), !d && !h) {
          f && (s.content = Ph(s.content, u.index, gw));
          continue;
        }
        if (h)
          for (n = i.length - 1; n >= 0; n--) {
            let O = i[n];
            if (i[n].level < o)
              break;
            if (O.single === f && i[n].level === o) {
              O = i[n];
              let x, v;
              f ? (x = e.md.options.quotes[2], v = e.md.options.quotes[3]) : (x = e.md.options.quotes[0], v = e.md.options.quotes[1]), s.content = Ph(s.content, u.index, v), t[O.token].content = Ph(
                t[O.token].content,
                O.pos,
                x
              ), l += v.length - 1, O.token === r && (l += x.length - 1), a = s.content, c = a.length, i.length = n;
              continue e;
            }
          }
        d ? i.push({
          token: r,
          pos: u.index,
          single: f,
          level: o
        }) : h && f && (s.content = Ph(s.content, u.index, gw));
      }
  }
}
function kF(t) {
  if (t.md.options.typographer)
    for (let e = t.tokens.length - 1; e >= 0; e--)
      t.tokens[e].type !== "inline" || !wF.test(t.tokens[e].content) || SF(t.tokens[e].children, t);
}
function EF(t) {
  let e, n;
  const i = t.tokens, r = i.length;
  for (let s = 0; s < r; s++) {
    if (i[s].type !== "inline") continue;
    const o = i[s].children, a = o.length;
    for (e = 0; e < a; e++)
      o[e].type === "text_special" && (o[e].type = "text");
    for (e = n = 0; e < a; e++)
      o[e].type === "text" && e + 1 < a && o[e + 1].type === "text" ? o[e + 1].content = o[e].content + o[e + 1].content : (e !== n && (o[n] = o[e]), n++);
    e !== n && (o.length = n);
  }
}
const Ng = [
  ["normalize", uF],
  ["block", dF],
  ["inline", hF],
  ["linkify", mF],
  ["replacements", xF],
  ["smartquotes", kF],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", EF]
];
function v2() {
  this.ruler = new ui();
  for (let t = 0; t < Ng.length; t++)
    this.ruler.push(Ng[t][0], Ng[t][1]);
}
v2.prototype.process = function(t) {
  const e = this.ruler.getRules("");
  for (let n = 0, i = e.length; n < i; n++)
    e[n](t);
};
v2.prototype.State = AM;
function ns(t, e, n, i) {
  this.src = t, this.md = e, this.env = n, this.tokens = i, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const r = this.src;
  for (let s = 0, o = 0, a = 0, l = 0, c = r.length, u = !1; o < c; o++) {
    const d = r.charCodeAt(o);
    if (!u)
      if (xt(d)) {
        a++, d === 9 ? l += 4 - l % 4 : l++;
        continue;
      } else
        u = !0;
    (d === 10 || o === c - 1) && (d !== 10 && o++, this.bMarks.push(s), this.eMarks.push(o), this.tShift.push(a), this.sCount.push(l), this.bsCount.push(0), u = !1, a = 0, l = 0, s = o + 1);
  }
  this.bMarks.push(r.length), this.eMarks.push(r.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
ns.prototype.push = function(t, e, n) {
  const i = new pr(t, e, n);
  return i.block = !0, n < 0 && this.level--, i.level = this.level, n > 0 && this.level++, this.tokens.push(i), i;
};
ns.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
ns.prototype.skipEmptyLines = function(e) {
  for (let n = this.lineMax; e < n && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
ns.prototype.skipSpaces = function(e) {
  for (let n = this.src.length; e < n; e++) {
    const i = this.src.charCodeAt(e);
    if (!xt(i))
      break;
  }
  return e;
};
ns.prototype.skipSpacesBack = function(e, n) {
  if (e <= n)
    return e;
  for (; e > n; )
    if (!xt(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
ns.prototype.skipChars = function(e, n) {
  for (let i = this.src.length; e < i && this.src.charCodeAt(e) === n; e++)
    ;
  return e;
};
ns.prototype.skipCharsBack = function(e, n, i) {
  if (e <= i)
    return e;
  for (; e > i; )
    if (n !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
ns.prototype.getLines = function(e, n, i, r) {
  if (e >= n)
    return "";
  const s = new Array(n - e);
  for (let o = 0, a = e; a < n; a++, o++) {
    let l = 0;
    const c = this.bMarks[a];
    let u = c, d;
    for (a + 1 < n || r ? d = this.eMarks[a] + 1 : d = this.eMarks[a]; u < d && l < i; ) {
      const h = this.src.charCodeAt(u);
      if (xt(h))
        h === 9 ? l += 4 - (l + this.bsCount[a]) % 4 : l++;
      else if (u - c < this.tShift[a])
        l++;
      else
        break;
      u++;
    }
    l > i ? s[o] = new Array(l - i + 1).join(" ") + this.src.slice(u, d) : s[o] = this.src.slice(u, d);
  }
  return s.join("");
};
ns.prototype.Token = pr;
const CF = 65536;
function Dg(t, e) {
  const n = t.bMarks[e] + t.tShift[e], i = t.eMarks[e];
  return t.src.slice(n, i);
}
function bw(t) {
  const e = [], n = t.length;
  let i = 0, r = t.charCodeAt(i), s = !1, o = 0, a = "";
  for (; i < n; )
    r === 124 && (s ? (a += t.substring(o, i - 1), o = i) : (e.push(a + t.substring(o, i)), a = "", o = i + 1)), s = r === 92, i++, r = t.charCodeAt(i);
  return e.push(a + t.substring(o)), e;
}
function AF(t, e, n, i) {
  if (e + 2 > n)
    return !1;
  let r = e + 1;
  if (t.sCount[r] < t.blkIndent || t.sCount[r] - t.blkIndent >= 4)
    return !1;
  let s = t.bMarks[r] + t.tShift[r];
  if (s >= t.eMarks[r])
    return !1;
  const o = t.src.charCodeAt(s++);
  if (o !== 124 && o !== 45 && o !== 58 || s >= t.eMarks[r])
    return !1;
  const a = t.src.charCodeAt(s++);
  if (a !== 124 && a !== 45 && a !== 58 && !xt(a) || o === 45 && xt(a))
    return !1;
  for (; s < t.eMarks[r]; ) {
    const O = t.src.charCodeAt(s);
    if (O !== 124 && O !== 45 && O !== 58 && !xt(O))
      return !1;
    s++;
  }
  let l = Dg(t, e + 1), c = l.split("|");
  const u = [];
  for (let O = 0; O < c.length; O++) {
    const x = c[O].trim();
    if (!x) {
      if (O === 0 || O === c.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(x))
      return !1;
    x.charCodeAt(x.length - 1) === 58 ? u.push(x.charCodeAt(0) === 58 ? "center" : "right") : x.charCodeAt(0) === 58 ? u.push("left") : u.push("");
  }
  if (l = Dg(t, e).trim(), l.indexOf("|") === -1 || t.sCount[e] - t.blkIndent >= 4)
    return !1;
  c = bw(l), c.length && c[0] === "" && c.shift(), c.length && c[c.length - 1] === "" && c.pop();
  const d = c.length;
  if (d === 0 || d !== u.length)
    return !1;
  if (i)
    return !0;
  const h = t.parentType;
  t.parentType = "table";
  const f = t.md.block.ruler.getRules("blockquote"), p = t.push("table_open", "table", 1), m = [e, 0];
  p.map = m;
  const g = t.push("thead_open", "thead", 1);
  g.map = [e, e + 1];
  const b = t.push("tr_open", "tr", 1);
  b.map = [e, e + 1];
  for (let O = 0; O < c.length; O++) {
    const x = t.push("th_open", "th", 1);
    u[O] && (x.attrs = [["style", "text-align:" + u[O]]]);
    const v = t.push("inline", "", 0);
    v.content = c[O].trim(), v.children = [], t.push("th_close", "th", -1);
  }
  t.push("tr_close", "tr", -1), t.push("thead_close", "thead", -1);
  let _, y = 0;
  for (r = e + 2; r < n && !(t.sCount[r] < t.blkIndent); r++) {
    let O = !1;
    for (let v = 0, w = f.length; v < w; v++)
      if (f[v](t, r, n, !0)) {
        O = !0;
        break;
      }
    if (O || (l = Dg(t, r).trim(), !l) || t.sCount[r] - t.blkIndent >= 4 || (c = bw(l), c.length && c[0] === "" && c.shift(), c.length && c[c.length - 1] === "" && c.pop(), y += d - c.length, y > CF))
      break;
    if (r === e + 2) {
      const v = t.push("tbody_open", "tbody", 1);
      v.map = _ = [e + 2, 0];
    }
    const x = t.push("tr_open", "tr", 1);
    x.map = [r, r + 1];
    for (let v = 0; v < d; v++) {
      const w = t.push("td_open", "td", 1);
      u[v] && (w.attrs = [["style", "text-align:" + u[v]]]);
      const T = t.push("inline", "", 0);
      T.content = c[v] ? c[v].trim() : "", T.children = [], t.push("td_close", "td", -1);
    }
    t.push("tr_close", "tr", -1);
  }
  return _ && (t.push("tbody_close", "tbody", -1), _[1] = r), t.push("table_close", "table", -1), m[1] = r, t.parentType = h, t.line = r, !0;
}
function TF(t, e, n) {
  if (t.sCount[e] - t.blkIndent < 4)
    return !1;
  let i = e + 1, r = i;
  for (; i < n; ) {
    if (t.isEmpty(i)) {
      i++;
      continue;
    }
    if (t.sCount[i] - t.blkIndent >= 4) {
      i++, r = i;
      continue;
    }
    break;
  }
  t.line = r;
  const s = t.push("code_block", "code", 0);
  return s.content = t.getLines(e, r, 4 + t.blkIndent, !1) + `
`, s.map = [e, t.line], !0;
}
function MF(t, e, n, i) {
  let r = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || r + 3 > s)
    return !1;
  const o = t.src.charCodeAt(r);
  if (o !== 126 && o !== 96)
    return !1;
  let a = r;
  r = t.skipChars(r, o);
  let l = r - a;
  if (l < 3)
    return !1;
  const c = t.src.slice(a, r), u = t.src.slice(r, s);
  if (o === 96 && u.indexOf(String.fromCharCode(o)) >= 0)
    return !1;
  if (i)
    return !0;
  let d = e, h = !1;
  for (; d++, !(d >= n || (r = a = t.bMarks[d] + t.tShift[d], s = t.eMarks[d], r < s && t.sCount[d] < t.blkIndent)); )
    if (t.src.charCodeAt(r) === o && !(t.sCount[d] - t.blkIndent >= 4) && (r = t.skipChars(r, o), !(r - a < l) && (r = t.skipSpaces(r), !(r < s)))) {
      h = !0;
      break;
    }
  l = t.sCount[e], t.line = d + (h ? 1 : 0);
  const f = t.push("fence", "code", 0);
  return f.info = u, f.content = t.getLines(e + 1, d, l, !0), f.markup = c, f.map = [e, t.line], !0;
}
function PF(t, e, n, i) {
  let r = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  const o = t.lineMax;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(r) !== 62)
    return !1;
  if (i)
    return !0;
  const a = [], l = [], c = [], u = [], d = t.md.block.ruler.getRules("blockquote"), h = t.parentType;
  t.parentType = "blockquote";
  let f = !1, p;
  for (p = e; p < n; p++) {
    const y = t.sCount[p] < t.blkIndent;
    if (r = t.bMarks[p] + t.tShift[p], s = t.eMarks[p], r >= s)
      break;
    if (t.src.charCodeAt(r++) === 62 && !y) {
      let x = t.sCount[p] + 1, v, w;
      t.src.charCodeAt(r) === 32 ? (r++, x++, w = !1, v = !0) : t.src.charCodeAt(r) === 9 ? (v = !0, (t.bsCount[p] + x) % 4 === 3 ? (r++, x++, w = !1) : w = !0) : v = !1;
      let T = x;
      for (a.push(t.bMarks[p]), t.bMarks[p] = r; r < s; ) {
        const S = t.src.charCodeAt(r);
        if (xt(S))
          S === 9 ? T += 4 - (T + t.bsCount[p] + (w ? 1 : 0)) % 4 : T++;
        else
          break;
        r++;
      }
      f = r >= s, l.push(t.bsCount[p]), t.bsCount[p] = t.sCount[p] + 1 + (v ? 1 : 0), c.push(t.sCount[p]), t.sCount[p] = T - x, u.push(t.tShift[p]), t.tShift[p] = r - t.bMarks[p];
      continue;
    }
    if (f)
      break;
    let O = !1;
    for (let x = 0, v = d.length; x < v; x++)
      if (d[x](t, p, n, !0)) {
        O = !0;
        break;
      }
    if (O) {
      t.lineMax = p, t.blkIndent !== 0 && (a.push(t.bMarks[p]), l.push(t.bsCount[p]), u.push(t.tShift[p]), c.push(t.sCount[p]), t.sCount[p] -= t.blkIndent);
      break;
    }
    a.push(t.bMarks[p]), l.push(t.bsCount[p]), u.push(t.tShift[p]), c.push(t.sCount[p]), t.sCount[p] = -1;
  }
  const m = t.blkIndent;
  t.blkIndent = 0;
  const g = t.push("blockquote_open", "blockquote", 1);
  g.markup = ">";
  const b = [e, 0];
  g.map = b, t.md.block.tokenize(t, e, p);
  const _ = t.push("blockquote_close", "blockquote", -1);
  _.markup = ">", t.lineMax = o, t.parentType = h, b[1] = t.line;
  for (let y = 0; y < u.length; y++)
    t.bMarks[y + e] = a[y], t.tShift[y + e] = u[y], t.sCount[y + e] = c[y], t.bsCount[y + e] = l[y];
  return t.blkIndent = m, !0;
}
function RF(t, e, n, i) {
  const r = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let s = t.bMarks[e] + t.tShift[e];
  const o = t.src.charCodeAt(s++);
  if (o !== 42 && o !== 45 && o !== 95)
    return !1;
  let a = 1;
  for (; s < r; ) {
    const c = t.src.charCodeAt(s++);
    if (c !== o && !xt(c))
      return !1;
    c === o && a++;
  }
  if (a < 3)
    return !1;
  if (i)
    return !0;
  t.line = e + 1;
  const l = t.push("hr", "hr", 0);
  return l.map = [e, t.line], l.markup = Array(a + 1).join(String.fromCharCode(o)), !0;
}
function Ow(t, e) {
  const n = t.eMarks[e];
  let i = t.bMarks[e] + t.tShift[e];
  const r = t.src.charCodeAt(i++);
  if (r !== 42 && r !== 45 && r !== 43)
    return -1;
  if (i < n) {
    const s = t.src.charCodeAt(i);
    if (!xt(s))
      return -1;
  }
  return i;
}
function yw(t, e) {
  const n = t.bMarks[e] + t.tShift[e], i = t.eMarks[e];
  let r = n;
  if (r + 1 >= i)
    return -1;
  let s = t.src.charCodeAt(r++);
  if (s < 48 || s > 57)
    return -1;
  for (; ; ) {
    if (r >= i)
      return -1;
    if (s = t.src.charCodeAt(r++), s >= 48 && s <= 57) {
      if (r - n >= 10)
        return -1;
      continue;
    }
    if (s === 41 || s === 46)
      break;
    return -1;
  }
  return r < i && (s = t.src.charCodeAt(r), !xt(s)) ? -1 : r;
}
function $F(t, e) {
  const n = t.level + 2;
  for (let i = e + 2, r = t.tokens.length - 2; i < r; i++)
    t.tokens[i].level === n && t.tokens[i].type === "paragraph_open" && (t.tokens[i + 2].hidden = !0, t.tokens[i].hidden = !0, i += 2);
}
function NF(t, e, n, i) {
  let r, s, o, a, l = e, c = !0;
  if (t.sCount[l] - t.blkIndent >= 4 || t.listIndent >= 0 && t.sCount[l] - t.listIndent >= 4 && t.sCount[l] < t.blkIndent)
    return !1;
  let u = !1;
  i && t.parentType === "paragraph" && t.sCount[l] >= t.blkIndent && (u = !0);
  let d, h, f;
  if ((f = yw(t, l)) >= 0) {
    if (d = !0, o = t.bMarks[l] + t.tShift[l], h = Number(t.src.slice(o, f - 1)), u && h !== 1) return !1;
  } else if ((f = Ow(t, l)) >= 0)
    d = !1;
  else
    return !1;
  if (u && t.skipSpaces(f) >= t.eMarks[l])
    return !1;
  if (i)
    return !0;
  const p = t.src.charCodeAt(f - 1), m = t.tokens.length;
  d ? (a = t.push("ordered_list_open", "ol", 1), h !== 1 && (a.attrs = [["start", h]])) : a = t.push("bullet_list_open", "ul", 1);
  const g = [l, 0];
  a.map = g, a.markup = String.fromCharCode(p);
  let b = !1;
  const _ = t.md.block.ruler.getRules("list"), y = t.parentType;
  for (t.parentType = "list"; l < n; ) {
    s = f, r = t.eMarks[l];
    const O = t.sCount[l] + f - (t.bMarks[l] + t.tShift[l]);
    let x = O;
    for (; s < r; ) {
      const K = t.src.charCodeAt(s);
      if (K === 9)
        x += 4 - (x + t.bsCount[l]) % 4;
      else if (K === 32)
        x++;
      else
        break;
      s++;
    }
    const v = s;
    let w;
    v >= r ? w = 1 : w = x - O, w > 4 && (w = 1);
    const T = O + w;
    a = t.push("list_item_open", "li", 1), a.markup = String.fromCharCode(p);
    const S = [l, 0];
    a.map = S, d && (a.info = t.src.slice(o, f - 1));
    const $ = t.tight, I = t.tShift[l], F = t.sCount[l], V = t.listIndent;
    if (t.listIndent = t.blkIndent, t.blkIndent = T, t.tight = !0, t.tShift[l] = v - t.bMarks[l], t.sCount[l] = x, v >= r && t.isEmpty(l + 1) ? t.line = Math.min(t.line + 2, n) : t.md.block.tokenize(t, l, n, !0), (!t.tight || b) && (c = !1), b = t.line - l > 1 && t.isEmpty(t.line - 1), t.blkIndent = t.listIndent, t.listIndent = V, t.tShift[l] = I, t.sCount[l] = F, t.tight = $, a = t.push("list_item_close", "li", -1), a.markup = String.fromCharCode(p), l = t.line, S[1] = l, l >= n || t.sCount[l] < t.blkIndent || t.sCount[l] - t.blkIndent >= 4)
      break;
    let q = !1;
    for (let K = 0, ie = _.length; K < ie; K++)
      if (_[K](t, l, n, !0)) {
        q = !0;
        break;
      }
    if (q)
      break;
    if (d) {
      if (f = yw(t, l), f < 0)
        break;
      o = t.bMarks[l] + t.tShift[l];
    } else if (f = Ow(t, l), f < 0)
      break;
    if (p !== t.src.charCodeAt(f - 1))
      break;
  }
  return d ? a = t.push("ordered_list_close", "ol", -1) : a = t.push("bullet_list_close", "ul", -1), a.markup = String.fromCharCode(p), g[1] = l, t.line = l, t.parentType = y, c && $F(t, m), !0;
}
function DF(t, e, n, i) {
  let r = t.bMarks[e] + t.tShift[e], s = t.eMarks[e], o = e + 1;
  if (t.sCount[e] - t.blkIndent >= 4 || t.src.charCodeAt(r) !== 91)
    return !1;
  function a(_) {
    const y = t.lineMax;
    if (_ >= y || t.isEmpty(_))
      return null;
    let O = !1;
    if (t.sCount[_] - t.blkIndent > 3 && (O = !0), t.sCount[_] < 0 && (O = !0), !O) {
      const w = t.md.block.ruler.getRules("reference"), T = t.parentType;
      t.parentType = "reference";
      let S = !1;
      for (let $ = 0, I = w.length; $ < I; $++)
        if (w[$](t, _, y, !0)) {
          S = !0;
          break;
        }
      if (t.parentType = T, S)
        return null;
    }
    const x = t.bMarks[_] + t.tShift[_], v = t.eMarks[_];
    return t.src.slice(x, v + 1);
  }
  let l = t.src.slice(r, s + 1);
  s = l.length;
  let c = -1;
  for (r = 1; r < s; r++) {
    const _ = l.charCodeAt(r);
    if (_ === 91)
      return !1;
    if (_ === 93) {
      c = r;
      break;
    } else if (_ === 10) {
      const y = a(o);
      y !== null && (l += y, s = l.length, o++);
    } else if (_ === 92 && (r++, r < s && l.charCodeAt(r) === 10)) {
      const y = a(o);
      y !== null && (l += y, s = l.length, o++);
    }
  }
  if (c < 0 || l.charCodeAt(c + 1) !== 58)
    return !1;
  for (r = c + 2; r < s; r++) {
    const _ = l.charCodeAt(r);
    if (_ === 10) {
      const y = a(o);
      y !== null && (l += y, s = l.length, o++);
    } else if (!xt(_)) break;
  }
  const u = t.md.helpers.parseLinkDestination(l, r, s);
  if (!u.ok)
    return !1;
  const d = t.md.normalizeLink(u.str);
  if (!t.md.validateLink(d))
    return !1;
  r = u.pos;
  const h = r, f = o, p = r;
  for (; r < s; r++) {
    const _ = l.charCodeAt(r);
    if (_ === 10) {
      const y = a(o);
      y !== null && (l += y, s = l.length, o++);
    } else if (!xt(_)) break;
  }
  let m = t.md.helpers.parseLinkTitle(l, r, s);
  for (; m.can_continue; ) {
    const _ = a(o);
    if (_ === null) break;
    l += _, r = s, s = l.length, o++, m = t.md.helpers.parseLinkTitle(l, r, s, m);
  }
  let g;
  for (r < s && p !== r && m.ok ? (g = m.str, r = m.pos) : (g = "", r = h, o = f); r < s; ) {
    const _ = l.charCodeAt(r);
    if (!xt(_))
      break;
    r++;
  }
  if (r < s && l.charCodeAt(r) !== 10 && g)
    for (g = "", r = h, o = f; r < s; ) {
      const _ = l.charCodeAt(r);
      if (!xt(_))
        break;
      r++;
    }
  if (r < s && l.charCodeAt(r) !== 10)
    return !1;
  const b = v0(l.slice(1, c));
  return b ? (i || (typeof t.env.references > "u" && (t.env.references = {}), typeof t.env.references[b] > "u" && (t.env.references[b] = { title: g, href: d }), t.line = o), !0) : !1;
}
const IF = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], LF = "[a-zA-Z_:][a-zA-Z0-9:._-]*", BF = "[^\"'=<>`\\x00-\\x20]+", QF = "'[^']*'", FF = '"[^"]*"', zF = "(?:" + BF + "|" + QF + "|" + FF + ")", UF = "(?:\\s+" + LF + "(?:\\s*=\\s*" + zF + ")?)", MM = "<[A-Za-z][A-Za-z0-9\\-]*" + UF + "*\\s*\\/?>", PM = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", WF = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", VF = "<[?][\\s\\S]*?[?]>", ZF = "<![A-Za-z][^>]*>", HF = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", qF = new RegExp("^(?:" + MM + "|" + PM + "|" + WF + "|" + VF + "|" + ZF + "|" + HF + ")"), XF = new RegExp("^(?:" + MM + "|" + PM + ")"), el = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + IF.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(XF.source + "\\s*$"), /^$/, !1]
];
function jF(t, e, n, i) {
  let r = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4 || !t.md.options.html || t.src.charCodeAt(r) !== 60)
    return !1;
  let o = t.src.slice(r, s), a = 0;
  for (; a < el.length && !el[a][0].test(o); a++)
    ;
  if (a === el.length)
    return !1;
  if (i)
    return el[a][2];
  let l = e + 1;
  if (!el[a][1].test(o)) {
    for (; l < n && !(t.sCount[l] < t.blkIndent); l++)
      if (r = t.bMarks[l] + t.tShift[l], s = t.eMarks[l], o = t.src.slice(r, s), el[a][1].test(o)) {
        o.length !== 0 && l++;
        break;
      }
  }
  t.line = l;
  const c = t.push("html_block", "", 0);
  return c.map = [e, l], c.content = t.getLines(e, l, t.blkIndent, !0), !0;
}
function YF(t, e, n, i) {
  let r = t.bMarks[e] + t.tShift[e], s = t.eMarks[e];
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  let o = t.src.charCodeAt(r);
  if (o !== 35 || r >= s)
    return !1;
  let a = 1;
  for (o = t.src.charCodeAt(++r); o === 35 && r < s && a <= 6; )
    a++, o = t.src.charCodeAt(++r);
  if (a > 6 || r < s && !xt(o))
    return !1;
  if (i)
    return !0;
  s = t.skipSpacesBack(s, r);
  const l = t.skipCharsBack(s, 35, r);
  l > r && xt(t.src.charCodeAt(l - 1)) && (s = l), t.line = e + 1;
  const c = t.push("heading_open", "h" + String(a), 1);
  c.markup = "########".slice(0, a), c.map = [e, t.line];
  const u = t.push("inline", "", 0);
  u.content = t.src.slice(r, s).trim(), u.map = [e, t.line], u.children = [];
  const d = t.push("heading_close", "h" + String(a), -1);
  return d.markup = "########".slice(0, a), !0;
}
function GF(t, e, n) {
  const i = t.md.block.ruler.getRules("paragraph");
  if (t.sCount[e] - t.blkIndent >= 4)
    return !1;
  const r = t.parentType;
  t.parentType = "paragraph";
  let s = 0, o, a = e + 1;
  for (; a < n && !t.isEmpty(a); a++) {
    if (t.sCount[a] - t.blkIndent > 3)
      continue;
    if (t.sCount[a] >= t.blkIndent) {
      let f = t.bMarks[a] + t.tShift[a];
      const p = t.eMarks[a];
      if (f < p && (o = t.src.charCodeAt(f), (o === 45 || o === 61) && (f = t.skipChars(f, o), f = t.skipSpaces(f), f >= p))) {
        s = o === 61 ? 1 : 2;
        break;
      }
    }
    if (t.sCount[a] < 0)
      continue;
    let h = !1;
    for (let f = 0, p = i.length; f < p; f++)
      if (i[f](t, a, n, !0)) {
        h = !0;
        break;
      }
    if (h)
      break;
  }
  if (!s)
    return !1;
  const l = t.getLines(e, a, t.blkIndent, !1).trim();
  t.line = a + 1;
  const c = t.push("heading_open", "h" + String(s), 1);
  c.markup = String.fromCharCode(o), c.map = [e, t.line];
  const u = t.push("inline", "", 0);
  u.content = l, u.map = [e, t.line - 1], u.children = [];
  const d = t.push("heading_close", "h" + String(s), -1);
  return d.markup = String.fromCharCode(o), t.parentType = r, !0;
}
function KF(t, e, n) {
  const i = t.md.block.ruler.getRules("paragraph"), r = t.parentType;
  let s = e + 1;
  for (t.parentType = "paragraph"; s < n && !t.isEmpty(s); s++) {
    if (t.sCount[s] - t.blkIndent > 3 || t.sCount[s] < 0)
      continue;
    let c = !1;
    for (let u = 0, d = i.length; u < d; u++)
      if (i[u](t, s, n, !0)) {
        c = !0;
        break;
      }
    if (c)
      break;
  }
  const o = t.getLines(e, s, t.blkIndent, !1).trim();
  t.line = s;
  const a = t.push("paragraph_open", "p", 1);
  a.map = [e, t.line];
  const l = t.push("inline", "", 0);
  return l.content = o, l.map = [e, t.line], l.children = [], t.push("paragraph_close", "p", -1), t.parentType = r, !0;
}
const Rh = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", AF, ["paragraph", "reference"]],
  ["code", TF],
  ["fence", MF, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", PF, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", RF, ["paragraph", "reference", "blockquote", "list"]],
  ["list", NF, ["paragraph", "reference", "blockquote"]],
  ["reference", DF],
  ["html_block", jF, ["paragraph", "reference", "blockquote"]],
  ["heading", YF, ["paragraph", "reference", "blockquote"]],
  ["lheading", GF],
  ["paragraph", KF]
];
function x0() {
  this.ruler = new ui();
  for (let t = 0; t < Rh.length; t++)
    this.ruler.push(Rh[t][0], Rh[t][1], { alt: (Rh[t][2] || []).slice() });
}
x0.prototype.tokenize = function(t, e, n) {
  const i = this.ruler.getRules(""), r = i.length, s = t.md.options.maxNesting;
  let o = e, a = !1;
  for (; o < n && (t.line = o = t.skipEmptyLines(o), !(o >= n || t.sCount[o] < t.blkIndent)); ) {
    if (t.level >= s) {
      t.line = n;
      break;
    }
    const l = t.line;
    let c = !1;
    for (let u = 0; u < r; u++)
      if (c = i[u](t, o, n, !1), c) {
        if (l >= t.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!c) throw new Error("none of the block rules matched");
    t.tight = !a, t.isEmpty(t.line - 1) && (a = !0), o = t.line, o < n && t.isEmpty(o) && (a = !0, o++, t.line = o);
  }
};
x0.prototype.parse = function(t, e, n, i) {
  if (!t)
    return;
  const r = new this.State(t, e, n, i);
  this.tokenize(r, r.line, r.lineMax);
};
x0.prototype.State = ns;
function Wd(t, e, n, i) {
  this.src = t, this.env = n, this.md = e, this.tokens = i, this.tokens_meta = Array(i.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Wd.prototype.pushPending = function() {
  const t = new pr("text", "", 0);
  return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t;
};
Wd.prototype.push = function(t, e, n) {
  this.pending && this.pushPending();
  const i = new pr(t, e, n);
  let r = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), i.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], r = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(i), this.tokens_meta.push(r), i;
};
Wd.prototype.scanDelims = function(t, e) {
  const n = this.posMax, i = this.src.charCodeAt(t), r = t > 0 ? this.src.charCodeAt(t - 1) : 32;
  let s = t;
  for (; s < n && this.src.charCodeAt(s) === i; )
    s++;
  const o = s - t, a = s < n ? this.src.charCodeAt(s) : 32, l = ju(r) || Xu(String.fromCharCode(r)), c = ju(a) || Xu(String.fromCharCode(a)), u = qu(r), d = qu(a), h = !d && (!c || u || l), f = !u && (!l || d || c);
  return { can_open: h && (e || !f || l), can_close: f && (e || !h || c), length: o };
};
Wd.prototype.Token = pr;
function JF(t) {
  switch (t) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function ez(t, e) {
  let n = t.pos;
  for (; n < t.posMax && !JF(t.src.charCodeAt(n)); )
    n++;
  return n === t.pos ? !1 : (e || (t.pending += t.src.slice(t.pos, n)), t.pos = n, !0);
}
const tz = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function nz(t, e) {
  if (!t.md.options.linkify || t.linkLevel > 0) return !1;
  const n = t.pos, i = t.posMax;
  if (n + 3 > i || t.src.charCodeAt(n) !== 58 || t.src.charCodeAt(n + 1) !== 47 || t.src.charCodeAt(n + 2) !== 47) return !1;
  const r = t.pending.match(tz);
  if (!r) return !1;
  const s = r[1], o = t.md.linkify.matchAtStart(t.src.slice(n - s.length));
  if (!o) return !1;
  let a = o.url;
  if (a.length <= s.length) return !1;
  a = a.replace(/\*+$/, "");
  const l = t.md.normalizeLink(a);
  if (!t.md.validateLink(l)) return !1;
  if (!e) {
    t.pending = t.pending.slice(0, -s.length);
    const c = t.push("link_open", "a", 1);
    c.attrs = [["href", l]], c.markup = "linkify", c.info = "auto";
    const u = t.push("text", "", 0);
    u.content = t.md.normalizeLinkText(a);
    const d = t.push("link_close", "a", -1);
    d.markup = "linkify", d.info = "auto";
  }
  return t.pos += a.length - s.length, !0;
}
function iz(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 10)
    return !1;
  const i = t.pending.length - 1, r = t.posMax;
  if (!e)
    if (i >= 0 && t.pending.charCodeAt(i) === 32)
      if (i >= 1 && t.pending.charCodeAt(i - 1) === 32) {
        let s = i - 1;
        for (; s >= 1 && t.pending.charCodeAt(s - 1) === 32; ) s--;
        t.pending = t.pending.slice(0, s), t.push("hardbreak", "br", 0);
      } else
        t.pending = t.pending.slice(0, -1), t.push("softbreak", "br", 0);
    else
      t.push("softbreak", "br", 0);
  for (n++; n < r && xt(t.src.charCodeAt(n)); )
    n++;
  return t.pos = n, !0;
}
const x2 = [];
for (let t = 0; t < 256; t++)
  x2.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t) {
  x2[t.charCodeAt(0)] = 1;
});
function rz(t, e) {
  let n = t.pos;
  const i = t.posMax;
  if (t.src.charCodeAt(n) !== 92 || (n++, n >= i)) return !1;
  let r = t.src.charCodeAt(n);
  if (r === 10) {
    for (e || t.push("hardbreak", "br", 0), n++; n < i && (r = t.src.charCodeAt(n), !!xt(r)); )
      n++;
    return t.pos = n, !0;
  }
  let s = t.src[n];
  if (r >= 55296 && r <= 56319 && n + 1 < i) {
    const a = t.src.charCodeAt(n + 1);
    a >= 56320 && a <= 57343 && (s += t.src[n + 1], n++);
  }
  const o = "\\" + s;
  if (!e) {
    const a = t.push("text_special", "", 0);
    r < 256 && x2[r] !== 0 ? a.content = s : a.content = o, a.markup = o, a.info = "escape";
  }
  return t.pos = n + 1, !0;
}
function sz(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 96)
    return !1;
  const r = n;
  n++;
  const s = t.posMax;
  for (; n < s && t.src.charCodeAt(n) === 96; )
    n++;
  const o = t.src.slice(r, n), a = o.length;
  if (t.backticksScanned && (t.backticks[a] || 0) <= r)
    return e || (t.pending += o), t.pos += a, !0;
  let l = n, c;
  for (; (c = t.src.indexOf("`", l)) !== -1; ) {
    for (l = c + 1; l < s && t.src.charCodeAt(l) === 96; )
      l++;
    const u = l - c;
    if (u === a) {
      if (!e) {
        const d = t.push("code_inline", "code", 0);
        d.markup = o, d.content = t.src.slice(n, c).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return t.pos = l, !0;
    }
    t.backticks[u] = c;
  }
  return t.backticksScanned = !0, e || (t.pending += o), t.pos += a, !0;
}
function oz(t, e) {
  const n = t.pos, i = t.src.charCodeAt(n);
  if (e || i !== 126)
    return !1;
  const r = t.scanDelims(t.pos, !0);
  let s = r.length;
  const o = String.fromCharCode(i);
  if (s < 2)
    return !1;
  let a;
  s % 2 && (a = t.push("text", "", 0), a.content = o, s--);
  for (let l = 0; l < s; l += 2)
    a = t.push("text", "", 0), a.content = o + o, t.delimiters.push({
      marker: i,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: t.tokens.length - 1,
      end: -1,
      open: r.can_open,
      close: r.can_close
    });
  return t.pos += r.length, !0;
}
function _w(t, e) {
  let n;
  const i = [], r = e.length;
  for (let s = 0; s < r; s++) {
    const o = e[s];
    if (o.marker !== 126 || o.end === -1)
      continue;
    const a = e[o.end];
    n = t.tokens[o.token], n.type = "s_open", n.tag = "s", n.nesting = 1, n.markup = "~~", n.content = "", n = t.tokens[a.token], n.type = "s_close", n.tag = "s", n.nesting = -1, n.markup = "~~", n.content = "", t.tokens[a.token - 1].type === "text" && t.tokens[a.token - 1].content === "~" && i.push(a.token - 1);
  }
  for (; i.length; ) {
    const s = i.pop();
    let o = s + 1;
    for (; o < t.tokens.length && t.tokens[o].type === "s_close"; )
      o++;
    o--, s !== o && (n = t.tokens[o], t.tokens[o] = t.tokens[s], t.tokens[s] = n);
  }
}
function az(t) {
  const e = t.tokens_meta, n = t.tokens_meta.length;
  _w(t, t.delimiters);
  for (let i = 0; i < n; i++)
    e[i] && e[i].delimiters && _w(t, e[i].delimiters);
}
const RM = {
  tokenize: oz,
  postProcess: az
};
function lz(t, e) {
  const n = t.pos, i = t.src.charCodeAt(n);
  if (e || i !== 95 && i !== 42)
    return !1;
  const r = t.scanDelims(t.pos, i === 42);
  for (let s = 0; s < r.length; s++) {
    const o = t.push("text", "", 0);
    o.content = String.fromCharCode(i), t.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: i,
      // Total length of these series of delimiters.
      //
      length: r.length,
      // A position of the token this delimiter corresponds to.
      //
      token: t.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: r.can_open,
      close: r.can_close
    });
  }
  return t.pos += r.length, !0;
}
function vw(t, e) {
  const n = e.length;
  for (let i = n - 1; i >= 0; i--) {
    const r = e[i];
    if (r.marker !== 95 && r.marker !== 42 || r.end === -1)
      continue;
    const s = e[r.end], o = i > 0 && e[i - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[i - 1].marker === r.marker && e[i - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === s.token + 1, a = String.fromCharCode(r.marker), l = t.tokens[r.token];
    l.type = o ? "strong_open" : "em_open", l.tag = o ? "strong" : "em", l.nesting = 1, l.markup = o ? a + a : a, l.content = "";
    const c = t.tokens[s.token];
    c.type = o ? "strong_close" : "em_close", c.tag = o ? "strong" : "em", c.nesting = -1, c.markup = o ? a + a : a, c.content = "", o && (t.tokens[e[i - 1].token].content = "", t.tokens[e[r.end + 1].token].content = "", i--);
  }
}
function cz(t) {
  const e = t.tokens_meta, n = t.tokens_meta.length;
  vw(t, t.delimiters);
  for (let i = 0; i < n; i++)
    e[i] && e[i].delimiters && vw(t, e[i].delimiters);
}
const $M = {
  tokenize: lz,
  postProcess: cz
};
function uz(t, e) {
  let n, i, r, s, o = "", a = "", l = t.pos, c = !0;
  if (t.src.charCodeAt(t.pos) !== 91)
    return !1;
  const u = t.pos, d = t.posMax, h = t.pos + 1, f = t.md.helpers.parseLinkLabel(t, t.pos, !0);
  if (f < 0)
    return !1;
  let p = f + 1;
  if (p < d && t.src.charCodeAt(p) === 40) {
    for (c = !1, p++; p < d && (n = t.src.charCodeAt(p), !(!xt(n) && n !== 10)); p++)
      ;
    if (p >= d)
      return !1;
    if (l = p, r = t.md.helpers.parseLinkDestination(t.src, p, t.posMax), r.ok) {
      for (o = t.md.normalizeLink(r.str), t.md.validateLink(o) ? p = r.pos : o = "", l = p; p < d && (n = t.src.charCodeAt(p), !(!xt(n) && n !== 10)); p++)
        ;
      if (r = t.md.helpers.parseLinkTitle(t.src, p, t.posMax), p < d && l !== p && r.ok)
        for (a = r.str, p = r.pos; p < d && (n = t.src.charCodeAt(p), !(!xt(n) && n !== 10)); p++)
          ;
    }
    (p >= d || t.src.charCodeAt(p) !== 41) && (c = !0), p++;
  }
  if (c) {
    if (typeof t.env.references > "u")
      return !1;
    if (p < d && t.src.charCodeAt(p) === 91 ? (l = p + 1, p = t.md.helpers.parseLinkLabel(t, p), p >= 0 ? i = t.src.slice(l, p++) : p = f + 1) : p = f + 1, i || (i = t.src.slice(h, f)), s = t.env.references[v0(i)], !s)
      return t.pos = u, !1;
    o = s.href, a = s.title;
  }
  if (!e) {
    t.pos = h, t.posMax = f;
    const m = t.push("link_open", "a", 1), g = [["href", o]];
    m.attrs = g, a && g.push(["title", a]), t.linkLevel++, t.md.inline.tokenize(t), t.linkLevel--, t.push("link_close", "a", -1);
  }
  return t.pos = p, t.posMax = d, !0;
}
function dz(t, e) {
  let n, i, r, s, o, a, l, c, u = "";
  const d = t.pos, h = t.posMax;
  if (t.src.charCodeAt(t.pos) !== 33 || t.src.charCodeAt(t.pos + 1) !== 91)
    return !1;
  const f = t.pos + 2, p = t.md.helpers.parseLinkLabel(t, t.pos + 1, !1);
  if (p < 0)
    return !1;
  if (s = p + 1, s < h && t.src.charCodeAt(s) === 40) {
    for (s++; s < h && (n = t.src.charCodeAt(s), !(!xt(n) && n !== 10)); s++)
      ;
    if (s >= h)
      return !1;
    for (c = s, a = t.md.helpers.parseLinkDestination(t.src, s, t.posMax), a.ok && (u = t.md.normalizeLink(a.str), t.md.validateLink(u) ? s = a.pos : u = ""), c = s; s < h && (n = t.src.charCodeAt(s), !(!xt(n) && n !== 10)); s++)
      ;
    if (a = t.md.helpers.parseLinkTitle(t.src, s, t.posMax), s < h && c !== s && a.ok)
      for (l = a.str, s = a.pos; s < h && (n = t.src.charCodeAt(s), !(!xt(n) && n !== 10)); s++)
        ;
    else
      l = "";
    if (s >= h || t.src.charCodeAt(s) !== 41)
      return t.pos = d, !1;
    s++;
  } else {
    if (typeof t.env.references > "u")
      return !1;
    if (s < h && t.src.charCodeAt(s) === 91 ? (c = s + 1, s = t.md.helpers.parseLinkLabel(t, s), s >= 0 ? r = t.src.slice(c, s++) : s = p + 1) : s = p + 1, r || (r = t.src.slice(f, p)), o = t.env.references[v0(r)], !o)
      return t.pos = d, !1;
    u = o.href, l = o.title;
  }
  if (!e) {
    i = t.src.slice(f, p);
    const m = [];
    t.md.inline.parse(
      i,
      t.md,
      t.env,
      m
    );
    const g = t.push("image", "img", 0), b = [["src", u], ["alt", ""]];
    g.attrs = b, g.children = m, g.content = i, l && b.push(["title", l]);
  }
  return t.pos = s, t.posMax = h, !0;
}
const hz = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, fz = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function pz(t, e) {
  let n = t.pos;
  if (t.src.charCodeAt(n) !== 60)
    return !1;
  const i = t.pos, r = t.posMax;
  for (; ; ) {
    if (++n >= r) return !1;
    const o = t.src.charCodeAt(n);
    if (o === 60) return !1;
    if (o === 62) break;
  }
  const s = t.src.slice(i + 1, n);
  if (fz.test(s)) {
    const o = t.md.normalizeLink(s);
    if (!t.md.validateLink(o))
      return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      a.attrs = [["href", o]], a.markup = "autolink", a.info = "auto";
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(s);
      const c = t.push("link_close", "a", -1);
      c.markup = "autolink", c.info = "auto";
    }
    return t.pos += s.length + 2, !0;
  }
  if (hz.test(s)) {
    const o = t.md.normalizeLink("mailto:" + s);
    if (!t.md.validateLink(o))
      return !1;
    if (!e) {
      const a = t.push("link_open", "a", 1);
      a.attrs = [["href", o]], a.markup = "autolink", a.info = "auto";
      const l = t.push("text", "", 0);
      l.content = t.md.normalizeLinkText(s);
      const c = t.push("link_close", "a", -1);
      c.markup = "autolink", c.info = "auto";
    }
    return t.pos += s.length + 2, !0;
  }
  return !1;
}
function mz(t) {
  return /^<a[>\s]/i.test(t);
}
function gz(t) {
  return /^<\/a\s*>/i.test(t);
}
function bz(t) {
  const e = t | 32;
  return e >= 97 && e <= 122;
}
function Oz(t, e) {
  if (!t.md.options.html)
    return !1;
  const n = t.posMax, i = t.pos;
  if (t.src.charCodeAt(i) !== 60 || i + 2 >= n)
    return !1;
  const r = t.src.charCodeAt(i + 1);
  if (r !== 33 && r !== 63 && r !== 47 && !bz(r))
    return !1;
  const s = t.src.slice(i).match(qF);
  if (!s)
    return !1;
  if (!e) {
    const o = t.push("html_inline", "", 0);
    o.content = s[0], mz(o.content) && t.linkLevel++, gz(o.content) && t.linkLevel--;
  }
  return t.pos += s[0].length, !0;
}
const yz = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, _z = /^&([a-z][a-z0-9]{1,31});/i;
function vz(t, e) {
  const n = t.pos, i = t.posMax;
  if (t.src.charCodeAt(n) !== 38 || n + 1 >= i) return !1;
  if (t.src.charCodeAt(n + 1) === 35) {
    const s = t.src.slice(n).match(yz);
    if (s) {
      if (!e) {
        const o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), a = t.push("text_special", "", 0);
        a.content = _2(o) ? Dp(o) : Dp(65533), a.markup = s[0], a.info = "entity";
      }
      return t.pos += s[0].length, !0;
    }
  } else {
    const s = t.src.slice(n).match(_z);
    if (s) {
      const o = kM(s[0]);
      if (o !== s[0]) {
        if (!e) {
          const a = t.push("text_special", "", 0);
          a.content = o, a.markup = s[0], a.info = "entity";
        }
        return t.pos += s[0].length, !0;
      }
    }
  }
  return !1;
}
function xw(t) {
  const e = {}, n = t.length;
  if (!n) return;
  let i = 0, r = -2;
  const s = [];
  for (let o = 0; o < n; o++) {
    const a = t[o];
    if (s.push(0), (t[i].marker !== a.marker || r !== a.token - 1) && (i = o), r = a.token, a.length = a.length || 0, !a.close) continue;
    e.hasOwnProperty(a.marker) || (e[a.marker] = [-1, -1, -1, -1, -1, -1]);
    const l = e[a.marker][(a.open ? 3 : 0) + a.length % 3];
    let c = i - s[i] - 1, u = c;
    for (; c > l; c -= s[c] + 1) {
      const d = t[c];
      if (d.marker === a.marker && d.open && d.end < 0) {
        let h = !1;
        if ((d.close || a.open) && (d.length + a.length) % 3 === 0 && (d.length % 3 !== 0 || a.length % 3 !== 0) && (h = !0), !h) {
          const f = c > 0 && !t[c - 1].open ? s[c - 1] + 1 : 0;
          s[o] = o - c + f, s[c] = f, a.open = !1, d.end = o, d.close = !1, u = -1, r = -2;
          break;
        }
      }
    }
    u !== -1 && (e[a.marker][(a.open ? 3 : 0) + (a.length || 0) % 3] = u);
  }
}
function xz(t) {
  const e = t.tokens_meta, n = t.tokens_meta.length;
  xw(t.delimiters);
  for (let i = 0; i < n; i++)
    e[i] && e[i].delimiters && xw(e[i].delimiters);
}
function wz(t) {
  let e, n, i = 0;
  const r = t.tokens, s = t.tokens.length;
  for (e = n = 0; e < s; e++)
    r[e].nesting < 0 && i--, r[e].level = i, r[e].nesting > 0 && i++, r[e].type === "text" && e + 1 < s && r[e + 1].type === "text" ? r[e + 1].content = r[e].content + r[e + 1].content : (e !== n && (r[n] = r[e]), n++);
  e !== n && (r.length = n);
}
const Ig = [
  ["text", ez],
  ["linkify", nz],
  ["newline", iz],
  ["escape", rz],
  ["backticks", sz],
  ["strikethrough", RM.tokenize],
  ["emphasis", $M.tokenize],
  ["link", uz],
  ["image", dz],
  ["autolink", pz],
  ["html_inline", Oz],
  ["entity", vz]
], Lg = [
  ["balance_pairs", xz],
  ["strikethrough", RM.postProcess],
  ["emphasis", $M.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", wz]
];
function Vd() {
  this.ruler = new ui();
  for (let t = 0; t < Ig.length; t++)
    this.ruler.push(Ig[t][0], Ig[t][1]);
  this.ruler2 = new ui();
  for (let t = 0; t < Lg.length; t++)
    this.ruler2.push(Lg[t][0], Lg[t][1]);
}
Vd.prototype.skipToken = function(t) {
  const e = t.pos, n = this.ruler.getRules(""), i = n.length, r = t.md.options.maxNesting, s = t.cache;
  if (typeof s[e] < "u") {
    t.pos = s[e];
    return;
  }
  let o = !1;
  if (t.level < r) {
    for (let a = 0; a < i; a++)
      if (t.level++, o = n[a](t, !0), t.level--, o) {
        if (e >= t.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    t.pos = t.posMax;
  o || t.pos++, s[e] = t.pos;
};
Vd.prototype.tokenize = function(t) {
  const e = this.ruler.getRules(""), n = e.length, i = t.posMax, r = t.md.options.maxNesting;
  for (; t.pos < i; ) {
    const s = t.pos;
    let o = !1;
    if (t.level < r) {
      for (let a = 0; a < n; a++)
        if (o = e[a](t, !1), o) {
          if (s >= t.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (o) {
      if (t.pos >= i)
        break;
      continue;
    }
    t.pending += t.src[t.pos++];
  }
  t.pending && t.pushPending();
};
Vd.prototype.parse = function(t, e, n, i) {
  const r = new this.State(t, e, n, i);
  this.tokenize(r);
  const s = this.ruler2.getRules(""), o = s.length;
  for (let a = 0; a < o; a++)
    s[a](r);
};
Vd.prototype.State = Wd;
function Sz(t) {
  const e = {};
  t = t || {}, e.src_Any = _M.source, e.src_Cc = vM.source, e.src_Z = wM.source, e.src_P = O2.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
  const n = "[><]";
  return e.src_pseudo_letter = "(?:(?!" + n + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + n + "|" + e.src_ZPCc + ")(?!" + (t["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e.src_ZPCc + "))((?![$+<=>^`|])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + e.src_ZPCc + "))((?![$+<=>^`|])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
}
function Yb(t) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    n && Object.keys(n).forEach(function(i) {
      t[i] = n[i];
    });
  }), t;
}
function w0(t) {
  return Object.prototype.toString.call(t);
}
function kz(t) {
  return w0(t) === "[object String]";
}
function Ez(t) {
  return w0(t) === "[object Object]";
}
function Cz(t) {
  return w0(t) === "[object RegExp]";
}
function ww(t) {
  return w0(t) === "[object Function]";
}
function Az(t) {
  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const NM = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function Tz(t) {
  return Object.keys(t || {}).reduce(function(e, n) {
    return e || NM.hasOwnProperty(n);
  }, !1);
}
const Mz = {
  "http:": {
    validate: function(t, e, n) {
      const i = t.slice(e);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(i) ? i.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t, e, n) {
      const i = t.slice(e);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(i) ? e >= 3 && t[e - 3] === ":" || e >= 3 && t[e - 3] === "/" ? 0 : i.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t, e, n) {
      const i = t.slice(e);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(i) ? i.match(n.re.mailto)[0].length : 0;
    }
  }
}, Pz = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", Rz = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
function $z(t) {
  t.__index__ = -1, t.__text_cache__ = "";
}
function Nz(t) {
  return function(e, n) {
    const i = e.slice(n);
    return t.test(i) ? i.match(t)[0].length : 0;
  };
}
function Sw() {
  return function(t, e) {
    e.normalize(t);
  };
}
function Ip(t) {
  const e = t.re = Sz(t.__opts__), n = t.__tlds__.slice();
  t.onCompile(), t.__tlds_replaced__ || n.push(Pz), n.push(e.src_xn), e.src_tlds = n.join("|");
  function i(a) {
    return a.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(i(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(i(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(i(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(i(e.tpl_host_fuzzy_test), "i");
  const r = [];
  t.__compiled__ = {};
  function s(a, l) {
    throw new Error('(LinkifyIt) Invalid schema "' + a + '": ' + l);
  }
  Object.keys(t.__schemas__).forEach(function(a) {
    const l = t.__schemas__[a];
    if (l === null)
      return;
    const c = { validate: null, link: null };
    if (t.__compiled__[a] = c, Ez(l)) {
      Cz(l.validate) ? c.validate = Nz(l.validate) : ww(l.validate) ? c.validate = l.validate : s(a, l), ww(l.normalize) ? c.normalize = l.normalize : l.normalize ? s(a, l) : c.normalize = Sw();
      return;
    }
    if (kz(l)) {
      r.push(a);
      return;
    }
    s(a, l);
  }), r.forEach(function(a) {
    t.__compiled__[t.__schemas__[a]] && (t.__compiled__[a].validate = t.__compiled__[t.__schemas__[a]].validate, t.__compiled__[a].normalize = t.__compiled__[t.__schemas__[a]].normalize);
  }), t.__compiled__[""] = { validate: null, normalize: Sw() };
  const o = Object.keys(t.__compiled__).filter(function(a) {
    return a.length > 0 && t.__compiled__[a];
  }).map(Az).join("|");
  t.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + o + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + o + ")", "ig"), t.re.schema_at_start = RegExp("^" + t.re.schema_search.source, "i"), t.re.pretest = RegExp(
    "(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@",
    "i"
  ), $z(t);
}
function Dz(t, e) {
  const n = t.__index__, i = t.__last_index__, r = t.__text_cache__.slice(n, i);
  this.schema = t.__schema__.toLowerCase(), this.index = n + e, this.lastIndex = i + e, this.raw = r, this.text = r, this.url = r;
}
function Gb(t, e) {
  const n = new Dz(t, e);
  return t.__compiled__[n.schema].normalize(n, t), n;
}
function wi(t, e) {
  if (!(this instanceof wi))
    return new wi(t, e);
  e || Tz(t) && (e = t, t = {}), this.__opts__ = Yb({}, NM, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Yb({}, Mz, t), this.__compiled__ = {}, this.__tlds__ = Rz, this.__tlds_replaced__ = !1, this.re = {}, Ip(this);
}
wi.prototype.add = function(e, n) {
  return this.__schemas__[e] = n, Ip(this), this;
};
wi.prototype.set = function(e) {
  return this.__opts__ = Yb(this.__opts__, e), this;
};
wi.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  let n, i, r, s, o, a, l, c, u;
  if (this.re.schema_test.test(e)) {
    for (l = this.re.schema_search, l.lastIndex = 0; (n = l.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, n[2], l.lastIndex), s) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (c = e.search(this.re.host_fuzzy_test), c >= 0 && (this.__index__ < 0 || c < this.__index__) && (i = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = i.index + i[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = i.index + i[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (r = e.match(this.re.email_fuzzy)) !== null && (o = r.index + r[1].length, a = r.index + r[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && a > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = a))), this.__index__ >= 0;
};
wi.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
wi.prototype.testSchemaAt = function(e, n, i) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(e, i, this) : 0;
};
wi.prototype.match = function(e) {
  const n = [];
  let i = 0;
  this.__index__ >= 0 && this.__text_cache__ === e && (n.push(Gb(this, i)), i = this.__last_index__);
  let r = i ? e.slice(i) : e;
  for (; this.test(r); )
    n.push(Gb(this, i)), r = r.slice(this.__last_index__), i += this.__last_index__;
  return n.length ? n : null;
};
wi.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return null;
  const n = this.re.schema_at_start.exec(e);
  if (!n) return null;
  const i = this.testSchemaAt(e, n[2], n[0].length);
  return i ? (this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + i, Gb(this, 0)) : null;
};
wi.prototype.tlds = function(e, n) {
  return e = Array.isArray(e) ? e : [e], n ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(i, r, s) {
    return i !== s[r - 1];
  }).reverse(), Ip(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, Ip(this), this);
};
wi.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
wi.prototype.onCompile = function() {
};
const kl = 2147483647, Dr = 36, w2 = 1, Yu = 26, Iz = 38, Lz = 700, DM = 72, IM = 128, LM = "-", Bz = /^xn--/, Qz = /[^\0-\x7F]/, Fz = /[\x2E\u3002\uFF0E\uFF61]/g, zz = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Bg = Dr - w2, Ir = Math.floor, Qg = String.fromCharCode;
function Vs(t) {
  throw new RangeError(zz[t]);
}
function Uz(t, e) {
  const n = [];
  let i = t.length;
  for (; i--; )
    n[i] = e(t[i]);
  return n;
}
function BM(t, e) {
  const n = t.split("@");
  let i = "";
  n.length > 1 && (i = n[0] + "@", t = n[1]), t = t.replace(Fz, ".");
  const r = t.split("."), s = Uz(r, e).join(".");
  return i + s;
}
function QM(t) {
  const e = [];
  let n = 0;
  const i = t.length;
  for (; n < i; ) {
    const r = t.charCodeAt(n++);
    if (r >= 55296 && r <= 56319 && n < i) {
      const s = t.charCodeAt(n++);
      (s & 64512) == 56320 ? e.push(((r & 1023) << 10) + (s & 1023) + 65536) : (e.push(r), n--);
    } else
      e.push(r);
  }
  return e;
}
const Wz = (t) => String.fromCodePoint(...t), Vz = function(t) {
  return t >= 48 && t < 58 ? 26 + (t - 48) : t >= 65 && t < 91 ? t - 65 : t >= 97 && t < 123 ? t - 97 : Dr;
}, kw = function(t, e) {
  return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
}, FM = function(t, e, n) {
  let i = 0;
  for (t = n ? Ir(t / Lz) : t >> 1, t += Ir(t / e); t > Bg * Yu >> 1; i += Dr)
    t = Ir(t / Bg);
  return Ir(i + (Bg + 1) * t / (t + Iz));
}, zM = function(t) {
  const e = [], n = t.length;
  let i = 0, r = IM, s = DM, o = t.lastIndexOf(LM);
  o < 0 && (o = 0);
  for (let a = 0; a < o; ++a)
    t.charCodeAt(a) >= 128 && Vs("not-basic"), e.push(t.charCodeAt(a));
  for (let a = o > 0 ? o + 1 : 0; a < n; ) {
    const l = i;
    for (let u = 1, d = Dr; ; d += Dr) {
      a >= n && Vs("invalid-input");
      const h = Vz(t.charCodeAt(a++));
      h >= Dr && Vs("invalid-input"), h > Ir((kl - i) / u) && Vs("overflow"), i += h * u;
      const f = d <= s ? w2 : d >= s + Yu ? Yu : d - s;
      if (h < f)
        break;
      const p = Dr - f;
      u > Ir(kl / p) && Vs("overflow"), u *= p;
    }
    const c = e.length + 1;
    s = FM(i - l, c, l == 0), Ir(i / c) > kl - r && Vs("overflow"), r += Ir(i / c), i %= c, e.splice(i++, 0, r);
  }
  return String.fromCodePoint(...e);
}, UM = function(t) {
  const e = [];
  t = QM(t);
  const n = t.length;
  let i = IM, r = 0, s = DM;
  for (const l of t)
    l < 128 && e.push(Qg(l));
  const o = e.length;
  let a = o;
  for (o && e.push(LM); a < n; ) {
    let l = kl;
    for (const u of t)
      u >= i && u < l && (l = u);
    const c = a + 1;
    l - i > Ir((kl - r) / c) && Vs("overflow"), r += (l - i) * c, i = l;
    for (const u of t)
      if (u < i && ++r > kl && Vs("overflow"), u === i) {
        let d = r;
        for (let h = Dr; ; h += Dr) {
          const f = h <= s ? w2 : h >= s + Yu ? Yu : h - s;
          if (d < f)
            break;
          const p = d - f, m = Dr - f;
          e.push(
            Qg(kw(f + p % m, 0))
          ), d = Ir(p / m);
        }
        e.push(Qg(kw(d, 0))), s = FM(r, c, a === o), r = 0, ++a;
      }
    ++r, ++i;
  }
  return e.join("");
}, Zz = function(t) {
  return BM(t, function(e) {
    return Bz.test(e) ? zM(e.slice(4).toLowerCase()) : e;
  });
}, Hz = function(t) {
  return BM(t, function(e) {
    return Qz.test(e) ? "xn--" + UM(e) : e;
  });
}, WM = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: QM,
    encode: Wz
  },
  decode: zM,
  encode: UM,
  toASCII: Hz,
  toUnicode: Zz
}, qz = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, Xz = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, jz = {
  options: {
    // Enable HTML tags in source
    html: !0,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !0,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, Yz = {
  default: qz,
  zero: Xz,
  commonmark: jz
}, Gz = /^(vbscript|javascript|file|data):/, Kz = /^data:image\/(gif|png|jpeg|webp);/;
function Jz(t) {
  const e = t.trim().toLowerCase();
  return Gz.test(e) ? Kz.test(e) : !0;
}
const VM = ["http:", "https:", "mailto:"];
function eU(t) {
  const e = b2(t, !0);
  if (e.hostname && (!e.protocol || VM.indexOf(e.protocol) >= 0))
    try {
      e.hostname = WM.toASCII(e.hostname);
    } catch {
    }
  return Ud(g2(e));
}
function tU(t) {
  const e = b2(t, !0);
  if (e.hostname && (!e.protocol || VM.indexOf(e.protocol) >= 0))
    try {
      e.hostname = WM.toUnicode(e.hostname);
    } catch {
    }
  return Vl(g2(e), Vl.defaultChars + "%");
}
function Zi(t, e) {
  if (!(this instanceof Zi))
    return new Zi(t, e);
  e || y2(t) || (e = t || {}, t = "default"), this.inline = new Vd(), this.block = new x0(), this.core = new v2(), this.renderer = new mc(), this.linkify = new wi(), this.validateLink = Jz, this.normalizeLink = eU, this.normalizeLinkText = tU, this.utils = iF, this.helpers = _0({}, aF), this.options = {}, this.configure(t), e && this.set(e);
}
Zi.prototype.set = function(t) {
  return _0(this.options, t), this;
};
Zi.prototype.configure = function(t) {
  const e = this;
  if (y2(t)) {
    const n = t;
    if (t = Yz[n], !t)
      throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  }
  if (!t)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t.options && e.set(t.options), t.components && Object.keys(t.components).forEach(function(n) {
    t.components[n].rules && e[n].ruler.enableOnly(t.components[n].rules), t.components[n].rules2 && e[n].ruler2.enableOnly(t.components[n].rules2);
  }), this;
};
Zi.prototype.enable = function(t, e) {
  let n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(r) {
    n = n.concat(this[r].ruler.enable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(t, !0));
  const i = t.filter(function(r) {
    return n.indexOf(r) < 0;
  });
  if (i.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + i);
  return this;
};
Zi.prototype.disable = function(t, e) {
  let n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(r) {
    n = n.concat(this[r].ruler.disable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(t, !0));
  const i = t.filter(function(r) {
    return n.indexOf(r) < 0;
  });
  if (i.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + i);
  return this;
};
Zi.prototype.use = function(t) {
  const e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t.apply(t, e), this;
};
Zi.prototype.parse = function(t, e) {
  if (typeof t != "string")
    throw new Error("Input data should be a String");
  const n = new this.core.State(t, this, e);
  return this.core.process(n), n.tokens;
};
Zi.prototype.render = function(t, e) {
  return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e);
};
Zi.prototype.parseInline = function(t, e) {
  const n = new this.core.State(t, this, e);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
Zi.prototype.renderInline = function(t, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e);
};
const nU = new u0({
  nodes: {
    doc: {
      content: "block+"
    },
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return ["p", 0];
      }
    },
    blockquote: {
      content: "block+",
      group: "block",
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return ["blockquote", 0];
      }
    },
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return ["div", ["hr"]];
      }
    },
    heading: {
      attrs: { level: { default: 1 } },
      content: "(text | image)*",
      group: "block",
      defining: !0,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } }
      ],
      toDOM(t) {
        return ["h" + t.attrs.level, 0];
      }
    },
    code_block: {
      content: "text*",
      group: "block",
      code: !0,
      defining: !0,
      marks: "",
      attrs: { params: { default: "" } },
      parseDOM: [{ tag: "pre", preserveWhitespace: "full", getAttrs: (t) => ({ params: t.getAttribute("data-params") || "" }) }],
      toDOM(t) {
        return ["pre", t.attrs.params ? { "data-params": t.attrs.params } : {}, ["code", 0]];
      }
    },
    ordered_list: {
      content: "list_item+",
      group: "block",
      attrs: { order: { default: 1 }, tight: { default: !1 } },
      parseDOM: [{ tag: "ol", getAttrs(t) {
        return {
          order: t.hasAttribute("start") ? +t.getAttribute("start") : 1,
          tight: t.hasAttribute("data-tight")
        };
      } }],
      toDOM(t) {
        return ["ol", {
          start: t.attrs.order == 1 ? null : t.attrs.order,
          "data-tight": t.attrs.tight ? "true" : null
        }, 0];
      }
    },
    bullet_list: {
      content: "list_item+",
      group: "block",
      attrs: { tight: { default: !1 } },
      parseDOM: [{ tag: "ul", getAttrs: (t) => ({ tight: t.hasAttribute("data-tight") }) }],
      toDOM(t) {
        return ["ul", { "data-tight": t.attrs.tight ? "true" : null }, 0];
      }
    },
    list_item: {
      content: "block+",
      defining: !0,
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return ["li", 0];
      }
    },
    text: {
      group: "inline"
    },
    image: {
      inline: !0,
      attrs: {
        src: {},
        alt: { default: null },
        title: { default: null }
      },
      group: "inline",
      draggable: !0,
      parseDOM: [{ tag: "img[src]", getAttrs(t) {
        return {
          src: t.getAttribute("src"),
          title: t.getAttribute("title"),
          alt: t.getAttribute("alt")
        };
      } }],
      toDOM(t) {
        return ["img", t.attrs];
      }
    },
    hard_break: {
      inline: !0,
      group: "inline",
      selectable: !1,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return ["br"];
      }
    }
  },
  marks: {
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (t) => t.type.name == "em" }
      ],
      toDOM() {
        return ["em"];
      }
    },
    strong: {
      parseDOM: [
        { tag: "strong" },
        { tag: "b", getAttrs: (t) => t.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (t) => t.type.name == "strong" },
        { style: "font-weight", getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null }
      ],
      toDOM() {
        return ["strong"];
      }
    },
    link: {
      attrs: {
        href: {},
        title: { default: null }
      },
      inclusive: !1,
      parseDOM: [{ tag: "a[href]", getAttrs(t) {
        return { href: t.getAttribute("href"), title: t.getAttribute("title") };
      } }],
      toDOM(t) {
        return ["a", t.attrs];
      }
    },
    code: {
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return ["code"];
      }
    }
  }
});
function iU(t, e) {
  if (t.isText && e.isText && nt.sameSet(t.marks, e.marks))
    return t.withText(t.text + e.text);
}
class rU {
  constructor(e, n) {
    this.schema = e, this.tokenHandlers = n, this.stack = [{ type: e.topNodeType, attrs: null, content: [], marks: nt.none }];
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  push(e) {
    this.stack.length && this.top().content.push(e);
  }
  // Adds the given text to the current position in the document,
  // using the current marks as styling.
  addText(e) {
    if (!e)
      return;
    let n = this.top(), i = n.content, r = i[i.length - 1], s = this.schema.text(e, n.marks), o;
    r && (o = iU(r, s)) ? i[i.length - 1] = o : i.push(s);
  }
  // Adds the given mark to the set of active marks.
  openMark(e) {
    let n = this.top();
    n.marks = e.addToSet(n.marks);
  }
  // Removes the given mark from the set of active marks.
  closeMark(e) {
    let n = this.top();
    n.marks = e.removeFromSet(n.marks);
  }
  parseTokens(e) {
    for (let n = 0; n < e.length; n++) {
      let i = e[n], r = this.tokenHandlers[i.type];
      if (!r)
        throw new Error("Token type `" + i.type + "` not supported by Markdown parser");
      r(this, i, e, n);
    }
  }
  // Add a node at the current position.
  addNode(e, n, i) {
    let r = this.top(), s = e.createAndFill(n, i, r ? r.marks : []);
    return s ? (this.push(s), s) : null;
  }
  // Wrap subsequent content in a node of the given type.
  openNode(e, n) {
    this.stack.push({ type: e, attrs: n, content: [], marks: nt.none });
  }
  // Close and return the node that is currently on top of the stack.
  closeNode() {
    let e = this.stack.pop();
    return this.addNode(e.type, e.attrs, e.content);
  }
}
function Rc(t, e, n, i) {
  return t.getAttrs ? t.getAttrs(e, n, i) : t.attrs instanceof Function ? t.attrs(e) : t.attrs;
}
function Fg(t, e) {
  return t.noCloseToken || e == "code_inline" || e == "code_block" || e == "fence";
}
function Ew(t) {
  return t[t.length - 1] == `
` ? t.slice(0, t.length - 1) : t;
}
function zg() {
}
function sU(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i in e) {
    let r = e[i];
    if (r.block) {
      let s = t.nodeType(r.block);
      Fg(r, i) ? n[i] = (o, a, l, c) => {
        o.openNode(s, Rc(r, a, l, c)), o.addText(Ew(a.content)), o.closeNode();
      } : (n[i + "_open"] = (o, a, l, c) => o.openNode(s, Rc(r, a, l, c)), n[i + "_close"] = (o) => o.closeNode());
    } else if (r.node) {
      let s = t.nodeType(r.node);
      n[i] = (o, a, l, c) => o.addNode(s, Rc(r, a, l, c));
    } else if (r.mark) {
      let s = t.marks[r.mark];
      Fg(r, i) ? n[i] = (o, a, l, c) => {
        o.openMark(s.create(Rc(r, a, l, c))), o.addText(Ew(a.content)), o.closeMark(s);
      } : (n[i + "_open"] = (o, a, l, c) => o.openMark(s.create(Rc(r, a, l, c))), n[i + "_close"] = (o) => o.closeMark(s));
    } else if (r.ignore)
      Fg(r, i) ? n[i] = zg : (n[i + "_open"] = zg, n[i + "_close"] = zg);
    else
      throw new RangeError("Unrecognized parsing spec " + JSON.stringify(r));
  }
  return n.text = (i, r) => i.addText(r.content), n.inline = (i, r) => i.parseTokens(r.children), n.softbreak = n.softbreak || ((i) => i.addText(" ")), n;
}
class oU {
  /**
  Create a parser with the given configuration. You can configure
  the markdown-it parser to parse the dialect you want, and provide
  a description of the ProseMirror entities those tokens map to in
  the `tokens` object, which maps token names to descriptions of
  what to do with them. Such a description is an object, and may
  have the following properties:
  */
  constructor(e, n, i) {
    this.schema = e, this.tokenizer = n, this.tokens = i, this.tokenHandlers = sU(e, i);
  }
  /**
  Parse a string as [CommonMark](http://commonmark.org/) markup,
  and create a ProseMirror document as prescribed by this parser's
  rules.
  
  The second argument, when given, is passed through to the
  [Markdown
  parser](https://markdown-it.github.io/markdown-it/#MarkdownIt.parse).
  */
  parse(e, n = {}) {
    let i = new rU(this.schema, this.tokenHandlers), r;
    i.parseTokens(this.tokenizer.parse(e, n));
    do
      r = i.closeNode();
    while (i.stack.length);
    return r || this.schema.topNodeType.createAndFill();
  }
}
function Cw(t, e) {
  for (; ++e < t.length; )
    if (t[e].type != "list_item_open")
      return t[e].hidden;
  return !1;
}
const Eve = new oU(nU, Zi("commonmark", { html: !1 }), {
  blockquote: { block: "blockquote" },
  paragraph: { block: "paragraph" },
  list_item: { block: "list_item" },
  bullet_list: { block: "bullet_list", getAttrs: (t, e, n) => ({ tight: Cw(e, n) }) },
  ordered_list: { block: "ordered_list", getAttrs: (t, e, n) => ({
    order: +t.attrGet("start") || 1,
    tight: Cw(e, n)
  }) },
  heading: { block: "heading", getAttrs: (t) => ({ level: +t.tag.slice(1) }) },
  code_block: { block: "code_block", noCloseToken: !0 },
  fence: { block: "code_block", getAttrs: (t) => ({ params: t.info || "" }), noCloseToken: !0 },
  hr: { node: "horizontal_rule" },
  image: { node: "image", getAttrs: (t) => ({
    src: t.attrGet("src"),
    title: t.attrGet("title") || null,
    alt: t.children[0] && t.children[0].content || null
  }) },
  hardbreak: { node: "hard_break" },
  em: { mark: "em" },
  strong: { mark: "strong" },
  link: { mark: "link", getAttrs: (t) => ({
    href: t.attrGet("href"),
    title: t.attrGet("title") || null
  }) },
  code_inline: { mark: "code", noCloseToken: !0 }
}), aU = { open: "", close: "", mixable: !0 };
class lU {
  /**
  Construct a serializer with the given configuration. The `nodes`
  object should map node names in a given schema to function that
  take a serializer state and such a node, and serialize the node.
  */
  constructor(e, n, i = {}) {
    this.nodes = e, this.marks = n, this.options = i;
  }
  /**
  Serialize the content of the given node to
  [CommonMark](http://commonmark.org/).
  */
  serialize(e, n = {}) {
    n = Object.assign({}, this.options, n);
    let i = new uU(this.nodes, this.marks, n);
    return i.renderContent(e), i.out;
  }
}
const Cve = new lU({
  blockquote(t, e) {
    t.wrapBlock("> ", null, e, () => t.renderContent(e));
  },
  code_block(t, e) {
    const n = e.textContent.match(/`{3,}/gm), i = n ? n.sort().slice(-1)[0] + "`" : "```";
    t.write(i + (e.attrs.params || "") + `
`), t.text(e.textContent, !1), t.write(`
`), t.write(i), t.closeBlock(e);
  },
  heading(t, e) {
    t.write(t.repeat("#", e.attrs.level) + " "), t.renderInline(e, !1), t.closeBlock(e);
  },
  horizontal_rule(t, e) {
    t.write(e.attrs.markup || "---"), t.closeBlock(e);
  },
  bullet_list(t, e) {
    t.renderList(e, "  ", () => (e.attrs.bullet || "*") + " ");
  },
  ordered_list(t, e) {
    let n = e.attrs.order || 1, i = String(n + e.childCount - 1).length, r = t.repeat(" ", i + 2);
    t.renderList(e, r, (s) => {
      let o = String(n + s);
      return t.repeat(" ", i - o.length) + o + ". ";
    });
  },
  list_item(t, e) {
    t.renderContent(e);
  },
  paragraph(t, e) {
    t.renderInline(e), t.closeBlock(e);
  },
  image(t, e) {
    t.write("![" + t.esc(e.attrs.alt || "") + "](" + e.attrs.src.replace(/[\(\)]/g, "\\$&") + (e.attrs.title ? ' "' + e.attrs.title.replace(/"/g, '\\"') + '"' : "") + ")");
  },
  hard_break(t, e, n, i) {
    for (let r = i + 1; r < n.childCount; r++)
      if (n.child(r).type != e.type) {
        t.write(`\\
`);
        return;
      }
  },
  text(t, e) {
    t.text(e.text, !t.inAutolink);
  }
}, {
  em: { open: "*", close: "*", mixable: !0, expelEnclosingWhitespace: !0 },
  strong: { open: "**", close: "**", mixable: !0, expelEnclosingWhitespace: !0 },
  link: {
    open(t, e, n, i) {
      return t.inAutolink = cU(e, n, i), t.inAutolink ? "<" : "[";
    },
    close(t, e, n, i) {
      let { inAutolink: r } = t;
      return t.inAutolink = void 0, r ? ">" : "](" + e.attrs.href.replace(/[\(\)"]/g, "\\$&") + (e.attrs.title ? ` "${e.attrs.title.replace(/"/g, '\\"')}"` : "") + ")";
    },
    mixable: !0
  },
  code: {
    open(t, e, n, i) {
      return Aw(n.child(i), -1);
    },
    close(t, e, n, i) {
      return Aw(n.child(i - 1), 1);
    },
    escape: !1
  }
});
function Aw(t, e) {
  let n = /`+/g, i, r = 0;
  if (t.isText)
    for (; i = n.exec(t.text); )
      r = Math.max(r, i[0].length);
  let s = r > 0 && e > 0 ? " `" : "`";
  for (let o = 0; o < r; o++)
    s += "`";
  return r > 0 && e < 0 && (s += " "), s;
}
function cU(t, e, n) {
  if (t.attrs.title || !/^\w+:/.test(t.attrs.href))
    return !1;
  let i = e.child(n);
  return !i.isText || i.text != t.attrs.href || i.marks[i.marks.length - 1] != t ? !1 : n == e.childCount - 1 || !t.isInSet(e.child(n + 1).marks);
}
class uU {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.nodes = e, this.marks = n, this.options = i, this.delim = "", this.out = "", this.closed = null, this.inAutolink = void 0, this.atBlockStart = !1, this.inTightList = !1, typeof this.options.tightLists > "u" && (this.options.tightLists = !1), typeof this.options.hardBreakNodeName > "u" && (this.options.hardBreakNodeName = "hard_break");
  }
  /**
  @internal
  */
  flushClose(e = 2) {
    if (this.closed) {
      if (this.atBlank() || (this.out += `
`), e > 1) {
        let n = this.delim, i = /\s+$/.exec(n);
        i && (n = n.slice(0, n.length - i[0].length));
        for (let r = 1; r < e; r++)
          this.out += n + `
`;
      }
      this.closed = null;
    }
  }
  /**
  @internal
  */
  getMark(e) {
    let n = this.marks[e];
    if (!n) {
      if (this.options.strict !== !1)
        throw new Error(`Mark type \`${e}\` not supported by Markdown renderer`);
      n = aU;
    }
    return n;
  }
  /**
  Render a block, prefixing each line with `delim`, and the first
  line in `firstDelim`. `node` should be the node that is closed at
  the end of the block, and `f` is a function that renders the
  content of the block.
  */
  wrapBlock(e, n, i, r) {
    let s = this.delim;
    this.write(n ?? e), this.delim += e, r(), this.delim = s, this.closeBlock(i);
  }
  /**
  @internal
  */
  atBlank() {
    return /(^|\n)$/.test(this.out);
  }
  /**
  Ensure the current content ends with a newline.
  */
  ensureNewLine() {
    this.atBlank() || (this.out += `
`);
  }
  /**
  Prepare the state for writing output (closing closed paragraphs,
  adding delimiters, and so on), and then optionally add content
  (unescaped) to the output.
  */
  write(e) {
    this.flushClose(), this.delim && this.atBlank() && (this.out += this.delim), e && (this.out += e);
  }
  /**
  Close the block for the given node.
  */
  closeBlock(e) {
    this.closed = e;
  }
  /**
  Add the given text to the document. When escape is not `false`,
  it will be escaped.
  */
  text(e, n = !0) {
    let i = e.split(`
`);
    for (let r = 0; r < i.length; r++)
      this.write(), !n && i[r][0] == "[" && /(^|[^\\])\!$/.test(this.out) && (this.out = this.out.slice(0, this.out.length - 1) + "\\!"), this.out += n ? this.esc(i[r], this.atBlockStart) : i[r], r != i.length - 1 && (this.out += `
`);
  }
  /**
  Render the given node as a block.
  */
  render(e, n, i) {
    if (this.nodes[e.type.name])
      this.nodes[e.type.name](this, e, n, i);
    else {
      if (this.options.strict !== !1)
        throw new Error("Token type `" + e.type.name + "` not supported by Markdown renderer");
      e.type.isLeaf || (e.type.inlineContent ? this.renderInline(e) : this.renderContent(e), e.isBlock && this.closeBlock(e));
    }
  }
  /**
  Render the contents of `parent` as block nodes.
  */
  renderContent(e) {
    e.forEach((n, i, r) => this.render(n, e, r));
  }
  /**
  Render the contents of `parent` as inline content.
  */
  renderInline(e, n = !0) {
    this.atBlockStart = n;
    let i = [], r = "", s = (o, a, l) => {
      let c = o ? o.marks : [];
      o && o.type.name === this.options.hardBreakNodeName && (c = c.filter((m) => {
        if (l + 1 == e.childCount)
          return !1;
        let g = e.child(l + 1);
        return m.isInSet(g.marks) && (!g.isText || /\S/.test(g.text));
      }));
      let u = r;
      if (r = "", o && o.isText && c.some((m) => {
        let g = this.getMark(m.type.name);
        return g && g.expelEnclosingWhitespace && !m.isInSet(i);
      })) {
        let [m, g, b] = /^(\s*)(.*)$/m.exec(o.text);
        g && (u += g, o = b ? o.withText(b) : null, o || (c = i));
      }
      if (o && o.isText && c.some((m) => {
        let g = this.getMark(m.type.name);
        return g && g.expelEnclosingWhitespace && (l == e.childCount - 1 || !m.isInSet(e.child(l + 1).marks));
      })) {
        let [m, g, b] = /^(.*?)(\s*)$/m.exec(o.text);
        b && (r = b, o = g ? o.withText(g) : null, o || (c = i));
      }
      let d = c.length ? c[c.length - 1] : null, h = d && this.getMark(d.type.name).escape === !1, f = c.length - (h ? 1 : 0);
      e: for (let m = 0; m < f; m++) {
        let g = c[m];
        if (!this.getMark(g.type.name).mixable)
          break;
        for (let b = 0; b < i.length; b++) {
          let _ = i[b];
          if (!this.getMark(_.type.name).mixable)
            break;
          if (g.eq(_)) {
            m > b ? c = c.slice(0, b).concat(g).concat(c.slice(b, m)).concat(c.slice(m + 1, f)) : b > m && (c = c.slice(0, m).concat(c.slice(m + 1, b)).concat(g).concat(c.slice(b, f)));
            continue e;
          }
        }
      }
      let p = 0;
      for (; p < Math.min(i.length, f) && c[p].eq(i[p]); )
        ++p;
      for (; p < i.length; )
        this.text(this.markString(i.pop(), !1, e, l), !1);
      if (u && this.text(u), o) {
        for (; i.length < f; ) {
          let m = c[i.length];
          i.push(m), this.text(this.markString(m, !0, e, l), !1), this.atBlockStart = !1;
        }
        h && o.isText ? this.text(this.markString(d, !0, e, l) + o.text + this.markString(d, !1, e, l + 1), !1) : this.render(o, e, l), this.atBlockStart = !1;
      }
      o != null && o.isText && o.nodeSize > 0 && (this.atBlockStart = !1);
    };
    e.forEach(s), s(null, 0, e.childCount), this.atBlockStart = !1;
  }
  /**
  Render a node's content as a list. `delim` should be the extra
  indentation added to all lines except the first in an item,
  `firstDelim` is a function going from an item index to a
  delimiter for the first line of the item.
  */
  renderList(e, n, i) {
    this.closed && this.closed.type == e.type ? this.flushClose(3) : this.inTightList && this.flushClose(1);
    let r = typeof e.attrs.tight < "u" ? e.attrs.tight : this.options.tightLists, s = this.inTightList;
    this.inTightList = r, e.forEach((o, a, l) => {
      l && r && this.flushClose(1), this.wrapBlock(n, i(l), e, () => this.render(o, e, l));
    }), this.inTightList = s;
  }
  /**
  Escape the given string so that it can safely appear in Markdown
  content. If `startOfLine` is true, also escape characters that
  have special meaning only at the start of the line.
  */
  esc(e, n = !1) {
    return e = e.replace(/[`*\\~\[\]_]/g, (i, r) => i == "_" && r > 0 && r + 1 < e.length && e[r - 1].match(/\w/) && e[r + 1].match(/\w/) ? i : "\\" + i), n && (e = e.replace(/^(\+[ ]|[\-*>])/, "\\$&").replace(/^(\s*)(#{1,6})(\s|$)/, "$1\\$2$3").replace(/^(\s*\d+)\.\s/, "$1\\. ")), this.options.escapeExtraCharacters && (e = e.replace(this.options.escapeExtraCharacters, "\\$&")), e;
  }
  /**
  @internal
  */
  quote(e) {
    let n = e.indexOf('"') == -1 ? '""' : e.indexOf("'") == -1 ? "''" : "()";
    return n[0] + e + n[1];
  }
  /**
  Repeat the given string `n` times.
  */
  repeat(e, n) {
    let i = "";
    for (let r = 0; r < n; r++)
      i += e;
    return i;
  }
  /**
  Get the markdown string for a given opening or closing mark.
  */
  markString(e, n, i, r) {
    let s = this.getMark(e.type.name), o = n ? s.open : s.close;
    return typeof o == "string" ? o : o(this, e, i, r);
  }
  /**
  Get leading and trailing whitespace from a string. Values of
  leading or trailing property of the return object will be undefined
  if there is no match.
  */
  getEnclosingWhitespace(e) {
    return {
      leading: (e.match(/^(\s+)/) || [void 0])[0],
      trailing: (e.match(/(\s+)$/) || [void 0])[0]
    };
  }
}
function Fe() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var i in n) if (Object.prototype.hasOwnProperty.call(n, i)) {
      var r = n[i];
      typeof r == "string" ? t.setAttribute(i, r) : r != null && (t[i] = r);
    }
    e++;
  }
  for (; e < arguments.length; e++) ZM(t, arguments[e]);
  return t;
}
function ZM(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var n = 0; n < e.length; n++) ZM(t, e[n]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
const pu = "http://www.w3.org/2000/svg", dU = "http://www.w3.org/1999/xlink", Kb = "ProseMirror-icon";
function hU(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++)
    e = (e << 5) - e + t.charCodeAt(n) | 0;
  return e;
}
function fU(t, e) {
  let n = (t.nodeType == 9 ? t : t.ownerDocument) || document, i = n.createElement("div");
  if (i.className = Kb, e.path) {
    let { path: r, width: s, height: o } = e, a = "pm-icon-" + hU(r).toString(16);
    n.getElementById(a) || pU(t, a, e);
    let l = i.appendChild(n.createElementNS(pu, "svg"));
    l.style.width = s / o + "em", l.appendChild(n.createElementNS(pu, "use")).setAttributeNS(dU, "href", /([^#]*)/.exec(n.location.toString())[1] + "#" + a);
  } else if (e.dom)
    i.appendChild(e.dom.cloneNode(!0));
  else {
    let { text: r, css: s } = e;
    i.appendChild(n.createElement("span")).textContent = r || "", s && (i.firstChild.style.cssText = s);
  }
  return i;
}
function pU(t, e, n) {
  let [i, r] = t.nodeType == 9 ? [t, t.body] : [t.ownerDocument || document, t], s = i.getElementById(Kb + "-collection");
  s || (s = i.createElementNS(pu, "svg"), s.id = Kb + "-collection", s.style.display = "none", r.insertBefore(s, r.firstChild));
  let o = i.createElementNS(pu, "symbol");
  o.id = e, o.setAttribute("viewBox", "0 0 " + n.width + " " + n.height), o.appendChild(i.createElementNS(pu, "path")).setAttribute("d", n.path), s.appendChild(o);
}
const Kn = "ProseMirror-menu";
class Va {
  /**
  Create a menu item.
  */
  constructor(e) {
    this.spec = e;
  }
  /**
  Renders the icon according to its [display
  spec](https://prosemirror.net/docs/ref/#menu.MenuItemSpec.display), and adds an event handler which
  executes the command when the representation is clicked.
  */
  render(e) {
    let n = this.spec, i = n.render ? n.render(e) : n.icon ? fU(e.root, n.icon) : n.label ? Fe("div", null, Gu(e, n.label)) : null;
    if (!i)
      throw new RangeError("MenuItem without icon or label property");
    if (n.title) {
      const s = typeof n.title == "function" ? n.title(e.state) : n.title;
      i.setAttribute("title", Gu(e, s));
    }
    n.class && i.classList.add(n.class), n.css && (i.style.cssText += n.css), i.addEventListener("mousedown", (s) => {
      s.preventDefault(), i.classList.contains(Kn + "-disabled") || n.run(e.state, e.dispatch, e, s);
    });
    function r(s) {
      if (n.select) {
        let a = n.select(s);
        if (i.style.display = a ? "" : "none", !a)
          return !1;
      }
      let o = !0;
      if (n.enable && (o = n.enable(s) || !1, Jb(i, Kn + "-disabled", !o)), n.active) {
        let a = o && n.active(s) || !1;
        Jb(i, Kn + "-active", a);
      }
      return !0;
    }
    return { dom: i, update: r };
  }
}
function Gu(t, e) {
  return t._props.translate ? t._props.translate(e) : e;
}
let mu = { time: 0, node: null };
function HM(t) {
  mu.time = Date.now(), mu.node = t.target;
}
function qM(t) {
  return Date.now() - 100 < mu.time && mu.node && t.contains(mu.node);
}
class Ave {
  /**
  Create a dropdown wrapping the elements.
  */
  constructor(e, n = {}) {
    this.options = n, this.options = n || {}, this.content = Array.isArray(e) ? e : [e];
  }
  /**
  Render the dropdown menu and sub-items.
  */
  render(e) {
    let n = XM(this.content, e), i = e.dom.ownerDocument.defaultView || window, r = Fe("div", {
      class: Kn + "-dropdown " + (this.options.class || ""),
      style: this.options.css
    }, Gu(e, this.options.label || ""));
    this.options.title && r.setAttribute("title", Gu(e, this.options.title));
    let s = Fe("div", { class: Kn + "-dropdown-wrap" }, r), o = null, a = null, l = () => {
      o && o.close() && (o = null, i.removeEventListener("mousedown", a));
    };
    r.addEventListener("mousedown", (u) => {
      u.preventDefault(), HM(u), o ? l() : (o = this.expand(s, n.dom), i.addEventListener("mousedown", a = () => {
        qM(s) || l();
      }));
    });
    function c(u) {
      let d = n.update(u);
      return s.style.display = d ? "" : "none", d;
    }
    return { dom: s, update: c };
  }
  /**
  @internal
  */
  expand(e, n) {
    let i = Fe("div", { class: Kn + "-dropdown-menu " + (this.options.class || "") }, n), r = !1;
    function s() {
      return r ? !1 : (r = !0, e.removeChild(i), !0);
    }
    return e.appendChild(i), { close: s, node: i };
  }
}
function XM(t, e) {
  let n = [], i = [];
  for (let r = 0; r < t.length; r++) {
    let { dom: s, update: o } = t[r].render(e);
    n.push(Fe("div", { class: Kn + "-dropdown-item" }, s)), i.push(o);
  }
  return { dom: n, update: jM(i, n) };
}
function jM(t, e) {
  return (n) => {
    let i = !1;
    for (let r = 0; r < t.length; r++) {
      let s = t[r](n);
      e[r].style.display = s ? "" : "none", s && (i = !0);
    }
    return i;
  };
}
class Tve {
  /**
  Creates a submenu for the given group of menu elements. The
  following options are recognized:
  */
  constructor(e, n = {}) {
    this.options = n, this.content = Array.isArray(e) ? e : [e];
  }
  /**
  Renders the submenu.
  */
  render(e) {
    let n = XM(this.content, e), i = e.dom.ownerDocument.defaultView || window, r = Fe("div", { class: Kn + "-submenu-label" }, Gu(e, this.options.label || "")), s = Fe("div", { class: Kn + "-submenu-wrap" }, r, Fe("div", { class: Kn + "-submenu" }, n.dom)), o = null;
    r.addEventListener("mousedown", (l) => {
      l.preventDefault(), HM(l), Jb(s, Kn + "-submenu-wrap-active", !1), o || i.addEventListener("mousedown", o = () => {
        qM(s) || (s.classList.remove(Kn + "-submenu-wrap-active"), i.removeEventListener("mousedown", o), o = null);
      });
    });
    function a(l) {
      let c = n.update(l);
      return s.style.display = c ? "" : "none", c;
    }
    return { dom: s, update: a };
  }
}
function mU(t, e) {
  let n = document.createDocumentFragment(), i = [], r = [];
  for (let o = 0; o < e.length; o++) {
    let a = e[o], l = [], c = [];
    for (let u = 0; u < a.length; u++) {
      let { dom: d, update: h } = a[u].render(t), f = Fe("span", { class: Kn + "item" }, d);
      n.appendChild(f), c.push(f), l.push(h);
    }
    l.length && (i.push(jM(l, c)), o < e.length - 1 && r.push(n.appendChild(gU())));
  }
  function s(o) {
    let a = !1, l = !1;
    for (let c = 0; c < i.length; c++) {
      let u = i[c](o);
      c && (r[c - 1].style.display = l && u ? "" : "none"), l = u, u && (a = !0);
    }
    return a;
  }
  return { dom: n, update: s };
}
function gU() {
  return Fe("span", { class: Kn + "separator" });
}
const Zd = {
  join: {
    width: 800,
    height: 900,
    path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
  },
  lift: {
    width: 1024,
    height: 1024,
    path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
  },
  selectParentNode: { text: "", css: "font-weight: bold" },
  undo: {
    width: 1024,
    height: 1024,
    path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
  },
  redo: {
    width: 1024,
    height: 1024,
    path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
  },
  strong: {
    width: 805,
    height: 1024,
    path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
  },
  em: {
    width: 585,
    height: 1024,
    path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
  },
  code: {
    width: 896,
    height: 1024,
    path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
  },
  link: {
    width: 951,
    height: 1024,
    path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
  },
  bulletList: {
    width: 768,
    height: 896,
    path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
  },
  orderedList: {
    width: 768,
    height: 896,
    path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
  },
  blockquote: {
    width: 640,
    height: 896,
    path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
  }
}, Mve = new Va({
  title: "Join with above block",
  run: $b,
  select: (t) => $b(t),
  icon: Zd.join
}), Pve = new Va({
  title: "Lift out of enclosing block",
  run: Nb,
  select: (t) => Nb(t),
  icon: Zd.lift
}), Rve = new Va({
  title: "Select parent node",
  run: Db,
  select: (t) => Db(t),
  icon: Zd.selectParentNode
});
let $ve = new Va({
  title: "Undo last change",
  run: Rp,
  enable: (t) => Rp(t),
  icon: Zd.undo
}), Nve = new Va({
  title: "Redo last undone change",
  run: $p,
  enable: (t) => $p(t),
  icon: Zd.redo
});
function Dve(t, e) {
  let n = {
    run(i, r) {
      return Ib(t, e.attrs)(i, r);
    },
    select(i) {
      return Ib(t, e.attrs)(i);
    }
  };
  for (let i in e)
    n[i] = e[i];
  return new Va(n);
}
function Ive(t, e) {
  let n = Lb(t, e.attrs), i = {
    run: n,
    enable(r) {
      return n(r);
    },
    active(r) {
      let { $from: s, to: o, node: a } = r.selection;
      return a ? a.hasMarkup(t, e.attrs) : o <= s.end() && s.parent.hasMarkup(t, e.attrs);
    }
  };
  for (let r in e)
    i[r] = e[r];
  return new Va(i);
}
function Jb(t, e, n) {
  n ? t.classList.add(e) : t.classList.remove(e);
}
const $h = "ProseMirror-menubar";
function bU() {
  if (typeof navigator > "u")
    return !1;
  let t = navigator.userAgent;
  return !/Edge\/\d/.test(t) && /AppleWebKit/.test(t) && /Mobile\/\w+/.test(t);
}
function Lve(t) {
  return new Ue({
    view(e) {
      return new OU(e, t);
    }
  });
}
class OU {
  constructor(e, n) {
    this.editorView = e, this.options = n, this.spacer = null, this.maxHeight = 0, this.widthForMaxHeight = 0, this.floating = !1, this.scrollHandler = null, this.wrapper = Fe("div", { class: $h + "-wrapper" }), this.menu = this.wrapper.appendChild(Fe("div", { class: $h })), this.menu.className = $h, e.dom.parentNode && e.dom.parentNode.replaceChild(this.wrapper, e.dom), this.wrapper.appendChild(e.dom);
    let { dom: i, update: r } = mU(this.editorView, this.options.content);
    if (this.contentUpdate = r, this.menu.appendChild(i), this.update(), n.floating && !bU()) {
      this.updateFloat();
      let s = vU(this.wrapper);
      this.scrollHandler = (o) => {
        let a = this.editorView.root;
        (a.body || a).contains(this.wrapper) ? this.updateFloat(o.target.getBoundingClientRect ? o.target : void 0) : s.forEach((l) => l.removeEventListener("scroll", this.scrollHandler));
      }, s.forEach((o) => o.addEventListener("scroll", this.scrollHandler));
    }
  }
  update() {
    this.contentUpdate(this.editorView.state), this.floating ? this.updateScrollCursor() : (this.menu.offsetWidth != this.widthForMaxHeight && (this.widthForMaxHeight = this.menu.offsetWidth, this.maxHeight = 0), this.menu.offsetHeight > this.maxHeight && (this.maxHeight = this.menu.offsetHeight, this.menu.style.minHeight = this.maxHeight + "px"));
  }
  updateScrollCursor() {
    let e = this.editorView.root.getSelection();
    if (!e.focusNode)
      return;
    let n = e.getRangeAt(0).getClientRects(), i = n[yU(e) ? 0 : n.length - 1];
    if (!i)
      return;
    let r = this.menu.getBoundingClientRect();
    if (i.top < r.bottom && i.bottom > r.top) {
      let s = _U(this.wrapper);
      s && (s.scrollTop -= r.bottom - i.top);
    }
  }
  updateFloat(e) {
    let n = this.wrapper, i = n.getBoundingClientRect(), r = e ? Math.max(0, e.getBoundingClientRect().top) : 0;
    if (this.floating)
      if (i.top >= r || i.bottom < this.menu.offsetHeight + 10)
        this.floating = !1, this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "", this.menu.style.display = "", this.spacer.parentNode.removeChild(this.spacer), this.spacer = null;
      else {
        let s = (n.offsetWidth - n.clientWidth) / 2;
        this.menu.style.left = i.left + s + "px", this.menu.style.display = i.top > (this.editorView.dom.ownerDocument.defaultView || window).innerHeight ? "none" : "", e && (this.menu.style.top = r + "px");
      }
    else if (i.top < r && i.bottom >= this.menu.offsetHeight + 10) {
      this.floating = !0;
      let s = this.menu.getBoundingClientRect();
      this.menu.style.left = s.left + "px", this.menu.style.width = s.width + "px", e && (this.menu.style.top = r + "px"), this.menu.style.position = "fixed", this.spacer = Fe("div", { class: $h + "-spacer", style: `height: ${s.height}px` }), n.insertBefore(this.spacer, this.menu);
    }
  }
  destroy() {
    this.wrapper.parentNode && this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);
  }
}
function yU(t) {
  return t.anchorNode == t.focusNode ? t.anchorOffset > t.focusOffset : t.anchorNode.compareDocumentPosition(t.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING;
}
function _U(t) {
  for (let e = t.parentNode; e; e = e.parentNode)
    if (e.scrollHeight > e.clientHeight)
      return e;
}
function vU(t) {
  let e = [t.ownerDocument.defaultView || window];
  for (let n = t.parentNode; n; n = n.parentNode)
    e.push(n);
  return e;
}
const xU = ["p", 0], wU = ["blockquote", 0], SU = ["hr"], kU = ["pre", ["code", 0]], EU = ["br"], CU = {
  /**
  NodeSpec The top level document node.
  */
  doc: {
    content: "block+"
  },
  /**
  A plain paragraph textblock. Represented in the DOM
  as a `<p>` element.
  */
  paragraph: {
    content: "inline*",
    group: "block",
    parseDOM: [{ tag: "p" }],
    toDOM() {
      return xU;
    }
  },
  /**
  A blockquote (`<blockquote>`) wrapping one or more blocks.
  */
  blockquote: {
    content: "block+",
    group: "block",
    defining: !0,
    parseDOM: [{ tag: "blockquote" }],
    toDOM() {
      return wU;
    }
  },
  /**
  A horizontal rule (`<hr>`).
  */
  horizontal_rule: {
    group: "block",
    parseDOM: [{ tag: "hr" }],
    toDOM() {
      return SU;
    }
  },
  /**
  A heading textblock, with a `level` attribute that
  should hold the number 1 to 6. Parsed and serialized as `<h1>` to
  `<h6>` elements.
  */
  heading: {
    attrs: { level: { default: 1, validate: "number" } },
    content: "inline*",
    group: "block",
    defining: !0,
    parseDOM: [
      { tag: "h1", attrs: { level: 1 } },
      { tag: "h2", attrs: { level: 2 } },
      { tag: "h3", attrs: { level: 3 } },
      { tag: "h4", attrs: { level: 4 } },
      { tag: "h5", attrs: { level: 5 } },
      { tag: "h6", attrs: { level: 6 } }
    ],
    toDOM(t) {
      return ["h" + t.attrs.level, 0];
    }
  },
  /**
  A code listing. Disallows marks or non-text inline
  nodes by default. Represented as a `<pre>` element with a
  `<code>` element inside of it.
  */
  code_block: {
    content: "text*",
    marks: "",
    group: "block",
    code: !0,
    defining: !0,
    parseDOM: [{ tag: "pre", preserveWhitespace: "full" }],
    toDOM() {
      return kU;
    }
  },
  /**
  The text node.
  */
  text: {
    group: "inline"
  },
  /**
  An inline image (`<img>`) node. Supports `src`,
  `alt`, and `href` attributes. The latter two default to the empty
  string.
  */
  image: {
    inline: !0,
    attrs: {
      src: { validate: "string" },
      alt: { default: null, validate: "string|null" },
      title: { default: null, validate: "string|null" }
    },
    group: "inline",
    draggable: !0,
    parseDOM: [{ tag: "img[src]", getAttrs(t) {
      return {
        src: t.getAttribute("src"),
        title: t.getAttribute("title"),
        alt: t.getAttribute("alt")
      };
    } }],
    toDOM(t) {
      let { src: e, alt: n, title: i } = t.attrs;
      return ["img", { src: e, alt: n, title: i }];
    }
  },
  /**
  A hard line break, represented in the DOM as `<br>`.
  */
  hard_break: {
    inline: !0,
    group: "inline",
    selectable: !1,
    parseDOM: [{ tag: "br" }],
    toDOM() {
      return EU;
    }
  }
}, AU = ["em", 0], TU = ["strong", 0], MU = ["code", 0], PU = {
  /**
  A link. Has `href` and `title` attributes. `title`
  defaults to the empty string. Rendered and parsed as an `<a>`
  element.
  */
  link: {
    attrs: {
      href: { validate: "string" },
      title: { default: null, validate: "string|null" }
    },
    inclusive: !1,
    parseDOM: [{ tag: "a[href]", getAttrs(t) {
      return { href: t.getAttribute("href"), title: t.getAttribute("title") };
    } }],
    toDOM(t) {
      let { href: e, title: n } = t.attrs;
      return ["a", { href: e, title: n }, 0];
    }
  },
  /**
  An emphasis mark. Rendered as an `<em>` element. Has parse rules
  that also match `<i>` and `font-style: italic`.
  */
  em: {
    parseDOM: [
      { tag: "i" },
      { tag: "em" },
      { style: "font-style=italic" },
      { style: "font-style=normal", clearMark: (t) => t.type.name == "em" }
    ],
    toDOM() {
      return AU;
    }
  },
  /**
  A strong mark. Rendered as `<strong>`, parse rules also match
  `<b>` and `font-weight: bold`.
  */
  strong: {
    parseDOM: [
      { tag: "strong" },
      // This works around a Google Docs misbehavior where
      // pasted content will be inexplicably wrapped in `<b>`
      // tags with a font-weight normal.
      { tag: "b", getAttrs: (t) => t.style.fontWeight != "normal" && null },
      { style: "font-weight=400", clearMark: (t) => t.type.name == "strong" },
      { style: "font-weight", getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null }
    ],
    toDOM() {
      return TU;
    }
  },
  /**
  Code font mark. Represented as a `<code>` element.
  */
  code: {
    parseDOM: [{ tag: "code" }],
    toDOM() {
      return MU;
    }
  }
}, Bve = new u0({ nodes: CU, marks: PU }), RU = ["ol", 0], $U = ["ul", 0], NU = ["li", 0], DU = {
  attrs: { order: { default: 1, validate: "number" } },
  parseDOM: [{ tag: "ol", getAttrs(t) {
    return { order: t.hasAttribute("start") ? +t.getAttribute("start") : 1 };
  } }],
  toDOM(t) {
    return t.attrs.order == 1 ? RU : ["ol", { start: t.attrs.order }, 0];
  }
}, IU = {
  parseDOM: [{ tag: "ul" }],
  toDOM() {
    return $U;
  }
}, LU = {
  parseDOM: [{ tag: "li" }],
  toDOM() {
    return NU;
  },
  defining: !0
};
function Ug(t, e) {
  let n = {};
  for (let i in t)
    n[i] = t[i];
  for (let i in e)
    n[i] = e[i];
  return n;
}
function Qve(t, e, n) {
  return t.append({
    ordered_list: Ug(DU, { content: "list_item+", group: n }),
    bullet_list: Ug(IU, { content: "list_item+", group: n }),
    list_item: Ug(LU, { content: e })
  });
}
function BU(t, e = null) {
  return function(n, i) {
    let { $from: r, $to: s } = n.selection, o = r.blockRange(s), a = !1, l = o;
    if (!o)
      return !1;
    if (o.depth >= 2 && r.node(o.depth - 1).type.compatibleContent(t) && o.startIndex == 0) {
      if (r.index(o.depth - 1) == 0)
        return !1;
      let u = n.doc.resolve(o.start - 2);
      l = new Sp(u, u, o.depth), o.endIndex < o.parent.childCount && (o = new Sp(r, n.doc.resolve(s.end(o.depth)), o.depth)), a = !0;
    }
    let c = d0(l, t, e, o);
    return c ? (i && i(QU(n.tr, o, c, a, t).scrollIntoView()), !0) : !1;
  };
}
function QU(t, e, n, i, r) {
  let s = Y.empty;
  for (let u = n.length - 1; u >= 0; u--)
    s = Y.from(n[u].type.create(n[u].attrs, s));
  t.step(new on(e.start - (i ? 2 : 0), e.end, e.start, e.end, new ne(s, 0, 0), n.length, !0));
  let o = 0;
  for (let u = 0; u < n.length; u++)
    n[u].type == r && (o = u + 1);
  let a = n.length - o, l = e.start + n.length - (i ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, h = !0; u < d; u++, h = !1)
    !h && Vr(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += c.child(u).nodeSize;
  return t;
}
function FU(t, e) {
  return function(n, i) {
    let { $from: r, $to: s, node: o } = n.selection;
    if (o && o.isBlock || r.depth < 2 || !r.sameParent(s))
      return !1;
    let a = r.node(-1);
    if (a.type != t)
      return !1;
    if (r.parent.content.size == 0 && r.node(-1).childCount == r.indexAfter(-1)) {
      if (r.depth == 3 || r.node(-3).type != t || r.index(-2) != r.node(-2).childCount - 1)
        return !1;
      if (i) {
        let d = Y.empty, h = r.index(-1) ? 1 : r.index(-2) ? 2 : 3;
        for (let b = r.depth - h; b >= r.depth - 3; b--)
          d = Y.from(r.node(b).copy(d));
        let f = r.indexAfter(-1) < r.node(-2).childCount ? 1 : r.indexAfter(-2) < r.node(-3).childCount ? 2 : 3;
        d = d.append(Y.from(t.createAndFill()));
        let p = r.before(r.depth - (h - 1)), m = n.tr.replace(p, r.after(-f), new ne(d, 4 - h, 0)), g = -1;
        m.doc.nodesBetween(p, m.doc.content.size, (b, _) => {
          if (g > -1)
            return !1;
          b.isTextblock && b.content.size == 0 && (g = _ + 1);
        }), g > -1 && m.setSelection(_e.near(m.doc.resolve(g))), i(m.scrollIntoView());
      }
      return !0;
    }
    let l = s.pos == r.end() ? a.contentMatchAt(0).defaultType : null, c = n.tr.delete(r.pos, s.pos), u = l ? [e ? { type: t, attrs: e } : null, { type: l }] : void 0;
    return Vr(c.doc, r.pos, 2, u) ? (i && i(c.split(r.pos, 2, u).scrollIntoView()), !0) : !1;
  };
}
function Fve(t, e) {
  let n = FU(t, e);
  return (i, r) => n(i, r && ((s) => {
    let o = i.storedMarks || i.selection.$to.parentOffset && i.selection.$from.marks();
    o && s.ensureMarks(o), r(s);
  }));
}
function zU(t) {
  return function(e, n) {
    let { $from: i, $to: r } = e.selection, s = i.blockRange(r, (o) => o.childCount > 0 && o.firstChild.type == t);
    return s ? n ? i.node(s.depth - 1).type == t ? UU(e, n, t, s) : WU(e, n, s) : !0 : !1;
  };
}
function UU(t, e, n, i) {
  let r = t.tr, s = i.end, o = i.$to.end(i.depth);
  s < o && (r.step(new on(s - 1, o, s, o, new ne(Y.from(n.create(null, i.parent.copy())), 1, 0), 1, !0)), i = new Sp(r.doc.resolve(i.$from.pos), r.doc.resolve(o), i.depth));
  const a = pc(i);
  if (a == null)
    return !1;
  r.lift(i, a);
  let l = r.mapping.map(s, -1) - 1;
  return es(r.doc, l) && r.join(l), e(r.scrollIntoView()), !0;
}
function WU(t, e, n) {
  let i = t.tr, r = n.parent;
  for (let f = n.end, p = n.endIndex - 1, m = n.startIndex; p > m; p--)
    f -= r.child(p).nodeSize, i.delete(f - 1, f + 1);
  let s = i.doc.resolve(n.start), o = s.nodeAfter;
  if (i.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == r.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, o.content.append(l ? Y.empty : Y.from(r))))
    return !1;
  let d = s.pos, h = d + o.nodeSize;
  return i.step(new on(d - (a ? 1 : 0), h + (l ? 1 : 0), d + 1, h - 1, new ne((a ? Y.empty : Y.from(r.copy(Y.empty))).append(l ? Y.empty : Y.from(r.copy(Y.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(i.scrollIntoView()), !0;
}
function VU(t) {
  return function(e, n) {
    let { $from: i, $to: r } = e.selection, s = i.blockRange(r, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let a = s.parent, l = a.child(o - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type, u = Y.from(c ? t.create() : null), d = new ne(Y.from(t.create(null, Y.from(a.type.create(null, u)))), c ? 3 : 1, 0), h = s.start, f = s.end;
      n(e.tr.step(new on(h - (c ? 3 : 1), f, h, f, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
var eO, tO;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  eO = (e) => t.get(e), tO = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  eO = (i) => {
    for (let r = 0; r < t.length; r += 2)
      if (t[r] == i)
        return t[r + 1];
  }, tO = (i, r) => (n == 10 && (n = 0), t[n++] = i, t[n++] = r);
}
var Je = class {
  constructor(t, e, n, i) {
    this.width = t, this.height = e, this.map = n, this.problems = i;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t)
        continue;
      const i = e % this.width, r = e / this.width | 0;
      let s = i + 1, o = r + 1;
      for (let a = 1; s < this.width && this.map[e + a] == n; a++)
        s++;
      for (let a = 1; o < this.height && this.map[e + this.width * a] == n; a++)
        o++;
      return { left: i, top: r, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: i, right: r, top: s, bottom: o } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? i == 0 : r == this.width) ? null : this.map[s * this.width + (n < 0 ? i - 1 : r)] : (n < 0 ? s == 0 : o == this.height) ? null : this.map[i + this.width * (n < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: i,
      top: r,
      bottom: s
    } = this.findCell(t), {
      left: o,
      right: a,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(n, o),
      top: Math.min(r, l),
      right: Math.max(i, a),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let i = t.top; i < t.bottom; i++)
      for (let r = t.left; r < t.right; r++) {
        const s = i * this.width + r, o = this.map[s];
        n[o] || (n[o] = !0, !(r == t.left && r && this.map[s - 1] == o || i == t.top && i && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let i = 0, r = 0; ; i++) {
      const s = r + n.child(i).nodeSize;
      if (i == t) {
        let o = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; o < a && this.map[o] < r; )
          o++;
        return o == a ? s - 1 : this.map[o];
      }
      r = s;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return eO(t) || tO(t, ZU(t));
  }
};
function ZU(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = HU(t), n = t.childCount, i = [];
  let r = 0, s = null;
  const o = [];
  for (let c = 0, u = e * n; c < u; c++)
    i[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = t.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; r < i.length && i[r] != 0; )
        r++;
      if (p == d.childCount)
        break;
      const m = d.child(p), { colspan: g, rowspan: b, colwidth: _ } = m.attrs;
      for (let y = 0; y < b; y++) {
        if (y + c >= n) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: b - y
          });
          break;
        }
        const O = r + y * e;
        for (let x = 0; x < g; x++) {
          i[O + x] == 0 ? i[O + x] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: g - x
          });
          const v = _ && _[x];
          if (v) {
            const w = (O + x) % e * 2, T = o[w];
            T == null || T != v && o[w + 1] == 1 ? (o[w] = v, o[w + 1] = 1) : T == v && o[w + 1]++;
          }
        }
      }
      r += g, u += m.nodeSize;
    }
    const h = (c + 1) * e;
    let f = 0;
    for (; r < h; )
      i[r++] == 0 && f++;
    f && (s || (s = [])).push({ type: "missing", row: c, n: f }), u++;
  }
  const a = new Je(e, n, i, s);
  let l = !1;
  for (let c = 0; !l && c < o.length; c += 2)
    o[c] != null && o[c + 1] < n && (l = !0);
  return l && qU(a, o, t), a;
}
function HU(t) {
  let e = -1, n = !1;
  for (let i = 0; i < t.childCount; i++) {
    const r = t.child(i);
    let s = 0;
    if (n)
      for (let o = 0; o < i; o++) {
        const a = t.child(o);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          o + c.attrs.rowspan > i && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < r.childCount; o++) {
      const a = r.child(o);
      s += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function qU(t, e, n) {
  t.problems || (t.problems = []);
  const i = {};
  for (let r = 0; r < t.map.length; r++) {
    const s = t.map[r];
    if (i[s])
      continue;
    i[s] = !0;
    const o = n.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let a = null;
    const l = o.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = (r + c) % t.width, d = e[u * 2];
      d != null && (!l.colwidth || l.colwidth[c] != d) && ((a || (a = XU(l)))[c] = d);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: a
    });
  }
}
function XU(t) {
  if (t.colwidth)
    return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++)
    e.push(0);
  return e;
}
function Tw(t, e) {
  if (typeof t == "string")
    return {};
  const n = t.getAttribute("data-colwidth"), i = n && /^\d+(,\d+)*$/.test(n) ? n.split(",").map((o) => Number(o)) : null, r = Number(t.getAttribute("colspan") || 1), s = {
    colspan: r,
    rowspan: Number(t.getAttribute("rowspan") || 1),
    colwidth: i && i.length == r ? i : null
  };
  for (const o in e) {
    const a = e[o].getFromDOM, l = a && a(t);
    l != null && (s[o] = l);
  }
  return s;
}
function Mw(t, e) {
  const n = {};
  t.attrs.colspan != 1 && (n.colspan = t.attrs.colspan), t.attrs.rowspan != 1 && (n.rowspan = t.attrs.rowspan), t.attrs.colwidth && (n["data-colwidth"] = t.attrs.colwidth.join(","));
  for (const i in e) {
    const r = e[i].setDOMAttr;
    r && r(t.attrs[i], n);
  }
  return n;
}
function zve(t) {
  const e = t.cellAttributes || {}, n = {
    colspan: { default: 1 },
    rowspan: { default: 1 },
    colwidth: { default: null }
  };
  for (const i in e)
    n[i] = { default: e[i].default };
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: !0,
      group: t.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: t.cellContent,
      attrs: n,
      tableRole: "cell",
      isolating: !0,
      parseDOM: [
        { tag: "td", getAttrs: (i) => Tw(i, e) }
      ],
      toDOM(i) {
        return ["td", Mw(i, e), 0];
      }
    },
    table_header: {
      content: t.cellContent,
      attrs: n,
      tableRole: "header_cell",
      isolating: !0,
      parseDOM: [
        { tag: "th", getAttrs: (i) => Tw(i, e) }
      ],
      toDOM(i) {
        return ["th", Mw(i, e), 0];
      }
    }
  };
}
function An(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const i = t.nodes[n], r = i.spec.tableRole;
      r && (e[r] = i);
    }
  }
  return e;
}
var Gs = new Ke("selectingCells");
function gc(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function jU(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell")
      return t.node(e);
  }
  return null;
}
function mr(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function S0(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = gc(e.$head) || YU(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function YU(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const i = e.type.spec.tableRole;
    if (i == "cell" || i == "header_cell")
      return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const i = e.type.spec.tableRole;
    if (i == "cell" || i == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function nO(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function GU(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function S2(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function Uve(t) {
  return Je.get(t.node(-1)).findCell(t.pos - t.start(-1));
}
function Wve(t) {
  return Je.get(t.node(-1)).colCount(t.pos - t.start(-1));
}
function YM(t, e, n) {
  const i = t.node(-1), r = Je.get(i), s = t.start(-1), o = r.nextCell(t.pos - s, e, n);
  return o == null ? null : t.node(0).resolve(s + o);
}
function Ca(t, e, n = 1) {
  const i = { ...t, colspan: t.colspan - n };
  return i.colwidth && (i.colwidth = i.colwidth.slice(), i.colwidth.splice(e, n), i.colwidth.some((r) => r > 0) || (i.colwidth = null)), i;
}
function GM(t, e, n = 1) {
  const i = { ...t, colspan: t.colspan + n };
  if (i.colwidth) {
    i.colwidth = i.colwidth.slice();
    for (let r = 0; r < n; r++)
      i.colwidth.splice(e, 0, 0);
  }
  return i;
}
function KU(t, e, n) {
  const i = An(e.type.schema).header_cell;
  for (let r = 0; r < t.height; r++)
    if (e.nodeAt(t.map[n + r * t.width]).type != i)
      return !1;
  return !0;
}
var at = class ds extends _e {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const i = e.node(-1), r = Je.get(i), s = e.start(-1), o = r.rectBetween(
      e.pos - s,
      n.pos - s
    ), a = e.node(0), l = r.cellsInRect(o).filter((u) => u != n.pos - s);
    l.unshift(n.pos - s);
    const c = l.map((u) => {
      const d = i.nodeAt(u);
      if (!d)
        throw RangeError(`No cell with offset ${u} found`);
      const h = s + u + 1;
      return new Cp(
        a.resolve(h),
        a.resolve(h + d.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const i = e.resolve(n.map(this.$anchorCell.pos)), r = e.resolve(n.map(this.$headCell.pos));
    if (nO(i) && nO(r) && S2(i, r)) {
      const s = this.$anchorCell.node(-1) != i.node(-1);
      return s && this.isRowSelection() ? ds.rowSelection(i, r) : s && this.isColSelection() ? ds.colSelection(i, r) : new ds(i, r);
    }
    return ce.between(i, r);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = Je.get(e), i = this.$anchorCell.start(-1), r = n.rectBetween(
      this.$anchorCell.pos - i,
      this.$headCell.pos - i
    ), s = {}, o = [];
    for (let l = r.top; l < r.bottom; l++) {
      const c = [];
      for (let u = l * n.width + r.left, d = r.left; d < r.right; d++, u++) {
        const h = n.map[u];
        if (s[h])
          continue;
        s[h] = !0;
        const f = n.findCell(h);
        let p = e.nodeAt(h);
        if (!p)
          throw RangeError(`No cell with offset ${h} found`);
        const m = r.left - f.left, g = f.right - r.right;
        if (m > 0 || g > 0) {
          let b = p.attrs;
          if (m > 0 && (b = Ca(b, 0, m)), g > 0 && (b = Ca(
            b,
            b.colspan - g,
            g
          )), f.left < r.left) {
            if (p = p.type.createAndFill(b), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(b)}`
              );
          } else
            p = p.type.create(b, p.content);
        }
        if (f.top < r.top || f.bottom > r.bottom) {
          const b = {
            ...p.attrs,
            rowspan: Math.min(f.bottom, r.bottom) - Math.max(f.top, r.top)
          };
          f.top < r.top ? p = p.type.createAndFill(b) : p = p.type.create(b, p.content);
        }
        c.push(p);
      }
      o.push(e.child(l).copy(Y.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : o;
    return new ne(Y.from(a), 1, 1);
  }
  replace(e, n = ne.empty) {
    const i = e.steps.length, r = this.ranges;
    for (let o = 0; o < r.length; o++) {
      const { $from: a, $to: l } = r[o], c = e.mapping.slice(i);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        o ? ne.empty : n
      );
    }
    const s = _e.findFrom(
      e.doc.resolve(e.mapping.slice(i).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, n) {
    this.replace(e, new ne(Y.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), i = Je.get(n), r = this.$anchorCell.start(-1), s = i.cellsInRect(
      i.rectBetween(
        this.$anchorCell.pos - r,
        this.$headCell.pos - r
      )
    );
    for (let o = 0; o < s.length; o++)
      e(n.nodeAt(s[o]), r + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0)
      return !1;
    const i = e + this.$anchorCell.nodeAfter.attrs.rowspan, r = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(i, r) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const i = e.node(-1), r = Je.get(i), s = e.start(-1), o = r.findCell(e.pos - s), a = r.findCell(n.pos - s), l = e.node(0);
    return o.top <= a.top ? (o.top > 0 && (e = l.resolve(s + r.map[o.left])), a.bottom < r.height && (n = l.resolve(
      s + r.map[r.width * (r.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (n = l.resolve(s + r.map[a.left])), o.bottom < r.height && (e = l.resolve(
      s + r.map[r.width * (r.height - 1) + o.right - 1]
    ))), new ds(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = Je.get(e), i = this.$anchorCell.start(-1), r = n.colCount(this.$anchorCell.pos - i), s = n.colCount(this.$headCell.pos - i);
    if (Math.min(r, s) > 0)
      return !1;
    const o = r + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, a) == n.width;
  }
  eq(e) {
    return e instanceof ds && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const i = e.node(-1), r = Je.get(i), s = e.start(-1), o = r.findCell(e.pos - s), a = r.findCell(n.pos - s), l = e.node(0);
    return o.left <= a.left ? (o.left > 0 && (e = l.resolve(
      s + r.map[o.top * r.width]
    )), a.right < r.width && (n = l.resolve(
      s + r.map[r.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (n = l.resolve(s + r.map[a.top * r.width])), o.right < r.width && (e = l.resolve(
      s + r.map[r.width * (o.top + 1) - 1]
    ))), new ds(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new ds(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, i = n) {
    return new ds(e.resolve(n), e.resolve(i));
  }
  getBookmark() {
    return new JU(this.$anchorCell.pos, this.$headCell.pos);
  }
};
at.prototype.visible = !1;
_e.jsonID("cell", at);
var JU = class KM {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new KM(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), i = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && i.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && i.index() < i.parent.childCount && S2(n, i) ? new at(n, i) : _e.near(i, 1);
  }
};
function eW(t) {
  if (!(t.selection instanceof at))
    return null;
  const e = [];
  return t.selection.forEachCell((n, i) => {
    e.push(
      zt.node(i, i + n.nodeSize, { class: "selectedCell" })
    );
  }), We.create(t.doc, e);
}
function tW({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < t.pos - 6)
    return !1;
  let n = t.pos, i = e.pos, r = t.depth;
  for (; r >= 0 && !(t.after(r + 1) < t.end(r)); r--, n++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, i--)
    ;
  return n == i && /row|table/.test(t.node(r).type.spec.tableRole);
}
function nW({ $from: t, $to: e }) {
  let n, i;
  for (let r = t.depth; r > 0; r--) {
    const s = t.node(r);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      n = s;
      break;
    }
  }
  for (let r = e.depth; r > 0; r--) {
    const s = e.node(r);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      i = s;
      break;
    }
  }
  return n !== i && e.parentOffset === 0;
}
function iW(t, e, n) {
  const i = (e || t).selection, r = (e || t).doc;
  let s, o;
  if (i instanceof ge && (o = i.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = at.create(r, i.from);
    else if (o == "row") {
      const a = r.resolve(i.from + 1);
      s = at.rowSelection(a, a);
    } else if (!n) {
      const a = Je.get(i.node), l = i.from + 1, c = l + a.map[a.width * a.height - 1];
      s = at.create(r, l + 1, c);
    }
  } else i instanceof ce && tW(i) ? s = ce.create(r, i.from) : i instanceof ce && nW(i) && (s = ce.create(r, i.$from.start(), i.$from.end()));
  return s && (e || (e = t.tr)).setSelection(s), e;
}
var rW = new Ke("fix-tables");
function JM(t, e, n, i) {
  const r = t.childCount, s = e.childCount;
  e:
    for (let o = 0, a = 0; o < s; o++) {
      const l = e.child(o);
      for (let c = a, u = Math.min(r, o + 3); c < u; c++)
        if (t.child(c) == l) {
          a = c + 1, n += l.nodeSize;
          continue e;
        }
      i(l, n), a < r && t.child(a).sameMarkup(l) ? JM(t.child(a), l, n + 1, i) : l.nodesBetween(0, l.content.size, i, n + 1), n += l.nodeSize;
    }
}
function eP(t, e) {
  let n;
  const i = (r, s) => {
    r.type.spec.tableRole == "table" && (n = sW(t, r, s, n));
  };
  return e ? e.doc != t.doc && JM(e.doc, t.doc, 0, i) : t.doc.descendants(i), n;
}
function sW(t, e, n, i) {
  const r = Je.get(e);
  if (!r.problems)
    return i;
  i || (i = t.tr);
  const s = [];
  for (let l = 0; l < r.height; l++)
    s.push(0);
  for (let l = 0; l < r.problems.length; l++) {
    const c = r.problems[l];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      const d = u.attrs;
      for (let h = 0; h < d.rowspan; h++)
        s[c.row + h] += c.n;
      i.setNodeMarkup(
        i.mapping.map(n + 1 + c.pos),
        null,
        Ca(d, d.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      i.setNodeMarkup(i.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      i.setNodeMarkup(i.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    }
  }
  let o, a;
  for (let l = 0; l < s.length; l++)
    s[l] && (o == null && (o = l), a = l);
  for (let l = 0, c = n + 1; l < r.height; l++) {
    const u = e.child(l), d = c + u.nodeSize, h = s[l];
    if (h > 0) {
      let f = "cell";
      u.firstChild && (f = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let g = 0; g < h; g++) {
        const b = An(t.schema)[f].createAndFill();
        b && p.push(b);
      }
      const m = (l == 0 || o == l - 1) && a == l ? c + 1 : d - 1;
      i.insert(i.mapping.map(m), p);
    }
    c = d;
  }
  return i.setMeta(rW, { fixTables: !0 });
}
function oW(t) {
  if (!t.size)
    return null;
  let { content: e, openStart: n, openEnd: i } = t;
  for (; e.childCount == 1 && (n > 0 && i > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, i--, e = e.child(0).content;
  const r = e.child(0), s = r.type.spec.tableRole, o = r.type.schema, a = [];
  if (s == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const u = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, i - 1);
      (u || d) && (c = iO(
        An(o).row,
        new ne(c, u, d)
      ).content), a.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    a.push(
      n || i ? iO(
        An(o).row,
        new ne(e, n, i)
      ).content : e
    );
  else
    return null;
  return aW(o, a);
}
function aW(t, e) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: a, colspan: l } = s.child(o).attrs;
      for (let c = r; c < r + a; c++)
        n[c] = (n[c] || 0) + l;
    }
  }
  let i = 0;
  for (let r = 0; r < n.length; r++)
    i = Math.max(i, n[r]);
  for (let r = 0; r < n.length; r++)
    if (r >= e.length && e.push(Y.empty), n[r] < i) {
      const s = An(t).cell.createAndFill(), o = [];
      for (let a = n[r]; a < i; a++)
        o.push(s);
      e[r] = e[r].append(Y.from(o));
    }
  return { height: e.length, width: i, rows: e };
}
function iO(t, e) {
  const n = t.createAndFill();
  return new e2(n).replace(0, n.content.size, e).doc;
}
function lW({ width: t, height: e, rows: n }, i, r) {
  if (t != i) {
    const s = [], o = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = [];
      for (let u = s[a] || 0, d = 0; u < i; d++) {
        let h = l.child(d % l.childCount);
        u + h.attrs.colspan > i && (h = h.type.createChecked(
          Ca(
            h.attrs,
            h.attrs.colspan,
            u + h.attrs.colspan - i
          ),
          h.content
        )), c.push(h), u += h.attrs.colspan;
        for (let f = 1; f < h.attrs.rowspan; f++)
          s[a + f] = (s[a + f] || 0) + h.attrs.colspan;
      }
      o.push(Y.from(c));
    }
    n = o, t = i;
  }
  if (e != r) {
    const s = [];
    for (let o = 0, a = 0; o < r; o++, a++) {
      const l = [], c = n[a % e];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        o + d.attrs.rowspan > r && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, r - d.attrs.rowspan)
          },
          d.content
        )), l.push(d);
      }
      s.push(Y.from(l));
    }
    n = s, e = r;
  }
  return { width: t, height: e, rows: n };
}
function cW(t, e, n, i, r, s, o) {
  const a = t.doc.type.schema, l = An(a);
  let c, u;
  if (r > e.width)
    for (let d = 0, h = 0; d < e.height; d++) {
      const f = n.child(d);
      h += f.nodeSize;
      const p = [];
      let m;
      f.lastChild == null || f.lastChild.type == l.cell ? m = c || (c = l.cell.createAndFill()) : m = u || (u = l.header_cell.createAndFill());
      for (let g = e.width; g < r; g++)
        p.push(m);
      t.insert(t.mapping.slice(o).map(h - 1 + i), p);
    }
  if (s > e.height) {
    const d = [];
    for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, r); p++) {
      const g = p >= e.width ? !1 : n.nodeAt(e.map[m + p]).type == l.header_cell;
      d.push(
        g ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const h = l.row.create(null, Y.from(d)), f = [];
    for (let p = e.height; p < s; p++)
      f.push(h);
    t.insert(t.mapping.slice(o).map(i + n.nodeSize - 2), f);
  }
  return !!(c || u);
}
function Pw(t, e, n, i, r, s, o, a) {
  if (o == 0 || o == e.height)
    return !1;
  let l = !1;
  for (let c = r; c < s; c++) {
    const u = o * e.width + c, d = e.map[u];
    if (e.map[u - e.width] == d) {
      l = !0;
      const h = n.nodeAt(d), { top: f, left: p } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(a).map(d + i), null, {
        ...h.attrs,
        rowspan: o - f
      }), t.insert(
        t.mapping.slice(a).map(e.positionAt(o, p, n)),
        h.type.createAndFill({
          ...h.attrs,
          rowspan: f + h.attrs.rowspan - o
        })
      ), c += h.attrs.colspan - 1;
    }
  }
  return l;
}
function Rw(t, e, n, i, r, s, o, a) {
  if (o == 0 || o == e.width)
    return !1;
  let l = !1;
  for (let c = r; c < s; c++) {
    const u = c * e.width + o, d = e.map[u];
    if (e.map[u - 1] == d) {
      l = !0;
      const h = n.nodeAt(d), f = e.colCount(d), p = t.mapping.slice(a).map(d + i);
      t.setNodeMarkup(
        p,
        null,
        Ca(
          h.attrs,
          o - f,
          h.attrs.colspan - (o - f)
        )
      ), t.insert(
        p + h.nodeSize,
        h.type.createAndFill(
          Ca(h.attrs, 0, o - f)
        )
      ), c += h.attrs.rowspan - 1;
    }
  }
  return l;
}
function $w(t, e, n, i, r) {
  let s = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!s)
    throw new Error("No table found");
  let o = Je.get(s);
  const { top: a, left: l } = i, c = l + r.width, u = a + r.height, d = t.tr;
  let h = 0;
  function f() {
    if (s = n ? d.doc.nodeAt(n - 1) : d.doc, !s)
      throw new Error("No table found");
    o = Je.get(s), h = d.mapping.maps.length;
  }
  cW(d, o, s, n, c, u, h) && f(), Pw(d, o, s, n, l, c, a, h) && f(), Pw(d, o, s, n, l, c, u, h) && f(), Rw(d, o, s, n, a, u, l, h) && f(), Rw(d, o, s, n, a, u, c, h) && f();
  for (let p = a; p < u; p++) {
    const m = o.positionAt(p, l, s), g = o.positionAt(p, c, s);
    d.replace(
      d.mapping.slice(h).map(m + n),
      d.mapping.slice(h).map(g + n),
      new ne(r.rows[p - a], 0, 0)
    );
  }
  f(), d.setSelection(
    new at(
      d.doc.resolve(n + o.positionAt(a, l, s)),
      d.doc.resolve(n + o.positionAt(u - 1, c - 1, s))
    )
  ), e(d);
}
var uW = m0({
  ArrowLeft: Nh("horiz", -1),
  ArrowRight: Nh("horiz", 1),
  ArrowUp: Nh("vert", -1),
  ArrowDown: Nh("vert", 1),
  "Shift-ArrowLeft": Dh("horiz", -1),
  "Shift-ArrowRight": Dh("horiz", 1),
  "Shift-ArrowUp": Dh("vert", -1),
  "Shift-ArrowDown": Dh("vert", 1),
  Backspace: Ih,
  "Mod-Backspace": Ih,
  Delete: Ih,
  "Mod-Delete": Ih
});
function Hf(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function Nh(t, e) {
  return (n, i, r) => {
    if (!r)
      return !1;
    const s = n.selection;
    if (s instanceof at)
      return Hf(
        n,
        i,
        _e.near(s.$headCell, e)
      );
    if (t != "horiz" && !s.empty)
      return !1;
    const o = tP(r, t, e);
    if (o == null)
      return !1;
    if (t == "horiz")
      return Hf(
        n,
        i,
        _e.near(n.doc.resolve(s.head + e), e)
      );
    {
      const a = n.doc.resolve(o), l = YM(a, t, e);
      let c;
      return l ? c = _e.near(l, 1) : e < 0 ? c = _e.near(n.doc.resolve(a.before(-1)), -1) : c = _e.near(n.doc.resolve(a.after(-1)), 1), Hf(n, i, c);
    }
  };
}
function Dh(t, e) {
  return (n, i, r) => {
    if (!r)
      return !1;
    const s = n.selection;
    let o;
    if (s instanceof at)
      o = s;
    else {
      const l = tP(r, t, e);
      if (l == null)
        return !1;
      o = new at(n.doc.resolve(l));
    }
    const a = YM(o.$headCell, t, e);
    return a ? Hf(
      n,
      i,
      new at(o.$anchorCell, a)
    ) : !1;
  };
}
function Ih(t, e) {
  const n = t.selection;
  if (!(n instanceof at))
    return !1;
  if (e) {
    const i = t.tr, r = An(t.schema).cell.createAndFill().content;
    n.forEachCell((s, o) => {
      s.content.eq(r) || i.replace(
        i.mapping.map(o + 1),
        i.mapping.map(o + s.nodeSize - 1),
        new ne(r, 0, 0)
      );
    }), i.docChanged && e(i);
  }
  return !0;
}
function dW(t, e) {
  const n = t.state.doc, i = gc(n.resolve(e));
  return i ? (t.dispatch(t.state.tr.setSelection(new at(i))), !0) : !1;
}
function hW(t, e, n) {
  if (!mr(t.state))
    return !1;
  let i = oW(n);
  const r = t.state.selection;
  if (r instanceof at) {
    i || (i = {
      width: 1,
      height: 1,
      rows: [
        Y.from(
          iO(An(t.state.schema).cell, n)
        )
      ]
    });
    const s = r.$anchorCell.node(-1), o = r.$anchorCell.start(-1), a = Je.get(s).rectBetween(
      r.$anchorCell.pos - o,
      r.$headCell.pos - o
    );
    return i = lW(i, a.right - a.left, a.bottom - a.top), $w(t.state, t.dispatch, o, a, i), !0;
  } else if (i) {
    const s = S0(t.state), o = s.start(-1);
    return $w(
      t.state,
      t.dispatch,
      o,
      Je.get(s.node(-1)).findCell(s.pos - o),
      i
    ), !0;
  } else
    return !1;
}
function fW(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey)
    return;
  const i = Nw(t, e.target);
  let r;
  if (e.shiftKey && t.state.selection instanceof at)
    s(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && i && (r = gc(t.state.selection.$anchor)) != null && ((n = Wg(t, e)) == null ? void 0 : n.pos) != r.pos)
    s(r, e), e.preventDefault();
  else if (!i)
    return;
  function s(l, c) {
    let u = Wg(t, c);
    const d = Gs.getState(t.state) == null;
    if (!u || !S2(l, u))
      if (d)
        u = l;
      else
        return;
    const h = new at(l, u);
    if (d || !t.state.selection.eq(h)) {
      const f = t.state.tr.setSelection(h);
      d && f.setMeta(Gs, l.pos), t.dispatch(f);
    }
  }
  function o() {
    t.root.removeEventListener("mouseup", o), t.root.removeEventListener("dragstart", o), t.root.removeEventListener("mousemove", a), Gs.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(Gs, -1));
  }
  function a(l) {
    const c = l, u = Gs.getState(t.state);
    let d;
    if (u != null)
      d = t.state.doc.resolve(u);
    else if (Nw(t, c.target) != i && (d = Wg(t, e), !d))
      return o();
    d && s(d, c);
  }
  t.root.addEventListener("mouseup", o), t.root.addEventListener("dragstart", o), t.root.addEventListener("mousemove", a);
}
function tP(t, e, n) {
  if (!(t.state.selection instanceof ce))
    return null;
  const { $head: i } = t.state.selection;
  for (let r = i.depth - 1; r >= 0; r--) {
    const s = i.node(r);
    if ((n < 0 ? i.index(r) : i.indexAfter(r)) != (n < 0 ? 0 : s.childCount))
      return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const a = i.before(r), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function Nw(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Wg(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? gc(t.state.doc.resolve(n.pos)) : null;
}
var pW = class {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), rO(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, rO(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function rO(t, e, n, i, r, s) {
  var o;
  let a = 0, l = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u) {
    for (let d = 0, h = 0; d < u.childCount; d++) {
      const { colspan: f, colwidth: p } = u.child(d).attrs;
      for (let m = 0; m < f; m++, h++) {
        const g = r == h ? s : p && p[m], b = g ? g + "px" : "";
        a += g || i, g || (l = !1), c ? (c.style.width != b && (c.style.width = b), c = c.nextSibling) : e.appendChild(document.createElement("col")).style.width = b;
      }
    }
    for (; c; ) {
      const d = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = d;
    }
    l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
  }
}
var Pi = new Ke(
  "tableColumnResizing"
);
function mW({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  View: n = pW,
  lastColumnResizable: i = !0
} = {}) {
  const r = new Ue({
    key: Pi,
    state: {
      init(s, o) {
        var a, l;
        const c = (l = (a = r.spec) == null ? void 0 : a.props) == null ? void 0 : l.nodeViews, u = An(o.schema).table.name;
        return n && c && (c[u] = (d, h) => new n(d, e, h)), new gW(-1, !1);
      },
      apply(s, o) {
        return o.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const o = Pi.getState(s);
        return o && o.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, o) => {
          bW(
            s,
            o,
            t,
            e,
            i
          );
        },
        mouseleave: (s) => {
          OW(s);
        },
        mousedown: (s, o) => {
          yW(s, o, e);
        }
      },
      decorations: (s) => {
        const o = Pi.getState(s);
        if (o && o.activeHandle > -1)
          return kW(s, o.activeHandle);
      },
      nodeViews: {}
    }
  });
  return r;
}
var gW = class qf {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, i = e.getMeta(Pi);
    if (i && i.setHandle != null)
      return new qf(i.setHandle, !1);
    if (i && i.setDragging !== void 0)
      return new qf(n.activeHandle, i.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let r = e.mapping.map(n.activeHandle, -1);
      return nO(e.doc.resolve(r)) || (r = -1), new qf(r, n.dragging);
    }
    return n;
  }
};
function bW(t, e, n, i, r) {
  const s = Pi.getState(t.state);
  if (s && !s.dragging) {
    const o = vW(e.target);
    let a = -1;
    if (o) {
      const { left: l, right: c } = o.getBoundingClientRect();
      e.clientX - l <= n ? a = Dw(t, e, "left", n) : c - e.clientX <= n && (a = Dw(t, e, "right", n));
    }
    if (a != s.activeHandle) {
      if (!r && a !== -1) {
        const l = t.state.doc.resolve(a), c = l.node(-1), u = Je.get(c), d = l.start(-1);
        if (u.colCount(l.pos - d) + l.nodeAfter.attrs.colspan - 1 == u.width - 1)
          return;
      }
      nP(t, a);
    }
  }
}
function OW(t) {
  const e = Pi.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && nP(t, -1);
}
function yW(t, e, n) {
  var i;
  const r = (i = t.dom.ownerDocument.defaultView) != null ? i : window, s = Pi.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging)
    return !1;
  const o = t.state.doc.nodeAt(s.activeHandle), a = _W(t, s.activeHandle, o.attrs);
  t.dispatch(
    t.state.tr.setMeta(Pi, {
      setDragging: { startX: e.clientX, startWidth: a }
    })
  );
  function l(u) {
    r.removeEventListener("mouseup", l), r.removeEventListener("mousemove", c);
    const d = Pi.getState(t.state);
    d != null && d.dragging && (xW(
      t,
      d.activeHandle,
      Iw(d.dragging, u, n)
    ), t.dispatch(
      t.state.tr.setMeta(Pi, { setDragging: null })
    ));
  }
  function c(u) {
    if (!u.which)
      return l(u);
    const d = Pi.getState(t.state);
    if (d && d.dragging) {
      const h = Iw(d.dragging, u, n);
      wW(t, d.activeHandle, h, n);
    }
  }
  return r.addEventListener("mouseup", l), r.addEventListener("mousemove", c), e.preventDefault(), !0;
}
function _W(t, e, { colspan: n, colwidth: i }) {
  const r = i && i[i.length - 1];
  if (r)
    return r;
  const s = t.domAtPos(e);
  let a = s.node.childNodes[s.offset].offsetWidth, l = n;
  if (i)
    for (let c = 0; c < n; c++)
      i[c] && (a -= i[c], l--);
  return a / l;
}
function vW(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function Dw(t, e, n, i) {
  const r = n == "right" ? -i : i, s = t.posAtCoords({
    left: e.clientX + r,
    top: e.clientY
  });
  if (!s)
    return -1;
  const { pos: o } = s, a = gc(t.state.doc.resolve(o));
  if (!a)
    return -1;
  if (n == "right")
    return a.pos;
  const l = Je.get(a.node(-1)), c = a.start(-1), u = l.map.indexOf(a.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function Iw(t, e, n) {
  const i = e.clientX - t.startX;
  return Math.max(n, t.startWidth + i);
}
function nP(t, e) {
  t.dispatch(
    t.state.tr.setMeta(Pi, { setHandle: e })
  );
}
function xW(t, e, n) {
  const i = t.state.doc.resolve(e), r = i.node(-1), s = Je.get(r), o = i.start(-1), a = s.colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + a;
    if (c && s.map[u] == s.map[u - s.width])
      continue;
    const d = s.map[u], h = r.nodeAt(d).attrs, f = h.colspan == 1 ? 0 : a - s.colCount(d);
    if (h.colwidth && h.colwidth[f] == n)
      continue;
    const p = h.colwidth ? h.colwidth.slice() : SW(h.colspan);
    p[f] = n, l.setNodeMarkup(o + d, null, { ...h, colwidth: p });
  }
  l.docChanged && t.dispatch(l);
}
function wW(t, e, n, i) {
  const r = t.state.doc.resolve(e), s = r.node(-1), o = r.start(-1), a = Je.get(s).colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(r.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && rO(
    s,
    l.firstChild,
    l,
    i,
    a,
    n
  );
}
function SW(t) {
  return Array(t).fill(0);
}
function kW(t, e) {
  const n = [], i = t.doc.resolve(e), r = i.node(-1);
  if (!r)
    return We.empty;
  const s = Je.get(r), o = i.start(-1), a = s.colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  for (let l = 0; l < s.height; l++) {
    const c = a + l * s.width;
    if ((a == s.width - 1 || s.map[c] != s.map[c + 1]) && (l == 0 || s.map[c] != s.map[c - s.width])) {
      const u = s.map[c], d = o + u + r.nodeAt(u).nodeSize - 1, h = document.createElement("div");
      h.className = "column-resize-handle", n.push(zt.widget(d, h));
    }
  }
  return We.create(t.doc, n);
}
function gr(t) {
  const e = t.selection, n = S0(t), i = n.node(-1), r = n.start(-1), s = Je.get(i);
  return { ...e instanceof at ? s.rectBetween(
    e.$anchorCell.pos - r,
    e.$headCell.pos - r
  ) : s.findCell(n.pos - r), tableStart: r, map: s, table: i };
}
function iP(t, { map: e, tableStart: n, table: i }, r) {
  let s = r > 0 ? -1 : 0;
  KU(e, i, r + s) && (s = r == 0 || r == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const a = o * e.width + r;
    if (r > 0 && r < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = i.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        GM(c.attrs, r - e.colCount(l))
      ), o += c.attrs.rowspan - 1;
    } else {
      const l = s == null ? An(i.type.schema).cell : i.nodeAt(e.map[a + s]).type, c = e.positionAt(o, r, i);
      t.insert(t.mapping.map(n + c), l.createAndFill());
    }
  }
  return t;
}
function EW(t, e) {
  if (!mr(t))
    return !1;
  if (e) {
    const n = gr(t);
    e(iP(t.tr, n, n.left));
  }
  return !0;
}
function rP(t, e) {
  if (!mr(t))
    return !1;
  if (e) {
    const n = gr(t);
    e(iP(t.tr, n, n.right));
  }
  return !0;
}
function CW(t, { map: e, table: n, tableStart: i }, r) {
  const s = t.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const a = o * e.width + r, l = e.map[a], c = n.nodeAt(l), u = c.attrs;
    if (r > 0 && e.map[a - 1] == l || r < e.width - 1 && e.map[a + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(s).map(i + l),
        null,
        Ca(u, r - e.colCount(l))
      );
    else {
      const d = t.mapping.slice(s).map(i + l);
      t.delete(d, d + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function AW(t, e) {
  if (!mr(t))
    return !1;
  if (e) {
    const n = gr(t), i = t.tr;
    if (n.left == 0 && n.right == n.map.width)
      return !1;
    for (let r = n.right - 1; CW(i, n, r), r != n.left; r--) {
      const s = n.tableStart ? i.doc.nodeAt(n.tableStart - 1) : i.doc;
      if (!s)
        throw RangeError("No table found");
      n.table = s, n.map = Je.get(s);
    }
    e(i);
  }
  return !0;
}
function TW(t, e, n) {
  var i;
  const r = An(e.type.schema).header_cell;
  for (let s = 0; s < t.width; s++)
    if (((i = e.nodeAt(t.map[s + n * t.width])) == null ? void 0 : i.type) != r)
      return !1;
  return !0;
}
function sP(t, { map: e, tableStart: n, table: i }, r) {
  var s;
  let o = n;
  for (let c = 0; c < r; c++)
    o += i.child(c).nodeSize;
  const a = [];
  let l = r > 0 ? -1 : 0;
  TW(e, i, r + l) && (l = r == 0 || r == e.height ? null : 0);
  for (let c = 0, u = e.width * r; c < e.width; c++, u++)
    if (r > 0 && r < e.height && e.map[u] == e.map[u - e.width]) {
      const d = e.map[u], h = i.nodeAt(d).attrs;
      t.setNodeMarkup(n + d, null, {
        ...h,
        rowspan: h.rowspan + 1
      }), c += h.colspan - 1;
    } else {
      const d = l == null ? An(i.type.schema).cell : (s = i.nodeAt(e.map[u + l * e.width])) == null ? void 0 : s.type, h = d == null ? void 0 : d.createAndFill();
      h && a.push(h);
    }
  return t.insert(o, An(i.type.schema).row.create(null, a)), t;
}
function MW(t, e) {
  if (!mr(t))
    return !1;
  if (e) {
    const n = gr(t);
    e(sP(t.tr, n, n.top));
  }
  return !0;
}
function oP(t, e) {
  if (!mr(t))
    return !1;
  if (e) {
    const n = gr(t);
    e(sP(t.tr, n, n.bottom));
  }
  return !0;
}
function PW(t, { map: e, table: n, tableStart: i }, r) {
  let s = 0;
  for (let c = 0; c < r; c++)
    s += n.child(c).nodeSize;
  const o = s + n.child(r).nodeSize, a = t.mapping.maps.length;
  t.delete(s + i, o + i);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = r * e.width; c < e.width; c++, u++) {
    const d = e.map[u];
    if (!l.has(d)) {
      if (l.add(d), r > 0 && d == e.map[u - e.width]) {
        const h = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(d + i), null, {
          ...h,
          rowspan: h.rowspan - 1
        }), c += h.colspan - 1;
      } else if (r < e.height && d == e.map[u + e.width]) {
        const h = n.nodeAt(d), f = h.attrs, p = h.type.create(
          { ...f, rowspan: h.attrs.rowspan - 1 },
          h.content
        ), m = e.positionAt(r + 1, c, n);
        t.insert(t.mapping.slice(a).map(i + m), p), c += f.colspan - 1;
      }
    }
  }
}
function RW(t, e) {
  if (!mr(t))
    return !1;
  if (e) {
    const n = gr(t), i = t.tr;
    if (n.top == 0 && n.bottom == n.map.height)
      return !1;
    for (let r = n.bottom - 1; PW(i, n, r), r != n.top; r--) {
      const s = n.tableStart ? i.doc.nodeAt(n.tableStart - 1) : i.doc;
      if (!s)
        throw RangeError("No table found");
      n.table = s, n.map = Je.get(n.table);
    }
    e(i);
  }
  return !0;
}
function Lw(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function $W({ width: t, height: e, map: n }, i) {
  let r = i.top * t + i.left, s = r, o = (i.bottom - 1) * t + i.left, a = r + (i.right - i.left - 1);
  for (let l = i.top; l < i.bottom; l++) {
    if (i.left > 0 && n[s] == n[s - 1] || i.right < t && n[a] == n[a + 1])
      return !0;
    s += t, a += t;
  }
  for (let l = i.left; l < i.right; l++) {
    if (i.top > 0 && n[r] == n[r - t] || i.bottom < e && n[o] == n[o + t])
      return !0;
    r++, o++;
  }
  return !1;
}
function Bw(t, e) {
  const n = t.selection;
  if (!(n instanceof at) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const i = gr(t), { map: r } = i;
  if ($W(r, i))
    return !1;
  if (e) {
    const s = t.tr, o = {};
    let a = Y.empty, l, c;
    for (let u = i.top; u < i.bottom; u++)
      for (let d = i.left; d < i.right; d++) {
        const h = r.map[u * r.width + d], f = i.table.nodeAt(h);
        if (!(o[h] || !f))
          if (o[h] = !0, l == null)
            l = h, c = f;
          else {
            Lw(f) || (a = a.append(f.content));
            const p = s.mapping.map(h + i.tableStart);
            s.delete(p, p + f.nodeSize);
          }
      }
    if (l == null || c == null)
      return !0;
    if (s.setNodeMarkup(l + i.tableStart, null, {
      ...GM(
        c.attrs,
        c.attrs.colspan,
        i.right - i.left - c.attrs.colspan
      ),
      rowspan: i.bottom - i.top
    }), a.size) {
      const u = l + 1 + c.content.size, d = Lw(c) ? l + 1 : u;
      s.replaceWith(d + i.tableStart, u + i.tableStart, a);
    }
    s.setSelection(
      new at(s.doc.resolve(l + i.tableStart))
    ), e(s);
  }
  return !0;
}
function Qw(t, e) {
  const n = An(t.schema);
  return NW(({ node: i }) => n[i.type.spec.tableRole])(t, e);
}
function NW(t) {
  return (e, n) => {
    var i;
    const r = e.selection;
    let s, o;
    if (r instanceof at) {
      if (r.$anchorCell.pos != r.$headCell.pos)
        return !1;
      s = r.$anchorCell.nodeAfter, o = r.$anchorCell.pos;
    } else {
      if (s = jU(r.$from), !s)
        return !1;
      o = (i = gc(r.$from)) == null ? void 0 : i.pos;
    }
    if (s == null || o == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1)
      return !1;
    if (n) {
      let a = s.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
      const u = gr(e), d = e.tr;
      for (let f = 0; f < u.right - u.left; f++)
        l.push(
          c ? {
            ...a,
            colwidth: c && c[f] ? [c[f]] : null
          } : a
        );
      let h;
      for (let f = u.top; f < u.bottom; f++) {
        let p = u.map.positionAt(f, u.left, u.table);
        f == u.top && (p += s.nodeSize);
        for (let m = u.left, g = 0; m < u.right; m++, g++)
          m == u.left && f == u.top || d.insert(
            h = d.mapping.map(p + u.tableStart, 1),
            t({ node: s, row: f, col: m }).createAndFill(l[g])
          );
      }
      d.setNodeMarkup(
        o,
        t({ node: s, row: u.top, col: u.left }),
        l[0]
      ), r instanceof at && d.setSelection(
        new at(
          d.doc.resolve(r.$anchorCell.pos),
          h ? d.doc.resolve(h) : void 0
        )
      ), n(d);
    }
    return !0;
  };
}
function DW(t, e) {
  return function(n, i) {
    if (!mr(n))
      return !1;
    const r = S0(n);
    if (r.nodeAfter.attrs[t] === e)
      return !1;
    if (i) {
      const s = n.tr;
      n.selection instanceof at ? n.selection.forEachCell((o, a) => {
        o.attrs[t] !== e && s.setNodeMarkup(a, null, {
          ...o.attrs,
          [t]: e
        });
      }) : s.setNodeMarkup(r.pos, null, {
        ...r.nodeAfter.attrs,
        [t]: e
      }), i(s);
    }
    return !0;
  };
}
function IW(t) {
  return function(e, n) {
    if (!mr(e))
      return !1;
    if (n) {
      const i = An(e.schema), r = gr(e), s = e.tr, o = r.map.cellsInRect(
        t == "column" ? {
          left: r.left,
          top: 0,
          right: r.right,
          bottom: r.map.height
        } : t == "row" ? {
          left: 0,
          top: r.top,
          right: r.map.width,
          bottom: r.bottom
        } : r
      ), a = o.map((l) => r.table.nodeAt(l));
      for (let l = 0; l < o.length; l++)
        a[l].type == i.header_cell && s.setNodeMarkup(
          r.tableStart + o[l],
          i.cell,
          a[l].attrs
        );
      if (s.steps.length == 0)
        for (let l = 0; l < o.length; l++)
          s.setNodeMarkup(
            r.tableStart + o[l],
            i.header_cell,
            a[l].attrs
          );
      n(s);
    }
    return !0;
  };
}
function Fw(t, e, n) {
  const i = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let r = 0; r < i.length; r++) {
    const s = e.table.nodeAt(i[r]);
    if (s && s.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function Ku(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? IW(t) : function(n, i) {
    if (!mr(n))
      return !1;
    if (i) {
      const r = An(n.schema), s = gr(n), o = n.tr, a = Fw("row", s, r), l = Fw(
        "column",
        s,
        r
      ), u = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0, d = t == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : t == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, h = t == "column" ? l ? r.cell : r.header_cell : t == "row" ? a ? r.cell : r.header_cell : r.cell;
      s.map.cellsInRect(d).forEach((f) => {
        const p = f + s.tableStart, m = o.doc.nodeAt(p);
        m && o.setNodeMarkup(p, h, m.attrs);
      }), i(o);
    }
    return !0;
  };
}
var Zve = Ku("row", {
  useDeprecatedLogic: !0
}), Hve = Ku("column", {
  useDeprecatedLogic: !0
}), LW = Ku("cell", {
  useDeprecatedLogic: !0
});
function BW(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n)
      return t.pos - n.nodeSize;
    for (let i = t.index(-1) - 1, r = t.before(); i >= 0; i--) {
      const s = t.node(-1).child(i), o = s.lastChild;
      if (o)
        return r - 1 - o.nodeSize;
      r -= s.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let i = t.indexAfter(-1), r = t.after(); i < n.childCount; i++) {
      const s = n.child(i);
      if (s.childCount)
        return r + 1;
      r += s.nodeSize;
    }
  }
  return null;
}
function zw(t) {
  return function(e, n) {
    if (!mr(e))
      return !1;
    const i = BW(S0(e), t);
    if (i == null)
      return !1;
    if (n) {
      const r = e.doc.resolve(i);
      n(
        e.tr.setSelection(ce.between(r, GU(r))).scrollIntoView()
      );
    }
    return !0;
  };
}
function QW(t, e) {
  const n = t.selection.$anchor;
  for (let i = n.depth; i > 0; i--)
    if (n.node(i).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(i), n.after(i)).scrollIntoView()
      ), !0;
  return !1;
}
function FW({
  allowTableNodeSelection: t = !1
} = {}) {
  return new Ue({
    key: Gs,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const i = e.getMeta(Gs);
        if (i != null)
          return i == -1 ? null : i;
        if (n == null || !e.docChanged)
          return n;
        const { deleted: r, pos: s } = e.mapping.mapResult(n);
        return r ? null : s;
      }
    },
    props: {
      decorations: eW,
      handleDOMEvents: {
        mousedown: fW
      },
      createSelectionBetween(e) {
        return Gs.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: dW,
      handleKeyDown: uW,
      handlePaste: hW
    },
    appendTransaction(e, n, i) {
      return iW(
        i,
        eP(i, n),
        t
      );
    }
  });
}
var Uw = new Ke("trailingNode");
function qve(t) {
  const { ignoredNodes: e = [], nodeName: n = "paragraph" } = t ?? {}, i = /* @__PURE__ */ new Set([...e, n]);
  let r, s;
  return new Ue({
    key: Uw,
    appendTransaction(o, a, l) {
      const { doc: c, tr: u } = l, d = Uw.getState(l), h = c.content.size;
      if (d)
        return u.insert(h, r.create());
    },
    state: {
      init: (o, { doc: a, schema: l }) => {
        var u;
        const c = l.nodes[n];
        if (!c)
          throw new Error(`Invalid node being used for trailing node extension: '${n}'`);
        return r = c, s = Object.values(l.nodes).map((d) => d).filter((d) => !i.has(d.name)), s.includes((u = a.lastChild) == null ? void 0 : u.type);
      },
      apply: (o, a) => {
        var l;
        return o.docChanged ? s.includes((l = o.doc.lastChild) == null ? void 0 : l.type) : a;
      }
    }
  });
}
function k0(t) {
  const { state: e, transaction: n } = t;
  let { selection: i } = n, { doc: r } = n, { storedMarks: s } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return i;
    },
    get doc() {
      return r;
    },
    get tr() {
      return i = n.selection, r = n.doc, s = n.storedMarks, n;
    }
  };
}
class E0 {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: i } = this, { view: r } = n, { tr: s } = i, o = this.buildProps(s);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...u) => {
      const d = l(...u)(o);
      return !s.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(s), d;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: i, editor: r, state: s } = this, { view: o } = r, a = [], l = !!e, c = e || s.tr, u = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), a.every((h) => h === !0)), d = {
      ...Object.fromEntries(Object.entries(i).map(([h, f]) => [h, (...m) => {
        const g = this.buildProps(c, n), b = f(...m)(g);
        return a.push(b), d;
      }])),
      run: u
    };
    return d;
  }
  createCan(e) {
    const { rawCommands: n, state: i } = this, r = !1, s = e || i.tr, o = this.buildProps(s, r);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({ ...o, dispatch: void 0 })])),
      chain: () => this.createChain(s, r)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: i, editor: r, state: s } = this, { view: o } = r, a = {
      tr: e,
      editor: r,
      view: o,
      state: k0({
        state: s,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(i).map(([l, c]) => [l, (...u) => c(...u)(a)]));
      }
    };
    return a;
  }
}
class zW {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const i = this.callbacks[e];
    return i && i.forEach((r) => r.apply(this, n)), this;
  }
  off(e, n) {
    const i = this.callbacks[e];
    return i && (n ? this.callbacks[e] = i.filter((r) => r !== n) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function he(t, e, n) {
  return t.config[e] === void 0 && t.parent ? he(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? he(t.parent, e, n) : null
  }) : t.config[e];
}
function C0(t) {
  const e = t.filter((r) => r.type === "extension"), n = t.filter((r) => r.type === "node"), i = t.filter((r) => r.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: i
  };
}
function aP(t) {
  const e = [], { nodeExtensions: n, markExtensions: i } = C0(t), r = [...n, ...i], s = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage,
      extensions: r
    }, l = he(o, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([h, f]) => {
          e.push({
            type: d,
            name: h,
            attribute: {
              ...s,
              ...f
            }
          });
        });
      });
    });
  }), r.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = he(o, "addAttributes", a);
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const h = {
        ...s,
        ...d
      };
      typeof (h == null ? void 0 : h.default) == "function" && (h.default = h.default()), h != null && h.isRequired && (h == null ? void 0 : h.default) === void 0 && delete h.default, e.push({
        type: o.name,
        name: u,
        attribute: h
      });
    });
  }), e;
}
function Zt(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function Ee(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const i = { ...e };
    return Object.entries(n).forEach(([r, s]) => {
      if (!i[r]) {
        i[r] = s;
        return;
      }
      if (r === "class") {
        const a = s ? s.split(" ") : [], l = i[r] ? i[r].split(" ") : [], c = a.filter((u) => !l.includes(u));
        i[r] = [...l, ...c].join(" ");
      } else r === "style" ? i[r] = [i[r], s].join("; ") : i[r] = s;
    }), i;
  }, {});
}
function sO(t, e) {
  return e.filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, i) => Ee(n, i), {});
}
function lP(t) {
  return typeof t == "function";
}
function Ne(t, e = void 0, ...n) {
  return lP(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function UW(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function WW(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function Ww(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const i = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (i === !1)
        return !1;
      const r = e.reduce((s, o) => {
        const a = o.attribute.parseHTML ? o.attribute.parseHTML(n) : WW(n.getAttribute(o.name));
        return a == null ? s : {
          ...s,
          [o.name]: a
        };
      }, {});
      return { ...i, ...r };
    }
  };
}
function Vw(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && UW(n) ? !1 : n != null)
  );
}
function cP(t, e) {
  var n;
  const i = aP(t), { nodeExtensions: r, markExtensions: s } = C0(t), o = (n = r.find((c) => he(c, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(r.map((c) => {
    const u = i.filter((b) => b.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, h = t.reduce((b, _) => {
      const y = he(_, "extendNodeSchema", d);
      return {
        ...b,
        ...y ? y(c) : {}
      };
    }, {}), f = Vw({
      ...h,
      content: Ne(he(c, "content", d)),
      marks: Ne(he(c, "marks", d)),
      group: Ne(he(c, "group", d)),
      inline: Ne(he(c, "inline", d)),
      atom: Ne(he(c, "atom", d)),
      selectable: Ne(he(c, "selectable", d)),
      draggable: Ne(he(c, "draggable", d)),
      code: Ne(he(c, "code", d)),
      whitespace: Ne(he(c, "whitespace", d)),
      defining: Ne(he(c, "defining", d)),
      isolating: Ne(he(c, "isolating", d)),
      attrs: Object.fromEntries(u.map((b) => {
        var _;
        return [b.name, { default: (_ = b == null ? void 0 : b.attribute) === null || _ === void 0 ? void 0 : _.default }];
      }))
    }), p = Ne(he(c, "parseHTML", d));
    p && (f.parseDOM = p.map((b) => Ww(b, u)));
    const m = he(c, "renderHTML", d);
    m && (f.toDOM = (b) => m({
      node: b,
      HTMLAttributes: sO(b, u)
    }));
    const g = he(c, "renderText", d);
    return g && (f.toText = g), [c.name, f];
  })), l = Object.fromEntries(s.map((c) => {
    const u = i.filter((g) => g.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, h = t.reduce((g, b) => {
      const _ = he(b, "extendMarkSchema", d);
      return {
        ...g,
        ..._ ? _(c) : {}
      };
    }, {}), f = Vw({
      ...h,
      inclusive: Ne(he(c, "inclusive", d)),
      excludes: Ne(he(c, "excludes", d)),
      group: Ne(he(c, "group", d)),
      spanning: Ne(he(c, "spanning", d)),
      code: Ne(he(c, "code", d)),
      attrs: Object.fromEntries(u.map((g) => {
        var b;
        return [g.name, { default: (b = g == null ? void 0 : g.attribute) === null || b === void 0 ? void 0 : b.default }];
      }))
    }), p = Ne(he(c, "parseHTML", d));
    p && (f.parseDOM = p.map((g) => Ww(g, u)));
    const m = he(c, "renderHTML", d);
    return m && (f.toDOM = (g) => m({
      mark: g,
      HTMLAttributes: sO(g, u)
    })), [c.name, f];
  }));
  return new u0({
    topNode: o,
    nodes: a,
    marks: l
  });
}
function Vg(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function Zw(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
const VW = (t, e = 500) => {
  let n = "";
  const i = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, i - e), i, (r, s, o, a) => {
    var l, c;
    const u = ((c = (l = r.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
      node: r,
      pos: s,
      parent: o,
      index: a
    })) || r.textContent || "%leaf%";
    n += r.isAtom ? u : u.slice(0, Math.max(0, i - s));
  }), n;
};
function k2(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class Hd {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const ZW = (t, e) => {
  if (k2(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const i = [n.text];
  return i.index = n.index, i.input = t, i.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), i.push(n.replaceWith)), i;
};
function Lh(t) {
  var e;
  const { editor: n, from: i, to: r, text: s, rules: o, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(i);
  if (
    // check for code node
    c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find((h) => h.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = VW(c) + s;
  return o.forEach((h) => {
    if (u)
      return;
    const f = ZW(d, h.find);
    if (!f)
      return;
    const p = l.state.tr, m = k0({
      state: l.state,
      transaction: p
    }), g = {
      from: i - (f[0].length - s.length),
      to: r
    }, { commands: b, chain: _, can: y } = new E0({
      editor: n,
      state: m
    });
    h.handler({
      state: m,
      range: g,
      match: f,
      commands: b,
      chain: _,
      can: y
    }) === null || !p.steps.length || (p.setMeta(a, {
      transform: p,
      from: i,
      to: r,
      text: s
    }), l.dispatch(p), u = !0);
  }), u;
}
function HW(t) {
  const { editor: e, rules: n } = t, i = new Ue({
    state: {
      init() {
        return null;
      },
      apply(r, s) {
        const o = r.getMeta(i);
        if (o)
          return o;
        const a = r.getMeta("applyInputRules");
        return !!a && setTimeout(() => {
          const { from: c, text: u } = a, d = c + u.length;
          Lh({
            editor: e,
            from: c,
            to: d,
            text: u,
            rules: n,
            plugin: i
          });
        }), r.selectionSet || r.docChanged ? null : s;
      }
    },
    props: {
      handleTextInput(r, s, o, a) {
        return Lh({
          editor: e,
          from: s,
          to: o,
          text: a,
          rules: n,
          plugin: i
        });
      },
      handleDOMEvents: {
        compositionend: (r) => (setTimeout(() => {
          const { $cursor: s } = r.state.selection;
          s && Lh({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: "",
            rules: n,
            plugin: i
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(r, s) {
        if (s.key !== "Enter")
          return !1;
        const { $cursor: o } = r.state.selection;
        return o ? Lh({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: n,
          plugin: i
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return i;
}
function qW(t) {
  return typeof t == "number";
}
class E2 {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const XW = (t, e, n) => {
  if (k2(e))
    return [...t.matchAll(e)];
  const i = e(t, n);
  return i ? i.map((r) => {
    const s = [r.text];
    return s.index = r.index, s.input = t, s.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(r.replaceWith)), s;
  }) : [];
};
function jW(t) {
  const { editor: e, state: n, from: i, to: r, rule: s, pasteEvent: o, dropEvent: a } = t, { commands: l, chain: c, can: u } = new E0({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(i, r, (f, p) => {
    if (!f.isTextblock || f.type.spec.code)
      return;
    const m = Math.max(i, p), g = Math.min(r, p + f.content.size), b = f.textBetween(m - p, g - p, void 0, "");
    XW(b, s.find, o).forEach((y) => {
      if (y.index === void 0)
        return;
      const O = m + y.index + 1, x = O + y[0].length, v = {
        from: n.tr.mapping.map(O),
        to: n.tr.mapping.map(x)
      }, w = s.handler({
        state: n,
        range: v,
        match: y,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: o,
        dropEvent: a
      });
      d.push(w);
    });
  }), d.every((f) => f !== null);
}
const YW = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function GW(t) {
  const { editor: e, rules: n } = t;
  let i = null, r = !1, s = !1, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  const l = ({ state: u, from: d, to: h, rule: f, pasteEvt: p }) => {
    const m = u.tr, g = k0({
      state: u,
      transaction: m
    });
    if (!(!jW({
      editor: e,
      state: g,
      from: Math.max(d - 1, 0),
      to: h.b - 1,
      rule: f,
      pasteEvent: p,
      dropEvent: a
    }) || !m.steps.length))
      return a = typeof DragEvent < "u" ? new DragEvent("drop") : null, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
  };
  return n.map((u) => new Ue({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const h = (f) => {
        var p;
        i = !((p = d.dom.parentElement) === null || p === void 0) && p.contains(f.target) ? d.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", h), {
        destroy() {
          window.removeEventListener("dragstart", h);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, h) => (s = i === d.dom.parentElement, a = h, !1),
        paste: (d, h) => {
          var f;
          const p = (f = h.clipboardData) === null || f === void 0 ? void 0 : f.getData("text/html");
          return o = h, r = !!(p != null && p.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, h, f) => {
      const p = d[0], m = p.getMeta("uiEvent") === "paste" && !r, g = p.getMeta("uiEvent") === "drop" && !s, b = p.getMeta("applyPasteRules"), _ = !!b;
      if (!m && !g && !_)
        return;
      if (_) {
        const { from: x, text: v } = b, w = x + v.length, T = YW(v);
        return l({
          rule: u,
          state: f,
          from: x,
          to: { b: w },
          pasteEvt: T
        });
      }
      const y = h.doc.content.findDiffStart(f.doc.content), O = h.doc.content.findDiffEnd(f.doc.content);
      if (!(!qW(y) || !O || y === O.b))
        return l({
          rule: u,
          state: f,
          from: y,
          to: O,
          pasteEvt: o
        });
    }
  }));
}
function KW(t) {
  const e = t.filter((n, i) => t.indexOf(n) !== i);
  return [...new Set(e)];
}
class ra {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = ra.resolve(e), this.schema = cP(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = ra.sort(ra.flatten(e)), i = KW(n.map((r) => r.name));
    return i.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${i.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const i = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, r = he(n, "addExtensions", i);
      return r ? [n, ...this.flatten(r())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((i, r) => {
      const s = he(i, "priority") || 100, o = he(r, "priority") || 100;
      return s > o ? -1 : s < o ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const i = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: Vg(n.name, this.schema)
      }, r = he(n, "addCommands", i);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = ra.sort([...this.extensions].reverse()), i = [], r = [], s = n.map((o) => {
      const a = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: Vg(o.name, this.schema)
      }, l = [], c = he(o, "addKeyboardShortcuts", a);
      let u = {};
      if (o.type === "mark" && he(o, "exitable", a) && (u.ArrowRight = () => Tn.handleExit({ editor: e, mark: o })), c) {
        const m = Object.fromEntries(Object.entries(c()).map(([g, b]) => [g, () => b({ editor: e })]));
        u = { ...u, ...m };
      }
      const d = p7(u);
      l.push(d);
      const h = he(o, "addInputRules", a);
      Zw(o, e.options.enableInputRules) && h && i.push(...h());
      const f = he(o, "addPasteRules", a);
      Zw(o, e.options.enablePasteRules) && f && r.push(...f());
      const p = he(o, "addProseMirrorPlugins", a);
      if (p) {
        const m = p();
        l.push(...m);
      }
      return l;
    }).flat();
    return [
      HW({
        editor: e,
        rules: i
      }),
      ...GW({
        editor: e,
        rules: r
      }),
      ...s
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return aP(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = C0(this.extensions);
    return Object.fromEntries(n.filter((i) => !!he(i, "addNodeView")).map((i) => {
      const r = this.attributes.filter((l) => l.type === i.name), s = {
        name: i.name,
        options: i.options,
        storage: i.storage,
        editor: e,
        type: Zt(i.name, this.schema)
      }, o = he(i, "addNodeView", s);
      if (!o)
        return [];
      const a = (l, c, u, d) => {
        const h = sO(l, r);
        return o()({
          editor: e,
          node: l,
          getPos: u,
          decorations: d,
          HTMLAttributes: h,
          extension: i
        });
      };
      return [i.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const i = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: Vg(e.name, this.schema)
      };
      e.type === "mark" && (!((n = Ne(he(e, "keepOnSplit", i))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const r = he(e, "onBeforeCreate", i), s = he(e, "onCreate", i), o = he(e, "onUpdate", i), a = he(e, "onSelectionUpdate", i), l = he(e, "onTransaction", i), c = he(e, "onFocus", i), u = he(e, "onBlur", i), d = he(e, "onDestroy", i);
      r && this.editor.on("beforeCreate", r), s && this.editor.on("create", s), o && this.editor.on("update", o), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
}
function JW(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Bh(t) {
  return JW(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function A0(t, e) {
  const n = { ...t };
  return Bh(t) && Bh(e) && Object.keys(e).forEach((i) => {
    Bh(e[i]) && Bh(t[i]) ? n[i] = A0(t[i], e[i]) : n[i] = e[i];
  }), n;
}
class mt {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ne(he(this, "addOptions", {
      name: this.name
    }))), this.storage = Ne(he(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new mt(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => A0(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new mt({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ne(he(n, "addOptions", {
      name: n.name
    })), n.storage = Ne(he(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function uP(t, e, n) {
  const { from: i, to: r } = e, { blockSeparator: s = `

`, textSerializers: o = {} } = n || {};
  let a = "";
  return t.nodesBetween(i, r, (l, c, u, d) => {
    var h;
    l.isBlock && c > i && (a += s);
    const f = o == null ? void 0 : o[l.type.name];
    if (f)
      return u && (a += f({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), !1;
    l.isText && (a += (h = l == null ? void 0 : l.text) === null || h === void 0 ? void 0 : h.slice(Math.max(i, c) - c, r - c));
  }), a;
}
function C2(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const dP = mt.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: i, selection: r } = e, { ranges: s } = r, o = Math.min(...s.map((u) => u.$from.pos)), a = Math.max(...s.map((u) => u.$to.pos)), l = C2(n);
            return uP(i, { from: o, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), eV = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), tV = (t = !1) => ({ commands: e }) => e.setContent("", t), nV = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: i } = e, { ranges: r } = i;
  return n && r.forEach(({ $from: s, $to: o }) => {
    t.doc.nodesBetween(s.pos, o.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), h = c.resolve(u.map(l + a.nodeSize)), f = d.blockRange(h);
      if (!f)
        return;
      const p = pc(f);
      if (a.type.isTextblock) {
        const { defaultType: m } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(f.start, m);
      }
      (p || p === 0) && e.lift(f, p);
    });
  }), !0;
}, iV = (t) => (e) => t(e), rV = () => ({ state: t, dispatch: e }) => AT(t, e), sV = (t, e) => ({ editor: n, tr: i }) => {
  const { state: r } = n, s = r.doc.slice(t.from, t.to);
  i.deleteRange(t.from, t.to);
  const o = i.mapping.map(e);
  return i.insert(o, s.content), i.setSelection(new ce(i.doc.resolve(o - 1))), !0;
}, oV = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, i = n.$anchor.node();
  if (i.content.size > 0)
    return !1;
  const r = t.selection.$anchor;
  for (let s = r.depth; s > 0; s -= 1)
    if (r.node(s).type === i.type) {
      if (e) {
        const a = r.before(s), l = r.after(s);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, aV = (t) => ({ tr: e, state: n, dispatch: i }) => {
  const r = Zt(t, n.schema), s = e.selection.$anchor;
  for (let o = s.depth; o > 0; o -= 1)
    if (s.node(o).type === r) {
      if (i) {
        const l = s.before(o), c = s.after(o);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, lV = (t) => ({ tr: e, dispatch: n }) => {
  const { from: i, to: r } = t;
  return n && e.delete(i, r), !0;
}, cV = () => ({ state: t, dispatch: e }) => n2(t, e), uV = () => ({ commands: t }) => t.keyboardShortcut("Enter"), dV = () => ({ state: t, dispatch: e }) => CT(t, e);
function Lp(t, e, n = { strict: !0 }) {
  const i = Object.keys(e);
  return i.length ? i.every((r) => n.strict ? e[r] === t[r] : k2(e[r]) ? e[r].test(t[r]) : e[r] === t[r]) : !0;
}
function oO(t, e, n = {}) {
  return t.find((i) => i.type === e && Lp(i.attrs, n));
}
function hV(t, e, n = {}) {
  return !!oO(t, e, n);
}
function A2(t, e, n = {}) {
  if (!t || !e)
    return;
  let i = t.parent.childAfter(t.parentOffset);
  if (t.parentOffset === i.offset && i.offset !== 0 && (i = t.parent.childBefore(t.parentOffset)), !i.node)
    return;
  const r = oO([...i.node.marks], e, n);
  if (!r)
    return;
  let s = i.index, o = t.start() + i.offset, a = s + 1, l = o + i.node.nodeSize;
  for (oO([...i.node.marks], e, n); s > 0 && r.isInSet(t.parent.child(s - 1).marks); )
    s -= 1, o -= t.parent.child(s).nodeSize;
  for (; a < t.parent.childCount && hV([...t.parent.child(a).marks], e, n); )
    l += t.parent.child(a).nodeSize, a += 1;
  return {
    from: o,
    to: l
  };
}
function Io(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const fV = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  const s = Io(t, i.schema), { doc: o, selection: a } = n, { $from: l, from: c, to: u } = a;
  if (r) {
    const d = A2(l, s, e);
    if (d && d.from <= c && d.to >= u) {
      const h = ce.create(o, d.from, d.to);
      n.setSelection(h);
    }
  }
  return !0;
}, pV = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let i = 0; i < n.length; i += 1)
    if (n[i](e))
      return !0;
  return !1;
};
function qd(t) {
  return t instanceof ce;
}
function xs(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function hP(t, e = null) {
  if (!e)
    return null;
  const n = _e.atStart(t), i = _e.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return i;
  const r = n.from, s = i.to;
  return e === "all" ? ce.create(t, xs(0, r, s), xs(t.content.size, r, s)) : ce.create(t, xs(e, r, s), xs(e, r, s));
}
function T0() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const mV = (t = null, e = {}) => ({ editor: n, view: i, tr: r, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const o = () => {
    T0() && i.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (i.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (i.hasFocus() && t === null || t === !1)
    return !0;
  if (s && t === null && !qd(n.state.selection))
    return o(), !0;
  const a = hP(r.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return s && (l || r.setSelection(a), l && r.storedMarks && r.setStoredMarks(r.storedMarks), o()), !0;
}, gV = (t, e) => (n) => t.every((i, r) => e(i, { ...n, index: r })), bV = (t, e) => ({ tr: n, commands: i }) => i.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), fP = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const i = e[n];
    i.nodeType === 3 && i.nodeValue && /^(\n\s\s|\n)$/.test(i.nodeValue) ? t.removeChild(i) : i.nodeType === 1 && fP(i);
  }
  return t;
};
function Xc(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return fP(n);
}
function Bp(t, e, n) {
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const i = typeof t == "object" && t !== null, r = typeof t == "string";
  if (i)
    try {
      return Array.isArray(t) && t.length > 0 ? Y.fromArray(t.map((o) => e.nodeFromJSON(o))) : e.nodeFromJSON(t);
    } catch (s) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: s });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", s), Bp("", e, n);
    }
  if (r) {
    if (n.errorOnInvalidContent) {
      let o = !1, a = "";
      const l = new u0({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (o = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? ws.fromSchema(l).parseSlice(Xc(t), n.parseOptions) : ws.fromSchema(l).parse(Xc(t), n.parseOptions), n.errorOnInvalidContent && o)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const s = ws.fromSchema(e);
    return n.slice ? s.parseSlice(Xc(t), n.parseOptions).content : s.parse(Xc(t), n.parseOptions);
  }
  return Bp("", e, n);
}
function OV(t, e, n) {
  const i = t.steps.length - 1;
  if (i < e)
    return;
  const r = t.steps[i];
  if (!(r instanceof tn || r instanceof on))
    return;
  const s = t.mapping.maps[i];
  let o = 0;
  s.forEach((a, l, c, u) => {
    o === 0 && (o = u);
  }), t.setSelection(_e.near(t.doc.resolve(o), n));
}
const yV = (t) => !("type" in t), _V = (t, e, n) => ({ tr: i, dispatch: r, editor: s }) => {
  var o;
  if (r) {
    n = {
      parseOptions: {},
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    try {
      a = Bp(e, s.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (o = n.errorOnInvalidContent) !== null && o !== void 0 ? o : s.options.enableContentCheck
      });
    } catch (p) {
      return s.emit("contentError", {
        editor: s,
        error: p,
        disableCollaboration: () => {
          console.error("[tiptap error]: Unable to disable collaboration at this point in time");
        }
      }), !1;
    }
    let { from: l, to: c } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, u = !0, d = !0;
    if ((yV(a) ? a : [a]).forEach((p) => {
      p.check(), u = u ? p.isText && p.marks.length === 0 : !1, d = d ? p.isBlock : !1;
    }), l === c && d) {
      const { parent: p } = i.doc.resolve(l);
      p.isTextblock && !p.type.spec.code && !p.childCount && (l -= 1, c += 1);
    }
    let f;
    u ? (Array.isArray(e) ? f = e.map((p) => p.text || "").join("") : typeof e == "object" && e && e.text ? f = e.text : f = e, i.insertText(f, l, c)) : (f = a, i.replaceWith(l, c, f)), n.updateSelection && OV(i, i.steps.length - 1, -1), n.applyInputRules && i.setMeta("applyInputRules", { from: l, text: f }), n.applyPasteRules && i.setMeta("applyPasteRules", { from: l, text: f });
  }
  return !0;
}, vV = () => ({ state: t, dispatch: e }) => $b(t, e), xV = () => ({ state: t, dispatch: e }) => J9(t, e), wV = () => ({ state: t, dispatch: e }) => _T(t, e), SV = () => ({ state: t, dispatch: e }) => ST(t, e), kV = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const i = h0(t.doc, t.selection.$from.pos, -1);
    return i == null ? !1 : (n.join(i, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, EV = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const i = h0(t.doc, t.selection.$from.pos, 1);
    return i == null ? !1 : (n.join(i, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, CV = () => ({ state: t, dispatch: e }) => G9(t, e), AV = () => ({ state: t, dispatch: e }) => K9(t, e);
function pP() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function TV(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let i, r, s, o;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      T0() || pP() ? o = !0 : r = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return i && (n = `Alt-${n}`), r && (n = `Ctrl-${n}`), o && (n = `Meta-${n}`), s && (n = `Shift-${n}`), n;
}
const MV = (t) => ({ editor: e, view: n, tr: i, dispatch: r }) => {
  const s = TV(t).split(/-(?!$)/), o = s.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(i.mapping);
    u && r && i.maybeStep(u);
  }), !0;
};
function Fi(t, e, n = {}) {
  const { from: i, to: r, empty: s } = t.selection, o = e ? Zt(e, t.schema) : null, a = [];
  t.doc.nodesBetween(i, r, (d, h) => {
    if (d.isText)
      return;
    const f = Math.max(i, h), p = Math.min(r, h + d.nodeSize);
    a.push({
      node: d,
      from: f,
      to: p
    });
  });
  const l = r - i, c = a.filter((d) => o ? o.name === d.node.type.name : !0).filter((d) => Lp(d.node.attrs, n, { strict: !1 }));
  return s ? !!c.length : c.reduce((d, h) => d + h.to - h.from, 0) >= l;
}
const PV = (t, e = {}) => ({ state: n, dispatch: i }) => {
  const r = Zt(t, n.schema);
  return Fi(n, r, e) ? Nb(n, i) : !1;
}, RV = () => ({ state: t, dispatch: e }) => TT(t, e), $V = (t) => ({ state: e, dispatch: n }) => {
  const i = Zt(t, e.schema);
  return zU(i)(e, n);
}, NV = () => ({ state: t, dispatch: e }) => ET(t, e);
function M0(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Hw(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((i, r) => (n.includes(r) || (i[r] = t[r]), i), {});
}
const DV = (t, e) => ({ tr: n, state: i, dispatch: r }) => {
  let s = null, o = null;
  const a = M0(typeof t == "string" ? t : t.name, i.schema);
  return a ? (a === "node" && (s = Zt(t, i.schema)), a === "mark" && (o = Io(t, i.schema)), r && n.selection.ranges.forEach((l) => {
    i.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
      s && s === c.type && n.setNodeMarkup(u, void 0, Hw(c.attrs, e)), o && c.marks.length && c.marks.forEach((d) => {
        o === d.type && n.addMark(u, u + c.nodeSize, o.create(Hw(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, IV = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), LV = () => ({ tr: t, commands: e }) => e.setTextSelection({
  from: 0,
  to: t.doc.content.size
}), BV = () => ({ state: t, dispatch: e }) => xT(t, e), QV = () => ({ state: t, dispatch: e }) => kT(t, e), FV = () => ({ state: t, dispatch: e }) => Db(t, e), zV = () => ({ state: t, dispatch: e }) => NT(t, e), UV = () => ({ state: t, dispatch: e }) => $T(t, e);
function aO(t, e, n = {}, i = {}) {
  return Bp(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: i.errorOnInvalidContent
  });
}
const WV = (t, e = !1, n = {}, i = {}) => ({ editor: r, tr: s, dispatch: o, commands: a }) => {
  var l, c;
  const { doc: u } = s;
  if (n.preserveWhitespace !== "full") {
    const d = aO(t, r.schema, n, {
      errorOnInvalidContent: (l = i.errorOnInvalidContent) !== null && l !== void 0 ? l : r.options.enableContentCheck
    });
    return o && s.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), !0;
  }
  return o && s.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: u.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (c = i.errorOnInvalidContent) !== null && c !== void 0 ? c : r.options.enableContentCheck
  });
};
function Xd(t, e) {
  const n = Io(e, t.schema), { from: i, to: r, empty: s } = t.selection, o = [];
  s ? (t.storedMarks && o.push(...t.storedMarks), o.push(...t.selection.$head.marks())) : t.doc.nodesBetween(i, r, (l) => {
    o.push(...l.marks);
  });
  const a = o.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function VV(t, e) {
  const n = new e2(t);
  return e.forEach((i) => {
    i.steps.forEach((r) => {
      n.step(r);
    });
  }), n;
}
function ZV(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function lO(t, e) {
  const n = [];
  return t.descendants((i, r) => {
    e(i) && n.push({
      node: i,
      pos: r
    });
  }), n;
}
function HV(t, e, n) {
  const i = [];
  return t.nodesBetween(e.from, e.to, (r, s) => {
    n(r) && i.push({
      node: r,
      pos: s
    });
  }), i;
}
function mP(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const i = t.node(n);
    if (e(i))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: i
      };
  }
}
function Hi(t) {
  return (e) => mP(e.$from, t);
}
function gP(t, e) {
  const n = Wa.fromSchema(e).serializeFragment(t), r = document.implementation.createHTMLDocument().createElement("div");
  return r.appendChild(n), r.innerHTML;
}
function T2(t, e) {
  const n = ra.resolve(t);
  return cP(n, e);
}
function Xve(t, e) {
  const n = T2(e), i = Wr.fromJSON(n, t);
  return gP(i.content, n);
}
function jve(t, e) {
  const n = T2(e), i = Xc(t);
  return ws.fromSchema(n).parse(i).toJSON();
}
function bP(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return uP(t, n, e);
}
function Yve(t, e, n) {
  const { blockSeparator: i = `

`, textSerializers: r = {} } = n || {}, s = T2(e), o = Wr.fromJSON(s, t);
  return bP(o, {
    blockSeparator: i,
    textSerializers: {
      ...C2(s),
      ...r
    }
  });
}
function qV(t, e) {
  const n = Zt(e, t.schema), { from: i, to: r } = t.selection, s = [];
  t.doc.nodesBetween(i, r, (a) => {
    s.push(a);
  });
  const o = s.reverse().find((a) => a.type.name === n.name);
  return o ? { ...o.attrs } : {};
}
function OP(t, e) {
  const n = M0(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? qV(t, e) : n === "mark" ? Xd(t, e) : {};
}
function XV(t, e = JSON.stringify) {
  const n = {};
  return t.filter((i) => {
    const r = e(i);
    return Object.prototype.hasOwnProperty.call(n, r) ? !1 : n[r] = !0;
  });
}
function jV(t) {
  const e = XV(t);
  return e.length === 1 ? e : e.filter((n, i) => !e.filter((s, o) => o !== i).some((s) => n.oldRange.from >= s.oldRange.from && n.oldRange.to <= s.oldRange.to && n.newRange.from >= s.newRange.from && n.newRange.to <= s.newRange.to));
}
function YV(t) {
  const { mapping: e, steps: n } = t, i = [];
  return e.maps.forEach((r, s) => {
    const o = [];
    if (r.ranges.length)
      r.forEach((a, l) => {
        o.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[s];
      if (a === void 0 || l === void 0)
        return;
      o.push({ from: a, to: l });
    }
    o.forEach(({ from: a, to: l }) => {
      const c = e.slice(s).map(a, -1), u = e.slice(s).map(l), d = e.invert().map(c, -1), h = e.invert().map(u);
      i.push({
        oldRange: {
          from: d,
          to: h
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), jV(i);
}
function GV(t, e = 0) {
  const i = t.type === t.type.schema.topNodeType ? 0 : 1, r = e, s = r + t.nodeSize, o = t.marks.map((c) => {
    const u = {
      type: c.type.name
    };
    return Object.keys(c.attrs).length && (u.attrs = { ...c.attrs }), u;
  }), a = { ...t.attrs }, l = {
    type: t.type.name,
    from: r,
    to: s
  };
  return Object.keys(a).length && (l.attrs = a), o.length && (l.marks = o), t.content.childCount && (l.content = [], t.forEach((c, u) => {
    var d;
    (d = l.content) === null || d === void 0 || d.push(GV(c, e + u + i));
  })), t.text && (l.text = t.text), l;
}
function M2(t, e, n) {
  const i = [];
  return t === e ? n.resolve(t).marks().forEach((r) => {
    const s = n.resolve(t - 1), o = A2(s, r.type);
    o && i.push({
      mark: r,
      ...o
    });
  }) : n.nodesBetween(t, e, (r, s) => {
    !r || (r == null ? void 0 : r.nodeSize) === void 0 || i.push(...r.marks.map((o) => ({
      from: s,
      to: s + r.nodeSize,
      mark: o
    })));
  }), i;
}
const KV = (t, e, n, i = 20) => {
  const r = t.doc.resolve(n);
  let s = i, o = null;
  for (; s > 0 && o === null; ) {
    const a = r.node(s);
    (a == null ? void 0 : a.type.name) === e ? o = a : s -= 1;
  }
  return [o, s];
};
function Xf(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([i]) => {
    const r = t.find((s) => s.type === e && s.name === i);
    return r ? r.attribute.keepOnSplit : !1;
  }));
}
function cO(t, e, n = {}) {
  const { empty: i, ranges: r } = t.selection, s = e ? Io(e, t.schema) : null;
  if (i)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((d) => s ? s.name === d.type.name : !0).find((d) => Lp(d.attrs, n, { strict: !1 }));
  let o = 0;
  const a = [];
  if (r.forEach(({ $from: d, $to: h }) => {
    const f = d.pos, p = h.pos;
    t.doc.nodesBetween(f, p, (m, g) => {
      if (!m.isText && !m.marks.length)
        return;
      const b = Math.max(f, g), _ = Math.min(p, g + m.nodeSize), y = _ - b;
      o += y, a.push(...m.marks.map((O) => ({
        mark: O,
        from: b,
        to: _
      })));
    });
  }), o === 0)
    return !1;
  const l = a.filter((d) => s ? s.name === d.mark.type.name : !0).filter((d) => Lp(d.mark.attrs, n, { strict: !1 })).reduce((d, h) => d + h.to - h.from, 0), c = a.filter((d) => s ? d.mark.type !== s && d.mark.type.excludes(s) : !0).reduce((d, h) => d + h.to - h.from, 0);
  return (l > 0 ? l + c : l) >= o;
}
function xi(t, e, n = {}) {
  if (!e)
    return Fi(t, null, n) || cO(t, null, n);
  const i = M0(e, t.schema);
  return i === "node" ? Fi(t, e, n) : i === "mark" ? cO(t, e, n) : !1;
}
const JV = (t, e) => {
  const { $from: n, $to: i, $anchor: r } = t.selection;
  if (e) {
    const s = Hi((a) => a.type.name === e)(t.selection);
    if (!s)
      return !1;
    const o = t.doc.resolve(s.pos + 1);
    return r.pos + 1 === o.end();
  }
  return !(i.parentOffset < i.parent.nodeSize - 2 || n.pos !== i.pos);
}, eZ = (t) => {
  const { $from: e, $to: n } = t.selection;
  return !(e.parentOffset > 0 || e.pos !== n.pos);
};
function uO(t, e) {
  const { nodeExtensions: n } = C0(e), i = n.find((o) => o.name === t);
  if (!i)
    return !1;
  const r = {
    name: i.name,
    options: i.options,
    storage: i.storage
  }, s = Ne(he(i, "group", r));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function P2(t, { checkChildren: e } = { checkChildren: !0 }) {
  if (t.isText)
    return !t.text;
  if (t.content.childCount === 0)
    return !0;
  if (t.isLeaf)
    return !1;
  if (e) {
    let n = !0;
    return t.content.forEach((i) => {
      n !== !1 && (P2(i) || (n = !1));
    }), n;
  }
  return !1;
}
function Qp(t) {
  return t instanceof ge;
}
function R2(t, e, n) {
  const r = t.state.doc.content.size, s = xs(e, 0, r), o = xs(n, 0, r), a = t.coordsAtPos(s), l = t.coordsAtPos(o, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), h = Math.max(a.right, l.right), f = h - d, p = u - c, b = {
    top: c,
    bottom: u,
    left: d,
    right: h,
    width: f,
    height: p,
    x: d,
    y: c
  };
  return {
    ...b,
    toJSON: () => b
  };
}
function tZ(t, e, n) {
  var i;
  const { selection: r } = e;
  let s = null;
  if (qd(r) && (s = r.$cursor), s) {
    const a = (i = t.storedMarks) !== null && i !== void 0 ? i : s.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: o } = r;
  return o.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (u, d, h) => {
      if (c)
        return !1;
      if (u.isInline) {
        const f = !h || h.type.allowsMarkType(n), p = !!n.isInSet(u.marks) || !u.marks.some((m) => m.type.excludes(n));
        c = f && p;
      }
      return !c;
    }), c;
  });
}
const nZ = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  const { selection: s } = n, { empty: o, ranges: a } = s, l = Io(t, i.schema);
  if (r)
    if (o) {
      const c = Xd(i, l);
      n.addStoredMark(l.create({
        ...c,
        ...e
      }));
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        i.doc.nodesBetween(u, d, (h, f) => {
          const p = Math.max(f, u), m = Math.min(f + h.nodeSize, d);
          h.marks.find((b) => b.type === l) ? h.marks.forEach((b) => {
            l === b.type && n.addMark(p, m, l.create({
              ...b.attrs,
              ...e
            }));
          }) : n.addMark(p, m, l.create(e));
        });
      });
  return tZ(i, n, l);
}, iZ = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), rZ = (t, e = {}) => ({ state: n, dispatch: i, chain: r }) => {
  const s = Zt(t, n.schema);
  return s.isTextblock ? r().command(({ commands: o }) => Lb(s, e)(n) ? !0 : o.clearNodes()).command(({ state: o }) => Lb(s, e)(o, i)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, sZ = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: i } = e, r = xs(t, 0, i.content.size), s = ge.create(i, r);
    e.setSelection(s);
  }
  return !0;
}, oZ = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: i } = e, { from: r, to: s } = typeof t == "number" ? { from: t, to: t } : t, o = ce.atStart(i).from, a = ce.atEnd(i).to, l = xs(r, o, a), c = xs(s, o, a), u = ce.create(i, l, c);
    e.setSelection(u);
  }
  return !0;
}, aZ = (t) => ({ state: e, dispatch: n }) => {
  const i = Zt(t, e.schema);
  return VU(i)(e, n);
};
function qw(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const i = n.filter((r) => e == null ? void 0 : e.includes(r.type.name));
    t.tr.ensureMarks(i);
  }
}
const lZ = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: i, editor: r }) => {
  const { selection: s, doc: o } = e, { $from: a, $to: l } = s, c = r.extensionManager.attributes, u = Xf(c, a.node().type.name, a.node().attrs);
  if (s instanceof ge && s.node.isBlock)
    return !a.parentOffset || !Vr(o, a.pos) ? !1 : (i && (t && qw(n, r.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, h = a.depth === 0 ? void 0 : ZV(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let f = d && h ? [
    {
      type: h,
      attrs: u
    }
  ] : void 0, p = Vr(e.doc, e.mapping.map(a.pos), 1, f);
  if (!f && !p && Vr(e.doc, e.mapping.map(a.pos), 1, h ? [{ type: h }] : void 0) && (p = !0, f = h ? [
    {
      type: h,
      attrs: u
    }
  ] : void 0), i) {
    if (p && (s instanceof ce && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, f), h && !d && !a.parentOffset && a.parent.type !== h)) {
      const m = e.mapping.map(a.before()), g = e.doc.resolve(m);
      a.node(-1).canReplaceWith(g.index(), g.index() + 1, h) && e.setNodeMarkup(e.mapping.map(a.before()), h);
    }
    t && qw(n, r.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return p;
}, cZ = (t) => ({ tr: e, state: n, dispatch: i, editor: r }) => {
  var s;
  const o = Zt(t, n.schema), { $from: a, $to: l } = n.selection, c = n.selection.node;
  if (c && c.isBlock || a.depth < 2 || !a.sameParent(l))
    return !1;
  const u = a.node(-1);
  if (u.type !== o)
    return !1;
  const d = r.extensionManager.attributes;
  if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
    if (a.depth === 2 || a.node(-3).type !== o || a.index(-2) !== a.node(-2).childCount - 1)
      return !1;
    if (i) {
      let g = Y.empty;
      const b = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
      for (let w = a.depth - b; w >= a.depth - 3; w -= 1)
        g = Y.from(a.node(w).copy(g));
      const _ = a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3, y = Xf(d, a.node().type.name, a.node().attrs), O = ((s = o.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(y)) || void 0;
      g = g.append(Y.from(o.createAndFill(null, O) || void 0));
      const x = a.before(a.depth - (b - 1));
      e.replace(x, a.after(-_), new ne(g, 4 - b, 0));
      let v = -1;
      e.doc.nodesBetween(x, e.doc.content.size, (w, T) => {
        if (v > -1)
          return !1;
        w.isTextblock && w.content.size === 0 && (v = T + 1);
      }), v > -1 && e.setSelection(ce.near(e.doc.resolve(v))), e.scrollIntoView();
    }
    return !0;
  }
  const h = l.pos === a.end() ? u.contentMatchAt(0).defaultType : null, f = Xf(d, u.type.name, u.attrs), p = Xf(d, a.node().type.name, a.node().attrs);
  e.delete(a.pos, l.pos);
  const m = h ? [
    { type: o, attrs: f },
    { type: h, attrs: p }
  ] : [{ type: o, attrs: f }];
  if (!Vr(e.doc, a.pos, 2))
    return !1;
  if (i) {
    const { selection: g, storedMarks: b } = n, { splittableMarks: _ } = r.extensionManager, y = b || g.$to.parentOffset && g.$from.marks();
    if (e.split(a.pos, 2, m).scrollIntoView(), !y || !i)
      return !0;
    const O = y.filter((x) => _.includes(x.type.name));
    e.ensureMarks(O);
  }
  return !0;
}, Zg = (t, e) => {
  const n = Hi((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const i = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (i === void 0)
    return !0;
  const r = t.doc.nodeAt(i);
  return n.node.type === (r == null ? void 0 : r.type) && es(t.doc, n.pos) && t.join(n.pos), !0;
}, Hg = (t, e) => {
  const n = Hi((o) => o.type === e)(t.selection);
  if (!n)
    return !0;
  const i = t.doc.resolve(n.start).after(n.depth);
  if (i === void 0)
    return !0;
  const r = t.doc.nodeAt(i);
  return n.node.type === (r == null ? void 0 : r.type) && es(t.doc, i) && t.join(i), !0;
}, uZ = (t, e, n, i = {}) => ({ editor: r, tr: s, state: o, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: h } = r.extensionManager, f = Zt(t, o.schema), p = Zt(e, o.schema), { selection: m, storedMarks: g } = o, { $from: b, $to: _ } = m, y = b.blockRange(_), O = g || m.$to.parentOffset && m.$from.marks();
  if (!y)
    return !1;
  const x = Hi((v) => uO(v.type.name, d))(m);
  if (y.depth >= 1 && x && y.depth - x.depth <= 1) {
    if (x.node.type === f)
      return c.liftListItem(p);
    if (uO(x.node.type.name, d) && f.validContent(x.node.content) && a)
      return l().command(() => (s.setNodeMarkup(x.pos, f), !0)).command(() => Zg(s, f)).command(() => Hg(s, f)).run();
  }
  return !n || !O || !a ? l().command(() => u().wrapInList(f, i) ? !0 : c.clearNodes()).wrapInList(f, i).command(() => Zg(s, f)).command(() => Hg(s, f)).run() : l().command(() => {
    const v = u().wrapInList(f, i), w = O.filter((T) => h.includes(T.type.name));
    return s.ensureMarks(w), v ? !0 : c.clearNodes();
  }).wrapInList(f, i).command(() => Zg(s, f)).command(() => Hg(s, f)).run();
}, dZ = (t, e = {}, n = {}) => ({ state: i, commands: r }) => {
  const { extendEmptyMarkRange: s = !1 } = n, o = Io(t, i.schema);
  return cO(i, o, e) ? r.unsetMark(o, { extendEmptyMarkRange: s }) : r.setMark(o, e);
}, hZ = (t, e, n = {}) => ({ state: i, commands: r }) => {
  const s = Zt(t, i.schema), o = Zt(e, i.schema);
  return Fi(i, s, n) ? r.setNode(o) : r.setNode(s, n);
}, fZ = (t, e = {}) => ({ state: n, commands: i }) => {
  const r = Zt(t, n.schema);
  return Fi(n, r, e) ? i.lift(r) : i.wrapIn(r, e);
}, pZ = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let i = 0; i < n.length; i += 1) {
    const r = n[i];
    let s;
    if (r.spec.isInputRules && (s = r.getState(t))) {
      if (e) {
        const o = t.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          o.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          const l = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, t.schema.text(s.text, l));
        } else
          o.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, mZ = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: i, ranges: r } = n;
  return i || e && r.forEach((s) => {
    t.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, gZ = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  var s;
  const { extendEmptyMarkRange: o = !1 } = e, { selection: a } = n, l = Io(t, i.schema), { $from: c, empty: u, ranges: d } = a;
  if (!r)
    return !0;
  if (u && o) {
    let { from: h, to: f } = a;
    const p = (s = c.marks().find((g) => g.type === l)) === null || s === void 0 ? void 0 : s.attrs, m = A2(c, l, p);
    m && (h = m.from, f = m.to), n.removeMark(h, f, l);
  } else
    d.forEach((h) => {
      n.removeMark(h.$from.pos, h.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, bZ = (t, e = {}) => ({ tr: n, state: i, dispatch: r }) => {
  let s = null, o = null;
  const a = M0(typeof t == "string" ? t : t.name, i.schema);
  return a ? (a === "node" && (s = Zt(t, i.schema)), a === "mark" && (o = Io(t, i.schema)), r && n.selection.ranges.forEach((l) => {
    const c = l.$from.pos, u = l.$to.pos;
    i.doc.nodesBetween(c, u, (d, h) => {
      s && s === d.type && n.setNodeMarkup(h, void 0, {
        ...d.attrs,
        ...e
      }), o && d.marks.length && d.marks.forEach((f) => {
        if (o === f.type) {
          const p = Math.max(h, c), m = Math.min(h + d.nodeSize, u);
          n.addMark(p, m, o.create({
            ...f.attrs,
            ...e
          }));
        }
      });
    });
  }), !0) : !1;
}, OZ = (t, e = {}) => ({ state: n, dispatch: i }) => {
  const r = Zt(t, n.schema);
  return Ib(r, e)(n, i);
}, yZ = (t, e = {}) => ({ state: n, dispatch: i }) => {
  const r = Zt(t, n.schema);
  return BU(r, e)(n, i);
};
var _Z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: eV,
  clearContent: tV,
  clearNodes: nV,
  command: iV,
  createParagraphNear: rV,
  cut: sV,
  deleteCurrentNode: oV,
  deleteNode: aV,
  deleteRange: lV,
  deleteSelection: cV,
  enter: uV,
  exitCode: dV,
  extendMarkRange: fV,
  first: pV,
  focus: mV,
  forEach: gV,
  insertContent: bV,
  insertContentAt: _V,
  joinBackward: wV,
  joinDown: xV,
  joinForward: SV,
  joinItemBackward: kV,
  joinItemForward: EV,
  joinTextblockBackward: CV,
  joinTextblockForward: AV,
  joinUp: vV,
  keyboardShortcut: MV,
  lift: PV,
  liftEmptyBlock: RV,
  liftListItem: $V,
  newlineInCode: NV,
  resetAttributes: DV,
  scrollIntoView: IV,
  selectAll: LV,
  selectNodeBackward: BV,
  selectNodeForward: QV,
  selectParentNode: FV,
  selectTextblockEnd: zV,
  selectTextblockStart: UV,
  setContent: WV,
  setMark: nZ,
  setMeta: iZ,
  setNode: rZ,
  setNodeSelection: sZ,
  setTextSelection: oZ,
  sinkListItem: aZ,
  splitBlock: lZ,
  splitListItem: cZ,
  toggleList: uZ,
  toggleMark: dZ,
  toggleNode: hZ,
  toggleWrap: fZ,
  undoInputRule: pZ,
  unsetAllMarks: mZ,
  unsetMark: gZ,
  updateAttributes: bZ,
  wrapIn: OZ,
  wrapInList: yZ
});
const yP = mt.create({
  name: "commands",
  addCommands() {
    return {
      ..._Z
    };
  }
}), _P = mt.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), vP = mt.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Ue({
        key: new Ke("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const i = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const i = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            }
          }
        }
      })
    ];
  }
}), xP = mt.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      // maybe convert first text block node to default node
      () => o.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: h, parent: f } = d, p = d.parent.isTextblock && h > 0 ? a.doc.resolve(h - 1) : d, m = p.parent.type.spec.isolating, g = d.pos - d.parentOffset, b = m && p.parent.childCount === 1 ? g === d.pos : _e.atStart(c).from === h;
        return !u || !f.type.isTextblock || f.textContent.length || !b || b && d.parent.type.name === "paragraph" ? !1 : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), i = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, r = {
      ...i
    }, s = {
      ...i,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return T0() || pP() ? s : r;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Ue({
        key: new Ke("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (!(t.some((p) => p.docChanged) && !e.doc.eq(n.doc)))
            return;
          const { empty: r, from: s, to: o } = e.selection, a = _e.atStart(e.doc).from, l = _e.atEnd(e.doc).to;
          if (r || !(s === a && o === l) || !(n.doc.textBetween(0, n.doc.content.size, " ", " ").length === 0))
            return;
          const d = n.tr, h = k0({
            state: n,
            transaction: d
          }), { commands: f } = new E0({
            editor: this.editor,
            state: h
          });
          if (f.clearNodes(), !!d.steps.length)
            return d;
        }
      })
    ];
  }
}), wP = mt.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var Gve = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: dP,
  Commands: yP,
  Editable: _P,
  FocusEvents: vP,
  Keymap: xP,
  Tabindex: wP
});
class Ko {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, i = !1, r = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = i, this.resolvedPos = e, this.editor = n, this.currentNode = r;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, i = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, i = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: i }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new Ko(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Ko(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Ko(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, i) => {
      const r = n.isBlock && !n.isTextblock, s = this.pos + i + 1, o = this.resolvedPos.doc.resolve(s);
      if (!r && o.depth <= this.depth)
        return;
      const a = new Ko(o, this.editor, r, r ? n : null);
      r && (a.actualDepth = this.depth + 1), e.push(new Ko(o, this.editor, r, r ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let i = null, r = this.parent;
    for (; r && !i; ) {
      if (r.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const s = r.node.attrs, o = Object.keys(n);
          for (let a = 0; a < o.length; a += 1) {
            const l = o[a];
            if (s[l] !== n[l])
              break;
          }
        } else
          i = r;
      r = r.parent;
    }
    return i;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, i = !1) {
    let r = [];
    if (!this.children || this.children.length === 0)
      return r;
    const s = Object.keys(n);
    return this.children.forEach((o) => {
      i && r.length > 0 || (o.node.type.name === e && s.every((l) => n[l] === o.node.attrs[l]) && r.push(o), !(i && r.length > 0) && (r = r.concat(o.querySelectorAll(e, n, i))));
    }), r;
  }
  setAttribute(e) {
    const n = this.editor.state.selection;
    this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, e).setTextSelection(n.from).run();
  }
}
const vZ = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function xZ(t, e, n) {
  const i = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ""}]`);
  if (i !== null)
    return i;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""), r.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(r), r;
}
let wZ = class extends zW {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      }
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }));
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = xZ(vZ, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(e, n) {
    const i = lP(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: i });
    this.view.updateState(r);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = typeof e == "string" ? `${e}$` : e.key, i = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((r) => !r.key.startsWith(n))
    });
    this.view.updateState(i);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const r = [...this.options.enableCoreExtensions ? [
      _P,
      dP.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      yP,
      vP,
      xP,
      wP
    ] : [], ...this.options.extensions].filter((s) => ["extension", "node", "mark"].includes(s == null ? void 0 : s.type));
    this.extensionManager = new ra(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new E0({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    let e;
    try {
      e = aO(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (s) {
      if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.options.extensions = this.options.extensions.filter((o) => o.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = aO(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const n = hP(e, this.options.autofocus);
    this.view = new qB(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: X9.create({
        doc: e,
        selection: n || void 0
      })
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass();
    const r = this.view.dom;
    r.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((o) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o);
      });
      return;
    }
    const n = this.state.apply(e), i = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), i && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const r = e.getMeta("focus"), s = e.getMeta("blur");
    r && this.emit("focus", {
      editor: this,
      event: r.event,
      transaction: e
    }), s && this.emit("blur", {
      editor: this,
      event: s.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return OP(this.state, e);
  }
  isActive(e, n) {
    const i = typeof e == "string" ? e : null, r = typeof e == "string" ? n : e;
    return xi(this.state, i, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return gP(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: i = {} } = e || {};
    return bP(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...C2(this.schema),
        ...i
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return P2(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.view && this.view.destroy(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new Ko(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Aa(t) {
  return new Hd({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      const r = Ne(t.getAttributes, void 0, i);
      if (r === !1 || r === null)
        return null;
      const { tr: s } = e, o = i[i.length - 1], a = i[0];
      if (o) {
        const l = a.search(/\S/), c = n.from + a.indexOf(o), u = c + o.length;
        if (M2(n.from, n.to, e.doc).filter((f) => f.mark.type.excluded.find((m) => m === t.type && m !== f.mark.type)).filter((f) => f.to > c).length)
          return null;
        u < n.to && s.delete(u, n.to), c > n.from && s.delete(n.from + l, c);
        const h = n.from + l + o.length;
        s.addMark(n.from + l, h, t.type.create(r || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function jd(t) {
  return new Hd({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      const r = Ne(t.getAttributes, void 0, i) || {}, { tr: s } = e, o = n.from;
      let a = n.to;
      const l = t.type.create(r);
      if (i[1]) {
        const c = i[0].lastIndexOf(i[1]);
        let u = o + c;
        u > a ? u = a : a = u + i[1].length;
        const d = i[0][i[0].length - 1];
        s.insertText(d, o + i[0].length - 1), s.replaceWith(u, a, l);
      } else if (i[0]) {
        const c = t.type.isInline ? o : o - 1;
        s.insert(c, t.type.create(r)).delete(s.mapping.map(o), s.mapping.map(a));
      }
      s.scrollIntoView();
    }
  });
}
function dO(t) {
  return new Hd({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      const r = e.doc.resolve(n.from), s = Ne(t.getAttributes, void 0, i) || {};
      if (!r.node(-1).canReplaceWith(r.index(-1), r.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s);
    }
  });
}
function Jve(t) {
  return new Hd({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      let r = t.replace, s = n.from;
      const o = n.to;
      if (i[1]) {
        const a = i[0].lastIndexOf(i[1]);
        r += i[0].slice(a + i[1].length), s += a;
        const l = s - o;
        l > 0 && (r = i[0].slice(a - l, a) + r, s = o);
      }
      e.tr.insertText(r, s, o);
    }
  });
}
function Hl(t) {
  return new Hd({
    find: t.find,
    handler: ({ state: e, range: n, match: i, chain: r }) => {
      const s = Ne(t.getAttributes, void 0, i) || {}, o = e.tr.delete(n.from, n.to), l = o.doc.resolve(n.from).blockRange(), c = l && d0(l, t.type, s);
      if (!c)
        return null;
      if (o.wrap(l, c), t.keepMarks && t.editor) {
        const { selection: d, storedMarks: h } = e, { splittableMarks: f } = t.editor.extensionManager, p = h || d.$to.parentOffset && d.$from.marks();
        if (p) {
          const m = p.filter((g) => f.includes(g.type.name));
          o.ensureMarks(m);
        }
      }
      if (t.keepAttributes) {
        const d = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        r().updateAttributes(d, s).run();
      }
      const u = o.doc.resolve(n.from - 1).nodeBefore;
      u && u.type === t.type && es(o.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(i, u)) && o.join(n.from - 1);
    }
  });
}
class Tn {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ne(he(this, "addOptions", {
      name: this.name
    }))), this.storage = Ne(he(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Tn(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => A0(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Tn(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ne(he(n, "addOptions", {
      name: n.name
    })), n.storage = Ne(he(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: i } = e.state, r = e.state.selection.$from;
    if (r.pos === r.end()) {
      const o = r.marks();
      if (!!!o.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1;
      const l = o.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && i.removeStoredMark(l), i.insertText(" ", r.pos), e.view.dispatch(i), !0;
    }
    return !1;
  }
}
let wt = class hO {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ne(he(this, "addOptions", {
      name: this.name
    }))), this.storage = Ne(he(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new hO(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => A0(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new hO(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ne(he(n, "addOptions", {
      name: n.name
    })), n.storage = Ne(he(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function SZ() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
class kZ {
  constructor(e, n, i) {
    this.isDragging = !1, this.component = e, this.editor = n.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...i
    }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.getPos = n.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var n, i, r, s, o, a, l;
    const { view: c } = this.editor, u = e.target, d = u.nodeType === 3 ? (n = u.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
    if (!this.dom || !((i = this.contentDOM) === null || i === void 0) && i.contains(u) || !d)
      return;
    let h = 0, f = 0;
    if (this.dom !== d) {
      const g = this.dom.getBoundingClientRect(), b = d.getBoundingClientRect(), _ = (r = e.offsetX) !== null && r !== void 0 ? r : (s = e.nativeEvent) === null || s === void 0 ? void 0 : s.offsetX, y = (o = e.offsetY) !== null && o !== void 0 ? o : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
      h = b.x - g.x + _, f = b.y - g.y + y;
    }
    (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(this.dom, h, f);
    const p = ge.create(c.state.doc, this.getPos()), m = c.state.tr.setSelection(p);
    c.dispatch(m);
  }
  stopEvent(e) {
    var n;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const i = e.target;
    if (!(this.dom.contains(i) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(i))))
      return !1;
    const s = e.type.startsWith("drag"), o = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(i.tagName) || i.isContentEditable) && !o && !s)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, d = ge.isSelectable(this.node), h = e.type === "copy", f = e.type === "paste", p = e.type === "cut", m = e.type === "mousedown";
    if (!u && d && s && e.preventDefault(), u && s && !c)
      return e.preventDefault(), !1;
    if (u && l && !c && m) {
      const g = i.closest("[data-drag-handle]");
      g && (this.dom === g || this.dom.contains(g)) && (this.isDragging = !0, document.addEventListener("dragend", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("drop", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("mouseup", () => {
        this.isDragging = !1;
      }, { once: !0 }));
    }
    return !(c || o || h || f || p || m && d);
  }
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (T0() || SZ()) && this.editor.isFocused && [
      ...Array.from(e.addedNodes),
      ...Array.from(e.removedNodes)
    ].every((i) => i.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  updateAttributes(e) {
    this.editor.commands.command(({ tr: n }) => {
      const i = this.getPos();
      return n.setNodeMarkup(i, void 0, {
        ...this.node.attrs,
        ...e
      }), !0;
    });
  }
  deleteNode() {
    const e = this.getPos(), n = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: n });
  }
}
function Eo(t) {
  return new E2({
    find: t.find,
    handler: ({ state: e, range: n, match: i, pasteEvent: r }) => {
      const s = Ne(t.getAttributes, void 0, i, r);
      if (s === !1 || s === null)
        return null;
      const { tr: o } = e, a = i[i.length - 1], l = i[0];
      let c = n.to;
      if (a) {
        const u = l.search(/\S/), d = n.from + l.indexOf(a), h = d + a.length;
        if (M2(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((g) => g === t.type && g !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        h < n.to && o.delete(h, n.to), d > n.from && o.delete(n.from + u, d), c = n.from + u + a.length, o.addMark(n.from + u, c, t.type.create(s || {})), o.removeStoredMark(t.type);
      }
    }
  });
}
function EZ(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function exe(t) {
  return typeof t == "string";
}
function CZ(t) {
  return new E2({
    find: t.find,
    handler({ match: e, chain: n, range: i, pasteEvent: r }) {
      const s = Ne(t.getAttributes, void 0, e, r);
      if (s === !1 || s === null)
        return null;
      e.input && n().deleteRange(i).insertContentAt(i.from, {
        type: t.type.name,
        attrs: s
      });
    }
  });
}
function txe(t) {
  return new E2({
    find: t.find,
    handler: ({ state: e, range: n, match: i }) => {
      let r = t.replace, s = n.from;
      const o = n.to;
      if (i[1]) {
        const a = i[0].lastIndexOf(i[1]);
        r += i[0].slice(a + i[1].length), s += a;
        const l = s - o;
        l > 0 && (r = i[0].slice(a - l, a) + r, s = o);
      }
      e.tr.insertText(r, s, o);
    }
  });
}
class nxe {
  constructor(e) {
    this.transaction = e, this.currentStep = this.transaction.steps.length;
  }
  map(e) {
    let n = !1;
    return {
      position: this.transaction.steps.slice(this.currentStep).reduce((r, s) => {
        const o = s.getMap().mapResult(r);
        return o.deleted && (n = !0), o.pos;
      }, e),
      deleted: n
    };
  }
}
var oi = "top", qi = "bottom", Xi = "right", ai = "left", $2 = "auto", Yd = [oi, qi, Xi, ai], ql = "start", Ju = "end", AZ = "clippingParents", SP = "viewport", $c = "popper", TZ = "reference", Xw = /* @__PURE__ */ Yd.reduce(function(t, e) {
  return t.concat([e + "-" + ql, e + "-" + Ju]);
}, []), kP = /* @__PURE__ */ [].concat(Yd, [$2]).reduce(function(t, e) {
  return t.concat([e, e + "-" + ql, e + "-" + Ju]);
}, []), MZ = "beforeRead", PZ = "read", RZ = "afterRead", $Z = "beforeMain", NZ = "main", DZ = "afterMain", IZ = "beforeWrite", LZ = "write", BZ = "afterWrite", QZ = [MZ, PZ, RZ, $Z, NZ, DZ, IZ, LZ, BZ];
function Jr(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function Si(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Ta(t) {
  var e = Si(t).Element;
  return t instanceof e || t instanceof Element;
}
function zi(t) {
  var e = Si(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function N2(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Si(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function FZ(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var i = e.styles[n] || {}, r = e.attributes[n] || {}, s = e.elements[n];
    !zi(s) || !Jr(s) || (Object.assign(s.style, i), Object.keys(r).forEach(function(o) {
      var a = r[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
    }));
  });
}
function zZ(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(i) {
      var r = e.elements[i], s = e.attributes[i] || {}, o = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : n[i]), a = o.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !zi(r) || !Jr(r) || (Object.assign(r.style, a), Object.keys(s).forEach(function(l) {
        r.removeAttribute(l);
      }));
    });
  };
}
const EP = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: FZ,
  effect: zZ,
  requires: ["computeStyles"]
};
function Zr(t) {
  return t.split("-")[0];
}
var ya = Math.max, Fp = Math.min, Xl = Math.round;
function fO() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function CP() {
  return !/^((?!chrome|android).)*safari/i.test(fO());
}
function jl(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var i = t.getBoundingClientRect(), r = 1, s = 1;
  e && zi(t) && (r = t.offsetWidth > 0 && Xl(i.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && Xl(i.height) / t.offsetHeight || 1);
  var o = Ta(t) ? Si(t) : window, a = o.visualViewport, l = !CP() && n, c = (i.left + (l && a ? a.offsetLeft : 0)) / r, u = (i.top + (l && a ? a.offsetTop : 0)) / s, d = i.width / r, h = i.height / s;
  return {
    width: d,
    height: h,
    top: u,
    right: c + d,
    bottom: u + h,
    left: c,
    x: c,
    y: u
  };
}
function D2(t) {
  var e = jl(t), n = t.offsetWidth, i = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: i
  };
}
function AP(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && N2(n)) {
    var i = e;
    do {
      if (i && t.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Ts(t) {
  return Si(t).getComputedStyle(t);
}
function UZ(t) {
  return ["table", "td", "th"].indexOf(Jr(t)) >= 0;
}
function Lo(t) {
  return ((Ta(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function P0(t) {
  return Jr(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (N2(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Lo(t)
  );
}
function jw(t) {
  return !zi(t) || // https://github.com/popperjs/popper-core/issues/837
  Ts(t).position === "fixed" ? null : t.offsetParent;
}
function WZ(t) {
  var e = /firefox/i.test(fO()), n = /Trident/i.test(fO());
  if (n && zi(t)) {
    var i = Ts(t);
    if (i.position === "fixed")
      return null;
  }
  var r = P0(t);
  for (N2(r) && (r = r.host); zi(r) && ["html", "body"].indexOf(Jr(r)) < 0; ) {
    var s = Ts(r);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return r;
    r = r.parentNode;
  }
  return null;
}
function Gd(t) {
  for (var e = Si(t), n = jw(t); n && UZ(n) && Ts(n).position === "static"; )
    n = jw(n);
  return n && (Jr(n) === "html" || Jr(n) === "body" && Ts(n).position === "static") ? e : n || WZ(t) || e;
}
function I2(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function gu(t, e, n) {
  return ya(t, Fp(e, n));
}
function VZ(t, e, n) {
  var i = gu(t, e, n);
  return i > n ? n : i;
}
function TP() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function MP(t) {
  return Object.assign({}, TP(), t);
}
function PP(t, e) {
  return e.reduce(function(n, i) {
    return n[i] = t, n;
  }, {});
}
var ZZ = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, MP(typeof e != "number" ? e : PP(e, Yd));
};
function HZ(t) {
  var e, n = t.state, i = t.name, r = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = Zr(n.placement), l = I2(a), c = [ai, Xi].indexOf(a) >= 0, u = c ? "height" : "width";
  if (!(!s || !o)) {
    var d = ZZ(r.padding, n), h = D2(s), f = l === "y" ? oi : ai, p = l === "y" ? qi : Xi, m = n.rects.reference[u] + n.rects.reference[l] - o[l] - n.rects.popper[u], g = o[l] - n.rects.reference[l], b = Gd(s), _ = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, y = m / 2 - g / 2, O = d[f], x = _ - h[u] - d[p], v = _ / 2 - h[u] / 2 + y, w = gu(O, v, x), T = l;
    n.modifiersData[i] = (e = {}, e[T] = w, e.centerOffset = w - v, e);
  }
}
function qZ(t) {
  var e = t.state, n = t.options, i = n.element, r = i === void 0 ? "[data-popper-arrow]" : i;
  r != null && (typeof r == "string" && (r = e.elements.popper.querySelector(r), !r) || AP(e.elements.popper, r) && (e.elements.arrow = r));
}
const XZ = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: HZ,
  effect: qZ,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Yl(t) {
  return t.split("-")[1];
}
var jZ = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function YZ(t, e) {
  var n = t.x, i = t.y, r = e.devicePixelRatio || 1;
  return {
    x: Xl(n * r) / r || 0,
    y: Xl(i * r) / r || 0
  };
}
function Yw(t) {
  var e, n = t.popper, i = t.popperRect, r = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, d = t.isFixed, h = o.x, f = h === void 0 ? 0 : h, p = o.y, m = p === void 0 ? 0 : p, g = typeof u == "function" ? u({
    x: f,
    y: m
  }) : {
    x: f,
    y: m
  };
  f = g.x, m = g.y;
  var b = o.hasOwnProperty("x"), _ = o.hasOwnProperty("y"), y = ai, O = oi, x = window;
  if (c) {
    var v = Gd(n), w = "clientHeight", T = "clientWidth";
    if (v === Si(n) && (v = Lo(n), Ts(v).position !== "static" && a === "absolute" && (w = "scrollHeight", T = "scrollWidth")), v = v, r === oi || (r === ai || r === Xi) && s === Ju) {
      O = qi;
      var S = d && v === x && x.visualViewport ? x.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        v[w]
      );
      m -= S - i.height, m *= l ? 1 : -1;
    }
    if (r === ai || (r === oi || r === qi) && s === Ju) {
      y = Xi;
      var $ = d && v === x && x.visualViewport ? x.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        v[T]
      );
      f -= $ - i.width, f *= l ? 1 : -1;
    }
  }
  var I = Object.assign({
    position: a
  }, c && jZ), F = u === !0 ? YZ({
    x: f,
    y: m
  }, Si(n)) : {
    x: f,
    y: m
  };
  if (f = F.x, m = F.y, l) {
    var V;
    return Object.assign({}, I, (V = {}, V[O] = _ ? "0" : "", V[y] = b ? "0" : "", V.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", V));
  }
  return Object.assign({}, I, (e = {}, e[O] = _ ? m + "px" : "", e[y] = b ? f + "px" : "", e.transform = "", e));
}
function GZ(t) {
  var e = t.state, n = t.options, i = n.gpuAcceleration, r = i === void 0 ? !0 : i, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: Zr(e.placement),
    variation: Yl(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: r,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Yw(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Yw(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const KZ = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: GZ,
  data: {}
};
var Qh = {
  passive: !0
};
function JZ(t) {
  var e = t.state, n = t.instance, i = t.options, r = i.scroll, s = r === void 0 ? !0 : r, o = i.resize, a = o === void 0 ? !0 : o, l = Si(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, Qh);
  }), a && l.addEventListener("resize", n.update, Qh), function() {
    s && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, Qh);
    }), a && l.removeEventListener("resize", n.update, Qh);
  };
}
const eH = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: JZ,
  data: {}
};
var tH = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function jf(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return tH[e];
  });
}
var nH = {
  start: "end",
  end: "start"
};
function Gw(t) {
  return t.replace(/start|end/g, function(e) {
    return nH[e];
  });
}
function L2(t) {
  var e = Si(t), n = e.pageXOffset, i = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: i
  };
}
function B2(t) {
  return jl(Lo(t)).left + L2(t).scrollLeft;
}
function iH(t, e) {
  var n = Si(t), i = Lo(t), r = n.visualViewport, s = i.clientWidth, o = i.clientHeight, a = 0, l = 0;
  if (r) {
    s = r.width, o = r.height;
    var c = CP();
    (c || !c && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a + B2(t),
    y: l
  };
}
function rH(t) {
  var e, n = Lo(t), i = L2(t), r = (e = t.ownerDocument) == null ? void 0 : e.body, s = ya(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), o = ya(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -i.scrollLeft + B2(t), l = -i.scrollTop;
  return Ts(r || n).direction === "rtl" && (a += ya(n.clientWidth, r ? r.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function Q2(t) {
  var e = Ts(t), n = e.overflow, i = e.overflowX, r = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + r + i);
}
function RP(t) {
  return ["html", "body", "#document"].indexOf(Jr(t)) >= 0 ? t.ownerDocument.body : zi(t) && Q2(t) ? t : RP(P0(t));
}
function bu(t, e) {
  var n;
  e === void 0 && (e = []);
  var i = RP(t), r = i === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Si(i), o = r ? [s].concat(s.visualViewport || [], Q2(i) ? i : []) : i, a = e.concat(o);
  return r ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(bu(P0(o)))
  );
}
function pO(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function sH(t, e) {
  var n = jl(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function Kw(t, e, n) {
  return e === SP ? pO(iH(t, n)) : Ta(e) ? sH(e, n) : pO(rH(Lo(t)));
}
function oH(t) {
  var e = bu(P0(t)), n = ["absolute", "fixed"].indexOf(Ts(t).position) >= 0, i = n && zi(t) ? Gd(t) : t;
  return Ta(i) ? e.filter(function(r) {
    return Ta(r) && AP(r, i) && Jr(r) !== "body";
  }) : [];
}
function aH(t, e, n, i) {
  var r = e === "clippingParents" ? oH(t) : [].concat(e), s = [].concat(r, [n]), o = s[0], a = s.reduce(function(l, c) {
    var u = Kw(t, c, i);
    return l.top = ya(u.top, l.top), l.right = Fp(u.right, l.right), l.bottom = Fp(u.bottom, l.bottom), l.left = ya(u.left, l.left), l;
  }, Kw(t, o, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function $P(t) {
  var e = t.reference, n = t.element, i = t.placement, r = i ? Zr(i) : null, s = i ? Yl(i) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (r) {
    case oi:
      l = {
        x: o,
        y: e.y - n.height
      };
      break;
    case qi:
      l = {
        x: o,
        y: e.y + e.height
      };
      break;
    case Xi:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case ai:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = r ? I2(r) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (s) {
      case ql:
        l[c] = l[c] - (e[u] / 2 - n[u] / 2);
        break;
      case Ju:
        l[c] = l[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function ed(t, e) {
  e === void 0 && (e = {});
  var n = e, i = n.placement, r = i === void 0 ? t.placement : i, s = n.strategy, o = s === void 0 ? t.strategy : s, a = n.boundary, l = a === void 0 ? AZ : a, c = n.rootBoundary, u = c === void 0 ? SP : c, d = n.elementContext, h = d === void 0 ? $c : d, f = n.altBoundary, p = f === void 0 ? !1 : f, m = n.padding, g = m === void 0 ? 0 : m, b = MP(typeof g != "number" ? g : PP(g, Yd)), _ = h === $c ? TZ : $c, y = t.rects.popper, O = t.elements[p ? _ : h], x = aH(Ta(O) ? O : O.contextElement || Lo(t.elements.popper), l, u, o), v = jl(t.elements.reference), w = $P({
    reference: v,
    element: y,
    strategy: "absolute",
    placement: r
  }), T = pO(Object.assign({}, y, w)), S = h === $c ? T : v, $ = {
    top: x.top - S.top + b.top,
    bottom: S.bottom - x.bottom + b.bottom,
    left: x.left - S.left + b.left,
    right: S.right - x.right + b.right
  }, I = t.modifiersData.offset;
  if (h === $c && I) {
    var F = I[r];
    Object.keys($).forEach(function(V) {
      var q = [Xi, qi].indexOf(V) >= 0 ? 1 : -1, K = [oi, qi].indexOf(V) >= 0 ? "y" : "x";
      $[V] += F[K] * q;
    });
  }
  return $;
}
function lH(t, e) {
  e === void 0 && (e = {});
  var n = e, i = n.placement, r = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? kP : l, u = Yl(i), d = u ? a ? Xw : Xw.filter(function(p) {
    return Yl(p) === u;
  }) : Yd, h = d.filter(function(p) {
    return c.indexOf(p) >= 0;
  });
  h.length === 0 && (h = d);
  var f = h.reduce(function(p, m) {
    return p[m] = ed(t, {
      placement: m,
      boundary: r,
      rootBoundary: s,
      padding: o
    })[Zr(m)], p;
  }, {});
  return Object.keys(f).sort(function(p, m) {
    return f[p] - f[m];
  });
}
function cH(t) {
  if (Zr(t) === $2)
    return [];
  var e = jf(t);
  return [Gw(t), e, Gw(e)];
}
function uH(t) {
  var e = t.state, n = t.options, i = t.name;
  if (!e.modifiersData[i]._skip) {
    for (var r = n.mainAxis, s = r === void 0 ? !0 : r, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, f = n.flipVariations, p = f === void 0 ? !0 : f, m = n.allowedAutoPlacements, g = e.options.placement, b = Zr(g), _ = b === g, y = l || (_ || !p ? [jf(g)] : cH(g)), O = [g].concat(y).reduce(function($e, be) {
      return $e.concat(Zr(be) === $2 ? lH(e, {
        placement: be,
        boundary: u,
        rootBoundary: d,
        padding: c,
        flipVariations: p,
        allowedAutoPlacements: m
      }) : be);
    }, []), x = e.rects.reference, v = e.rects.popper, w = /* @__PURE__ */ new Map(), T = !0, S = O[0], $ = 0; $ < O.length; $++) {
      var I = O[$], F = Zr(I), V = Yl(I) === ql, q = [oi, qi].indexOf(F) >= 0, K = q ? "width" : "height", ie = ed(e, {
        placement: I,
        boundary: u,
        rootBoundary: d,
        altBoundary: h,
        padding: c
      }), k = q ? V ? Xi : ai : V ? qi : oi;
      x[K] > v[K] && (k = jf(k));
      var N = jf(k), W = [];
      if (s && W.push(ie[F] <= 0), a && W.push(ie[k] <= 0, ie[N] <= 0), W.every(function($e) {
        return $e;
      })) {
        S = I, T = !1;
        break;
      }
      w.set(I, W);
    }
    if (T)
      for (var X = p ? 3 : 1, ee = function(be) {
        var we = O.find(function(St) {
          var it = w.get(St);
          if (it)
            return it.slice(0, be).every(function(rt) {
              return rt;
            });
        });
        if (we)
          return S = we, "break";
      }, re = X; re > 0; re--) {
        var xe = ee(re);
        if (xe === "break") break;
      }
    e.placement !== S && (e.modifiersData[i]._skip = !0, e.placement = S, e.reset = !0);
  }
}
const dH = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: uH,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Jw(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function eS(t) {
  return [oi, Xi, qi, ai].some(function(e) {
    return t[e] >= 0;
  });
}
function hH(t) {
  var e = t.state, n = t.name, i = e.rects.reference, r = e.rects.popper, s = e.modifiersData.preventOverflow, o = ed(e, {
    elementContext: "reference"
  }), a = ed(e, {
    altBoundary: !0
  }), l = Jw(o, i), c = Jw(a, r, s), u = eS(l), d = eS(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
const fH = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hH
};
function pH(t, e, n) {
  var i = Zr(t), r = [ai, oi].indexOf(i) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, o = s[0], a = s[1];
  return o = o || 0, a = (a || 0) * r, [ai, Xi].indexOf(i) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function mH(t) {
  var e = t.state, n = t.options, i = t.name, r = n.offset, s = r === void 0 ? [0, 0] : r, o = kP.reduce(function(u, d) {
    return u[d] = pH(d, e.rects, s), u;
  }, {}), a = o[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[i] = o;
}
const gH = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: mH
};
function bH(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = $P({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const OH = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: bH,
  data: {}
};
function yH(t) {
  return t === "x" ? "y" : "x";
}
function _H(t) {
  var e = t.state, n = t.options, i = t.name, r = n.mainAxis, s = r === void 0 ? !0 : r, o = n.altAxis, a = o === void 0 ? !1 : o, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, h = n.tether, f = h === void 0 ? !0 : h, p = n.tetherOffset, m = p === void 0 ? 0 : p, g = ed(e, {
    boundary: l,
    rootBoundary: c,
    padding: d,
    altBoundary: u
  }), b = Zr(e.placement), _ = Yl(e.placement), y = !_, O = I2(b), x = yH(O), v = e.modifiersData.popperOffsets, w = e.rects.reference, T = e.rects.popper, S = typeof m == "function" ? m(Object.assign({}, e.rects, {
    placement: e.placement
  })) : m, $ = typeof S == "number" ? {
    mainAxis: S,
    altAxis: S
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, S), I = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, F = {
    x: 0,
    y: 0
  };
  if (v) {
    if (s) {
      var V, q = O === "y" ? oi : ai, K = O === "y" ? qi : Xi, ie = O === "y" ? "height" : "width", k = v[O], N = k + g[q], W = k - g[K], X = f ? -T[ie] / 2 : 0, ee = _ === ql ? w[ie] : T[ie], re = _ === ql ? -T[ie] : -w[ie], xe = e.elements.arrow, $e = f && xe ? D2(xe) : {
        width: 0,
        height: 0
      }, be = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : TP(), we = be[q], St = be[K], it = gu(0, w[ie], $e[ie]), rt = y ? w[ie] / 2 - X - it - we - $.mainAxis : ee - it - we - $.mainAxis, et = y ? -w[ie] / 2 + X + it + St + $.mainAxis : re + it + St + $.mainAxis, It = e.elements.arrow && Gd(e.elements.arrow), qt = It ? O === "y" ? It.clientTop || 0 : It.clientLeft || 0 : 0, Te = (V = I == null ? void 0 : I[O]) != null ? V : 0, gt = k + rt - Te - qt, kt = k + et - Te, Qe = gu(f ? Fp(N, gt) : N, k, f ? ya(W, kt) : W);
      v[O] = Qe, F[O] = Qe - k;
    }
    if (a) {
      var yn, Gt = O === "x" ? oi : ai, J = O === "x" ? qi : Xi, M = v[x], C = x === "y" ? "height" : "width", B = M + g[Gt], oe = M - g[J], Ce = [oi, ai].indexOf(b) !== -1, ye = (yn = I == null ? void 0 : I[x]) != null ? yn : 0, U = Ce ? B : M - w[C] - T[C] - ye + $.altAxis, E = Ce ? M + w[C] + T[C] - ye - $.altAxis : oe, z = f && Ce ? VZ(U, M, E) : gu(f ? U : B, M, f ? E : oe);
      v[x] = z, F[x] = z - M;
    }
    e.modifiersData[i] = F;
  }
}
const vH = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: _H,
  requiresIfExists: ["offset"]
};
function xH(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function wH(t) {
  return t === Si(t) || !zi(t) ? L2(t) : xH(t);
}
function SH(t) {
  var e = t.getBoundingClientRect(), n = Xl(e.width) / t.offsetWidth || 1, i = Xl(e.height) / t.offsetHeight || 1;
  return n !== 1 || i !== 1;
}
function kH(t, e, n) {
  n === void 0 && (n = !1);
  var i = zi(e), r = zi(e) && SH(e), s = Lo(e), o = jl(t, r, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !n) && ((Jr(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Q2(s)) && (a = wH(e)), zi(e) ? (l = jl(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = B2(s))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function EH(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), i = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function r(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && r(l);
      }
    }), i.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || r(s);
  }), i;
}
function CH(t) {
  var e = EH(t);
  return QZ.reduce(function(n, i) {
    return n.concat(e.filter(function(r) {
      return r.phase === i;
    }));
  }, []);
}
function AH(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function TH(t) {
  var e = t.reduce(function(n, i) {
    var r = n[i.name];
    return n[i.name] = r ? Object.assign({}, r, i, {
      options: Object.assign({}, r.options, i.options),
      data: Object.assign({}, r.data, i.data)
    }) : i, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var tS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function nS() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function MH(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, i = n === void 0 ? [] : n, r = e.defaultOptions, s = r === void 0 ? tS : r;
  return function(a, l, c) {
    c === void 0 && (c = s);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, tS, s),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], h = !1, f = {
      state: u,
      setOptions: function(b) {
        var _ = typeof b == "function" ? b(u.options) : b;
        m(), u.options = Object.assign({}, s, u.options, _), u.scrollParents = {
          reference: Ta(a) ? bu(a) : a.contextElement ? bu(a.contextElement) : [],
          popper: bu(l)
        };
        var y = CH(TH([].concat(i, u.options.modifiers)));
        return u.orderedModifiers = y.filter(function(O) {
          return O.enabled;
        }), p(), f.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!h) {
          var b = u.elements, _ = b.reference, y = b.popper;
          if (nS(_, y)) {
            u.rects = {
              reference: kH(_, Gd(y), u.options.strategy === "fixed"),
              popper: D2(y)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function($) {
              return u.modifiersData[$.name] = Object.assign({}, $.data);
            });
            for (var O = 0; O < u.orderedModifiers.length; O++) {
              if (u.reset === !0) {
                u.reset = !1, O = -1;
                continue;
              }
              var x = u.orderedModifiers[O], v = x.fn, w = x.options, T = w === void 0 ? {} : w, S = x.name;
              typeof v == "function" && (u = v({
                state: u,
                options: T,
                name: S,
                instance: f
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: AH(function() {
        return new Promise(function(g) {
          f.forceUpdate(), g(u);
        });
      }),
      destroy: function() {
        m(), h = !0;
      }
    };
    if (!nS(a, l))
      return f;
    f.setOptions(c).then(function(g) {
      !h && c.onFirstUpdate && c.onFirstUpdate(g);
    });
    function p() {
      u.orderedModifiers.forEach(function(g) {
        var b = g.name, _ = g.options, y = _ === void 0 ? {} : _, O = g.effect;
        if (typeof O == "function") {
          var x = O({
            state: u,
            name: b,
            instance: f,
            options: y
          }), v = function() {
          };
          d.push(x || v);
        }
      });
    }
    function m() {
      d.forEach(function(g) {
        return g();
      }), d = [];
    }
    return f;
  };
}
var PH = [eH, OH, KZ, EP, gH, dH, vH, XZ, fH], RH = /* @__PURE__ */ MH({
  defaultModifiers: PH
}), $H = "tippy-box", NP = "tippy-content", NH = "tippy-backdrop", DP = "tippy-arrow", IP = "tippy-svg-arrow", jo = {
  passive: !0,
  capture: !0
}, LP = function() {
  return document.body;
};
function qg(t, e, n) {
  if (Array.isArray(t)) {
    var i = t[e];
    return i ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function F2(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function BP(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function iS(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(i) {
    clearTimeout(n), n = setTimeout(function() {
      t(i);
    }, e);
  };
}
function DH(t) {
  return t.split(/\s+/).filter(Boolean);
}
function dl(t) {
  return [].concat(t);
}
function rS(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function IH(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function LH(t) {
  return t.split("-")[0];
}
function zp(t) {
  return [].slice.call(t);
}
function sS(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function Ou() {
  return document.createElement("div");
}
function R0(t) {
  return ["Element", "Fragment"].some(function(e) {
    return F2(t, e);
  });
}
function BH(t) {
  return F2(t, "NodeList");
}
function QH(t) {
  return F2(t, "MouseEvent");
}
function FH(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function zH(t) {
  return R0(t) ? [t] : BH(t) ? zp(t) : Array.isArray(t) ? t : zp(document.querySelectorAll(t));
}
function Xg(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function oS(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function UH(t) {
  var e, n = dl(t), i = n[0];
  return i != null && (e = i.ownerDocument) != null && e.body ? i.ownerDocument : document;
}
function WH(t, e) {
  var n = e.clientX, i = e.clientY;
  return t.every(function(r) {
    var s = r.popperRect, o = r.popperState, a = r.props, l = a.interactiveBorder, c = LH(o.placement), u = o.modifiersData.offset;
    if (!u)
      return !0;
    var d = c === "bottom" ? u.top.y : 0, h = c === "top" ? u.bottom.y : 0, f = c === "right" ? u.left.x : 0, p = c === "left" ? u.right.x : 0, m = s.top - i + d > l, g = i - s.bottom - h > l, b = s.left - n + f > l, _ = n - s.right - p > l;
    return m || g || b || _;
  });
}
function jg(t, e, n) {
  var i = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(r) {
    t[i](r, n);
  });
}
function aS(t, e) {
  for (var n = e; n; ) {
    var i;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (i = n.getRootNode()) == null ? void 0 : i.host;
  }
  return !1;
}
var Ar = {
  isTouch: !1
}, lS = 0;
function VH() {
  Ar.isTouch || (Ar.isTouch = !0, window.performance && document.addEventListener("mousemove", QP));
}
function QP() {
  var t = performance.now();
  t - lS < 20 && (Ar.isTouch = !1, document.removeEventListener("mousemove", QP)), lS = t;
}
function ZH() {
  var t = document.activeElement;
  if (FH(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function HH() {
  document.addEventListener("touchstart", VH, jo), window.addEventListener("blur", ZH);
}
var qH = typeof window < "u" && typeof document < "u", XH = qH ? (
  // @ts-ignore
  !!window.msCrypto
) : !1, jH = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, YH = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, lr = Object.assign({
  appendTo: LP,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, jH, YH), GH = Object.keys(lr), KH = function(e) {
  var n = Object.keys(e);
  n.forEach(function(i) {
    lr[i] = e[i];
  });
};
function FP(t) {
  var e = t.plugins || [], n = e.reduce(function(i, r) {
    var s = r.name, o = r.defaultValue;
    if (s) {
      var a;
      i[s] = t[s] !== void 0 ? t[s] : (a = lr[s]) != null ? a : o;
    }
    return i;
  }, {});
  return Object.assign({}, t, n);
}
function JH(t, e) {
  var n = e ? Object.keys(FP(Object.assign({}, lr, {
    plugins: e
  }))) : GH, i = n.reduce(function(r, s) {
    var o = (t.getAttribute("data-tippy-" + s) || "").trim();
    if (!o)
      return r;
    if (s === "content")
      r[s] = o;
    else
      try {
        r[s] = JSON.parse(o);
      } catch {
        r[s] = o;
      }
    return r;
  }, {});
  return i;
}
function cS(t, e) {
  var n = Object.assign({}, e, {
    content: BP(e.content, [t])
  }, e.ignoreAttributes ? {} : JH(t, e.plugins));
  return n.aria = Object.assign({}, lr.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
var eq = function() {
  return "innerHTML";
};
function mO(t, e) {
  t[eq()] = e;
}
function uS(t) {
  var e = Ou();
  return t === !0 ? e.className = DP : (e.className = IP, R0(t) ? e.appendChild(t) : mO(e, t)), e;
}
function dS(t, e) {
  R0(e.content) ? (mO(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? mO(t, e.content) : t.textContent = e.content);
}
function gO(t) {
  var e = t.firstElementChild, n = zp(e.children);
  return {
    box: e,
    content: n.find(function(i) {
      return i.classList.contains(NP);
    }),
    arrow: n.find(function(i) {
      return i.classList.contains(DP) || i.classList.contains(IP);
    }),
    backdrop: n.find(function(i) {
      return i.classList.contains(NH);
    })
  };
}
function zP(t) {
  var e = Ou(), n = Ou();
  n.className = $H, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var i = Ou();
  i.className = NP, i.setAttribute("data-state", "hidden"), dS(i, t.props), e.appendChild(n), n.appendChild(i), r(t.props, t.props);
  function r(s, o) {
    var a = gO(e), l = a.box, c = a.content, u = a.arrow;
    o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (s.content !== o.content || s.allowHTML !== o.allowHTML) && dS(c, t.props), o.arrow ? u ? s.arrow !== o.arrow && (l.removeChild(u), l.appendChild(uS(o.arrow))) : l.appendChild(uS(o.arrow)) : u && l.removeChild(u);
  }
  return {
    popper: e,
    onUpdate: r
  };
}
zP.$$tippy = !0;
var tq = 1, Fh = [], Yg = [];
function nq(t, e) {
  var n = cS(t, Object.assign({}, lr, FP(sS(e)))), i, r, s, o = !1, a = !1, l = !1, c = !1, u, d, h, f = [], p = iS(gt, n.interactiveDebounce), m, g = tq++, b = null, _ = IH(n.plugins), y = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, O = {
    // properties
    id: g,
    reference: t,
    popper: Ou(),
    popperInstance: b,
    props: n,
    state: y,
    plugins: _,
    // methods
    clearDelayTimeouts: U,
    setProps: E,
    setContent: z,
    show: G,
    hide: le,
    hideWithInteractivity: Ie,
    enable: Ce,
    disable: ye,
    unmount: dt,
    destroy: Uo
  };
  if (!n.render)
    return O;
  var x = n.render(O), v = x.popper, w = x.onUpdate;
  v.setAttribute("data-tippy-root", ""), v.id = "tippy-" + O.id, O.popper = v, t._tippy = O, v._tippy = O;
  var T = _.map(function(H) {
    return H.fn(O);
  }), S = t.hasAttribute("aria-expanded");
  return It(), X(), k(), N("onCreate", [O]), n.showOnCreate && B(), v.addEventListener("mouseenter", function() {
    O.props.interactive && O.state.isVisible && O.clearDelayTimeouts();
  }), v.addEventListener("mouseleave", function() {
    O.props.interactive && O.props.trigger.indexOf("mouseenter") >= 0 && q().addEventListener("mousemove", p);
  }), O;
  function $() {
    var H = O.props.touch;
    return Array.isArray(H) ? H : [H, 0];
  }
  function I() {
    return $()[0] === "hold";
  }
  function F() {
    var H;
    return !!((H = O.props.render) != null && H.$$tippy);
  }
  function V() {
    return m || t;
  }
  function q() {
    var H = V().parentNode;
    return H ? UH(H) : document;
  }
  function K() {
    return gO(v);
  }
  function ie(H) {
    return O.state.isMounted && !O.state.isVisible || Ar.isTouch || u && u.type === "focus" ? 0 : qg(O.props.delay, H ? 0 : 1, lr.delay);
  }
  function k(H) {
    H === void 0 && (H = !1), v.style.pointerEvents = O.props.interactive && !H ? "" : "none", v.style.zIndex = "" + O.props.zIndex;
  }
  function N(H, me, Ae) {
    if (Ae === void 0 && (Ae = !0), T.forEach(function(Xe) {
      Xe[H] && Xe[H].apply(Xe, me);
    }), Ae) {
      var lt;
      (lt = O.props)[H].apply(lt, me);
    }
  }
  function W() {
    var H = O.props.aria;
    if (H.content) {
      var me = "aria-" + H.content, Ae = v.id, lt = dl(O.props.triggerTarget || t);
      lt.forEach(function(Xe) {
        var $n = Xe.getAttribute(me);
        if (O.state.isVisible)
          Xe.setAttribute(me, $n ? $n + " " + Ae : Ae);
        else {
          var ki = $n && $n.replace(Ae, "").trim();
          ki ? Xe.setAttribute(me, ki) : Xe.removeAttribute(me);
        }
      });
    }
  }
  function X() {
    if (!(S || !O.props.aria.expanded)) {
      var H = dl(O.props.triggerTarget || t);
      H.forEach(function(me) {
        O.props.interactive ? me.setAttribute("aria-expanded", O.state.isVisible && me === V() ? "true" : "false") : me.removeAttribute("aria-expanded");
      });
    }
  }
  function ee() {
    q().removeEventListener("mousemove", p), Fh = Fh.filter(function(H) {
      return H !== p;
    });
  }
  function re(H) {
    if (!(Ar.isTouch && (l || H.type === "mousedown"))) {
      var me = H.composedPath && H.composedPath()[0] || H.target;
      if (!(O.props.interactive && aS(v, me))) {
        if (dl(O.props.triggerTarget || t).some(function(Ae) {
          return aS(Ae, me);
        })) {
          if (Ar.isTouch || O.state.isVisible && O.props.trigger.indexOf("click") >= 0)
            return;
        } else
          N("onClickOutside", [O, H]);
        O.props.hideOnClick === !0 && (O.clearDelayTimeouts(), O.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), O.state.isMounted || we());
      }
    }
  }
  function xe() {
    l = !0;
  }
  function $e() {
    l = !1;
  }
  function be() {
    var H = q();
    H.addEventListener("mousedown", re, !0), H.addEventListener("touchend", re, jo), H.addEventListener("touchstart", $e, jo), H.addEventListener("touchmove", xe, jo);
  }
  function we() {
    var H = q();
    H.removeEventListener("mousedown", re, !0), H.removeEventListener("touchend", re, jo), H.removeEventListener("touchstart", $e, jo), H.removeEventListener("touchmove", xe, jo);
  }
  function St(H, me) {
    rt(H, function() {
      !O.state.isVisible && v.parentNode && v.parentNode.contains(v) && me();
    });
  }
  function it(H, me) {
    rt(H, me);
  }
  function rt(H, me) {
    var Ae = K().box;
    function lt(Xe) {
      Xe.target === Ae && (jg(Ae, "remove", lt), me());
    }
    if (H === 0)
      return me();
    jg(Ae, "remove", d), jg(Ae, "add", lt), d = lt;
  }
  function et(H, me, Ae) {
    Ae === void 0 && (Ae = !1);
    var lt = dl(O.props.triggerTarget || t);
    lt.forEach(function(Xe) {
      Xe.addEventListener(H, me, Ae), f.push({
        node: Xe,
        eventType: H,
        handler: me,
        options: Ae
      });
    });
  }
  function It() {
    I() && (et("touchstart", Te, {
      passive: !0
    }), et("touchend", kt, {
      passive: !0
    })), DH(O.props.trigger).forEach(function(H) {
      if (H !== "manual")
        switch (et(H, Te), H) {
          case "mouseenter":
            et("mouseleave", kt);
            break;
          case "focus":
            et(XH ? "focusout" : "blur", Qe);
            break;
          case "focusin":
            et("focusout", Qe);
            break;
        }
    });
  }
  function qt() {
    f.forEach(function(H) {
      var me = H.node, Ae = H.eventType, lt = H.handler, Xe = H.options;
      me.removeEventListener(Ae, lt, Xe);
    }), f = [];
  }
  function Te(H) {
    var me, Ae = !1;
    if (!(!O.state.isEnabled || yn(H) || a)) {
      var lt = ((me = u) == null ? void 0 : me.type) === "focus";
      u = H, m = H.currentTarget, X(), !O.state.isVisible && QH(H) && Fh.forEach(function(Xe) {
        return Xe(H);
      }), H.type === "click" && (O.props.trigger.indexOf("mouseenter") < 0 || o) && O.props.hideOnClick !== !1 && O.state.isVisible ? Ae = !0 : B(H), H.type === "click" && (o = !Ae), Ae && !lt && oe(H);
    }
  }
  function gt(H) {
    var me = H.target, Ae = V().contains(me) || v.contains(me);
    if (!(H.type === "mousemove" && Ae)) {
      var lt = C().concat(v).map(function(Xe) {
        var $n, ki = Xe._tippy, ja = ($n = ki.popperInstance) == null ? void 0 : $n.state;
        return ja ? {
          popperRect: Xe.getBoundingClientRect(),
          popperState: ja,
          props: n
        } : null;
      }).filter(Boolean);
      WH(lt, H) && (ee(), oe(H));
    }
  }
  function kt(H) {
    var me = yn(H) || O.props.trigger.indexOf("click") >= 0 && o;
    if (!me) {
      if (O.props.interactive) {
        O.hideWithInteractivity(H);
        return;
      }
      oe(H);
    }
  }
  function Qe(H) {
    O.props.trigger.indexOf("focusin") < 0 && H.target !== V() || O.props.interactive && H.relatedTarget && v.contains(H.relatedTarget) || oe(H);
  }
  function yn(H) {
    return Ar.isTouch ? I() !== H.type.indexOf("touch") >= 0 : !1;
  }
  function Gt() {
    J();
    var H = O.props, me = H.popperOptions, Ae = H.placement, lt = H.offset, Xe = H.getReferenceClientRect, $n = H.moveTransition, ki = F() ? gO(v).arrow : null, ja = Xe ? {
      getBoundingClientRect: Xe,
      contextElement: Xe.contextElement || V()
    } : t, rv = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(_h) {
        var Ya = _h.state;
        if (F()) {
          var eD = K(), ug = eD.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(vh) {
            vh === "placement" ? ug.setAttribute("data-placement", Ya.placement) : Ya.attributes.popper["data-popper-" + vh] ? ug.setAttribute("data-" + vh, "") : ug.removeAttribute("data-" + vh);
          }), Ya.attributes.popper = {};
        }
      }
    }, Wo = [{
      name: "offset",
      options: {
        offset: lt
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !$n
      }
    }, rv];
    F() && ki && Wo.push({
      name: "arrow",
      options: {
        element: ki,
        padding: 3
      }
    }), Wo.push.apply(Wo, (me == null ? void 0 : me.modifiers) || []), O.popperInstance = RH(ja, v, Object.assign({}, me, {
      placement: Ae,
      onFirstUpdate: h,
      modifiers: Wo
    }));
  }
  function J() {
    O.popperInstance && (O.popperInstance.destroy(), O.popperInstance = null);
  }
  function M() {
    var H = O.props.appendTo, me, Ae = V();
    O.props.interactive && H === LP || H === "parent" ? me = Ae.parentNode : me = BP(H, [Ae]), me.contains(v) || me.appendChild(v), O.state.isMounted = !0, Gt();
  }
  function C() {
    return zp(v.querySelectorAll("[data-tippy-root]"));
  }
  function B(H) {
    O.clearDelayTimeouts(), H && N("onTrigger", [O, H]), be();
    var me = ie(!0), Ae = $(), lt = Ae[0], Xe = Ae[1];
    Ar.isTouch && lt === "hold" && Xe && (me = Xe), me ? i = setTimeout(function() {
      O.show();
    }, me) : O.show();
  }
  function oe(H) {
    if (O.clearDelayTimeouts(), N("onUntrigger", [O, H]), !O.state.isVisible) {
      we();
      return;
    }
    if (!(O.props.trigger.indexOf("mouseenter") >= 0 && O.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(H.type) >= 0 && o)) {
      var me = ie(!1);
      me ? r = setTimeout(function() {
        O.state.isVisible && O.hide();
      }, me) : s = requestAnimationFrame(function() {
        O.hide();
      });
    }
  }
  function Ce() {
    O.state.isEnabled = !0;
  }
  function ye() {
    O.hide(), O.state.isEnabled = !1;
  }
  function U() {
    clearTimeout(i), clearTimeout(r), cancelAnimationFrame(s);
  }
  function E(H) {
    if (!O.state.isDestroyed) {
      N("onBeforeUpdate", [O, H]), qt();
      var me = O.props, Ae = cS(t, Object.assign({}, me, sS(H), {
        ignoreAttributes: !0
      }));
      O.props = Ae, It(), me.interactiveDebounce !== Ae.interactiveDebounce && (ee(), p = iS(gt, Ae.interactiveDebounce)), me.triggerTarget && !Ae.triggerTarget ? dl(me.triggerTarget).forEach(function(lt) {
        lt.removeAttribute("aria-expanded");
      }) : Ae.triggerTarget && t.removeAttribute("aria-expanded"), X(), k(), w && w(me, Ae), O.popperInstance && (Gt(), C().forEach(function(lt) {
        requestAnimationFrame(lt._tippy.popperInstance.forceUpdate);
      })), N("onAfterUpdate", [O, H]);
    }
  }
  function z(H) {
    O.setProps({
      content: H
    });
  }
  function G() {
    var H = O.state.isVisible, me = O.state.isDestroyed, Ae = !O.state.isEnabled, lt = Ar.isTouch && !O.props.touch, Xe = qg(O.props.duration, 0, lr.duration);
    if (!(H || me || Ae || lt) && !V().hasAttribute("disabled") && (N("onShow", [O], !1), O.props.onShow(O) !== !1)) {
      if (O.state.isVisible = !0, F() && (v.style.visibility = "visible"), k(), be(), O.state.isMounted || (v.style.transition = "none"), F()) {
        var $n = K(), ki = $n.box, ja = $n.content;
        Xg([ki, ja], 0);
      }
      h = function() {
        var Wo;
        if (!(!O.state.isVisible || c)) {
          if (c = !0, v.offsetHeight, v.style.transition = O.props.moveTransition, F() && O.props.animation) {
            var cg = K(), _h = cg.box, Ya = cg.content;
            Xg([_h, Ya], Xe), oS([_h, Ya], "visible");
          }
          W(), X(), rS(Yg, O), (Wo = O.popperInstance) == null || Wo.forceUpdate(), N("onMount", [O]), O.props.animation && F() && it(Xe, function() {
            O.state.isShown = !0, N("onShown", [O]);
          });
        }
      }, M();
    }
  }
  function le() {
    var H = !O.state.isVisible, me = O.state.isDestroyed, Ae = !O.state.isEnabled, lt = qg(O.props.duration, 1, lr.duration);
    if (!(H || me || Ae) && (N("onHide", [O], !1), O.props.onHide(O) !== !1)) {
      if (O.state.isVisible = !1, O.state.isShown = !1, c = !1, o = !1, F() && (v.style.visibility = "hidden"), ee(), we(), k(!0), F()) {
        var Xe = K(), $n = Xe.box, ki = Xe.content;
        O.props.animation && (Xg([$n, ki], lt), oS([$n, ki], "hidden"));
      }
      W(), X(), O.props.animation ? F() && St(lt, O.unmount) : O.unmount();
    }
  }
  function Ie(H) {
    q().addEventListener("mousemove", p), rS(Fh, p), p(H);
  }
  function dt() {
    O.state.isVisible && O.hide(), O.state.isMounted && (J(), C().forEach(function(H) {
      H._tippy.unmount();
    }), v.parentNode && v.parentNode.removeChild(v), Yg = Yg.filter(function(H) {
      return H !== O;
    }), O.state.isMounted = !1, N("onHidden", [O]));
  }
  function Uo() {
    O.state.isDestroyed || (O.clearDelayTimeouts(), O.unmount(), qt(), delete t._tippy, O.state.isDestroyed = !0, N("onDestroy", [O]));
  }
}
function Bo(t, e) {
  e === void 0 && (e = {});
  var n = lr.plugins.concat(e.plugins || []);
  HH();
  var i = Object.assign({}, e, {
    plugins: n
  }), r = zH(t), s = r.reduce(function(o, a) {
    var l = a && nq(a, i);
    return l && o.push(l), o;
  }, []);
  return R0(t) ? s[0] : s;
}
Bo.defaultProps = lr;
Bo.setDefaultProps = KH;
Bo.currentInput = Ar;
Object.assign({}, EP, {
  effect: function(e) {
    var n = e.state, i = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, i.popper), n.styles = i, n.elements.arrow && Object.assign(n.elements.arrow.style, i.arrow);
  }
});
var iq = {
  name: "sticky",
  defaultValue: !1,
  fn: function(e) {
    var n = e.reference, i = e.popper;
    function r() {
      return e.popperInstance ? e.popperInstance.state.elements.reference : n;
    }
    function s(c) {
      return e.props.sticky === !0 || e.props.sticky === c;
    }
    var o = null, a = null;
    function l() {
      var c = s("reference") ? r().getBoundingClientRect() : null, u = s("popper") ? i.getBoundingClientRect() : null;
      (c && hS(o, c) || u && hS(a, u)) && e.popperInstance && e.popperInstance.update(), o = c, a = u, e.state.isMounted && requestAnimationFrame(l);
    }
    return {
      onMount: function() {
        e.props.sticky && l();
      }
    };
  }
};
function hS(t, e) {
  return t && e ? t.top !== e.top || t.right !== e.right || t.bottom !== e.bottom || t.left !== e.left : !0;
}
Bo.setDefaultProps({
  render: zP
});
let rq = class {
  constructor({ editor: e, element: n, view: i, tippyOptions: r = {}, updateDelay: s = 250, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: c, to: u }) => {
      const { doc: d, selection: h } = l, { empty: f } = h, p = !d.textBetween(c, u).length && qd(l.selection), m = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || m) || f || p || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const c = !(l != null && l.selection.eq(a.state.selection)), u = !(l != null && l.doc.eq(a.state.doc));
      !c && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, c, u, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, c, u) => {
      var d, h, f;
      const { state: p, composing: m } = a, { selection: g } = p;
      if (m || !l && !c)
        return;
      this.createTooltip();
      const { ranges: _ } = g, y = Math.min(..._.map((v) => v.$from.pos)), O = Math.max(..._.map((v) => v.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        view: a,
        state: p,
        oldState: u,
        from: y,
        to: O
      }))) {
        this.hide();
        return;
      }
      (h = this.tippy) === null || h === void 0 || h.setProps({
        getReferenceClientRect: ((f = this.tippyOptions) === null || f === void 0 ? void 0 : f.getReferenceClientRect) || (() => {
          if (Qp(p.selection)) {
            let v = a.nodeDOM(y);
            const w = v.dataset.nodeViewWrapper ? v : v.querySelector("[data-node-view-wrapper]");
            if (w && (v = w.firstChild), v)
              return v.getBoundingClientRect();
          }
          return R2(a, y, O);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = i, this.updateDelay = s, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Bo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: i } = e, r = i.selection.from !== i.selection.to;
    if (this.updateDelay > 0 && r) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const s = !(n != null && n.selection.eq(e.state.selection)), o = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, s, o, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
};
const UP = (t) => new Ue({
  key: typeof t.pluginKey == "string" ? new Ke(t.pluginKey) : t.pluginKey,
  view: (e) => new rq({ view: e, ...t })
});
mt.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      UP({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class sq {
  constructor({ editor: e, element: n, view: i, tippyOptions: r = {}, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: o, state: a }) => {
      const { selection: l } = a, { $anchor: c, empty: u } = l, d = c.depth === 1, h = c.parent.isTextblock && !c.parent.type.spec.code && !c.parent.textContent;
      return !(!o.hasFocus() || !u || !d || !h || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: o }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      o != null && o.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(o.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (o) => {
      this.blurHandler({ event: o });
    }, this.editor = e, this.element = n, this.view = i, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Bo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var i, r, s;
    const { state: o } = e, { doc: a, selection: l } = o, { from: c, to: u } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((i = this.shouldShow) === null || i === void 0 ? void 0 : i.call(this, {
      editor: this.editor,
      view: e,
      state: o,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (r = this.tippy) === null || r === void 0 || r.setProps({
      getReferenceClientRect: ((s = this.tippyOptions) === null || s === void 0 ? void 0 : s.getReferenceClientRect) || (() => R2(e, c, u))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const WP = (t) => new Ue({
  key: typeof t.pluginKey == "string" ? new Ke(t.pluginKey) : t.pluginKey,
  view: (e) => new sq({ view: e, ...t })
});
mt.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      WP({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const rxe = ke({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = pt(null);
    return Gi(() => {
      const { updateDelay: i, editor: r, pluginKey: s, shouldShow: o, tippyOptions: a } = t;
      r.registerPlugin(UP({
        updateDelay: i,
        editor: r,
        element: n.value,
        pluginKey: s,
        shouldShow: o,
        tippyOptions: a
      }));
    }), hc(() => {
      const { pluginKey: i, editor: r } = t;
      r.unregisterPlugin(i);
    }), () => {
      var i;
      return li("div", { ref: n }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
});
function fS(t) {
  return pD((e, n) => ({
    get() {
      return e(), t;
    },
    set(i) {
      t = i, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
class VP extends wZ {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = fS(this.view.state), this.reactiveExtensionStorage = fS(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), R(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    super.registerPlugin(e, n), this.reactiveState.value = this.view.state;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    super.unregisterPlugin(e), this.reactiveState.value = this.view.state;
  }
}
const oq = ke({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(t) {
    const e = pt(), n = Bd();
    return hD(() => {
      const i = t.editor;
      i && i.options.element && e.value && Il(() => {
        if (!e.value || !i.options.element.firstChild)
          return;
        const r = Z(e.value);
        e.value.append(...i.options.element.childNodes), i.contentComponent = n.ctx._, n && (i.appContext = {
          ...n.appContext,
          provides: {
            // @ts-ignore
            ...n.provides,
            ...n.appContext.provides
          }
        }), i.setOptions({
          element: r
        }), i.createNodeViews();
      });
    }), hc(() => {
      const i = t.editor;
      if (!i || (i.isDestroyed || i.view.setProps({
        nodeViews: {}
      }), i.contentComponent = null, i.appContext = null, !i.options.element.firstChild))
        return;
      const r = document.createElement("div");
      r.append(...i.options.element.childNodes), i.setOptions({
        element: r
      });
    }), { rootEl: e };
  },
  render() {
    return li("div", {
      ref: (t) => {
        this.rootEl = t;
      }
    });
  }
}), sxe = ke({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = pt(null);
    return Gi(() => {
      const { pluginKey: i, editor: r, tippyOptions: s, shouldShow: o } = t;
      r.registerPlugin(WP({
        pluginKey: i,
        editor: r,
        element: n.value,
        tippyOptions: s,
        shouldShow: o
      }));
    }), hc(() => {
      const { pluginKey: i, editor: r } = t;
      r.unregisterPlugin(i);
    }), () => {
      var i;
      return li("div", { ref: n }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
}), aq = ke({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return li(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
}), bc = ke({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var t, e;
    return li(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (t = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t));
  }
}), oxe = (t = {}) => {
  const e = ru();
  return Gi(() => {
    e.value = new VP(t);
  }), hc(() => {
    var n;
    (n = e.value) === null || n === void 0 || n.destroy();
  }), e;
};
class ZP {
  constructor(e, { props: n = {}, editor: i }) {
    this.editor = i, this.component = R(e), this.el = document.createElement("div"), this.props = fD(n), this.renderedComponent = this.renderComponent();
  }
  get element() {
    return this.renderedComponent.el;
  }
  get ref() {
    var e, n, i, r;
    return !((n = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || n === void 0) && n.exposed ? this.renderedComponent.vNode.component.exposed : (r = (i = this.renderedComponent.vNode) === null || i === void 0 ? void 0 : i.component) === null || r === void 0 ? void 0 : r.proxy;
  }
  renderComponent() {
    let e = li(this.component, this.props);
    return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && Mu(e, this.el), { vNode: e, destroy: () => {
      this.el && Mu(null, this.el), this.el = null, e = null;
    }, el: this.el ? this.el.firstElementChild : null };
  }
  updateProps(e = {}) {
    Object.entries(e).forEach(([n, i]) => {
      this.props[n] = i;
    }), this.renderComponent();
  }
  destroy() {
    this.renderedComponent.destroy();
  }
}
const lq = {
  editor: {
    type: Object,
    required: !0
  },
  node: {
    type: Object,
    required: !0
  },
  decorations: {
    type: Object,
    required: !0
  },
  selected: {
    type: Boolean,
    required: !0
  },
  extension: {
    type: Object,
    required: !0
  },
  getPos: {
    type: Function,
    required: !0
  },
  updateAttributes: {
    type: Function,
    required: !0
  },
  deleteNode: {
    type: Function,
    required: !0
  }
};
class cq extends kZ {
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: !1,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (r = {}) => this.updateAttributes(r),
      deleteNode: () => this.deleteNode()
    }, n = this.onDragStart.bind(this);
    this.decorationClasses = pt(this.getDecorationClasses());
    const i = ke({
      extends: { ...this.component },
      props: Object.keys(e),
      template: this.component.template,
      setup: (r) => {
        var s, o;
        return sv("onDragStart", n), sv("decorationClasses", this.decorationClasses), (o = (s = this.component).setup) === null || o === void 0 ? void 0 : o.call(s, r, {
          expose: () => {
          }
        });
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file
    });
    this.renderer = new ZP(i, {
      editor: this.editor,
      props: e
    });
  }
  get dom() {
    if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  get contentDOM() {
    return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
  }
  update(e, n) {
    const i = (r) => {
      this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(r);
    };
    if (typeof this.options.update == "function") {
      const r = this.node, s = this.decorations;
      return this.node = e, this.decorations = n, this.options.update({
        oldNode: r,
        oldDecorations: s,
        newNode: e,
        newDecorations: n,
        updateProps: () => i({ node: e, decorations: n })
      });
    }
    return e.type !== this.node.type ? !1 : (e === this.node && this.decorations === n || (this.node = e, this.decorations = n, i({ node: e, decorations: n })), !0);
  }
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  getDecorationClasses() {
    return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy();
  }
}
function Oc(t, e) {
  return (n) => n.editor.contentComponent ? new cq(t, n, e) : {};
}
const tl = [];
class uq {
  constructor({
    editor: e,
    element: n,
    view: i,
    tippyOptions: r = {},
    shouldShow: s,
    getRenderContainer: o,
    defaultAnimation: a = !0
  }) {
    Pe(this, "editor");
    Pe(this, "element");
    Pe(this, "view");
    Pe(this, "preventHide", !1);
    Pe(this, "tippy");
    Pe(this, "tippyOptions");
    Pe(this, "getRenderContainer");
    Pe(this, "defaultAnimation");
    Pe(this, "shouldShow", ({
      view: e,
      state: n,
      from: i,
      to: r
    }) => {
      const { doc: s, selection: o } = n, { empty: a } = o, l = !s.textBetween(i || 0, r || 0).length && qd(o);
      return !(!e.hasFocus() || a || l);
    });
    Pe(this, "mousedownHandler", () => {
      this.preventHide = !0;
    });
    Pe(this, "dragstartHandler", () => {
      this.hide();
    });
    Pe(this, "blurHandler", ({ event: e }) => {
      var i, r;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      e != null && e.relatedTarget && ((i = this.element.parentNode) != null && i.contains(e.relatedTarget)) || this.editor.isEditable && ((r = this.shouldShow) != null && r.call(this, {
        editor: this.editor,
        state: this.editor.state
      })) || this.hide();
    });
    Pe(this, "addActiveBubbleMenu", () => {
      tl.findIndex(
        (n) => {
          var i;
          return (n == null ? void 0 : n.id) === ((i = this.tippy) == null ? void 0 : i.id);
        }
      ) < 0 && tl.push(this.tippy);
    });
    Pe(this, "removeActiveBubbleMenu", () => {
      const e = tl.findIndex(
        (n) => {
          var i;
          return (n == null ? void 0 : n.id) === ((i = this.tippy) == null ? void 0 : i.id);
        }
      );
      e > -1 && tl.splice(e, 1);
    });
    this.editor = e, this.element = n, this.view = i, this.getRenderContainer = o, this.defaultAnimation = a, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, {
      capture: !0
    }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.tippyOptions = r || {}, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Bo(e, {
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "bottom-start",
      hideOnClick: "toggle",
      plugins: [iq],
      popperOptions: {
        modifiers: [
          {
            name: "customWidth",
            enabled: !0,
            phase: "beforeWrite",
            requires: ["computeStyles"],
            fn({ state: i }) {
              i.styles.popper.maxWidth = "98%";
            }
          }
        ]
      },
      ...Object.assign(
        {
          zIndex: 999,
          ...this.defaultAnimation ? {
            animation: "shift-toward-subtle",
            moveTransition: "transform 0.2s ease-in-out"
          } : {},
          fixed: !0
        },
        this.tippyOptions
      )
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener(
      "blur",
      (i) => {
        this.blurHandler({ event: i });
      }
    ));
  }
  update(e, n) {
    var x, v, w, T, S, $;
    const { state: i, composing: r } = e, { doc: s, selection: o } = i, a = n && n.doc.eq(s) && n.selection.eq(o);
    if (r || a)
      return;
    const { ranges: l } = o, c = Math.min(...l.map((I) => I.$from.pos)), u = Math.max(...l.map((I) => I.$to.pos)), d = e.domAtPos(c).node, f = e.nodeDOM(c) || d;
    if (!(this.editor.isEditable && ((x = this.shouldShow) == null ? void 0 : x.call(this, {
      editor: this.editor,
      view: e,
      node: f,
      state: i,
      oldState: n,
      from: c,
      to: u
    })))) {
      this.hide();
      return;
    }
    this.createTooltip();
    const m = o.$anchor.pos, g = (v = this.tippyOptions) != null && v.placement ? (w = this.tippyOptions) == null ? void 0 : w.placement : Qp(o) ? tl.length > 1 ? "bottom" : "top" : (T = this.tippy) != null && T.props.fixed || Math.abs(m - u) <= Math.abs(m - c) ? "bottom-start" : "top-start", b = tl.filter(
      (I) => {
        var F;
        return I.id !== ((F = this.tippy) == null ? void 0 : F.id) && I.popperInstance && I.popperInstance.state;
      }
    ), _ = (S = this.tippyOptions) == null ? void 0 : S.offset, y = (_ == null ? void 0 : _[0]) ?? 0;
    let O = b.length ? b.reduce((I, F, V, q) => {
      var N, W, X, ee, re, xe, $e, be, we, St, it, rt, et;
      const K = q[V - 1] ? ((re = (ee = (X = (W = (N = q[V - 1]) == null ? void 0 : N.popperInstance) == null ? void 0 : W.state) == null ? void 0 : X.modifiersData) == null ? void 0 : ee.popperOffsets) == null ? void 0 : re.y) ?? 0 : 0, ie = ((we = (be = ($e = (xe = F == null ? void 0 : F.popperInstance) == null ? void 0 : xe.state) == null ? void 0 : $e.modifiersData) == null ? void 0 : be.popperOffsets) == null ? void 0 : we.y) ?? 0, k = ((et = (rt = (it = (St = F == null ? void 0 : F.popperInstance) == null ? void 0 : St.state) == null ? void 0 : it.rects) == null ? void 0 : rt.popper) == null ? void 0 : et.height) ?? 10;
      return Math.abs(K - ie) <= k && (I += k), I;
    }, 0) : (_ == null ? void 0 : _[1]) ?? 10;
    O || (O = 10), ($ = this.tippy) == null || $.setProps({
      offset: [y, O],
      placement: g,
      getReferenceClientRect: () => {
        let I = null;
        return Qp(i.selection) && this.getRenderContainer && f && (I = this.getRenderContainer(f)), this.getRenderContainer && f && (I = this.getRenderContainer(f)), I && I.getBoundingClientRect ? I.getBoundingClientRect() : f && f.getBoundingClientRect ? f.getBoundingClientRect() : R2(e, c, u);
      }
    }), this.show();
  }
  show() {
    var e;
    this.addActiveBubbleMenu(), (e = this.tippy) == null || e.show();
  }
  hide() {
    var e;
    this.removeActiveBubbleMenu(), (e = this.tippy) == null || e.hide();
  }
  destroy() {
    var e;
    this.removeActiveBubbleMenu(), (e = this.tippy) == null || e.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, {
      capture: !0
    }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
  }
}
const dq = (t) => new Ue({
  key: typeof t.pluginKey == "string" ? new Ke(t.pluginKey) : t.pluginKey,
  view: (e) => new uq({ view: e, ...t })
}), hq = /* @__PURE__ */ ke({
  __name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    },
    getRenderContainer: {
      type: Function,
      default: null
    },
    defaultAnimation: {
      type: Boolean,
      default: !0
    }
  },
  setup(t) {
    const e = t, n = pt(null);
    return Gi(() => {
      const {
        editor: i,
        pluginKey: r,
        shouldShow: s,
        tippyOptions: o,
        getRenderContainer: a,
        defaultAnimation: l
      } = e;
      i.registerPlugin(
        dq({
          editor: i,
          element: n.value,
          pluginKey: r,
          shouldShow: s,
          tippyOptions: o,
          getRenderContainer: a,
          defaultAnimation: l
        })
      );
    }), hc(() => {
      const { pluginKey: i, editor: r } = e;
      r.unregisterPlugin(i);
    }), (i, r) => (P(), L("div", {
      ref_key: "root",
      ref: n
    }, [
      Wi(i.$slots, "default")
    ], 512));
  }
}), fq = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, pq = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m7 10l5 5l5-5z"
}, null, -1), mq = [
  pq
];
function gq(t, e) {
  return P(), L("svg", fq, [...mq]);
}
const bq = { name: "mdi-menu-down", render: gq }, Oq = ["disabled"], $t = /* @__PURE__ */ ke({
  __name: "ToolbarItem",
  props: {
    isActive: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    title: { default: void 0 },
    action: { type: Function, default: void 0 },
    icon: { default: void 0 },
    children: { default: void 0 }
  },
  setup(t) {
    return (e, n) => {
      var i;
      return ut((P(), L("button", {
        class: Ot([[
          { "bg-gray-200/70": e.isActive },
          { "cursor-not-allowed opacity-70": e.disabled },
          { "hover:bg-gray-100": !e.disabled }
        ], "inline-flex items-center space-x-1 p-1.5 rounded-md"]),
        disabled: e.disabled,
        tabindex: "-1",
        onClick: n[0] || (n[0] = //@ts-ignore
        (...r) => e.action && e.action(...r))
      }, [
        (P(), Re(Ni(e.icon))),
        (i = e.children) != null && i.length ? (P(), Re(Z(bq), { key: 0 })) : ei("", !0)
      ], 10, Oq)), [
        [Z(mo), e.title]
      ]);
    };
  }
}), Xn = /* @__PURE__ */ ke({
  __name: "ToolbarSubItem",
  props: {
    isActive: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    title: { default: void 0 },
    action: { type: Function, default: void 0 },
    icon: { default: void 0 }
  },
  setup(t) {
    const e = t, n = () => {
      var i;
      e.disabled || (i = e.action) == null || i.call(e);
    };
    return (i, r) => (P(), L("div", {
      class: Ot([[
        { "!bg-gray-100": i.isActive },
        { "cursor-not-allowed opacity-70 ": i.disabled },
        { "hover:bg-gray-100": !i.disabled }
      ], "flex flex-row items-center rounded gap-3 py-1 px-1.5 group cursor-pointer"]),
      onClick: n
    }, [
      (P(), Re(Ni(i.icon), {
        class: Ot(["bg-gray-100 p-1.5 rounded w-7 h-7", [
          { "!bg-white": i.isActive },
          { "group-hover:bg-white": !i.disabled }
        ]])
      }, null, 8, ["class"])),
      A("span", {
        class: Ot(["text-sm text-gray-600", [
          { "!text-gray-900 !font-medium": i.isActive },
          { "group-hover:font-medium group-hover:text-gray-900": !i.disabled }
        ]])
      }, Ft(i.title), 3)
    ], 2));
  }
}), yq = { class: "flex flex-col gap-0.5" }, _q = { class: "text-sm text-gray-600 group-hover:font-medium group-hover:text-gray-900" }, vq = {
  key: 0,
  class: "text-xs text-gray-500"
}, Qo = /* @__PURE__ */ ke({
  __name: "ToolboxItem",
  props: {
    editor: { default: void 0 },
    title: { default: void 0 },
    description: { default: void 0 },
    action: { type: Function, default: void 0 },
    icon: { default: void 0 }
  },
  setup(t) {
    const e = t, n = () => {
      var i;
      (i = e.action) == null || i.call(e);
    };
    return (i, r) => (P(), L("div", {
      class: "flex flex-row items-center rounded gap-3 py-1 px-1.5 group cursor-pointer hover:bg-gray-100",
      onClick: n
    }, [
      (P(), Re(Ni(i.icon), { class: "bg-gray-100 p-1.5 rounded w-7 h-7 group-hover:bg-white" })),
      A("div", yq, [
        A("span", _q, Ft(i.title), 1),
        i.description ? (P(), L("span", vq, Ft(i.description), 1)) : ei("", !0)
      ])
    ]));
  }
}), xq = { class: "bubble-menu bg-white flex items-center rounded-md p-1 border drop-shadow space-x-1" }, wq = /* @__PURE__ */ ke({
  __name: "EditorBubbleMenu",
  props: {
    editor: {
      type: Object,
      required: !0
    }
  },
  setup(t) {
    const e = t, n = () => {
      var s;
      return ((s = e.editor) == null ? void 0 : s.extensionManager).extensions.map((o) => {
        const { getBubbleMenu: a } = o.options;
        if (!a)
          return null;
        const l = a({
          editor: e.editor
        });
        return l.items && (l.items = l.items.sort(
          (c, u) => c.priority - u.priority
        )), l;
      }).filter(Boolean);
    }, i = (r, s) => {
      var o;
      return r.editor.isEditable ? (o = s.shouldShow) == null ? void 0 : o.call(s, r) : !1;
    };
    return (r, s) => (P(!0), L(Yt, null, Fr(n(), (o, a) => (P(), Re(hq, {
      key: a,
      "plugin-key": o == null ? void 0 : o.pluginKey,
      "should-show": (l) => i(l, o),
      editor: t.editor,
      "tippy-options": {
        maxWidth: "100%",
        ...o.tippyOptions
      },
      "get-render-container": o.getRenderContainer,
      "default-animation": o.defaultAnimation
    }, {
      default: ze(() => [
        A("div", xq, [
          o.items ? (P(!0), L(Yt, { key: 0 }, Fr(o.items, (l, c) => (P(), L(Yt, { key: c }, [
            l.component ? (P(), Re(Ni(l.component), sr({
              key: 0,
              ref_for: !0
            }, l.props, { editor: t.editor }), null, 16, ["editor"])) : (P(), Re(Ky, sr({
              key: 1,
              editor: t.editor,
              ref_for: !0
            }, l.props), null, 16, ["editor"]))
          ], 64))), 128)) : o.component ? (P(), Re(Ni(o == null ? void 0 : o.component), {
            key: 1,
            editor: t.editor
          }, null, 8, ["editor"])) : ei("", !0)
        ])
      ]),
      _: 2
    }, 1032, ["plugin-key", "should-show", "editor", "tippy-options", "get-render-container", "default-animation"]))), 128));
  }
}), Sq = /* @__PURE__ */ m3(wq, [["__scopeId", "data-v-d498a572"]]), kq = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Eq = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M17 13h-4v4h-2v-4H7v-2h4V7h2v4h4m-5-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2"
}, null, -1), Cq = [
  Eq
];
function Aq(t, e) {
  return P(), L("svg", kq, [...Cq]);
}
const Tq = { name: "mdi-plus-circle", render: Aq }, Mq = { class: "editor-header py-1 space-x-1 px-1 overflow-auto border-b drop-shadow-sm bg-white text-center" }, Pq = { class: "h-full inline-flex items-center" }, Rq = {
  class: "p-1.5 rounded-md hover:bg-gray-100",
  tabindex: "-1"
}, $q = { class: "relative rounded-md bg-white overflow-hidden drop-shadow w-56 p-1 max-h-96 overflow-y-auto space-y-1.5" }, Nq = /* @__PURE__ */ A("div", { class: "h-5 bg-gray-100 w-[1px] !mx-1" }, null, -1), Dq = { class: "relative rounded-md bg-white overflow-hidden drop-shadow w-56 p-1 max-h-96 overflow-y-auto space-y-1.5" }, Iq = /* @__PURE__ */ ke({
  __name: "EditorHeader",
  props: {
    editor: {
      type: VP,
      required: !0
    }
  },
  setup(t) {
    const e = t;
    function n() {
      var s;
      return ((s = e.editor) == null ? void 0 : s.extensionManager).extensions.reduce((o, a) => {
        const { getToolbarItems: l } = a.options;
        if (!l)
          return o;
        const c = l({
          editor: e.editor
        });
        return Array.isArray(c) ? [...o, ...c] : [...o, c];
      }, []).sort((o, a) => o.priority - a.priority);
    }
    function i() {
      var s;
      return ((s = e.editor) == null ? void 0 : s.extensionManager).extensions.reduce((o, a) => {
        const { getToolboxItems: l } = a.options;
        if (!l)
          return o;
        const c = l({
          editor: e.editor
        });
        return Array.isArray(c) ? [...o, ...c] : [...o, c];
      }, []).sort((o, a) => o.priority - a.priority);
    }
    return (r, s) => (P(), L("div", Mq, [
      A("div", Pq, [
        fe(Z(_8), null, {
          popper: ze(() => [
            A("div", $q, [
              (P(!0), L(Yt, null, Fr(i(), (o, a) => (P(), Re(Ni(o.component), sr({ ref_for: !0 }, o.props, {
                key: a,
                tabindex: "-1"
              }), null, 16))), 128))
            ])
          ]),
          default: ze(() => [
            A("button", Rq, [
              fe(Z(Tq), { class: "text-[#4CCBA0]" })
            ])
          ]),
          _: 1
        }),
        Nq,
        (P(!0), L(Yt, null, Fr(n(), (o, a) => {
          var l;
          return P(), L("div", { key: a }, [
            (l = o.children) != null && l.length ? (P(), Re(Z(Iu), {
              key: 1,
              class: "inline-flex",
              tabindex: "-1",
              triggers: ["click"],
              "popper-triggers": ["click"]
            }, {
              popper: ze(() => [
                A("div", Dq, [
                  (P(!0), L(Yt, null, Fr(o.children, (c, u) => (P(), Re(Ni(c.component), sr({ ref_for: !0 }, c.props, {
                    key: u,
                    tabindex: "-1"
                  }), null, 16))), 128))
                ])
              ]),
              default: ze(() => [
                (P(), Re(Ni(o.component), sr({ ref_for: !0 }, o.props, {
                  children: o.children,
                  tabindex: "-1"
                }), null, 16, ["children"]))
              ]),
              _: 2
            }, 1024)) : (P(), Re(Ni(o.component), sr({
              key: 0,
              ref_for: !0
            }, o.props, { tabindex: "-1" }), null, 16))
          ]);
        }), 128))
      ])
    ]));
  }
}), Lq = {
  key: 0,
  class: "halo-rich-text-editor"
}, Bq = { class: "h-full flex flex-row w-full overflow-hidden" }, Qq = { class: "overflow-y-auto flex-1 bg-white relative" }, Fq = {
  key: 0,
  class: "editor-header-extra"
}, zq = {
  key: 0,
  class: "h-full hidden sm:!block w-72 flex-shrink-0 flex-none"
}, Uq = /* @__PURE__ */ ke({
  __name: "Editor",
  props: {
    editor: {
      type: Object,
      required: !0
    },
    contentStyles: {
      type: Object,
      required: !1,
      default: () => ({})
    },
    locale: {
      type: String,
      required: !1,
      default: "zh-CN"
    }
  },
  setup(t) {
    const e = t;
    return In(
      () => e.locale,
      () => {
        Q.global.locale.value = e.locale;
      },
      {
        immediate: !0
      }
    ), (n, i) => t.editor ? (P(), L("div", Lq, [
      fe(Sq, { editor: t.editor }, null, 8, ["editor"]),
      fe(Iq, { editor: t.editor }, null, 8, ["editor"]),
      A("div", Bq, [
        A("div", Qq, [
          n.$slots.content ? (P(), L("div", Fq, [
            Wi(n.$slots, "content")
          ])) : ei("", !0),
          fe(Z(oq), {
            editor: t.editor,
            style: sn(t.contentStyles),
            class: "editor-content markdown-body relative"
          }, null, 8, ["editor", "style"])
        ]),
        n.$slots.extra ? (P(), L("div", zq, [
          Wi(n.$slots, "extra")
        ])) : ei("", !0)
      ])
    ])) : ei("", !0);
  }
}), Wq = wt.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), Vq = mt.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      a7(this.options)
    ];
  }
}), Zq = wt.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", Ee(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: i }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: r, storedMarks: s } = n;
          if (r.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: o } = this.options, { splittableMarks: a } = i.extensionManager, l = s || r.$to.parentOffset && r.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && l && o) {
              const d = l.filter((h) => a.includes(h.type.name));
              c.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), Hq = wt.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", Ee(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        const { selection: n } = e, { $from: i, $to: r } = n, s = t();
        return i.parentOffset === 0 ? s.insertContentAt({
          from: Math.max(i.pos - 1, 0),
          to: r.pos
        }, {
          type: this.name
        }) : Qp(n) ? s.insertContentAt(r.pos, {
          type: this.name
        }) : s.insertContent({ type: this.name }), s.command(({ tr: o, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: c } = o.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? o.setSelection(ce.create(o.doc, c.pos + 1)) : c.nodeAfter.isBlock ? o.setSelection(ge.create(o.doc, c.pos)) : o.setSelection(ce.create(o.doc, c.pos));
            else {
              const d = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              d && (o.insert(u, d), o.setSelection(ce.create(o.doc, u + 1)));
            }
            o.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      jd({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), qq = mt.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = e, r = [];
            if (!n)
              return null;
            const s = this.editor.isEmpty;
            return t.descendants((o, a) => {
              const l = i >= a && i <= a + o.nodeSize, c = !o.isLeaf && P2(o);
              if ((l || !this.options.showOnlyCurrent) && c) {
                const u = [this.options.emptyNodeClass];
                s && u.push(this.options.emptyEditorClass);
                const d = zt.node(a, a + o.nodeSize, {
                  class: u.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: o,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                r.push(d);
              }
              return this.options.includeChildren;
            }), We.create(t, r);
          }
        }
      })
    ];
  }
}), HP = Tn.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = Xd(t, this.type);
        return Object.entries(n).some(([, r]) => !!r) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), Xq = /^\s*>\s$/, jq = wt.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Hl({
        find: Xq,
        type: this.type
      })
    ];
  }
}), Yq = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Gq = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m10 7l-2 4h3v6H5v-6l2-4zm8 0l-2 4h3v6h-6v-6l2-4z"
}, null, -1), Kq = [
  Gq
];
function Jq(t, e) {
  return P(), L("svg", Yq, [...Kq]);
}
const eX = { name: "mdi-format-quote-open", render: Jq }, tX = jq.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 90,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("blockquote"),
            icon: R(eX),
            title: Q.global.t("editor.common.quote"),
            action: () => {
              e.commands.toggleBlockquote();
            }
          }
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            let n = e;
            for (; n && n.parentElement && n.tagName !== "BLOCKQUOTE"; )
              n = n.parentElement;
            return {
              el: n
            };
          }
        };
      }
    };
  }
}), nX = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, iX = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, rX = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, sX = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, oX = Tn.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Aa({
        find: nX,
        type: this.type
      }),
      Aa({
        find: rX,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Eo({
        find: iX,
        type: this.type
      }),
      Eo({
        find: sX,
        type: this.type
      })
    ];
  }
}), aX = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, lX = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M13.5 15.5H10v-3h3.5A1.5 1.5 0 0 1 15 14a1.5 1.5 0 0 1-1.5 1.5m-3.5-9h3A1.5 1.5 0 0 1 14.5 8A1.5 1.5 0 0 1 13 9.5h-3m5.6 1.29c.97-.68 1.65-1.79 1.65-2.79c0-2.26-1.75-4-4-4H7v14h7.04c2.1 0 3.71-1.7 3.71-3.79c0-1.52-.86-2.82-2.15-3.42"
}, null, -1), cX = [
  lX
];
function uX(t, e) {
  return P(), L("svg", aX, [...cX]);
}
const qP = { name: "mdi-format-bold", render: uX }, dX = oX.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 40,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("bold"),
            icon: R(qP),
            title: Q.global.t("editor.common.bold"),
            action: () => {
              e.chain().focus().toggleBold().run();
            }
          }
        };
      }
    };
  }
}), hX = wt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Ee(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), pS = Tn.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = Xd(t, this.type);
        return Object.entries(n).some(([, r]) => !!r) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), mS = /^\s*([-+*])\s$/, fX = wt.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(hX.name, this.editor.getAttributes(pS.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = Hl({
      find: mS,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Hl({
      find: mS,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(pS.name),
      editor: this.editor
    })), [
      t
    ];
  }
}), XP = wt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Ee(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), pX = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, mX = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M7 5h14v2H7zm0 8v-2h14v2zM4 4.5A1.5 1.5 0 0 1 5.5 6A1.5 1.5 0 0 1 4 7.5A1.5 1.5 0 0 1 2.5 6A1.5 1.5 0 0 1 4 4.5m0 6A1.5 1.5 0 0 1 5.5 12A1.5 1.5 0 0 1 4 13.5A1.5 1.5 0 0 1 2.5 12A1.5 1.5 0 0 1 4 10.5M7 19v-2h14v2zm-3-2.5A1.5 1.5 0 0 1 5.5 18A1.5 1.5 0 0 1 4 19.5A1.5 1.5 0 0 1 2.5 18A1.5 1.5 0 0 1 4 16.5"
}, null, -1), gX = [
  mX
];
function bX(t, e) {
  return P(), L("svg", pX, [...gX]);
}
const gS = { name: "mdi-format-list-bulleted", render: bX }, OX = fX.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 130,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("bulletList"),
            icon: R(gS),
            title: Q.global.t("editor.common.bullet_list"),
            action: () => e.chain().focus().toggleBulletList().run()
          }
        };
      },
      getCommandMenuItems() {
        return {
          priority: 130,
          icon: R(gS),
          title: "editor.common.bullet_list",
          keywords: ["bulletlist", "wuxuliebiao"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).toggleBulletList().run();
          }
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            let n = e;
            for (; n && n.tagName !== "LI"; )
              n = n.parentElement;
            return {
              el: n,
              dragDomOffset: {
                x: -12
              }
            };
          }
        };
      }
    };
  },
  addExtensions() {
    return [XP];
  }
}), yX = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/, _X = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g, vX = Tn.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Aa({
        find: yX,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Eo({
        find: _X,
        type: this.type
      })
    ];
  }
}), xX = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, wX = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m14.6 16.6l4.6-4.6l-4.6-4.6L16 6l6 6l-6 6zm-5.2 0L4.8 12l4.6-4.6L8 6l-6 6l6 6z"
}, null, -1), SX = [
  wX
];
function kX(t, e) {
  return P(), L("svg", xX, [...SX]);
}
const jP = { name: "mdi-code-tags", render: kX }, EX = vX.extend({
  exitable: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 100,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("code"),
            icon: R(jP),
            title: Q.global.t("editor.common.code"),
            action: () => e.chain().focus().toggleCode().run()
          }
        };
      }
    };
  }
}), CX = mt.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), AX = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, TX = /* @__PURE__ */ A("path", {
  d: "M9.624 11.998L12 5.665l2.375 6.333m-3.375-9l-5.5 14h2.25l1.125-3h6.25l1.125 3h2.25l-5.5-14h-2z",
  fill: "currentColor"
}, null, -1), MX = [
  TX
];
function PX(t, e) {
  return P(), L("svg", AX, [...MX]);
}
const YP = { name: "mdi-format-color", render: PX }, RX = "";
function yc(t, e) {
  e === void 0 && (e = {});
  var n = e.insertAt;
  if (!(!t || typeof document > "u")) {
    var i = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style");
    r.type = "text/css", n === "top" && i.firstChild ? i.insertBefore(r, i.firstChild) : i.appendChild(r), r.styleSheet ? r.styleSheet.cssText = t : r.appendChild(document.createTextNode(t));
  }
}
const _c = function(t, e) {
  const { componentPrefix: n = RX } = e || {};
  t.component(`${n}${this.name}`, this);
}, Gg = {};
var Kd = {
  name: "Checkboard",
  props: {
    size: {
      type: [Number, String],
      default: 8
    },
    white: {
      type: String,
      default: "#fff"
    },
    grey: {
      type: String,
      default: "#e6e6e6"
    }
  },
  computed: {
    bgStyle() {
      return {
        "background-image": `url(${NX(this.white, this.grey, this.size)})`
      };
    }
  }
};
function $X(t, e, n) {
  if (typeof document > "u")
    return null;
  const i = document.createElement("canvas");
  i.width = i.height = n * 2;
  const r = i.getContext("2d");
  return r ? (r.fillStyle = t, r.fillRect(0, 0, i.width, i.height), r.fillStyle = e, r.fillRect(0, 0, n, n), r.translate(n, n), r.fillRect(0, 0, n, n), i.toDataURL()) : null;
}
function NX(t, e, n) {
  const i = `${t},${e},${n}`;
  if (Gg[i])
    return Gg[i];
  const r = $X(t, e, n);
  return Gg[i] = r, r;
}
function DX(t, e, n, i, r, s) {
  return P(), L(
    "div",
    {
      class: "vc-checkerboard",
      style: sn(s.bgStyle)
    },
    null,
    4
    /* STYLE */
  );
}
var IX = ".vc-checkerboard{background-size:contain;bottom:0;left:0;position:absolute;right:0;top:0}";
yc(IX);
Kd.render = DX;
Kd.__file = "src/components/checkboard/checkboard.vue";
Kd.install = _c;
var $0 = {
  name: "Alpha",
  components: {
    Checkboard: Kd
  },
  props: {
    value: Object,
    onChange: Function
  },
  computed: {
    colors() {
      return this.value;
    },
    gradientColor() {
      const { rgba: t } = this.colors, e = [t.r, t.g, t.b].join(",");
      return `linear-gradient(to right, rgba(${e}, 0) 0%, rgba(${e}, 1) 100%)`;
    }
  },
  methods: {
    handleChange(t, e) {
      !e && t.preventDefault();
      const { container: n } = this.$refs;
      if (!n)
        return;
      const i = n.clientWidth, r = n.getBoundingClientRect().left + window.pageXOffset, o = (t.pageX || (t.touches ? t.touches[0].pageX : 0)) - r;
      let a;
      o < 0 ? a = 0 : o > i ? a = 1 : a = Math.round(o * 100 / i) / 100, this.colors.a !== a && this.$emit("change", {
        h: this.colors.hsl.h,
        s: this.colors.hsl.s,
        l: this.colors.hsl.l,
        a,
        source: "rgba"
      });
    },
    handleMouseDown(t) {
      this.handleChange(t, !0), window.addEventListener("mousemove", this.handleChange), window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp() {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange), window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }
};
const LX = { class: "vc-alpha" }, BX = { class: "vc-alpha-checkboard-wrap" }, QX = /* @__PURE__ */ A(
  "div",
  { class: "vc-alpha-picker" },
  null,
  -1
  /* HOISTED */
), FX = [
  QX
];
function zX(t, e, n, i, r, s) {
  const o = nr("Checkboard");
  return P(), L("div", LX, [
    A("div", BX, [
      fe(o)
    ]),
    A(
      "div",
      {
        class: "vc-alpha-gradient",
        style: sn({ background: s.gradientColor })
      },
      null,
      4
      /* STYLE */
    ),
    A(
      "div",
      {
        ref: "container",
        class: "vc-alpha-container",
        onMousedown: e[0] || (e[0] = (...a) => s.handleMouseDown && s.handleMouseDown(...a)),
        onTouchmove: e[1] || (e[1] = (...a) => s.handleChange && s.handleChange(...a)),
        onTouchstart: e[2] || (e[2] = (...a) => s.handleChange && s.handleChange(...a))
      },
      [
        A(
          "div",
          {
            class: "vc-alpha-pointer",
            style: sn({ left: `${s.colors.a * 100}%` })
          },
          FX,
          4
          /* STYLE */
        )
      ],
      544
      /* HYDRATE_EVENTS, NEED_PATCH */
    )
  ]);
}
var UX = ".vc-alpha,.vc-alpha-checkboard-wrap{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-checkboard-wrap{overflow:hidden}.vc-alpha-gradient{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-container{cursor:pointer;height:100%;margin:0 3px;position:relative;z-index:2}.vc-alpha-pointer{position:absolute;z-index:2}.vc-alpha-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
yc(UX);
$0.render = zX;
$0.__file = "src/components/alpha/alpha.vue";
$0.install = _c;
function On(t, e) {
  WX(t) && (t = "100%");
  var n = VX(t);
  return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t);
}
function zh(t) {
  return Math.min(1, Math.max(0, t));
}
function WX(t) {
  return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1;
}
function VX(t) {
  return typeof t == "string" && t.indexOf("%") !== -1;
}
function GP(t) {
  return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function Uh(t) {
  return t <= 1 ? "".concat(Number(t) * 100, "%") : t;
}
function sa(t) {
  return t.length === 1 ? "0" + t : String(t);
}
function ZX(t, e, n) {
  return {
    r: On(t, 255) * 255,
    g: On(e, 255) * 255,
    b: On(n, 255) * 255
  };
}
function bS(t, e, n) {
  t = On(t, 255), e = On(e, 255), n = On(n, 255);
  var i = Math.max(t, e, n), r = Math.min(t, e, n), s = 0, o = 0, a = (i + r) / 2;
  if (i === r)
    o = 0, s = 0;
  else {
    var l = i - r;
    switch (o = a > 0.5 ? l / (2 - i - r) : l / (i + r), i) {
      case t:
        s = (e - n) / l + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / l + 2;
        break;
      case n:
        s = (t - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function Kg(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function HX(t, e, n) {
  var i, r, s;
  if (t = On(t, 360), e = On(e, 100), n = On(n, 100), e === 0)
    r = n, s = n, i = n;
  else {
    var o = n < 0.5 ? n * (1 + e) : n + e - n * e, a = 2 * n - o;
    i = Kg(a, o, t + 1 / 3), r = Kg(a, o, t), s = Kg(a, o, t - 1 / 3);
  }
  return { r: i * 255, g: r * 255, b: s * 255 };
}
function OS(t, e, n) {
  t = On(t, 255), e = On(e, 255), n = On(n, 255);
  var i = Math.max(t, e, n), r = Math.min(t, e, n), s = 0, o = i, a = i - r, l = i === 0 ? 0 : a / i;
  if (i === r)
    s = 0;
  else {
    switch (i) {
      case t:
        s = (e - n) / a + (e < n ? 6 : 0);
        break;
      case e:
        s = (n - t) / a + 2;
        break;
      case n:
        s = (t - e) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function qX(t, e, n) {
  t = On(t, 360) * 6, e = On(e, 100), n = On(n, 100);
  var i = Math.floor(t), r = t - i, s = n * (1 - e), o = n * (1 - r * e), a = n * (1 - (1 - r) * e), l = i % 6, c = [n, o, s, s, a, n][l], u = [a, n, n, o, s, s][l], d = [s, s, a, n, n, o][l];
  return { r: c * 255, g: u * 255, b: d * 255 };
}
function yS(t, e, n, i) {
  var r = [
    sa(Math.round(t).toString(16)),
    sa(Math.round(e).toString(16)),
    sa(Math.round(n).toString(16))
  ];
  return i && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("");
}
function XX(t, e, n, i, r) {
  var s = [
    sa(Math.round(t).toString(16)),
    sa(Math.round(e).toString(16)),
    sa(Math.round(n).toString(16)),
    sa(jX(i))
  ];
  return r && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function jX(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function _S(t) {
  return pi(t) / 255;
}
function pi(t) {
  return parseInt(t, 16);
}
function YX(t) {
  return {
    r: t >> 16,
    g: (t & 65280) >> 8,
    b: t & 255
  };
}
var bO = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function GX(t) {
  var e = { r: 0, g: 0, b: 0 }, n = 1, i = null, r = null, s = null, o = !1, a = !1;
  return typeof t == "string" && (t = ej(t)), typeof t == "object" && (cs(t.r) && cs(t.g) && cs(t.b) ? (e = ZX(t.r, t.g, t.b), o = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : cs(t.h) && cs(t.s) && cs(t.v) ? (i = Uh(t.s), r = Uh(t.v), e = qX(t.h, i, r), o = !0, a = "hsv") : cs(t.h) && cs(t.s) && cs(t.l) && (i = Uh(t.s), s = Uh(t.l), e = HX(t.h, i, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = GP(n), {
    ok: o,
    format: t.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: n
  };
}
var KX = "[-\\+]?\\d+%?", JX = "[-\\+]?\\d*\\.\\d+%?", so = "(?:".concat(JX, ")|(?:").concat(KX, ")"), Jg = "[\\s|\\(]+(".concat(so, ")[,|\\s]+(").concat(so, ")[,|\\s]+(").concat(so, ")\\s*\\)?"), e1 = "[\\s|\\(]+(".concat(so, ")[,|\\s]+(").concat(so, ")[,|\\s]+(").concat(so, ")[,|\\s]+(").concat(so, ")\\s*\\)?"), er = {
  CSS_UNIT: new RegExp(so),
  rgb: new RegExp("rgb" + Jg),
  rgba: new RegExp("rgba" + e1),
  hsl: new RegExp("hsl" + Jg),
  hsla: new RegExp("hsla" + e1),
  hsv: new RegExp("hsv" + Jg),
  hsva: new RegExp("hsva" + e1),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function ej(t) {
  if (t = t.trim().toLowerCase(), t.length === 0)
    return !1;
  var e = !1;
  if (bO[t])
    t = bO[t], e = !0;
  else if (t === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = er.rgb.exec(t);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = er.rgba.exec(t), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = er.hsl.exec(t), n ? { h: n[1], s: n[2], l: n[3] } : (n = er.hsla.exec(t), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = er.hsv.exec(t), n ? { h: n[1], s: n[2], v: n[3] } : (n = er.hsva.exec(t), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = er.hex8.exec(t), n ? {
    r: pi(n[1]),
    g: pi(n[2]),
    b: pi(n[3]),
    a: _S(n[4]),
    format: e ? "name" : "hex8"
  } : (n = er.hex6.exec(t), n ? {
    r: pi(n[1]),
    g: pi(n[2]),
    b: pi(n[3]),
    format: e ? "name" : "hex"
  } : (n = er.hex4.exec(t), n ? {
    r: pi(n[1] + n[1]),
    g: pi(n[2] + n[2]),
    b: pi(n[3] + n[3]),
    a: _S(n[4] + n[4]),
    format: e ? "name" : "hex8"
  } : (n = er.hex3.exec(t), n ? {
    r: pi(n[1] + n[1]),
    g: pi(n[2] + n[2]),
    b: pi(n[3] + n[3]),
    format: e ? "name" : "hex"
  } : !1)))))))));
}
function cs(t) {
  return !!er.CSS_UNIT.exec(String(t));
}
var tj = (
  /** @class */
  function() {
    function t(e, n) {
      e === void 0 && (e = ""), n === void 0 && (n = {});
      var i;
      if (e instanceof t)
        return e;
      typeof e == "number" && (e = YX(e)), this.originalInput = e;
      var r = GX(e);
      this.originalInput = e, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (i = n.format) !== null && i !== void 0 ? i : r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok;
    }
    return t.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, t.prototype.isLight = function() {
      return !this.isDark();
    }, t.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
    }, t.prototype.getLuminance = function() {
      var e = this.toRgb(), n, i, r, s = e.r / 255, o = e.g / 255, a = e.b / 255;
      return s <= 0.03928 ? n = s / 12.92 : n = Math.pow((s + 0.055) / 1.055, 2.4), o <= 0.03928 ? i = o / 12.92 : i = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? r = a / 12.92 : r = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * i + 0.0722 * r;
    }, t.prototype.getAlpha = function() {
      return this.a;
    }, t.prototype.setAlpha = function(e) {
      return this.a = GP(e), this.roundA = Math.round(100 * this.a) / 100, this;
    }, t.prototype.isMonochrome = function() {
      var e = this.toHsl().s;
      return e === 0;
    }, t.prototype.toHsv = function() {
      var e = OS(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
    }, t.prototype.toHsvString = function() {
      var e = OS(this.r, this.g, this.b), n = Math.round(e.h * 360), i = Math.round(e.s * 100), r = Math.round(e.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(i, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHsl = function() {
      var e = bS(this.r, this.g, this.b);
      return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
    }, t.prototype.toHslString = function() {
      var e = bS(this.r, this.g, this.b), n = Math.round(e.h * 360), i = Math.round(e.s * 100), r = Math.round(e.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(i, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, t.prototype.toHex = function(e) {
      return e === void 0 && (e = !1), yS(this.r, this.g, this.b, e);
    }, t.prototype.toHexString = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex(e);
    }, t.prototype.toHex8 = function(e) {
      return e === void 0 && (e = !1), XX(this.r, this.g, this.b, this.a, e);
    }, t.prototype.toHex8String = function(e) {
      return e === void 0 && (e = !1), "#" + this.toHex8(e);
    }, t.prototype.toHexShortString = function(e) {
      return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e);
    }, t.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, t.prototype.toRgbString = function() {
      var e = Math.round(this.r), n = Math.round(this.g), i = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(e, ", ").concat(n, ", ").concat(i, ")") : "rgba(".concat(e, ", ").concat(n, ", ").concat(i, ", ").concat(this.roundA, ")");
    }, t.prototype.toPercentageRgb = function() {
      var e = function(n) {
        return "".concat(Math.round(On(n, 255) * 100), "%");
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      };
    }, t.prototype.toPercentageRgbString = function() {
      var e = function(n) {
        return Math.round(On(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
    }, t.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + yS(this.r, this.g, this.b, !1), n = 0, i = Object.entries(bO); n < i.length; n++) {
        var r = i[n], s = r[0], o = r[1];
        if (e === o)
          return s;
      }
      return !1;
    }, t.prototype.toString = function(e) {
      var n = !!e;
      e = e ?? this.format;
      var i = !1, r = this.a < 1 && this.a >= 0, s = !n && r && (e.startsWith("hex") || e === "name");
      return s ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (i = this.toRgbString()), e === "prgb" && (i = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (i = this.toHexString()), e === "hex3" && (i = this.toHexString(!0)), e === "hex4" && (i = this.toHex8String(!0)), e === "hex8" && (i = this.toHex8String()), e === "name" && (i = this.toName()), e === "hsl" && (i = this.toHslString()), e === "hsv" && (i = this.toHsvString()), i || this.toHexString());
    }, t.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, t.prototype.clone = function() {
      return new t(this.toString());
    }, t.prototype.lighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l += e / 100, n.l = zh(n.l), new t(n);
    }, t.prototype.brighten = function(e) {
      e === void 0 && (e = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), new t(n);
    }, t.prototype.darken = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.l -= e / 100, n.l = zh(n.l), new t(n);
    }, t.prototype.tint = function(e) {
      return e === void 0 && (e = 10), this.mix("white", e);
    }, t.prototype.shade = function(e) {
      return e === void 0 && (e = 10), this.mix("black", e);
    }, t.prototype.desaturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s -= e / 100, n.s = zh(n.s), new t(n);
    }, t.prototype.saturate = function(e) {
      e === void 0 && (e = 10);
      var n = this.toHsl();
      return n.s += e / 100, n.s = zh(n.s), new t(n);
    }, t.prototype.greyscale = function() {
      return this.desaturate(100);
    }, t.prototype.spin = function(e) {
      var n = this.toHsl(), i = (n.h + e) % 360;
      return n.h = i < 0 ? 360 + i : i, new t(n);
    }, t.prototype.mix = function(e, n) {
      n === void 0 && (n = 50);
      var i = this.toRgb(), r = new t(e).toRgb(), s = n / 100, o = {
        r: (r.r - i.r) * s + i.r,
        g: (r.g - i.g) * s + i.g,
        b: (r.b - i.b) * s + i.b,
        a: (r.a - i.a) * s + i.a
      };
      return new t(o);
    }, t.prototype.analogous = function(e, n) {
      e === void 0 && (e = 6), n === void 0 && (n = 30);
      var i = this.toHsl(), r = 360 / n, s = [this];
      for (i.h = (i.h - (r * e >> 1) + 720) % 360; --e; )
        i.h = (i.h + r) % 360, s.push(new t(i));
      return s;
    }, t.prototype.complement = function() {
      var e = this.toHsl();
      return e.h = (e.h + 180) % 360, new t(e);
    }, t.prototype.monochromatic = function(e) {
      e === void 0 && (e = 6);
      for (var n = this.toHsv(), i = n.h, r = n.s, s = n.v, o = [], a = 1 / e; e--; )
        o.push(new t({ h: i, s: r, v: s })), s = (s + a) % 1;
      return o;
    }, t.prototype.splitcomplement = function() {
      var e = this.toHsl(), n = e.h;
      return [
        this,
        new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
        new t({ h: (n + 216) % 360, s: e.s, l: e.l })
      ];
    }, t.prototype.onBackground = function(e) {
      var n = this.toRgb(), i = new t(e).toRgb(), r = n.a + i.a * (1 - n.a);
      return new t({
        r: (n.r * n.a + i.r * i.a * (1 - n.a)) / r,
        g: (n.g * n.a + i.g * i.a * (1 - n.a)) / r,
        b: (n.b * n.a + i.b * i.a * (1 - n.a)) / r,
        a: r
      });
    }, t.prototype.triad = function() {
      return this.polyad(3);
    }, t.prototype.tetrad = function() {
      return this.polyad(4);
    }, t.prototype.polyad = function(e) {
      for (var n = this.toHsl(), i = n.h, r = [this], s = 360 / e, o = 1; o < e; o++)
        r.push(new t({ h: (i + o * s) % 360, s: n.s, l: n.l }));
      return r;
    }, t.prototype.equals = function(e) {
      return this.toRgbString() === new t(e).toRgbString();
    }, t;
  }()
);
function Zs(...t) {
  return new tj(...t);
}
function t1(t, e) {
  const n = t && t.a;
  let i;
  t && t.hsl ? i = Zs(t.hsl) : t && t.hex && t.hex.length > 0 ? i = Zs(t.hex) : t && t.hsv ? i = Zs(t.hsv) : t && t.rgba ? i = Zs(t.rgba) : t && t.rgb ? i = Zs(t.rgb) : i = Zs(t), i && (i._a === void 0 || i._a === null) && i.setAlpha(n || i.getAlpha());
  const r = i.toHsl(), s = i.toHsv();
  return r.s === 0 && (s.h = r.h = t.h || t.hsl && t.hsl.h || e || 0), s.v < 0.0164 && (s.h = t.h || t.hsv && t.hsv.h || 0, s.s = t.s || t.hsv && t.hsv.s || 0), r.l < 0.01 && (r.h = t.h || t.hsl && t.hsl.h || 0, r.s = t.s || t.hsl && t.hsl.s || 0), {
    hsl: r,
    hex: i.toHexString().toUpperCase(),
    hex8: i.toHex8String().toUpperCase(),
    rgba: i.toRgb(),
    hsv: s,
    oldHue: t.h || e || r.h,
    source: t.source,
    a: i.getAlpha()
  };
}
var nj = {
  model: {
    prop: "modelValue",
    event: "update:modelValue"
  },
  props: ["modelValue"],
  data() {
    return {
      val: t1(this.modelValue)
    };
  },
  computed: {
    colors: {
      get() {
        return this.val;
      },
      set(t) {
        this.val = t, this.$emit("update:modelValue", t);
      }
    }
  },
  watch: {
    modelValue(t) {
      this.val = t1(t);
    }
  },
  methods: {
    colorChange(t, e) {
      this.oldHue = this.colors.hsl.h, this.colors = t1(t, e || this.oldHue);
    },
    isValidHex(t) {
      return Zs(t).isValid;
    },
    simpleCheckForValidColor(t) {
      const e = ["r", "g", "b", "a", "h", "s", "l", "v"];
      let n = 0, i = 0;
      for (let r = 0; r < e.length; r++) {
        const s = e[r];
        t[s] && (n++, isNaN(t[s]) || i++);
      }
      if (n === i)
        return t;
    },
    paletteUpperCase(t) {
      return t.map((e) => e.toUpperCase());
    },
    isTransparent(t) {
      return Zs(t).getAlpha() === 0;
    }
  }
}, N0 = {
  name: "EditableInput",
  props: {
    label: String,
    labelText: String,
    desc: String,
    value: [String, Number],
    max: Number,
    min: Number,
    arrowOffset: {
      type: Number,
      default: 1
    }
  },
  computed: {
    val: {
      get() {
        return this.value;
      },
      set(t) {
        if (this.max !== void 0 && +t > this.max)
          this.$refs.input.value = this.max;
        else
          return t;
      }
    },
    labelId() {
      return `input__label__${this.label}__${Math.random().toString().slice(2, 5)}`;
    },
    labelSpanText() {
      return this.labelText || this.label;
    }
  },
  methods: {
    update(t) {
      this.handleChange(t.target.value);
    },
    handleChange(t) {
      const e = {};
      e[this.label] = t, e.hex === void 0 && e["#"] === void 0 ? this.$emit("change", e) : t.length > 5 && this.$emit("change", e);
    },
    // **** unused
    // handleBlur (e) {
    //   console.log(e)
    // },
    handleKeyDown(t) {
      let { val: e } = this;
      const n = Number(e);
      if (n) {
        const i = this.arrowOffset || 1;
        t.keyCode === 38 && (e = n + i, this.handleChange(e), t.preventDefault()), t.keyCode === 40 && (e = n - i, this.handleChange(e), t.preventDefault());
      }
    }
    // **** unused
    // handleDrag (e) {
    //   console.log(e)
    // },
    // handleMouseDown (e) {
    //   console.log(e)
    // }
  }
};
const ij = { class: "vc-editable-input" }, rj = ["aria-labelledby"], sj = ["id", "for"], oj = { class: "vc-input__desc" };
function aj(t, e, n, i, r, s) {
  return P(), L("div", ij, [
    ut(A("input", {
      ref: "input",
      "onUpdate:modelValue": e[0] || (e[0] = (o) => s.val = o),
      "aria-labelledby": s.labelId,
      class: "vc-input__input",
      onKeydown: e[1] || (e[1] = (...o) => s.handleKeyDown && s.handleKeyDown(...o)),
      onInput: e[2] || (e[2] = (...o) => s.update && s.update(...o))
    }, null, 40, rj), [
      [Fn, s.val]
    ]),
    A("span", {
      id: s.labelId,
      for: n.label,
      class: "vc-input__label"
    }, Ft(s.labelSpanText), 9, sj),
    A(
      "span",
      oj,
      Ft(n.desc),
      1
      /* TEXT */
    )
  ]);
}
var lj = ".vc-editable-input{position:relative}.vc-input__input{border:0;outline:none;padding:0}.vc-input__label{text-transform:capitalize}";
yc(lj);
N0.render = aj;
N0.__file = "src/components/editable-input/editable-input.vue";
N0.install = _c;
function n1(t, e, n) {
  return e < n ? t < e ? e : t > n ? n : t : t < n ? n : t > e ? e : t;
}
var D0 = {
  name: "Saturation",
  props: {
    value: Object
  },
  computed: {
    colors() {
      return this.value;
    },
    bgColor() {
      return `hsl(${this.colors.hsv.h}, 100%, 50%)`;
    },
    pointerTop() {
      return `${-(this.colors.hsv.v * 100) + 1 + 100}%`;
    },
    pointerLeft() {
      return `${this.colors.hsv.s * 100}%`;
    }
  },
  methods: {
    handleChange(t, e) {
      !e && t.preventDefault();
      const { container: n } = this.$refs;
      if (!n)
        return;
      const i = n.clientWidth, r = n.clientHeight, s = n.getBoundingClientRect().left + window.pageXOffset, o = n.getBoundingClientRect().top + window.pageYOffset, a = t.pageX || (t.touches ? t.touches[0].pageX : 0), l = t.pageY || (t.touches ? t.touches[0].pageY : 0), c = n1(a - s, 0, i), u = n1(l - o, 0, r), d = c / i, h = n1(-(u / r) + 1, 0, 1);
      this.onChange({
        h: this.colors.hsv.h,
        s: d,
        v: h,
        a: this.colors.hsv.a,
        source: "hsva"
      });
    },
    onChange(t) {
      this.$emit("change", t);
    },
    handleMouseDown(t) {
      window.addEventListener("mousemove", this.handleChange), window.addEventListener("mouseup", this.handleChange), window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp(t) {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange), window.removeEventListener("mouseup", this.handleChange), window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }
};
const cj = /* @__PURE__ */ A(
  "div",
  { class: "vc-saturation--white" },
  null,
  -1
  /* HOISTED */
), uj = /* @__PURE__ */ A(
  "div",
  { class: "vc-saturation--black" },
  null,
  -1
  /* HOISTED */
), dj = /* @__PURE__ */ A(
  "div",
  { class: "vc-saturation-circle" },
  null,
  -1
  /* HOISTED */
), hj = [
  dj
];
function fj(t, e, n, i, r, s) {
  return P(), L(
    "div",
    {
      ref: "container",
      class: "vc-saturation",
      style: sn({ background: s.bgColor }),
      onMousedown: e[0] || (e[0] = (...o) => s.handleMouseDown && s.handleMouseDown(...o)),
      onTouchmove: e[1] || (e[1] = (...o) => s.handleChange && s.handleChange(...o)),
      onTouchstart: e[2] || (e[2] = (...o) => s.handleChange && s.handleChange(...o))
    },
    [
      cj,
      uj,
      A(
        "div",
        {
          class: "vc-saturation-pointer",
          style: sn({ top: s.pointerTop, left: s.pointerLeft })
        },
        hj,
        4
        /* STYLE */
      )
    ],
    36
    /* STYLE, HYDRATE_EVENTS */
  );
}
var pj = ".vc-saturation,.vc-saturation--black,.vc-saturation--white{bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.vc-saturation--white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.vc-saturation--black{background:linear-gradient(0deg,#000,transparent)}.vc-saturation-pointer{cursor:pointer;position:absolute}.vc-saturation-circle{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}";
yc(pj);
D0.render = fj;
D0.__file = "src/components/saturation/saturation.vue";
D0.install = _c;
var I0 = {
  name: "Hue",
  props: {
    value: Object,
    direction: {
      type: String,
      // [horizontal | vertical]
      default: "horizontal"
    }
  },
  data() {
    return {
      oldHue: 0,
      pullDirection: ""
    };
  },
  computed: {
    colors() {
      return this.value;
    },
    directionClass() {
      return {
        "vc-hue--horizontal": this.direction === "horizontal",
        "vc-hue--vertical": this.direction === "vertical"
      };
    },
    pointerTop() {
      return this.direction === "vertical" ? this.colors.hsl.h === 0 && this.pullDirection === "right" ? 0 : `${-(this.colors.hsl.h * 100 / 360) + 100}%` : 0;
    },
    pointerLeft() {
      return this.direction === "vertical" ? 0 : this.colors.hsl.h === 0 && this.pullDirection === "right" ? "100%" : `${this.colors.hsl.h * 100 / 360}%`;
    }
  },
  watch: {
    value: {
      handler(t, e) {
        const { h: n } = t.hsl;
        n !== 0 && n - this.oldHue > 0 && (this.pullDirection = "right"), n !== 0 && n - this.oldHue < 0 && (this.pullDirection = "left"), this.oldHue = n;
      },
      deep: !0,
      immediate: !0
    }
  },
  methods: {
    handleChange(t, e) {
      !e && t.preventDefault();
      const { container: n } = this.$refs;
      if (!n)
        return;
      const i = n.clientWidth, r = n.clientHeight, s = n.getBoundingClientRect().left + window.pageXOffset, o = n.getBoundingClientRect().top + window.pageYOffset, a = t.pageX || (t.touches ? t.touches[0].pageX : 0), l = t.pageY || (t.touches ? t.touches[0].pageY : 0), c = a - s, u = l - o;
      let d, h;
      this.direction === "vertical" ? (u < 0 ? d = 360 : u > r ? d = 0 : (h = -(u * 100 / r) + 100, d = 360 * h / 100), this.colors.hsl.h !== d && this.$emit("change", {
        h: d,
        s: this.colors.hsl.s,
        l: this.colors.hsl.l,
        a: this.colors.hsl.a,
        source: "hsl"
      })) : (c < 0 ? d = 0 : c > i ? d = 360 : (h = c * 100 / i, d = 360 * h / 100), this.colors.hsl.h !== d && this.$emit("change", {
        h: d,
        s: this.colors.hsl.s,
        l: this.colors.hsl.l,
        a: this.colors.hsl.a,
        source: "hsl"
      }));
    },
    handleMouseDown(t) {
      this.handleChange(t, !0), window.addEventListener("mousemove", this.handleChange), window.addEventListener("mouseup", this.handleChange), window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp(t) {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange), window.removeEventListener("mouseup", this.handleChange), window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }
};
const mj = ["aria-valuenow"], gj = /* @__PURE__ */ A(
  "div",
  { class: "vc-hue-picker" },
  null,
  -1
  /* HOISTED */
), bj = [
  gj
];
function Oj(t, e, n, i, r, s) {
  return P(), L(
    "div",
    {
      class: Ot(["vc-hue", [s.directionClass]])
    },
    [
      A("div", {
        ref: "container",
        class: "vc-hue-container",
        role: "slider",
        "aria-valuenow": s.colors.hsl.h,
        "aria-valuemin": "0",
        "aria-valuemax": "360",
        onMousedown: e[0] || (e[0] = (...o) => s.handleMouseDown && s.handleMouseDown(...o)),
        onTouchmove: e[1] || (e[1] = (...o) => s.handleChange && s.handleChange(...o)),
        onTouchstart: e[2] || (e[2] = (...o) => s.handleChange && s.handleChange(...o))
      }, [
        A(
          "div",
          {
            class: "vc-hue-pointer",
            style: sn({ top: s.pointerTop, left: s.pointerLeft }),
            role: "presentation"
          },
          bj,
          4
          /* STYLE */
        )
      ], 40, mj)
    ],
    2
    /* CLASS */
  );
}
var yj = ".vc-hue{border-radius:2px;bottom:0;left:0;position:absolute;right:0;top:0}.vc-hue--horizontal{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue--vertical{background:linear-gradient(0deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue-container{cursor:pointer;height:100%;margin:0 2px;position:relative}.vc-hue-pointer{position:absolute;z-index:2}.vc-hue-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
yc(yj);
I0.render = Oj;
I0.__file = "src/components/hue/hue.vue";
I0.install = _c;
const _j = [
  "#D0021B",
  "#F5A623",
  "#F8E71C",
  "#8B572A",
  "#7ED321",
  "#417505",
  "#BD10E0",
  "#9013FE",
  "#4A90E2",
  "#50E3C2",
  "#B8E986",
  "#000000",
  "#4A4A4A",
  "#9B9B9B",
  "#FFFFFF",
  "rgba(0,0,0,0)"
];
var L0 = {
  name: "Sketch",
  components: {
    Saturation: D0,
    Hue: I0,
    Alpha: $0,
    EdIn: N0,
    Checkboard: Kd
  },
  mixins: [nj],
  props: {
    presetColors: {
      type: Array,
      default() {
        return _j;
      }
    },
    disableAlpha: {
      type: Boolean,
      default: !1
    },
    disableFields: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    hex() {
      let t;
      return this.colors.a < 1 ? t = this.colors.hex8 : t = this.colors.hex, t.replace("#", "");
    },
    activeColor() {
      const { rgba: t } = this.colors;
      return `rgba(${[t.r, t.g, t.b, t.a].join(",")})`;
    }
  },
  methods: {
    handlePreset(t) {
      this.colorChange(t);
    },
    childChange(t) {
      this.colorChange(t);
    },
    inputChange(t) {
      t && (t.hex ? this.isValidHex(t.hex) && this.colorChange({
        hex: t.hex,
        source: "hex"
      }) : (t.r || t.g || t.b || t.a) && this.colorChange({
        r: t.r || this.colors.rgba.r,
        g: t.g || this.colors.rgba.g,
        b: t.b || this.colors.rgba.b,
        a: t.a || this.colors.rgba.a,
        source: "rgba"
      }));
    }
  }
};
const vj = { class: "vc-sketch-saturation-wrap" }, xj = { class: "vc-sketch-controls" }, wj = { class: "vc-sketch-sliders" }, Sj = { class: "vc-sketch-hue-wrap" }, kj = {
  key: 0,
  class: "vc-sketch-alpha-wrap"
}, Ej = { class: "vc-sketch-color-wrap" }, Cj = ["aria-label"], Aj = {
  key: 0,
  class: "vc-sketch-field"
}, Tj = { class: "vc-sketch-field--double" }, Mj = { class: "vc-sketch-field--single" }, Pj = { class: "vc-sketch-field--single" }, Rj = { class: "vc-sketch-field--single" }, $j = {
  key: 0,
  class: "vc-sketch-field--single"
}, Nj = {
  class: "vc-sketch-presets",
  role: "group",
  "aria-label": "A color preset, pick one to set as current color"
}, Dj = ["aria-label", "onClick"], Ij = ["aria-label", "onClick"];
function Lj(t, e, n, i, r, s) {
  const o = nr("Saturation"), a = nr("Hue"), l = nr("Alpha"), c = nr("Checkboard"), u = nr("EdIn");
  return P(), L(
    "div",
    {
      role: "application",
      "aria-label": "Sketch color picker",
      class: Ot(["vc-sketch", [n.disableAlpha ? "vc-sketch__disable-alpha" : ""]])
    },
    [
      A("div", vj, [
        fe(o, {
          value: t.colors,
          onChange: s.childChange
        }, null, 8, ["value", "onChange"])
      ]),
      A("div", xj, [
        A("div", wj, [
          A("div", Sj, [
            fe(a, {
              value: t.colors,
              onChange: s.childChange
            }, null, 8, ["value", "onChange"])
          ]),
          n.disableAlpha ? ei("v-if", !0) : (P(), L("div", kj, [
            fe(l, {
              value: t.colors,
              onChange: s.childChange
            }, null, 8, ["value", "onChange"])
          ]))
        ]),
        A("div", Ej, [
          A("div", {
            "aria-label": `Current color is ${s.activeColor}`,
            class: "vc-sketch-active-color",
            style: sn({ background: s.activeColor })
          }, null, 12, Cj),
          fe(c)
        ])
      ]),
      n.disableFields ? ei("v-if", !0) : (P(), L("div", Aj, [
        ei(" rgba "),
        A("div", Tj, [
          fe(u, {
            label: "hex",
            value: s.hex,
            onChange: s.inputChange
          }, null, 8, ["value", "onChange"])
        ]),
        A("div", Mj, [
          fe(u, {
            label: "r",
            value: t.colors.rgba.r,
            onChange: s.inputChange
          }, null, 8, ["value", "onChange"])
        ]),
        A("div", Pj, [
          fe(u, {
            label: "g",
            value: t.colors.rgba.g,
            onChange: s.inputChange
          }, null, 8, ["value", "onChange"])
        ]),
        A("div", Rj, [
          fe(u, {
            label: "b",
            value: t.colors.rgba.b,
            onChange: s.inputChange
          }, null, 8, ["value", "onChange"])
        ]),
        n.disableAlpha ? ei("v-if", !0) : (P(), L("div", $j, [
          fe(u, {
            label: "a",
            value: t.colors.a,
            "arrow-offset": 0.01,
            max: 1,
            onChange: s.inputChange
          }, null, 8, ["value", "arrow-offset", "onChange"])
        ]))
      ])),
      A("div", Nj, [
        (P(!0), L(
          Yt,
          null,
          Fr(n.presetColors, (d) => (P(), L(
            Yt,
            null,
            [
              t.isTransparent(d) ? (P(), L("div", {
                key: d,
                "aria-label": `Color:${d}`,
                class: "vc-sketch-presets-color",
                onClick: (h) => s.handlePreset(d)
              }, [
                fe(c)
              ], 8, Ij)) : (P(), L("div", {
                key: `!${d}`,
                class: "vc-sketch-presets-color",
                "aria-label": `Color:${d}`,
                style: sn({ background: d }),
                onClick: (h) => s.handlePreset(d)
              }, null, 12, Dj))
            ],
            64
            /* STABLE_FRAGMENT */
          ))),
          256
          /* UNKEYED_FRAGMENT */
        ))
      ])
    ],
    2
    /* CLASS */
  );
}
var Bj = ".vc-sketch{background:#fff;border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,.15),0 8px 16px rgba(0,0,0,.15);box-sizing:initial;padding:10px 10px 0;position:relative;width:200px}.vc-sketch-saturation-wrap{overflow:hidden;padding-bottom:75%;position:relative;width:100%}.vc-sketch-controls{display:flex}.vc-sketch-sliders{flex:1;padding:4px 0}.vc-sketch-sliders .vc-alpha-gradient,.vc-sketch-sliders .vc-hue{border-radius:2px}.vc-sketch-alpha-wrap,.vc-sketch-hue-wrap{height:10px;position:relative}.vc-sketch-alpha-wrap{margin-top:4px;overflow:hidden}.vc-sketch-color-wrap{border-radius:3px;height:24px;margin-left:4px;margin-top:4px;position:relative;width:24px}.vc-sketch-active-color{border-radius:2px;bottom:0;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15),inset 0 0 4px rgba(0,0,0,.25);left:0;position:absolute;right:0;top:0;z-index:2}.vc-sketch-color-wrap .vc-checkerboard{background-size:auto}.vc-sketch-field{display:flex;padding-top:4px}.vc-sketch-field .vc-input__input{border:none;box-shadow:inset 0 0 0 1px #ccc;font-size:10px;padding:4px 0 3px 10%;width:90%}.vc-sketch-field .vc-input__label{color:#222;display:block;font-size:11px;padding-bottom:4px;padding-top:3px;text-align:center;text-transform:capitalize}.vc-sketch-field--single{flex:1;padding-left:6px}.vc-sketch-field--double{flex:2}.vc-sketch-presets{border-top:1px solid #eee;margin-left:-10px;margin-right:-10px;padding-left:10px;padding-top:10px}.vc-sketch-presets-color{cursor:pointer;display:inline-block;height:16px;margin:0 10px 10px 0;overflow:hidden;position:relative;vertical-align:top;width:16px}.vc-sketch-presets-color,.vc-sketch-presets-color .vc-checkerboard{border-radius:3px;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15)}.vc-sketch__disable-alpha .vc-sketch-color-wrap{height:10px}";
yc(Bj);
L0.render = Lj;
L0.__file = "src/components/sketch/sketch.vue";
L0.install = _c;
function KP(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var JP = {}, e5 = {}, z2 = { exports: {} }, Et = String, t5 = function() {
  return { isColorSupported: !1, reset: Et, bold: Et, dim: Et, italic: Et, underline: Et, inverse: Et, hidden: Et, strikethrough: Et, black: Et, red: Et, green: Et, yellow: Et, blue: Et, magenta: Et, cyan: Et, white: Et, gray: Et, bgBlack: Et, bgRed: Et, bgGreen: Et, bgYellow: Et, bgBlue: Et, bgMagenta: Et, bgCyan: Et, bgWhite: Et };
};
z2.exports = t5();
z2.exports.createColors = t5;
var Qj = z2.exports;
(function(t) {
  var e = { ALLUSERSPROFILE: "C:\\ProgramData", APPCODE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\appcode.vmoptions", APPDATA: "C:\\Users\\51923\\AppData\\Roaming", "asl.log": "Destination=file", CATALINA_HOME: "D:\\Program Files (x86)\\apache-tomcat-9.0.84-windows-x64\\apache-tomcat-9.0.84", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133657579525662721", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_3964_AJVANIKVVIFJLRUS", CLASSPATH: ".;D:\\Program Files\\Java\\jdk-17\\lib\\dt.jar;D:\\Program Files\\Java\\jdk-17\\lib\\tools.jar", CLION_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\clion.vmoptions", COLOR: "1", COLORTERM: "truecolor", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "INSPIRON5593", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DATAGRIP_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\datagrip.vmoptions", DATASPELL_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\dataspell.vmoptions", DEVECOSTUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\devecostudio.vmoptions", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GATEWAY_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\gateway.vmoptions", GIT_ASKPASS: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", GOLAND_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\goland.vmoptions", HOME: "C:\\Users\\51923", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\51923", IDEA_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\idea.vmoptions", INIT_CWD: "D:\\editor", "IntelliJ IDEA": "E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;", JAVA_HOME: "D:\\Program Files\\Java\\jdk-17", JETBRAINSCLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrainsclient.vmoptions", JETBRAINS_CLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrains_client.vmoptions", LANG: "zh_CN.UTF-8", LOCALAPPDATA: "C:\\Users\\51923\\AppData\\Local", LOGONSERVER: "\\\\INSPIRON5593", Maven_Home: "D:\\apache-maven-3.9.5", MAVEN_OPTS: "-Xms128m -Xmx512m", NODE: "E:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_PATH: "D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\bin\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules;D:\\editor\\node_modules\\.pnpm\\node_modules", npm_command: "run-script", npm_config_cache: "C:\\Users\\51923\\AppData\\Local\\npm-cache", npm_config_chromedriver_cdnurl: "https://npm.taobao.org/mirrors/chromedriver/", npm_config_electron_builder_binaries_mirror: "https://npm.taobao.org/mirrors/electron-builder-binaries/", npm_config_electron_mirror: "https://npm.taobao.org/mirrors/electron/", npm_config_fetch_retry_maxtimeout: "120000", npm_config_fetch_retry_mintimeout: "20000", npm_config_globalconfig: "E:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "E:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\51923\\.npm-init.js", npm_config_local_prefix: "D:\\editor", npm_config_node_gyp: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.8.2", npm_config_prefix: "E:\\Program Files\\nodejs", npm_config_registry: "https://registry.npmmirror.com", npm_config_userconfig: "C:\\Users\\51923\\.npmrc", npm_config_user_agent: "npm/10.8.2 node/v18.19.0 win32 x64 workspaces/false", npm_execpath: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build --config ./vite.lib.config.ts", npm_node_execpath: "E:\\Program Files\\nodejs\\node.exe", npm_package_json: "D:\\editor\\package.json", npm_package_name: "hf-richtext", npm_package_version: "1.1.0", NUMBER_OF_PROCESSORS: "8", NVM_HOME: "E:\\Program Files (x86)\\nvm", NVM_SYMLINK: "E:\\Program Files\\nodejs", OneDrive: "C:\\Users\\51923\\OneDrive", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", Path: "D:\\editor\\node_modules\\.bin;D:\\node_modules\\.bin;E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Common Files\\Oracle\\Java\\javapath;D:\\Program Files\\Java\\jdk-17\\bin;D:\\Program Files\\Java\\jdk-17\\jre\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;E:\\tomcat\\apache-tomcat-8.5.11\\bin;E:\\mysql-5.6\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\apache-maven-3.9.5\\bin\\;E:\\Program Files\\Git\\cmd;E:\\Program Files\\TortoiseGit\\bin;E:\\Program Files (x86)\\Tencent\\web\\dll;E:\\Program Files\\Redis\\;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;C:\\Program Files\\dotnet\\;C:\\Users\\51923\\AppData\\Local\\Yarn\\bin;D:\\apache-maven-3.9.5\\bin;C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin;%CATALIN A_HOM E%\\bin;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\Scripts\\;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\;E:\\Programs\\Python\\Python38-32\\Scripts\\;E:\\Programs\\Python\\Python38-32\\;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin\\;C:\\Users\\51923\\AppData\\Local\\Microsoft\\WindowsApps;E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;E:\\Programs\\Microsoft VS Code\\bin;C:\\Users\\51923\\AppData\\Roaming\\npm;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;E:\\Program Files\\JetBrains\\PyCharm 2023.2.1\\bin;E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\OpenSSL-Win64\\bin;", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.CPL", PHPSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\phpstorm.vmoptions", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 126 Stepping 5, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "7e05", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "D:\\360MoveData\\Users\\51923\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", PyCharm: "E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;", PYCHARM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\pycharm.vmoptions", RIDER_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rider.vmoptions", RUBYMINE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rubymine.vmoptions", SESSIONNAME: "Console", STUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\studio.vmoptions", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\51923\\AppData\\Local\\Temp", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.91.1", TMP: "C:\\Users\\51923\\AppData\\Local\\Temp", USERDOMAIN: "INSPIRON5593", USERDOMAIN_ROAMINGPROFILE: "INSPIRON5593", USERNAME: "51923", USERPROFILE: "C:\\Users\\51923", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "", VSCODE_GIT_ASKPASS_MAIN: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "E:\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-c773be81e1-sock", VSCODE_INJECTION: "1", WEBIDE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webide.vmoptions", WEBSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webstorm.vmoptions", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function n(c, u) {
    for (var d in u) Object.defineProperty(c, d, {
      enumerable: !0,
      get: u[d]
    });
  }
  n(t, {
    dim: function() {
      return a;
    },
    default: function() {
      return l;
    }
  });
  const i = /* @__PURE__ */ r(Qj);
  function r(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  let s = /* @__PURE__ */ new Set();
  function o(c, u, d) {
    typeof process < "u" && e.JEST_WORKER_ID || d && s.has(d) || (d && s.add(d), console.warn(""), u.forEach((h) => console.warn(c, "-", h)));
  }
  function a(c) {
    return i.default.dim(c);
  }
  const l = {
    info(c, u) {
      o(i.default.bold(i.default.cyan("info")), ...Array.isArray(c) ? [
        c
      ] : [
        u,
        c
      ]);
    },
    warn(c, u) {
      o(i.default.bold(i.default.yellow("warn")), ...Array.isArray(c) ? [
        c
      ] : [
        u,
        c
      ]);
    },
    risk(c, u) {
      o(i.default.bold(i.default.magenta("risk")), ...Array.isArray(c) ? [
        c
      ] : [
        u,
        c
      ]);
    }
  };
})(e5);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  const e = /* @__PURE__ */ n(e5);
  function n(s) {
    return s && s.__esModule ? s : {
      default: s
    };
  }
  function i({ version: s, from: o, to: a }) {
    e.default.warn(`${o}-color-renamed`, [
      `As of Tailwind CSS ${s}, \`${o}\` has been renamed to \`${a}\`.`,
      "Update your configuration file to silence this warning."
    ]);
  }
  const r = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    get lightBlue() {
      return i({
        version: "v2.2",
        from: "lightBlue",
        to: "sky"
      }), this.sky;
    },
    get warmGray() {
      return i({
        version: "v3.0",
        from: "warmGray",
        to: "stone"
      }), this.stone;
    },
    get trueGray() {
      return i({
        version: "v3.0",
        from: "trueGray",
        to: "neutral"
      }), this.neutral;
    },
    get coolGray() {
      return i({
        version: "v3.0",
        from: "coolGray",
        to: "gray"
      }), this.gray;
    },
    get blueGray() {
      return i({
        version: "v3.0",
        from: "blueGray",
        to: "slate"
      }), this.slate;
    }
  };
})(JP);
let i1 = JP;
var Fj = (i1.__esModule ? i1 : { default: i1 }).default;
const vS = /* @__PURE__ */ KP(Fj), zj = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Uj = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M8.59 16.58L13.17 12L8.59 7.41L10 6l6 6l-6 6z"
}, null, -1), Wj = [
  Uj
];
function Vj(t, e) {
  return P(), L("svg", zj, [...Wj]);
}
const Zj = { name: "mdi-chevron-right", render: Vj }, Hj = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, qj = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M17.5 12a1.5 1.5 0 0 1-1.5-1.5A1.5 1.5 0 0 1 17.5 9a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m-3-4A1.5 1.5 0 0 1 13 6.5A1.5 1.5 0 0 1 14.5 5A1.5 1.5 0 0 1 16 6.5A1.5 1.5 0 0 1 14.5 8m-5 0A1.5 1.5 0 0 1 8 6.5A1.5 1.5 0 0 1 9.5 5A1.5 1.5 0 0 1 11 6.5A1.5 1.5 0 0 1 9.5 8m-3 4A1.5 1.5 0 0 1 5 10.5A1.5 1.5 0 0 1 6.5 9A1.5 1.5 0 0 1 8 10.5A1.5 1.5 0 0 1 6.5 12M12 3a9 9 0 0 0-9 9a9 9 0 0 0 9 9a1.5 1.5 0 0 0 1.5-1.5c0-.39-.15-.74-.39-1c-.23-.27-.38-.62-.38-1a1.5 1.5 0 0 1 1.5-1.5H16a5 5 0 0 0 5-5c0-4.42-4.03-8-9-8"
}, null, -1), Xj = [
  qj
];
function jj(t, e) {
  return P(), L("svg", Hj, [...Xj]);
}
const Yj = { name: "mdi-palette", render: jj }, Gj = { class: "grid grid-cols-9 gap-1.5 p-2 pt-1" }, Kj = ["title", "onClick"], Jj = { class: "p-1" }, eY = { class: "flex items-center rounded cursor-pointer hover:bg-gray-100 p-1 justify-between" }, tY = { class: "inline-flex items-center gap-2" }, nY = { class: "text-xs text-gray-600" }, B0 = /* @__PURE__ */ ke({
  __name: "ColorPickerDropdown",
  props: {
    modelValue: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = e;
    function i() {
      const o = [], a = Object.keys(
        vS
      ).reduce((l, c) => ([
        "gray",
        "red",
        "orange",
        "yellow",
        "green",
        "blue",
        "purple",
        "pink"
      ].includes(c) && (l[c] = vS[c]), l), {});
      for (const l in a) {
        const c = a[l], h = Object.entries(c).filter(([f]) => parseInt(f) >= 100 && parseInt(f) <= 900).sort((f, p) => parseInt(p[0]) - parseInt(f[0])).map(([f, p]) => ({
          color: p,
          name: `${l} ${f}`
        }));
        o.push(...h);
      }
      return o;
    }
    function r(o) {
      n("update:modelValue", o);
    }
    function s(o) {
      r(o.hex);
    }
    return (o, a) => (P(), Re(Z(Iu), { class: "inline-flex items-center" }, {
      popper: ze(() => [
        Wi(o.$slots, "prefix"),
        A("div", Gj, [
          (P(!0), L(Yt, null, Fr(i(), (l) => (P(), L("div", {
            key: l.color,
            style: sn({ backgroundColor: l.color }),
            class: "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
            title: l.name,
            onClick: (c) => r(l.color)
          }, null, 12, Kj))), 128))
        ]),
        fe(Z(Iu), { placement: "right" }, {
          popper: ze(() => [
            fe(Z(L0), {
              "model-value": "#000",
              "onUpdate:modelValue": s
            })
          ]),
          default: ze(() => [
            A("div", Jj, [
              A("div", eY, [
                A("div", tY, [
                  fe(Z(Yj)),
                  A("span", nY, Ft(Z(Q).global.t("editor.components.color_picker.more_color")), 1)
                ]),
                A("div", null, [
                  fe(Z(Zj))
                ])
              ])
            ])
          ]),
          _: 1
        })
      ]),
      default: ze(() => [
        Wi(o.$slots, "default")
      ]),
      _: 3
    }));
  }
}), iY = { class: "p-1" }, rY = /* @__PURE__ */ A("div", { class: "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300 bg-black" }, null, -1), sY = { class: "text-xs text-gray-600" }, oY = /* @__PURE__ */ ke({
  __name: "ColorToolbarItem",
  props: {
    editor: { default: void 0 },
    isActive: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    title: { default: void 0 },
    action: { type: Function, default: void 0 },
    icon: { default: void 0 }
  },
  setup(t) {
    const e = t;
    function n(r) {
      var s;
      r && ((s = e.editor) == null || s.chain().focus().setColor(r).run());
    }
    function i() {
      var r;
      (r = e.editor) == null || r.chain().focus().unsetColor().run();
    }
    return (r, s) => (P(), Re(B0, { "onUpdate:modelValue": n }, {
      prefix: ze(() => [
        A("div", iY, [
          A("div", {
            class: "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
            onClick: i
          }, [
            rY,
            A("span", sY, Ft(Z(Q).global.t("editor.common.button.restore_default")), 1)
          ])
        ])
      ]),
      default: ze(() => [
        fe(Z($t), By(Qy(e)), null, 16)
      ]),
      _: 1
    }));
  }
}), aY = CX.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 81,
          component: R(oY),
          props: {
            editor: e,
            isActive: !1,
            icon: R(YP),
            title: Q.global.t("editor.common.color")
          }
        };
      }
    };
  },
  addExtensions() {
    return [HP];
  }
}), lY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, cY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M2 4v3h5v12h3V7h5V4zm19 5h-9v3h3v7h3v-7h3z"
}, null, -1), uY = [
  cY
];
function dY(t, e) {
  return P(), L("svg", lY, [...uY]);
}
const hY = { name: "mdi-format-size", render: dY }, fY = mt.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"],
      getToolbarItems({ editor: t }) {
        return {
          priority: 31,
          component: R($t),
          props: {
            editor: t,
            isActive: !1,
            icon: R(hY)
          },
          children: [
            {
              priority: 0,
              component: R(Xn),
              props: {
                editor: t,
                isActive: !1,
                title: Q.global.t("editor.common.text.default"),
                action: () => t.chain().focus().unsetFontSize().run()
              }
            },
            ...[8, 10, 12, 14, 16, 18, 20, 24, 30, 36, 48, 60, 72].map(
              (e) => ({
                priority: e,
                component: R(Xn),
                props: {
                  editor: t,
                  isActive: !1,
                  title: `${e} px`,
                  action: () => t.chain().focus().setFontSize(e).run()
                }
              })
            )
          ]
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (t) => t.style.fontSize || "",
            renderHTML: (t) => t.fontSize ? {
              style: `font-size: ${t.fontSize.toString().replace("px", "")}px`
            } : t
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (t) => ({ chain: e }) => e().setMark("textStyle", { fontSize: t }).run(),
      unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
    };
  },
  addExtensions() {
    return [HP];
  }
});
function pY(t) {
  return encodeURIComponent(
    String(t).trim().toLowerCase().replace(/\s+/g, "-")
  );
}
const mY = (t, e) => {
  const n = pY(t);
  let i = n;
  for (; e.includes(i); ) {
    const s = i.replace(n, "").match(/-(\d+)$/);
    s ? i = `${n}-${Number(s[1]) + 1}` : i = `${n}-1`;
  }
  return i;
}, td = (t) => (e) => {
  if (t.depth)
    for (let i = t.depth; i > 0; i--)
      return e.delete(t.before(i), t.after(i)).scrollIntoView(), !0;
  else {
    const i = t.parent;
    if (!i.isTextblock && i.nodeSize)
      return e.setSelection(
        ge.create(t.doc, t.pos)
      ).deleteSelection(), !0;
  }
  const n = t.pos;
  return n ? (e.delete(n, n + t.node().nodeSize), !0) : !1;
}, vc = (t, e) => {
  const { state: n } = e, i = n.selection.$anchor, r = !1;
  if (i.depth) {
    for (let s = i.depth; s > 0; s--)
      if (i.node(s).type.name === t)
        return e.dispatchTransaction && e.dispatchTransaction(
          n.tr.delete(i.before(s), i.after(s)).scrollIntoView()
        ), !0;
  } else {
    const s = n.selection.node;
    if (s && s.type.name === t)
      return e.chain().deleteSelection().run(), !0;
  }
  {
    const s = i.pos;
    if (s) {
      const o = n.tr.doc.nodeAt(s);
      if (o && o.type.name === t)
        return e.dispatchTransaction && e.dispatchTransaction(n.tr.delete(s, s + o.nodeSize)), !0;
    }
  }
  return r;
}, n5 = (t) => gY(t) || bY(t), gY = (t) => {
  var i;
  const e = (i = t.type.createAndFill()) == null ? void 0 : i.toJSON(), n = t.toJSON();
  return JSON.stringify(e) === JSON.stringify(n);
}, bY = (t) => t.type.name !== "paragraph" ? !1 : t.textContent.length === 0, OY = wt.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), yY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, _Y = /* @__PURE__ */ A("path", {
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  d: "m3 8l3-3l3 3m-6 8l3 3l3-3M6 5v14m7-13h7m-7 6h7m-7 6h7"
}, null, -1), vY = [
  _Y
];
function xY(t, e) {
  return P(), L("svg", yY, [...vY]);
}
const wY = { name: "tabler-line-height", render: xY }, yl = OY.extend({
  addAttributes() {
    return {
      lineHeight: {
        default: null,
        parseHTML: (t) => t.style.lineHeight,
        renderHTML: (t) => {
          const e = t.lineHeight;
          return e ? {
            style: `line-height: ${e}`
          } : {};
        }
      }
    };
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            let n = e;
            for (; n && n.tagName !== "P"; )
              n = n.parentElement;
            return {
              el: n,
              dragDomOffset: {
                y: -1
              }
            };
          },
          allowPropagationDownward: !0
        };
      },
      getToolbarItems({ editor: e }) {
        var n;
        return {
          priority: 220,
          component: R($t),
          props: {
            editor: e,
            isActive: !!((n = e.getAttributes(yl.name)) != null && n.lineHeight),
            icon: R(wY),
            title: Q.global.t("editor.common.line_height")
          },
          children: [0, 1, 1.5, 2, 2.5, 3].map((i) => {
            var r;
            return {
              priority: i,
              component: R(Xn),
              props: {
                editor: e,
                isActive: ((r = e.getAttributes(yl.name)) == null ? void 0 : r.lineHeight) === i,
                title: i ? String(i) : Q.global.t("editor.common.text.default"),
                action: () => e.chain().focus().updateAttributes(yl.name, {
                  lineHeight: i
                }).run()
              }
            };
          })
        };
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Backspace: ({ editor: t }) => {
        const { state: e, view: n } = t, { selection: i } = e;
        if (!xi(e, yl.name) || !(i instanceof ce) || !i.empty)
          return !1;
        const { $from: r } = i;
        if (r.parentOffset !== 0)
          return !1;
        const s = r.before(r.depth);
        return n5(r.parent) ? SY(
          r,
          s,
          e,
          n.dispatch
        ) : s === 0 ? !1 : kY(r, s, e, n.dispatch);
      }
    };
  }
});
function SY(t, e, n, i) {
  const { tr: r } = n;
  return td(t)(r) && i ? (e !== 0 && r.setSelection(ce.create(r.doc, e - 1)), i(r), !0) : !1;
}
function kY(t, e, n, i) {
  const { tr: r } = n;
  if (!i)
    return !1;
  const o = t.doc.resolve(e).nodeBefore;
  return !o || !o.type.isBlock || o.type.isText || o.type.name === yl.name ? !1 : td(t.doc.resolve(e - 1))(r) ? (i(r), !0) : !1;
}
const EY = wt.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Ee(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => dO({
      find: new RegExp(`^(#{1,${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
}), CY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, AY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm11 14v-2h2V6.31l-2.5 1.44V5.44L16 4h2v12h2v2z"
}, null, -1), TY = [
  AY
];
function MY(t, e) {
  return P(), L("svg", CY, [...TY]);
}
const xS = { name: "mdi-format-header-1", render: MY }, PY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, RY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm18 14h-6a2 2 0 0 1-2-2c0-.53.2-1 .54-1.36l4.87-5.23c.37-.36.59-.86.59-1.41a2 2 0 0 0-2-2a2 2 0 0 0-2 2h-2a4 4 0 0 1 4-4a4 4 0 0 1 4 4c0 1.1-.45 2.1-1.17 2.83L15 16h6z"
}, null, -1), $Y = [
  RY
];
function NY(t, e) {
  return P(), L("svg", PY, [...$Y]);
}
const wS = { name: "mdi-format-header-2", render: NY }, DY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, IY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-1h2v1h4v-4h-4v-2h4V6h-4v1h-2V6a2 2 0 0 1 2-2"
}, null, -1), LY = [
  IY
];
function BY(t, e) {
  return P(), L("svg", DY, [...LY]);
}
const SS = { name: "mdi-format-header-3", render: BY }, QY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, FY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm15 14v-5h-5v-2l5-7h2v7h1v2h-1v5zm0-7V7.42L15.45 11z"
}, null, -1), zY = [
  FY
];
function UY(t, e) {
  return P(), L("svg", QY, [...zY]);
}
const kS = { name: "mdi-format-header-4", render: UY }, WY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, VY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h5v2h-5v4h2a4 4 0 0 1 4 4a4 4 0 0 1-4 4h-2a2 2 0 0 1-2-2v-1h2v1h2a2 2 0 0 0 2-2a2 2 0 0 0-2-2h-2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2"
}, null, -1), ZY = [
  VY
];
function HY(t, e) {
  return P(), L("svg", WY, [...ZY]);
}
const ES = { name: "mdi-format-header-5", render: HY }, qY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, XY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm12 0h4a2 2 0 0 1 2 2v1h-2V6h-4v4h4a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2m0 8v4h4v-4z"
}, null, -1), jY = [
  XY
];
function YY(t, e) {
  return P(), L("svg", qY, [...jY]);
}
const CS = { name: "mdi-format-header-6", render: YY }, GY = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, KY = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 4h2v6h4V4h2v14H9v-6H5v6H3zm10 4h2.31l.32-3h2l-.32 3h2l.32-3h2l-.32 3H23v2h-1.9l-.2 2H23v2h-2.31l-.32 3h-2l.32-3h-2l-.32 3h-2l.32-3H13v-2h1.9l.2-2H13zm4.1 2l-.2 2h2l.2-2z"
}, null, -1), JY = [
  KY
];
function eG(t, e) {
  return P(), L("svg", GY, [...JY]);
}
const tG = { name: "mdi-format-header-pound", render: eG }, nG = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, iG = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M13 4a4 4 0 0 1 4 4a4 4 0 0 1-4 4h-2v6H9V4zm0 6a2 2 0 0 0 2-2a2 2 0 0 0-2-2h-2v4z"
}, null, -1), rG = [
  iG
];
function sG(t, e) {
  return P(), L("svg", nG, [...rG]);
}
const AS = { name: "mdi-format-paragraph", render: sG }, OO = EY.extend({
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      `h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`,
      Ee(this.options.HTMLAttributes, e),
      0
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 30,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("paragraph") || e.isActive("heading"),
            icon: R(tG)
          },
          children: [
            {
              priority: 10,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive("paragraph"),
                icon: R(AS),
                title: Q.global.t("editor.common.heading.paragraph"),
                action: () => e.chain().focus().setParagraph().run()
              }
            },
            {
              priority: 20,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive("heading", { level: 1 }),
                icon: R(xS),
                title: Q.global.t("editor.common.heading.header1"),
                action: () => e.chain().focus().toggleHeading({ level: 1 }).run()
              }
            },
            {
              priority: 30,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive("heading", { level: 2 }),
                icon: R(wS),
                title: Q.global.t("editor.common.heading.header2"),
                action: () => e.chain().focus().toggleHeading({ level: 2 }).run()
              }
            },
            {
              priority: 40,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive("heading", { level: 3 }),
                icon: R(SS),
                title: Q.global.t("editor.common.heading.header3"),
                action: () => e.chain().focus().toggleHeading({ level: 3 }).run()
              }
            },
            {
              priority: 50,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive("heading", { level: 4 }),
                icon: R(kS),
                title: Q.global.t("editor.common.heading.header4"),
                action: () => e.chain().focus().toggleHeading({ level: 4 }).run()
              }
            },
            {
              priority: 60,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive("heading", { level: 5 }),
                icon: R(ES),
                title: Q.global.t("editor.common.heading.header5"),
                action: () => e.chain().focus().toggleHeading({ level: 5 }).run()
              }
            },
            {
              priority: 70,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive("heading", { level: 6 }),
                icon: R(CS),
                title: Q.global.t("editor.common.heading.header6"),
                action: () => e.chain().focus().toggleHeading({ level: 6 }).run()
              }
            }
          ]
        };
      },
      getCommandMenuItems() {
        return [
          {
            priority: 10,
            icon: R(AS),
            title: "editor.common.heading.paragraph",
            keywords: ["paragraph", "text", "putongwenben"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setParagraph().run();
            }
          },
          {
            priority: 20,
            icon: R(xS),
            title: "editor.common.heading.header1",
            keywords: ["h1", "header1", "1", "yijibiaoti"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setNode("heading", { level: 1 }).run();
            }
          },
          {
            priority: 30,
            icon: R(wS),
            title: "editor.common.heading.header2",
            keywords: ["h2", "header2", "2", "erjibiaoti"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setNode("heading", { level: 2 }).run();
            }
          },
          {
            priority: 40,
            icon: R(SS),
            title: "editor.common.heading.header3",
            keywords: ["h3", "header3", "3", "sanjibiaoti"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setNode("heading", { level: 3 }).run();
            }
          },
          {
            priority: 50,
            icon: R(kS),
            title: "editor.common.heading.header4",
            keywords: ["h4", "header4", "4", "sijibiaoti"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setNode("heading", { level: 4 }).run();
            }
          },
          {
            priority: 60,
            icon: R(ES),
            title: "editor.common.heading.header5",
            keywords: ["h5", "header5", "5", "wujibiaoti"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setNode("heading", { level: 5 }).run();
            }
          },
          {
            priority: 70,
            icon: R(CS),
            title: "editor.common.heading.header6",
            keywords: ["h6", "header6", "6", "liujibiaoti"],
            command: ({ editor: e, range: n }) => {
              e.chain().focus().deleteRange(n).setNode("heading", { level: 6 }).run();
            }
          }
        ];
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            const n = ["H1", "H2", "H3", "H4", "H5", "H6"];
            let i = e;
            for (; i && !n.includes(i.tagName); )
              i = i.parentElement;
            if (!i)
              return {
                el: e
              };
            let r;
            switch (i == null ? void 0 : i.tagName) {
              case "H1":
                r = 10;
                break;
              case "H2":
                r = 2;
                break;
              case "H3":
                r = 0;
                break;
              case "H4":
                r = -3;
                break;
              case "H5":
                r = -5;
                break;
              case "H6":
                r = -5;
                break;
              default:
                r = 0;
                break;
            }
            return {
              el: i,
              dragDomOffset: {
                y: r
              }
            };
          }
        };
      }
    };
  },
  addExtensions() {
    return [yl];
  },
  addProseMirrorPlugins() {
    let t;
    return [
      new Ue({
        key: new Ke("generate-heading-id"),
        appendTransaction: (e, n, i) => {
          if (e.some((s) => {
            const o = this.editor.view.composing;
            if (t !== void 0 && !o)
              return t = void 0, !0;
            if (s.docChanged) {
              if (s.getMeta("paste"))
                return !0;
              t = o;
              const a = s.selection, { $from: l } = a;
              return l.parent.type.name === OO.name && !o;
            }
            return !1;
          })) {
            const s = i.tr, o = [];
            return i.doc.descendants((a, l) => {
              if (a.type.name === OO.name) {
                const c = mY(a.textContent, o);
                s.step(new ga(l, "id", c)), o.push(c);
              }
            }), s;
          }
        }
      })
    ];
  }
}), oG = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, aG = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, lG = Tn.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      Aa({
        find: oG,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Eo({
        find: aG,
        type: this.type
      })
    ];
  }
}), cG = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, uG = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m4 17l2.75-2.75l-.03-.02c-.58-.59-.58-1.54 0-2.12l4.74-4.74l4.24 4.24l-4.74 4.74c-.57.58-1.5.58-2.09.02l-.63.63zM15.91 2.91c.59-.58 1.54-.58 2.12 0l2.13 2.12c.58.59.58 1.54 0 2.13l-3.3 3.29l-4.24-4.24z"
}, null, -1), dG = [
  uG
];
function hG(t, e) {
  return P(), L("svg", cG, [...dG]);
}
const i5 = { name: "mdi-format-color-highlight", render: hG }, fG = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, pG = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M16.5 8C14 8 12 10 12 12.5s2 4.5 4.5 4.5s4.5-2 4.5-4.5S19 8 16.5 8m0 7.5c-1.7 0-3-1.3-3-3c0-.6.2-1.1.4-1.5l4.1 4.1c-.4.2-.9.4-1.5.4m2.6-1.5L15 9.9c.4-.3.9-.4 1.5-.4c1.7 0 3 1.3 3 3c0 .6-.2 1.1-.4 1.5m-7-6.3l-1.5-1.5l3.3-3.3c.6-.6 1.5-.6 2.1 0L18.2 5c.4.4.5.8.4 1.3c-.6-.2-1.3-.3-2-.3c-1.8 0-3.3.7-4.5 1.7m-1.6 7.2L9 16.3c-.6.6-1.5.6-2.1 0l-.7.7H2l2.8-2.8c-.6-.6-.6-1.5 0-2.1l4.7-4.7L11.1 9c-.7 1-1.1 2.2-1.1 3.5c0 .8.2 1.6.5 2.4"
}, null, -1), mG = [
  pG
];
function gG(t, e) {
  return P(), L("svg", fG, [...mG]);
}
const r5 = { name: "mdi-format-color-marker-cancel", render: gG }, bG = { class: "p-1" }, OG = { class: "inline-flex items-center gap-2" }, yG = { class: "text-xs text-gray-600" }, _G = { class: "p-1" }, vG = /* @__PURE__ */ A("div", {
  class: "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
  style: { "background-color": "#fff8c5" }
}, null, -1), xG = { class: "text-xs text-gray-600" }, wG = /* @__PURE__ */ ke({
  __name: "HighlightToolbarItem",
  props: {
    editor: { default: void 0 },
    isActive: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    title: { default: void 0 },
    action: { type: Function, default: void 0 },
    icon: { default: void 0 }
  },
  setup(t) {
    const e = t;
    function n(r) {
      var s;
      (s = e.editor) == null || s.chain().focus().setHighlight(r ? { color: r } : void 0).run();
    }
    function i() {
      var r;
      (r = e.editor) == null || r.chain().focus().unsetHighlight().run();
    }
    return (r, s) => (P(), Re(B0, { "onUpdate:modelValue": n }, {
      prefix: ze(() => [
        A("div", bG, [
          A("div", {
            class: "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
            onClick: i
          }, [
            A("div", OG, [
              fe(Z(r5)),
              A("span", yG, Ft(Z(Q).global.t("editor.extensions.highlight.unset")), 1)
            ])
          ])
        ]),
        A("div", _G, [
          A("div", {
            class: "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
            onClick: s[1] || (s[1] = (o) => n())
          }, [
            vG,
            A("span", xG, Ft(Z(Q).global.t("editor.common.button.restore_default")), 1)
          ])
        ])
      ]),
      default: ze(() => [
        fe(Z($t), sr(e, {
          onClick: s[0] || (s[0] = (o) => n())
        }), null, 16)
      ]),
      _: 1
    }));
  }
}), SG = lG.extend({
  addAttributes() {
    var t;
    return this.options.multicolor ? {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      style: {
        default: "display: inline-block;",
        parseHTML: (e) => e.getAttribute("style")
      }
    } : {};
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 80,
          component: R(wG),
          props: {
            editor: e,
            isActive: e.isActive("highlight"),
            icon: R(i5),
            title: Q.global.t("editor.common.highlight")
          }
        };
      }
    };
  }
}).configure({ multicolor: !0 }), kG = mt.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => Rp(t, e),
      redo: () => ({ state: t, dispatch: e }) => $p(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      uQ(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), EG = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, CG = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M10.5 7A6.5 6.5 0 0 0 4 13.5a6.5 6.5 0 0 0 6.5 6.5H14v-2h-3.5C8 18 6 16 6 13.5S8 9 10.5 9h5.67l-3.08 3.09l1.41 1.41L20 8l-5.5-5.5l-1.42 1.41L16.17 7zM18 18h-2v2h2z"
}, null, -1), AG = [
  CG
];
function TG(t, e) {
  return P(), L("svg", EG, [...AG]);
}
const MG = { name: "mdi-redo-variant", render: TG }, PG = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, RG = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M13.5 7a6.5 6.5 0 0 1 6.5 6.5a6.5 6.5 0 0 1-6.5 6.5H10v-2h3.5c2.5 0 4.5-2 4.5-4.5S16 9 13.5 9H7.83l3.08 3.09L9.5 13.5L4 8l5.5-5.5l1.42 1.41L7.83 7zM6 18h2v2H6z"
}, null, -1), $G = [
  RG
];
function NG(t, e) {
  return P(), L("svg", PG, [...$G]);
}
const DG = { name: "mdi-undo-variant", render: NG }, IG = kG.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return [
          {
            priority: 10,
            component: R($t),
            props: {
              editor: e,
              isActive: !1,
              icon: R(DG),
              title: Q.global.t("editor.menus.undo"),
              action: () => e.chain().undo().focus().run()
            }
          },
          {
            priority: 20,
            component: R($t),
            props: {
              editor: e,
              isActive: !1,
              icon: R(MG),
              title: Q.global.t("editor.menus.redo"),
              action: () => e.chain().redo().focus().run()
            }
          }
        ];
      }
    };
  }
}), LG = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, BG = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, QG = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, FG = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, zG = Tn.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Aa({
        find: LG,
        type: this.type
      }),
      Aa({
        find: QG,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Eo({
        find: BG,
        type: this.type
      }),
      Eo({
        find: FG,
        type: this.type
      })
    ];
  }
}), UG = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, WG = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"
}, null, -1), VG = [
  WG
];
function ZG(t, e) {
  return P(), L("svg", UG, [...VG]);
}
const s5 = { name: "mdi-format-italic", render: ZG }, HG = zG.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 50,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("italic"),
            icon: R(s5),
            title: Q.global.t("editor.common.italic"),
            action: () => e.chain().focus().toggleItalic().run()
          }
        };
      }
    };
  }
}), qG = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", XG = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", Gl = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, yO = "numeric", _O = "ascii", vO = "alpha", Yf = "asciinumeric", Wh = "alphanumeric", xO = "domain", o5 = "emoji", jG = "scheme", YG = "slashscheme", TS = "whitespace";
function GG(t, e) {
  return t in e || (e[t] = []), e[t];
}
function oa(t, e, n) {
  e[yO] && (e[Yf] = !0, e[Wh] = !0), e[_O] && (e[Yf] = !0, e[vO] = !0), e[Yf] && (e[Wh] = !0), e[vO] && (e[Wh] = !0), e[Wh] && (e[xO] = !0), e[o5] && (e[xO] = !0);
  for (const i in e) {
    const r = GG(i, n);
    r.indexOf(t) < 0 && r.push(t);
  }
}
function KG(t, e) {
  const n = {};
  for (const i in e)
    e[i].indexOf(t) >= 0 && (n[i] = !0);
  return n;
}
function jn(t) {
  t === void 0 && (t = null), this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
jn.groups = {};
jn.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let i = 0; i < e.jr.length; i++) {
      const r = e.jr[i][0], s = e.jr[i][1];
      if (s && r.test(t))
        return s;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e) {
    return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, i) {
    for (let r = 0; r < t.length; r++)
      this.tt(t[r], e, n, i);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, i) {
    i = i || jn.groups;
    let r;
    return e && e.j ? r = e : (r = new jn(e), n && i && oa(e, n, i)), this.jr.push([t, r]), r;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, i) {
    let r = this;
    const s = t.length;
    if (!s)
      return r;
    for (let o = 0; o < s - 1; o++)
      r = r.tt(t[o]);
    return r.tt(t[s - 1], e, n, i);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, i) {
    i = i || jn.groups;
    const r = this;
    if (e && e.j)
      return r.j[t] = e, e;
    const s = e;
    let o, a = r.go(t);
    if (a ? (o = new jn(), Gl(o.j, a.j), o.jr.push.apply(o.jr, a.jr), o.jd = a.jd, o.t = a.t) : o = new jn(), s) {
      if (i)
        if (o.t && typeof o.t == "string") {
          const l = Gl(KG(o.t, i), n);
          oa(s, l, i);
        } else n && oa(s, n, i);
      o.t = s;
    }
    return r.j[t] = o, o;
  }
};
const Le = (t, e, n, i, r) => t.ta(e, n, i, r), Ei = (t, e, n, i, r) => t.tr(e, n, i, r), MS = (t, e, n, i, r) => t.ts(e, n, i, r), te = (t, e, n, i, r) => t.tt(e, n, i, r), hs = "WORD", wO = "UWORD", nd = "LOCALHOST", SO = "TLD", kO = "UTLD", Gf = "SCHEME", hl = "SLASH_SCHEME", U2 = "NUM", a5 = "WS", W2 = "NL", yu = "OPENBRACE", _u = "CLOSEBRACE", Up = "OPENBRACKET", Wp = "CLOSEBRACKET", Vp = "OPENPAREN", Zp = "CLOSEPAREN", Hp = "OPENANGLEBRACKET", qp = "CLOSEANGLEBRACKET", Xp = "FULLWIDTHLEFTPAREN", jp = "FULLWIDTHRIGHTPAREN", Yp = "LEFTCORNERBRACKET", Gp = "RIGHTCORNERBRACKET", Kp = "LEFTWHITECORNERBRACKET", Jp = "RIGHTWHITECORNERBRACKET", em = "FULLWIDTHLESSTHAN", tm = "FULLWIDTHGREATERTHAN", nm = "AMPERSAND", im = "APOSTROPHE", rm = "ASTERISK", Hs = "AT", sm = "BACKSLASH", om = "BACKTICK", am = "CARET", Ks = "COLON", V2 = "COMMA", lm = "DOLLAR", kr = "DOT", cm = "EQUALS", Z2 = "EXCLAMATION", Er = "HYPHEN", um = "PERCENT", dm = "PIPE", hm = "PLUS", fm = "POUND", pm = "QUERY", H2 = "QUOTE", q2 = "SEMI", Cr = "SLASH", vu = "TILDE", mm = "UNDERSCORE", l5 = "EMOJI", gm = "SYM";
var c5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: hs,
  UWORD: wO,
  LOCALHOST: nd,
  TLD: SO,
  UTLD: kO,
  SCHEME: Gf,
  SLASH_SCHEME: hl,
  NUM: U2,
  WS: a5,
  NL: W2,
  OPENBRACE: yu,
  CLOSEBRACE: _u,
  OPENBRACKET: Up,
  CLOSEBRACKET: Wp,
  OPENPAREN: Vp,
  CLOSEPAREN: Zp,
  OPENANGLEBRACKET: Hp,
  CLOSEANGLEBRACKET: qp,
  FULLWIDTHLEFTPAREN: Xp,
  FULLWIDTHRIGHTPAREN: jp,
  LEFTCORNERBRACKET: Yp,
  RIGHTCORNERBRACKET: Gp,
  LEFTWHITECORNERBRACKET: Kp,
  RIGHTWHITECORNERBRACKET: Jp,
  FULLWIDTHLESSTHAN: em,
  FULLWIDTHGREATERTHAN: tm,
  AMPERSAND: nm,
  APOSTROPHE: im,
  ASTERISK: rm,
  AT: Hs,
  BACKSLASH: sm,
  BACKTICK: om,
  CARET: am,
  COLON: Ks,
  COMMA: V2,
  DOLLAR: lm,
  DOT: kr,
  EQUALS: cm,
  EXCLAMATION: Z2,
  HYPHEN: Er,
  PERCENT: um,
  PIPE: dm,
  PLUS: hm,
  POUND: fm,
  QUERY: pm,
  QUOTE: H2,
  SEMI: q2,
  SLASH: Cr,
  TILDE: vu,
  UNDERSCORE: mm,
  EMOJI: l5,
  SYM: gm
});
const nl = /[a-z]/, r1 = new RegExp("\\p{L}", "u"), s1 = new RegExp("\\p{Emoji}", "u"), o1 = /\d/, PS = /\s/, RS = `
`, JG = "", eK = "";
let Vh = null, Zh = null;
function tK(t) {
  t === void 0 && (t = []);
  const e = {};
  jn.groups = e;
  const n = new jn();
  Vh == null && (Vh = $S(qG)), Zh == null && (Zh = $S(XG)), te(n, "'", im), te(n, "{", yu), te(n, "}", _u), te(n, "[", Up), te(n, "]", Wp), te(n, "(", Vp), te(n, ")", Zp), te(n, "<", Hp), te(n, ">", qp), te(n, "", Xp), te(n, "", jp), te(n, "", Yp), te(n, "", Gp), te(n, "", Kp), te(n, "", Jp), te(n, "", em), te(n, "", tm), te(n, "&", nm), te(n, "*", rm), te(n, "@", Hs), te(n, "`", om), te(n, "^", am), te(n, ":", Ks), te(n, ",", V2), te(n, "$", lm), te(n, ".", kr), te(n, "=", cm), te(n, "!", Z2), te(n, "-", Er), te(n, "%", um), te(n, "|", dm), te(n, "+", hm), te(n, "#", fm), te(n, "?", pm), te(n, '"', H2), te(n, "/", Cr), te(n, ";", q2), te(n, "~", vu), te(n, "_", mm), te(n, "\\", sm);
  const i = Ei(n, o1, U2, {
    [yO]: !0
  });
  Ei(i, o1, i);
  const r = Ei(n, nl, hs, {
    [_O]: !0
  });
  Ei(r, nl, r);
  const s = Ei(n, r1, wO, {
    [vO]: !0
  });
  Ei(s, nl), Ei(s, r1, s);
  const o = Ei(n, PS, a5, {
    [TS]: !0
  });
  te(n, RS, W2, {
    [TS]: !0
  }), te(o, RS), Ei(o, PS, o);
  const a = Ei(n, s1, l5, {
    [o5]: !0
  });
  Ei(a, s1, a), te(a, JG, a);
  const l = te(a, eK);
  Ei(l, s1, a);
  const c = [[nl, r]], u = [[nl, null], [r1, s]];
  for (let d = 0; d < Vh.length; d++)
    Is(n, Vh[d], SO, hs, c);
  for (let d = 0; d < Zh.length; d++)
    Is(n, Zh[d], kO, wO, u);
  oa(SO, {
    tld: !0,
    ascii: !0
  }, e), oa(kO, {
    utld: !0,
    alpha: !0
  }, e), Is(n, "file", Gf, hs, c), Is(n, "mailto", Gf, hs, c), Is(n, "http", hl, hs, c), Is(n, "https", hl, hs, c), Is(n, "ftp", hl, hs, c), Is(n, "ftps", hl, hs, c), oa(Gf, {
    scheme: !0,
    ascii: !0
  }, e), oa(hl, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((d, h) => d[0] > h[0] ? 1 : -1);
  for (let d = 0; d < t.length; d++) {
    const h = t[d][0], p = t[d][1] ? {
      [jG]: !0
    } : {
      [YG]: !0
    };
    h.indexOf("-") >= 0 ? p[xO] = !0 : nl.test(h) ? o1.test(h) ? p[Yf] = !0 : p[_O] = !0 : p[yO] = !0, MS(n, h, h, p);
  }
  return MS(n, "localhost", nd, {
    ascii: !0
  }), n.jd = new jn(gm), {
    start: n,
    tokens: Gl({
      groups: e
    }, c5)
  };
}
function nK(t, e) {
  const n = iK(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), i = n.length, r = [];
  let s = 0, o = 0;
  for (; o < i; ) {
    let a = t, l = null, c = 0, u = null, d = -1, h = -1;
    for (; o < i && (l = a.go(n[o])); )
      a = l, a.accepts() ? (d = 0, h = 0, u = a) : d >= 0 && (d += n[o].length, h++), c += n[o].length, s += n[o].length, o++;
    s -= d, o -= h, c -= d, r.push({
      t: u.t,
      // token type/name
      v: e.slice(s - c, s),
      // string value
      s: s - c,
      // start index
      e: s
      // end index (excluding)
    });
  }
  return r;
}
function iK(t) {
  const e = [], n = t.length;
  let i = 0;
  for (; i < n; ) {
    let r = t.charCodeAt(i), s, o = r < 55296 || r > 56319 || i + 1 === n || (s = t.charCodeAt(i + 1)) < 56320 || s > 57343 ? t[i] : t.slice(i, i + 2);
    e.push(o), i += o.length;
  }
  return e;
}
function Is(t, e, n, i, r) {
  let s;
  const o = e.length;
  for (let a = 0; a < o - 1; a++) {
    const l = e[a];
    t.j[l] ? s = t.j[l] : (s = new jn(i), s.jr = r.slice(), t.j[l] = s), t = s;
  }
  return s = new jn(n), s.jr = r.slice(), t.j[e[o - 1]] = s, s;
}
function $S(t) {
  const e = [], n = [];
  let i = 0, r = "0123456789";
  for (; i < t.length; ) {
    let s = 0;
    for (; r.indexOf(t[i + s]) >= 0; )
      s++;
    if (s > 0) {
      e.push(n.join(""));
      for (let o = parseInt(t.substring(i, i + s), 10); o > 0; o--)
        n.pop();
      i += s;
    } else
      n.push(t[i]), i++;
  }
  return e;
}
const id = {
  defaultProtocol: "http",
  events: null,
  format: NS,
  formatHref: NS,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function X2(t, e) {
  e === void 0 && (e = null);
  let n = Gl({}, id);
  t && (n = Gl(n, t instanceof X2 ? t.o : t));
  const i = n.ignoreTags, r = [];
  for (let s = 0; s < i.length; s++)
    r.push(i[s].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = r;
}
X2.prototype = {
  o: id,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const i = e != null;
    let r = this.o[t];
    return r && (typeof r == "object" ? (r = n.t in r ? r[n.t] : id[t], typeof r == "function" && i && (r = r(e, n))) : typeof r == "function" && i && (r = r(e, n.t, n)), r);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let i = this.o[t];
    return typeof i == "function" && e != null && (i = i(e, n.t, n)), i;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function NS(t) {
  return t;
}
function u5(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
u5.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), i = t.get("format", e, this);
    return n && i.length > n ? i.substring(0, n) + "" : i;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t) {
    return t === void 0 && (t = id.defaultProtocol), {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), i = t.get("formatHref", n, this), r = t.get("tagName", n, e), s = this.toFormattedString(t), o = {}, a = t.get("className", n, e), l = t.get("target", n, e), c = t.get("rel", n, e), u = t.getObj("attributes", n, e), d = t.getObj("events", n, e);
    return o.href = i, a && (o.class = a), l && (o.target = l), c && (o.rel = c), u && Gl(o, u), {
      tagName: r,
      attributes: o,
      content: s,
      eventListeners: d
    };
  }
};
function Q0(t, e) {
  class n extends u5 {
    constructor(r, s) {
      super(r, s), this.t = t;
    }
  }
  for (const i in e)
    n.prototype[i] = e[i];
  return n.t = t, n;
}
const DS = Q0("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), IS = Q0("text"), rK = Q0("nl"), Hh = Q0("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t) {
    return t === void 0 && (t = id.defaultProtocol), this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== nd && t[1].t === Ks;
  }
}), Ci = (t) => new jn(t);
function sK(t) {
  let {
    groups: e
  } = t;
  const n = e.domain.concat([nm, rm, Hs, sm, om, am, lm, cm, Er, U2, um, dm, hm, fm, Cr, gm, vu, mm]), i = [im, Ks, V2, kr, Z2, pm, H2, q2, Hp, qp, yu, _u, Wp, Up, Vp, Zp, Xp, jp, Yp, Gp, Kp, Jp, em, tm], r = [nm, im, rm, sm, om, am, lm, cm, Er, yu, _u, um, dm, hm, fm, pm, Cr, gm, vu, mm], s = Ci(), o = te(s, vu);
  Le(o, r, o), Le(o, e.domain, o);
  const a = Ci(), l = Ci(), c = Ci();
  Le(s, e.domain, a), Le(s, e.scheme, l), Le(s, e.slashscheme, c), Le(a, r, o), Le(a, e.domain, a);
  const u = te(a, Hs);
  te(o, Hs, u), te(l, Hs, u), te(c, Hs, u);
  const d = te(o, kr);
  Le(d, r, o), Le(d, e.domain, o);
  const h = Ci();
  Le(u, e.domain, h), Le(h, e.domain, h);
  const f = te(h, kr);
  Le(f, e.domain, h);
  const p = Ci(DS);
  Le(f, e.tld, p), Le(f, e.utld, p), te(u, nd, p);
  const m = te(h, Er);
  Le(m, e.domain, h), Le(p, e.domain, h), te(p, kr, f), te(p, Er, m);
  const g = te(p, Ks);
  Le(g, e.numeric, DS);
  const b = te(a, Er), _ = te(a, kr);
  Le(b, e.domain, a), Le(_, r, o), Le(_, e.domain, a);
  const y = Ci(Hh);
  Le(_, e.tld, y), Le(_, e.utld, y), Le(y, e.domain, a), Le(y, r, o), te(y, kr, _), te(y, Er, b), te(y, Hs, u);
  const O = te(y, Ks), x = Ci(Hh);
  Le(O, e.numeric, x);
  const v = Ci(Hh), w = Ci();
  Le(v, n, v), Le(v, i, w), Le(w, n, v), Le(w, i, w), te(y, Cr, v), te(x, Cr, v);
  const T = te(l, Ks), S = te(c, Ks), $ = te(S, Cr), I = te($, Cr);
  Le(l, e.domain, a), te(l, kr, _), te(l, Er, b), Le(c, e.domain, a), te(c, kr, _), te(c, Er, b), Le(T, e.domain, v), te(T, Cr, v), Le(I, e.domain, v), Le(I, n, v), te(I, Cr, v);
  const F = [
    [yu, _u],
    // {}
    [Up, Wp],
    // []
    [Vp, Zp],
    // ()
    [Hp, qp],
    // <>
    [Xp, jp],
    // 
    [Yp, Gp],
    // 
    [Kp, Jp],
    // 
    [em, tm]
    // 
  ];
  for (let V = 0; V < F.length; V++) {
    const [q, K] = F[V], ie = te(v, q);
    te(w, q, ie), te(ie, K, v);
    const k = Ci(Hh);
    Le(ie, n, k);
    const N = Ci();
    Le(ie, i), Le(k, n, k), Le(k, i, N), Le(N, n, k), Le(N, i, N), te(k, K, v), te(N, K, v);
  }
  return te(s, nd, y), te(s, W2, rK), {
    start: s,
    tokens: c5
  };
}
function oK(t, e, n) {
  let i = n.length, r = 0, s = [], o = [];
  for (; r < i; ) {
    let a = t, l = null, c = null, u = 0, d = null, h = -1;
    for (; r < i && !(l = a.go(n[r].t)); )
      o.push(n[r++]);
    for (; r < i && (c = l || a.go(n[r].t)); )
      l = null, a = c, a.accepts() ? (h = 0, d = a) : h >= 0 && h++, r++, u++;
    if (h < 0)
      r -= u, r < i && (o.push(n[r]), r++);
    else {
      o.length > 0 && (s.push(a1(IS, e, o)), o = []), r -= h, u -= h;
      const f = d.t, p = n.slice(r - u, r);
      s.push(a1(f, e, p));
    }
  }
  return o.length > 0 && s.push(a1(IS, e, o)), s;
}
function a1(t, e, n) {
  const i = n[0].s, r = n[n.length - 1].e, s = e.slice(i, r);
  return new t(s, n);
}
const aK = typeof console < "u" && console && console.warn || (() => {
}), lK = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Pt = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function cK() {
  jn.groups = {}, Pt.scanner = null, Pt.parser = null, Pt.tokenQueue = [], Pt.pluginQueue = [], Pt.customSchemes = [], Pt.initialized = !1;
}
function LS(t, e) {
  if (e === void 0 && (e = !1), Pt.initialized && aK(`linkifyjs: already initialized - will not register custom scheme "${t}" ${lK}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Pt.customSchemes.push([t, e]);
}
function uK() {
  Pt.scanner = tK(Pt.customSchemes);
  for (let t = 0; t < Pt.tokenQueue.length; t++)
    Pt.tokenQueue[t][1]({
      scanner: Pt.scanner
    });
  Pt.parser = sK(Pt.scanner.tokens);
  for (let t = 0; t < Pt.pluginQueue.length; t++)
    Pt.pluginQueue[t][1]({
      scanner: Pt.scanner,
      parser: Pt.parser
    });
  Pt.initialized = !0;
}
function j2(t) {
  return Pt.initialized || uK(), oK(Pt.parser.start, t, nK(Pt.scanner.start, t));
}
function d5(t, e, n) {
  if (e === void 0 && (e = null), n === void 0 && (n = null), e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const i = new X2(n), r = j2(t), s = [];
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    a.isLink && (!e || a.t === e) && i.check(a) && s.push(a.toFormattedObject(i));
  }
  return s;
}
function dK(t, e) {
  const n = j2(t);
  return n.length === 1 && n[0].isLink && n[0].t === e;
}
function hK(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function fK(t) {
  return new Ue({
    key: new Ke("autolink"),
    appendTransaction: (e, n, i) => {
      const r = e.some((c) => c.docChanged) && !n.doc.eq(i.doc), s = e.some((c) => c.getMeta("preventAutolink"));
      if (!r || s)
        return;
      const { tr: o } = i, a = VV(n.doc, [...e]);
      if (YV(a).forEach(({ newRange: c }) => {
        const u = HV(i.doc, c, (f) => f.isTextblock);
        let d, h;
        if (u.length > 1 ? (d = u[0], h = i.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && i.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (d = u[0], h = i.doc.textBetween(d.pos, c.to, void 0, " ")), d && h) {
          const f = h.split(" ").filter((b) => b !== "");
          if (f.length <= 0)
            return !1;
          const p = f[f.length - 1], m = d.pos + h.lastIndexOf(p);
          if (!p)
            return !1;
          const g = j2(p).map((b) => b.toObject(t.defaultProtocol));
          if (!hK(g))
            return !1;
          g.filter((b) => b.isLink).map((b) => ({
            ...b,
            from: m + b.start + 1,
            to: m + b.end + 1
          })).filter((b) => i.schema.marks.code ? !i.doc.rangeHasMark(b.from, b.to, i.schema.marks.code) : !0).filter((b) => t.validate(b.value)).forEach((b) => {
            M2(b.from, b.to, i.doc).some((_) => _.mark.type === t.type) || o.addMark(b.from, b.to, t.type.create({
              href: b.href
            }));
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function pK(t) {
  return new Ue({
    key: new Ke("handleClickLink"),
    props: {
      handleClick: (e, n, i) => {
        var r, s;
        if (i.button !== 0 || !e.editable)
          return !1;
        let o = i.target;
        const a = [];
        for (; o.nodeName !== "DIV"; )
          a.push(o), o = o.parentNode;
        if (!a.find((h) => h.nodeName === "A"))
          return !1;
        const l = OP(e.state, t.type.name), c = i.target, u = (r = c == null ? void 0 : c.href) !== null && r !== void 0 ? r : l.href, d = (s = c == null ? void 0 : c.target) !== null && s !== void 0 ? s : l.target;
        return c && u ? (window.open(u, d), !0) : !1;
      }
    }
  });
}
function mK(t) {
  return new Ue({
    key: new Ke("handlePasteLink"),
    props: {
      handlePaste: (e, n, i) => {
        const { state: r } = e, { selection: s } = r, { empty: o } = s;
        if (o)
          return !1;
        let a = "";
        i.content.forEach((c) => {
          a += c.textContent;
        });
        const l = d5(a, { defaultProtocol: t.defaultProtocol }).find((c) => c.isLink && c.value === a);
        return !a || !l ? !1 : (t.editor.commands.setMark(t.type, {
          href: l.href
        }), !0);
      }
    }
  });
}
const gK = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g, bK = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
function BS(t) {
  return !t || t.replace(gK, "").match(bK);
}
const OK = Tn.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        LS(t);
        return;
      }
      LS(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    cK();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [{
      tag: "a[href]",
      getAttrs: (t) => {
        const e = t.getAttribute("href");
        return !e || !BS(e) ? !1 : { href: e };
      }
    }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return BS(t.href) ? ["a", Ee(this.options.HTMLAttributes, t), 0] : ["a", Ee(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => e().setMark(this.name, t).setMeta("preventAutolink", !0).run(),
      toggleLink: (t) => ({ chain: e }) => e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Eo({
        find: (t) => {
          const e = [];
          if (t) {
            const { validate: n } = this.options, i = d5(t).filter((r) => r.isLink && n(r.value));
            i.length && i.forEach((r) => e.push({
              text: r.value,
              data: {
                href: r.href
              },
              index: r.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [];
    return this.options.autolink && t.push(fK({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: this.options.validate
    })), this.options.openOnClick === !0 && t.push(pK({
      type: this.type
    })), this.options.linkOnPaste && t.push(mK({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
}), EO = OK.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        rel: null
      }
    };
  },
  addPasteRules() {
    return [];
  },
  renderHTML({ HTMLAttributes: t }) {
    const e = t.href;
    return e != null && e.toString().startsWith("javascript:") ? [
      "a",
      Ee(this.options.HTMLAttributes, {
        ...t,
        href: ""
      }),
      0
    ] : [
      "a",
      Ee(this.options.HTMLAttributes, t),
      0
    ];
  }
}), Jd = (t, e) => {
  const { $from: n } = e.selection, i = Zt(t, e.schema);
  let r = null, s = n.depth, o = n.pos, a = null;
  for (; s > 0 && a === null; )
    r = n.node(s), r.type === i ? a = s : (s -= 1, o -= 1);
  return a === null ? null : { $pos: e.doc.resolve(o), depth: a };
}, Y2 = (t, e) => {
  const n = Jd(t, e);
  if (!n)
    return !1;
  const [, i] = KV(e, t, n.$pos.pos + 4);
  return i;
}, h5 = (t, e, n) => {
  const { $anchor: i } = t.selection, r = Math.max(0, i.pos - 2), s = t.doc.resolve(r).node();
  return !(!s || !n.includes(s.type.name));
}, f5 = (t, e) => {
  var n;
  const { $anchor: i } = e.selection, r = e.doc.resolve(i.pos - 2);
  return !(r.index() === 0 || ((n = r.nodeBefore) === null || n === void 0 ? void 0 : n.type.name) !== t);
}, p5 = (t, e, n) => {
  if (!n)
    return !1;
  const i = Zt(t, e.schema);
  let r = !1;
  return n.descendants((s) => {
    s.type === i && (r = !0);
  }), r;
}, CO = (t, e, n) => {
  if (t.commands.undoInputRule())
    return !0;
  if (!Fi(t.state, e) && h5(t.state, e, n)) {
    const { $anchor: a } = t.state.selection, l = t.state.doc.resolve(a.before() - 1), c = [];
    l.node().descendants((h, f) => {
      h.type.name === e && c.push({ node: h, pos: f });
    });
    const u = c.at(-1);
    if (!u)
      return !1;
    const d = t.state.doc.resolve(l.start() + u.pos + 1);
    return t.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, d.end()).joinForward().run();
  }
  if (!Fi(t.state, e) || !eZ(t.state))
    return !1;
  const i = Jd(e, t.state);
  if (!i)
    return !1;
  const s = t.state.doc.resolve(i.$pos.pos - 2).node(i.depth), o = p5(e, t.state, s);
  return f5(e, t.state) && !o ? t.commands.joinItemBackward() : t.chain().liftListItem(e).run();
}, m5 = (t, e) => {
  const n = Y2(t, e), i = Jd(t, e);
  return !i || !n ? !1 : n > i.depth;
}, g5 = (t, e) => {
  const n = Y2(t, e), i = Jd(t, e);
  return !i || !n ? !1 : n < i.depth;
}, AO = (t, e) => !Fi(t.state, e) || !JV(t.state, e) ? !1 : m5(e, t.state) ? t.chain().focus(t.state.selection.from + 4).lift(e).joinBackward().run() : g5(e, t.state) ? t.chain().joinForward().joinBackward().run() : t.commands.joinItemForward(), yK = (t, e) => {
  var n;
  const { $anchor: i } = e.selection, r = e.doc.resolve(i.pos - i.parentOffset - 2);
  return !(r.index() === r.parent.childCount - 1 || ((n = r.nodeAfter) === null || n === void 0 ? void 0 : n.type.name) !== t);
};
var _K = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  findListItemPos: Jd,
  getNextListDepth: Y2,
  handleBackspace: CO,
  handleDelete: AO,
  hasListBefore: h5,
  hasListItemAfter: yK,
  hasListItemBefore: f5,
  listItemHasSubList: p5,
  nextListIsDeeper: m5,
  nextListIsHigher: g5
});
const vK = mt.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          t.state.schema.nodes[n] !== void 0 && AO(t, n) && (e = !0);
        }), e;
      },
      "Mod-Delete": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          t.state.schema.nodes[n] !== void 0 && AO(t, n) && (e = !0);
        }), e;
      },
      Backspace: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: i }) => {
          t.state.schema.nodes[n] !== void 0 && CO(t, n, i) && (e = !0);
        }), e;
      },
      "Mod-Backspace": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: i }) => {
          t.state.schema.nodes[n] !== void 0 && CO(t, n, i) && (e = !0);
        }), e;
      }
    };
  }
}), axe = vK.extend({
  addKeyboardShortcuts() {
    const t = (e) => {
      let n = !1;
      return e.state.selection.empty ? (this.options.listTypes.forEach(
        ({
          itemName: i,
          wrapperNames: r
        }) => {
          _K.handleBackspace(e, i, r) && (n = !0);
        }
      ), n) : !1;
    };
    return {
      Backspace: ({ editor: e }) => t(e),
      "Mod-Backspace": ({ editor: e }) => t(e)
    };
  }
}), xK = wt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Ee(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), QS = Tn.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = Xd(t, this.type);
        return Object.entries(n).some(([, r]) => !!r) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), FS = /^(\d+)\.\s$/, wK = wt.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", Ee(this.options.HTMLAttributes, n), 0] : ["ol", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(xK.name, this.editor.getAttributes(QS.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = Hl({
      find: FS,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Hl({
      find: FS,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(QS.name) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), SK = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, kK = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M7 13v-2h14v2zm0 6v-2h14v2zM7 7V5h14v2zM3 8V5H2V4h2v4zm-1 9v-1h3v4H2v-1h2v-.5H3v-1h1V17zm2.25-7a.75.75 0 0 1 .75.75c0 .2-.08.39-.21.52L3.12 13H5v1H2v-.92L4 11H2v-1z"
}, null, -1), EK = [
  kK
];
function CK(t, e) {
  return P(), L("svg", SK, [...EK]);
}
const zS = { name: "mdi-format-list-numbered", render: CK }, AK = wK.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 140,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("orderedList"),
            icon: R(zS),
            title: Q.global.t("editor.common.ordered_list"),
            action: () => e.chain().focus().toggleOrderedList().run()
          }
        };
      },
      getCommandMenuItems() {
        return {
          priority: 140,
          icon: R(zS),
          title: "editor.common.ordered_list",
          keywords: ["orderedlist", "youxuliebiao"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).toggleOrderedList().run();
          }
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            let n = e;
            for (; n && n.tagName !== "LI"; )
              n = n.parentElement;
            return {
              el: n,
              dragDomOffset: {
                x: -16,
                y: -1
              }
            };
          }
        };
      }
    };
  },
  addExtensions() {
    return [XP];
  }
}), TK = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, MK = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, PK = Tn.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Aa({
        find: TK,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Eo({
        find: MK,
        type: this.type
      })
    ];
  }
}), RK = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, $K = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 14h18v-2H3m2-8v3h5v3h4V7h5V4m-9 15h4v-3h-4z"
}, null, -1), NK = [
  $K
];
function DK(t, e) {
  return P(), L("svg", RK, [...NK]);
}
const b5 = { name: "mdi-format-strikethrough", render: DK }, IK = PK.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 70,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("strike"),
            icon: R(b5),
            title: Q.global.t("editor.common.strike"),
            action: () => e.chain().focus().toggleStrike().run()
          }
        };
      }
    };
  }
}), LK = Tn.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), BK = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, QK = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M16 7.41L11.41 12L16 16.59L14.59 18L10 13.41L5.41 18L4 16.59L8.59 12L4 7.41L5.41 6L10 10.59L14.59 6zm5.85 13.62h-4.88v-1l.89-.8c.76-.65 1.32-1.19 1.7-1.63c.37-.44.56-.85.57-1.24a.9.9 0 0 0-.27-.7c-.18-.16-.47-.28-.86-.28c-.31 0-.58.06-.84.18l-.66.38l-.45-1.17c.27-.21.59-.39.98-.53s.82-.24 1.29-.24c.78.04 1.38.25 1.78.66s.62.93.62 1.57c-.01.56-.19 1.08-.54 1.55c-.34.47-.76.92-1.27 1.36l-.64.52v.02h2.58z"
}, null, -1), FK = [
  QK
];
function zK(t, e) {
  return P(), L("svg", BK, [...FK]);
}
const O5 = { name: "mdi-format-subscript", render: zK }, UK = LK.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 120,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("subscript"),
            icon: R(O5),
            title: Q.global.t("editor.common.subscript"),
            action: () => e.chain().focus().toggleSubscript().run()
          }
        };
      }
    };
  }
}), WK = Tn.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), VK = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, ZK = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M16 7.41L11.41 12L16 16.59L14.59 18L10 13.41L5.41 18L4 16.59L8.59 12L4 7.41L5.41 6L10 10.59L14.59 6zM21.85 9h-4.88V8l.89-.82c.76-.64 1.32-1.18 1.7-1.63q.555-.66.57-1.23a.88.88 0 0 0-.27-.7c-.18-.19-.47-.28-.86-.29c-.31.01-.58.07-.84.17l-.66.39l-.45-1.17c.27-.22.59-.39.98-.53S18.85 2 19.32 2c.78 0 1.38.2 1.78.61c.4.39.62.93.62 1.57c-.01.56-.19 1.08-.54 1.55c-.34.48-.76.93-1.27 1.36l-.64.52v.02h2.58z"
}, null, -1), HK = [
  ZK
];
function qK(t, e) {
  return P(), L("svg", VK, [...HK]);
}
const y5 = { name: "mdi-format-superscript", render: qK }, XK = WK.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 110,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("superscript"),
            icon: R(y5),
            title: Q.global.t("editor.common.superscript"),
            action: () => e.chain().focus().toggleSuperscript().run()
          }
        };
      }
    };
  }
});
function US(t, e, n, i, r, s) {
  let o = 0, a = !0, l = e.firstChild;
  const c = t.firstChild;
  for (let u = 0, d = 0; u < c.childCount; u += 1) {
    const { colspan: h, colwidth: f } = c.child(u).attrs;
    for (let p = 0; p < h; p += 1, d += 1) {
      const m = r === d ? s : f && f[p], g = m ? `${m}px` : "";
      o += m || i, m || (a = !1), l ? (l.style.width !== g && (l.style.width = g), l = l.nextSibling) : e.appendChild(document.createElement("col")).style.width = g;
    }
  }
  for (; l; ) {
    const u = l.nextSibling;
    l.parentNode.removeChild(l), l = u;
  }
  a ? (n.style.width = `${o}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${o}px`);
}
let jK = class {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), US(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, US(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
};
function _5(t, e, n, i) {
  let r = 0, s = !0;
  const o = [], a = t.firstChild;
  if (!a)
    return {};
  for (let d = 0, h = 0; d < a.childCount; d += 1) {
    const { colspan: f, colwidth: p } = a.child(d).attrs;
    for (let m = 0; m < f; m += 1, h += 1) {
      const g = n === h ? i : p && p[m], b = g ? `${g}px` : "";
      r += g || e, g || (s = !1), o.push(["col", b ? { style: `width: ${b}` } : {}]);
    }
  }
  const l = s ? `${r}px` : "", c = s ? "" : `${r}px`;
  return { colgroup: ["colgroup", {}, ...o], tableWidth: l, tableMinWidth: c };
}
function WS(t, e) {
  return t.createAndFill();
}
function YK(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const i = t.nodes[n];
    i.spec.tableRole && (e[i.spec.tableRole] = i);
  }), t.cached.tableNodeTypes = e, e;
}
function GK(t, e, n, i, r) {
  const s = YK(t), o = [], a = [];
  for (let c = 0; c < n; c += 1) {
    const u = WS(s.cell);
    if (u && a.push(u), i) {
      const d = WS(s.header_cell);
      d && o.push(d);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(s.row.createChecked(null, i && c === 0 ? o : a));
  return s.table.createChecked(null, l);
}
function KK(t) {
  return t instanceof at;
}
const qh = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!KK(e))
    return !1;
  let n = 0;
  const i = mP(e.ranges[0].$from, (s) => s.type.name === "table");
  return i == null || i.node.descendants((s) => {
    if (s.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(s.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, JK = wt.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: jK,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: i, tableMinWidth: r } = _5(t, this.options.cellMinWidth);
    return [
      "table",
      Ee(this.options.HTMLAttributes, e, {
        style: i ? `width: ${i}` : `min-width: ${r}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: i, dispatch: r, editor: s }) => {
        const o = GK(s.schema, t, e, n);
        if (r) {
          const a = i.selection.from + 1;
          i.replaceSelectionWith(o).scrollIntoView().setSelection(ce.near(i.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => EW(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => rP(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => AW(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => MW(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => oP(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => RW(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => QW(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => Bw(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => Qw(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => Ku("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => Ku("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => LW(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => Bw(t, e) ? !0 : Qw(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: i }) => DW(t, e)(n, i),
      goToNextCell: () => ({ state: t, dispatch: e }) => zw(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => zw(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && eP(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const i = at.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(i);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: qh,
      "Mod-Backspace": qh,
      Delete: qh,
      "Mod-Delete": qh
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        mW({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          // @ts-ignore (incorrect type)
          View: this.options.View,
          // TODO: PR for @types/prosemirror-tables
          // @ts-ignore (incorrect type)
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      FW({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: Ne(he(t, "tableRole", e))
    };
  }
}), eJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, tJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 6.25A3.25 3.25 0 0 1 6.25 3h11.5A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75zM6.25 4.5A1.75 1.75 0 0 0 4.5 6.25V8.5h4v-4zM4.5 10v4h4v-4zm5.5 0v4h4v-4zm5.5 0v4h4v-4zm0 9.5h2.25a1.75 1.75 0 0 0 1.75-1.75V15.5h-4zm0-11h4V6.25a1.75 1.75 0 0 0-1.75-1.75H15.5zm-11 7v2.25c0 .966.784 1.75 1.75 1.75H8.5v-4z"
}, null, -1), nJ = [
  tJ
];
function iJ(t, e) {
  return P(), L("svg", eJ, [...nJ]);
}
const rJ = { name: "fluent-table-column-top-bottom-24-regular", render: iJ }, sJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, oJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M5 4h14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2m0 4v4h6V8zm8 0v4h6V8zm-8 6v4h6v-4zm8 0v4h6v-4z"
}, null, -1), aJ = [
  oJ
];
function lJ(t, e) {
  return P(), L("svg", sJ, [...aJ]);
}
const cJ = { name: "mdi-table", render: lJ }, uJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, dJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M11 2a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H2V2zm-7 8v4h7v-4zm0 6v4h7v-4zM4 4v4h7V4zm11 7h3V8h2v3h3v2h-3v3h-2v-3h-3z"
}, null, -1), hJ = [
  dJ
];
function fJ(t, e) {
  return P(), L("svg", uJ, [...hJ]);
}
const pJ = { name: "mdi-table-column-plus-after", render: fJ }, mJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, gJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M13 2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9V2zm7 8v4h-7v-4zm0 6v4h-7v-4zm0-12v4h-7V4zM9 11H6V8H4v3H1v2h3v3h2v-3h3z"
}, null, -1), bJ = [
  gJ
];
function OJ(t, e) {
  return P(), L("svg", mJ, [...bJ]);
}
const yJ = { name: "mdi-table-column-plus-before", render: OJ }, _J = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, vJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M4 2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2m0 8v4h7v-4zm0 6v4h7v-4zM4 4v4h7V4zm13.59 8L15 9.41L16.41 8L19 10.59L21.59 8L23 9.41L20.41 12L23 14.59L21.59 16L19 13.41L16.41 16L15 14.59z"
}, null, -1), xJ = [
  vJ
];
function wJ(t, e) {
  return P(), L("svg", _J, [...xJ]);
}
const SJ = { name: "mdi-table-column-remove", render: wJ }, kJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, EJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M1 6v13a2 2 0 0 0 2 2h6V11h12V6a2 2 0 0 0-2-2H3a2 2 0 0 0-2 2m2 0h4v3H3m4 10H3v-3h4m0-2H3v-3h4m2-2V6h4v3m6 0h-4V6h4m-2 10a1 1 0 1 1-1 1a1 1 0 0 1 1-1m0-3a6.45 6.45 0 0 1 6 4a6.5 6.5 0 0 1-12 0a6.45 6.45 0 0 1 6-4m0 1.5a2.5 2.5 0 1 0 2.5 2.5a2.5 2.5 0 0 0-2.5-2.5"
}, null, -1), CJ = [
  EJ
];
function AJ(t, e) {
  return P(), L("svg", kJ, [...CJ]);
}
const VS = { name: "mdi-table-headers-eye", render: AJ }, TJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, MJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M5 10H3V4h8v2H5zm14 8h-6v2h8v-6h-2zM5 18v-4H3v6h8v-2zM21 4h-8v2h6v4h2zM8 13v2l3-3l-3-3v2H3v2zm8-2V9l-3 3l3 3v-2h5v-2z"
}, null, -1), PJ = [
  MJ
];
function RJ(t, e) {
  return P(), L("svg", TJ, [...PJ]);
}
const $J = { name: "mdi-table-merge-cells", render: RJ }, NJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, DJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M18 14h2v3h3v2h-3v3h-2v-3h-3v-2h3zM4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4z"
}, null, -1), IJ = [
  DJ
];
function LJ(t, e) {
  return P(), L("svg", NJ, [...IJ]);
}
const BJ = { name: "mdi-table-plus", render: LJ }, QJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, FJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m15.46 15.88l1.42-1.42L19 16.59l2.12-2.13l1.42 1.42L20.41 18l2.13 2.12l-1.42 1.42L19 19.41l-2.12 2.13l-1.42-1.42L17.59 18zM4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4z"
}, null, -1), zJ = [
  FJ
];
function UJ(t, e) {
  return P(), L("svg", QJ, [...zJ]);
}
const WJ = { name: "mdi-table-remove", render: UJ }, VJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, ZJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M22 10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V3h2v2h4V3h2v2h4V3h2v2h4V3h2zM4 10h4V7H4zm6 0h4V7h-4zm10 0V7h-4v3zm-9 4h2v3h3v2h-3v3h-2v-3H8v-2h3z"
}, null, -1), HJ = [
  ZJ
];
function qJ(t, e) {
  return P(), L("svg", VJ, [...HJ]);
}
const XJ = { name: "mdi-table-row-plus-after", render: qJ }, jJ = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, YJ = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M22 14a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v7h2v-2h4v2h2v-2h4v2h2v-2h4v2h2zM4 14h4v3H4zm6 0h4v3h-4zm10 0v3h-4v-3zm-9-4h2V7h3V5h-3V2h-2v3H8v2h3z"
}, null, -1), GJ = [
  YJ
];
function KJ(t, e) {
  return P(), L("svg", jJ, [...GJ]);
}
const JJ = { name: "mdi-table-row-plus-before", render: KJ }, eee = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, tee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M9.41 13L12 15.59L14.59 13L16 14.41L13.41 17L16 19.59L14.59 21L12 18.41L9.41 21L8 19.59L10.59 17L8 14.41zM22 9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2zM4 9h4V6H4zm6 0h4V6h-4zm6 0h4V6h-4z"
}, null, -1), nee = [
  tee
];
function iee(t, e) {
  return P(), L("svg", eee, [...nee]);
}
const ree = { name: "mdi-table-row-remove", render: iee }, see = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, oee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M19 14h2v6H3v-6h2v4h14zM3 4v6h2V6h14v4h2V4zm8 7v2H8v2l-3-3l3-3v2zm5 0V9l3 3l-3 3v-2h-3v-2z"
}, null, -1), aee = [
  oee
];
function lee(t, e) {
  return P(), L("svg", see, [...aee]);
}
const cee = { name: "mdi-table-split-cell", render: lee }, uee = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, dee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}, null, -1), hee = [
  dee
];
function fee(t, e) {
  return P(), L("svg", uee, [...hee]);
}
const v5 = { name: "mdi-plus", render: fee }, x5 = (t) => {
  const e = F0(t.selection);
  if (e) {
    const { map: n } = Je.get(e.node);
    if (n && n.length) {
      const i = e.start + n[0], r = e.start + n[n.length - 1], s = t.doc.resolve(i), o = t.doc.resolve(r);
      return t.setSelection(new at(o, s));
    }
  }
  return t;
}, w5 = (t) => (e) => (n) => {
  const i = F0(n.selection), r = t === "row";
  if (i) {
    const s = Je.get(i.node);
    if (e >= 0 && e < (r ? s.height : s.width)) {
      const o = r ? s.cellsInRect({
        left: 0,
        right: 1,
        top: 0,
        bottom: s.height
      }) : s.cellsInRect({
        left: 0,
        right: s.width,
        top: 0,
        bottom: 1
      }), a = s.findCell(o[e]), l = {
        left: r ? s.width - 1 : a.left,
        right: r ? s.width : a.right,
        top: r ? a.top : s.height - 1,
        bottom: r ? a.bottom : s.height
      };
      let c = s.cellsInRect(l);
      for (; c.length === 0; )
        r ? l.left -= 1 : l.top -= 1, c = s.cellsInRect(l);
      const u = i.start + o[e], d = i.start + c[c.length - 1], h = n.doc.resolve(u), f = n.doc.resolve(d);
      return n.setSelection(new at(f, h));
    }
  }
  return n;
}, pee = w5("column"), mee = w5("row"), gee = (t) => (e) => {
  const n = F0(e);
  if (n) {
    const i = Je.get(n.node);
    return (Array.isArray(t) ? t : Array.from([t])).reduce((s, o) => {
      if (o >= 0 && o <= i.width - 1) {
        const a = i.cellsInRect({
          left: o,
          right: o + 1,
          top: 0,
          bottom: i.height
        });
        return s.concat(
          a.map((l) => {
            const c = n.node.nodeAt(l), u = l + n.start;
            return { pos: u, start: u + 1, node: c };
          })
        );
      }
      return s;
    }, []);
  }
}, bee = (t) => (e) => {
  const n = F0(e);
  if (n) {
    const i = Je.get(n.node);
    return (Array.isArray(t) ? t : Array.from([t])).reduce((s, o) => {
      if (o >= 0 && o <= i.height - 1) {
        const a = i.cellsInRect({
          left: 0,
          right: i.width,
          top: o,
          bottom: o + 1
        });
        return s.concat(
          a.map((l) => {
            const c = n.node.nodeAt(l), u = l + n.start;
            return { pos: u, start: u + 1, node: c };
          })
        );
      }
      return s;
    }, []);
  }
}, F0 = (t) => Hi((e) => e.type.spec.tableRole === "table")(
  t
), G2 = (t) => (e) => {
  const n = Je.get(e.$anchorCell.node(-1)), i = e.$anchorCell.start(-1), r = n.cellsInRect(t), s = n.cellsInRect(
    n.rectBetween(
      e.$anchorCell.pos - i,
      e.$headCell.pos - i
    )
  );
  for (let o = 0, a = r.length; o < a; o++)
    if (s.indexOf(r[o]) === -1)
      return !1;
  return !0;
}, z0 = (t) => t instanceof at, Oee = (t) => (e) => {
  if (z0(e)) {
    const n = Je.get(e.$anchorCell.node(-1)), i = n.cellsInRect({
      left: 0,
      right: n.width,
      top: 0,
      bottom: 1
    });
    if (t >= i.length)
      return !1;
    const r = n.findCell(i[t]);
    return G2({
      left: r.left,
      right: r.right,
      top: 0,
      bottom: n.height
    })(e);
  }
  return !1;
}, yee = (t) => (e) => {
  if (z0(e)) {
    const n = Je.get(e.$anchorCell.node(-1)), i = n.cellsInRect({
      left: 0,
      right: 1,
      top: 0,
      bottom: n.height
    });
    if (t >= i.length)
      return !1;
    const r = n.findCell(i[t]);
    return G2({
      left: 0,
      right: n.width,
      top: r.top,
      bottom: r.bottom
    })(e);
  }
  return !1;
}, TO = (t) => {
  if (z0(t)) {
    const e = Je.get(t.$anchorCell.node(-1));
    return G2({
      left: 0,
      right: e.width,
      top: 0,
      bottom: e.height
    })(t);
  }
  return !1;
}, _ee = (t) => {
  const { $anchor: e } = t.selection, n = Math.max(0, e.pos - 2), i = t.doc.resolve(n).node();
  return !(!i || i.type.name !== "table");
}, ZS = (t) => S5(1)(t), vee = (t) => S5(-1)(t), S5 = (t) => (e) => {
  const n = gr(e);
  if (n.table) {
    const i = n.map, r = i.cellsInRect(n), s = xee(i)(r[r.length - 1], t);
    if (s) {
      const { top: o, left: a } = s, l = i.map[o * i.width + a];
      return {
        start: l + n.tableStart + 2,
        node: n.table.nodeAt(l)
      };
    }
    return;
  }
}, xee = (t) => (e, n) => {
  function i({ top: o, left: a, right: l, bottom: c }) {
    const u = {
      top: o,
      left: a,
      right: l,
      bottom: c
    };
    if (l + 1 > t.width) {
      if (c === t.height)
        return;
      u.top++, u.left = 0, u.right = 1, u.bottom++;
    } else
      u.left++, u.right++;
    const d = t.map[u.top * t.width + u.left], h = t.findCell(d);
    return h.top != u.top || h.left < u.left ? i({
      ...u,
      right: h.right
    }) : d;
  }
  function r({ top: o, left: a, right: l, bottom: c }) {
    const u = {
      top: o,
      left: a,
      right: l,
      bottom: c
    };
    if (a - 1 < 0) {
      if (o === 0)
        return;
      u.top--, u.left = t.width - 1, u.right = t.width, u.bottom--;
    } else
      u.left--, u.right--;
    const d = t.map[u.top * t.width + u.left];
    return t.findCell(d).top != u.top ? r(u) : d;
  }
  function s(o, a) {
    const { top: l, left: c, right: u, bottom: d } = t.findCell(o);
    if (a == 0)
      return {
        top: l,
        left: c,
        right: u,
        bottom: d
      };
    const h = {
      top: l,
      left: c,
      right: u,
      bottom: d
    };
    let f;
    if (a > 0 ? (f = i(h), a--) : (f = r(h), a++), !!f)
      return s(f, a);
  }
  return s(e, n);
}, HS = wt.create({
  name: "tableCell",
  content: "block+",
  tableRole: "cell",
  isolating: !0,
  fakeSelection: !0,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      colspan: {
        default: 1,
        parseHTML: (e) => {
          const n = e.getAttribute("colspan");
          return n ? parseInt(n, 10) : 1;
        }
      },
      rowspan: {
        default: 1,
        parseHTML: (e) => {
          const n = e.getAttribute("rowspan");
          return n ? parseInt(n, 10) : 1;
        }
      },
      colwidth: {
        default: [100],
        parseHTML: (e) => {
          const n = e.getAttribute("colwidth");
          return n ? n.split(",").map((r) => parseInt(r, 10)) : null;
        }
      },
      style: {
        default: null
      }
    };
  },
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "td",
      Ee(this.options.HTMLAttributes, t),
      0
    ];
  },
  addStorage() {
    return {
      gripMap: /* @__PURE__ */ new Map()
    };
  },
  onDestroy() {
    this.storage.gripMap.clear();
  },
  addProseMirrorPlugins() {
    const t = this.editor, e = this.storage;
    return [
      new Ue({
        key: new Ke("table-cell-control"),
        props: {
          decorations(n) {
            const { doc: i, selection: r } = n, s = [], o = gee(0)(r);
            return o && o.forEach(({ pos: a }, l) => {
              l === 0 && s.push(
                zt.widget(a + 1, () => {
                  const c = "table" + l;
                  let u = "grip-table";
                  TO(r) && (u += " selected");
                  let h = e.gripMap.get(c);
                  return h || (h = document.createElement("a"), h.addEventListener("mousedown", (f) => {
                    f.preventDefault(), f.stopImmediatePropagation(), t.view.dispatch(x5(t.state.tr));
                  })), h.className = u, e.gripMap.set(c, h), h;
                })
              ), s.push(
                zt.widget(a + 1, () => {
                  const c = "row" + l, u = yee(l)(r);
                  let d = "grip-row";
                  u && (d += " selected"), l === 0 && (d += " first"), l === o.length - 1 && (d += " last");
                  let h = e.gripMap.get(c);
                  if (!h) {
                    h = document.createElement("a");
                    const f = li(
                      p3,
                      {
                        triggers: ["hover"]
                      },
                      {
                        default: () => li(v5, { class: "plus-icon" }),
                        popper: () => Q.global.t("editor.menus.table.add_row_after")
                      }
                    );
                    Mu(f, h), h.addEventListener(
                      "mousedown",
                      (p) => {
                        p.preventDefault(), p.stopImmediatePropagation(), t.view.dispatch(
                          mee(l)(t.state.tr)
                        ), p.target !== h && oP(t.state, t.view.dispatch);
                      },
                      !0
                    );
                  }
                  return h.className = d, e.gripMap.set(c, h), h;
                })
              );
            }), We.create(i, s);
          }
        }
      })
    ];
  }
}), qS = wt.create({
  name: "tableHeader",
  content: "block+",
  tableRole: "header_cell",
  isolating: !0,
  fakeSelection: !0,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: [100],
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((i) => parseInt(i, 10)) : null;
        }
      },
      style: {
        default: null
      }
    };
  },
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "th",
      Ee(this.options.HTMLAttributes, t),
      0
    ];
  },
  addStorage() {
    return {
      gripMap: /* @__PURE__ */ new Map()
    };
  },
  onDestroy() {
    this.storage.gripMap.clear();
  },
  addProseMirrorPlugins() {
    const t = this.editor, e = this.storage;
    return [
      new Ue({
        key: new Ke("table-header-control"),
        props: {
          decorations(n) {
            const { doc: i, selection: r } = n, s = [], o = bee(0)(r);
            return o && o.forEach(({ pos: a }, l) => {
              s.push(
                zt.widget(a + 1, () => {
                  const c = "column" + l, u = Oee(l)(r);
                  let d = "grip-column";
                  u && (d += " selected"), l === 0 ? d += " first" : l === o.length - 1 && (d += " last");
                  let h = e.gripMap.get(c);
                  if (!h) {
                    h = document.createElement("a");
                    const f = li(
                      p3,
                      {
                        triggers: ["hover"]
                      },
                      {
                        default: () => li(v5, { class: "plus-icon" }),
                        popper: () => Q.global.t(
                          "editor.menus.table.add_column_after"
                        )
                      }
                    );
                    Mu(f, h), h.addEventListener("mousedown", (p) => {
                      p.preventDefault(), p.stopImmediatePropagation(), t.view.dispatch(
                        pee(l)(t.state.tr)
                      ), p.target !== h && rP(t.state, t.view.dispatch);
                    });
                  }
                  return h.className = d, e.gripMap.set(c, h), h;
                })
              );
            }), We.create(i, s);
          }
        }
      })
    ];
  }
}), wee = wt.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", Ee(this.options.HTMLAttributes, t), 0];
  }
}), See = wee.extend({
  allowGapCursor: !1,
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      style: {
        default: "height: 60px;",
        parseHTML: (e) => e.getAttribute("style")
      }
    };
  }
});
function XS(t, e, n, i, r, s) {
  var u;
  let o = 0, a = !0, l = e.firstChild;
  const c = t.firstChild;
  if (c) {
    for (let d = 0, h = 0; d < c.childCount; d += 1) {
      const { colspan: f, colwidth: p } = c.child(d).attrs;
      for (let m = 0; m < f; m += 1, h += 1) {
        const g = r === h ? s : p && p[m], b = g ? `${g}px` : "";
        o += g || i, g || (a = !1), l ? (l.style.width !== b && (l.style.width = b), l = l.nextSibling) : e.appendChild(document.createElement("col")).style.width = b;
      }
    }
    for (; l; ) {
      const d = l.nextSibling;
      (u = l.parentNode) == null || u.removeChild(l), l = d;
    }
    a ? (n.style.width = `${o}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${o}px`);
  }
}
let MO;
class kee {
  constructor(e, n) {
    Pe(this, "node");
    Pe(this, "cellMinWidth");
    Pe(this, "dom");
    Pe(this, "scrollDom");
    Pe(this, "table");
    Pe(this, "colgroup");
    Pe(this, "contentDOM");
    Pe(this, "containerDOM");
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "table-container", this.containerDOM = this.dom.appendChild(document.createElement("div")), this.containerDOM.className = "tableWrapper", this.containerDOM.addEventListener("wheel", (i) => this.handleHorizontalWheel(this.containerDOM, i)), this.containerDOM.addEventListener("scroll", () => {
      if (!MO)
        return !1;
      const { view: i } = MO;
      i.dispatch(i.state.tr);
    }), this.scrollDom = document.createElement("div"), this.scrollDom.className = "scrollWrapper", this.containerDOM.appendChild(this.scrollDom), this.table = this.scrollDom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), XS(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody")), setTimeout(() => {
      this.updateTableShadow();
    });
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, XS(e, this.colgroup, this.table, this.cellMinWidth), this.updateTableShadow(), !0);
  }
  updateTableShadow() {
    const { scrollWidth: e, clientWidth: n, scrollLeft: i } = this.containerDOM;
    e > n && i < e - n ? this.dom.classList.add("table-right-shadow") : this.dom.classList.remove("table-right-shadow"), i > 0 ? this.dom.classList.add("table-left-shadow") : this.dom.classList.remove("table-left-shadow");
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || e.target === this.dom || this.colgroup.contains(e.target));
  }
  handleHorizontalWheel(e, n) {
    const { scrollWidth: i, clientWidth: r } = e;
    i > r && (n.stopPropagation(), n.preventDefault(), e.scrollBy({ left: n.deltaY }));
  }
}
const Yo = JK.extend({
  allowGapCursor: !0,
  addExtensions() {
    return [HS, See, qS];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {},
      resizable: !0,
      handleWidth: 5,
      cellMinWidth: 25,
      View: kee,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1,
      getToolboxItems({ editor: e }) {
        return {
          priority: 15,
          component: R(Qo),
          props: {
            editor: e,
            icon: R(BJ),
            title: Q.global.t("editor.menus.table.add"),
            action: () => e.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run()
          }
        };
      },
      getCommandMenuItems() {
        return {
          priority: 120,
          icon: R(cJ),
          title: "editor.extensions.commands_menu.table",
          keywords: ["table", "biaoge"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run();
          }
        };
      },
      getBubbleMenu({ editor: e }) {
        return {
          pluginKey: "tableBubbleMenu",
          shouldShow: ({ state: n }) => xi(n, Yo.name),
          getRenderContainer(n) {
            let i = n;
            for (i.nodeName === "#text" && (i = n.parentElement); i && i.classList && !i.classList.contains("tableWrapper"); )
              i = i.parentElement;
            return i;
          },
          tippyOptions: {
            offset: [26, 0]
          },
          items: [
            {
              priority: 10,
              props: {
                icon: R(yJ),
                title: Q.global.t("editor.menus.table.add_column_before"),
                action: () => {
                  e.chain().focus().addColumnBefore().run();
                }
              }
            },
            {
              priority: 20,
              props: {
                icon: R(pJ),
                title: Q.global.t("editor.menus.table.add_column_after"),
                action: () => e.chain().focus().addColumnAfter().run()
              }
            },
            {
              priority: 30,
              props: {
                icon: R(SJ),
                title: Q.global.t("editor.menus.table.delete_column"),
                action: () => e.chain().focus().deleteColumn().run()
              }
            },
            {
              priority: 40,
              component: R(Qt)
            },
            {
              priority: 50,
              props: {
                icon: R(JJ),
                title: Q.global.t("editor.menus.table.add_row_before"),
                action: () => e.chain().focus().addRowBefore().run()
              }
            },
            {
              priority: 60,
              props: {
                icon: R(XJ),
                title: Q.global.t("editor.menus.table.add_row_after"),
                action: () => e.chain().focus().addRowAfter().run()
              }
            },
            {
              priority: 70,
              props: {
                icon: R(ree),
                title: Q.global.t("editor.menus.table.delete_row"),
                action: () => e.chain().focus().deleteRow().run()
              }
            },
            {
              priority: 80,
              component: R(Qt)
            },
            {
              priority: 90,
              props: {
                icon: R(VS),
                title: Q.global.t("editor.menus.table.toggle_header_column"),
                action: () => e.chain().focus().toggleHeaderColumn().run()
              }
            },
            {
              priority: 100,
              props: {
                icon: R(VS),
                title: Q.global.t("editor.menus.table.toggle_header_row"),
                action: () => e.chain().focus().toggleHeaderRow().run()
              }
            },
            {
              priority: 101,
              props: {
                icon: R(rJ),
                title: Q.global.t("editor.menus.table.toggle_header_cell"),
                action: () => e.chain().focus().toggleHeaderCell().run()
              }
            },
            {
              priority: 110,
              component: R(Qt)
            },
            {
              priority: 120,
              props: {
                icon: R($J),
                title: Q.global.t("editor.menus.table.merge_cells"),
                action: () => e.chain().focus().mergeCells().run()
              }
            },
            {
              priority: 130,
              props: {
                icon: R(cee),
                title: Q.global.t("editor.menus.table.split_cell"),
                action: () => e.chain().focus().splitCell().run()
              }
            },
            {
              priority: 140,
              component: R(Qt)
            },
            {
              priority: 150,
              props: {
                icon: R(WJ),
                title: Q.global.t("editor.menus.table.delete_table"),
                action: () => e.chain().focus().deleteTable().run()
              }
            }
          ]
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            let n = e;
            for (; n && !n.classList.contains("tableWrapper"); )
              n = n.parentElement;
            return {
              el: n,
              dragDomOffset: {
                x: 20,
                y: 20
              }
            };
          },
          handleDrop({ view: e, event: n, slice: i, insertPos: r }) {
            const { state: s } = e, o = s.selection.$anchor;
            for (let a = o.depth; a > 0; a--)
              if (o.node(a).type.spec.tableRole == "table") {
                if (!e.posAtCoords({
                  left: n.clientX,
                  top: n.clientY
                }) || !i)
                  return;
                let u = s.tr;
                u = u.delete(o.before(a), o.after(a));
                const d = u.mapping.map(r);
                return u = u.replaceRange(d, d, i).scrollIntoView(), u ? (e.dispatch(u), n.preventDefault(), !0) : !1;
              }
          }
        };
      }
    };
  },
  addKeyboardShortcuts() {
    const t = () => {
      const { editor: e } = this;
      if (e.commands.undoInputRule())
        return !0;
      const { selection: n } = e.state;
      return !Fi(e.state, Yo.name) && _ee(e.state) && n.empty ? (e.commands.selectNodeBackward(), !0) : Fi(e.state, Yo.name) && TO(e.state.selection) ? (e.commands.deleteTable(), !0) : !1;
    };
    return {
      Backspace: () => t(),
      "Mod-Backspace": () => t(),
      "Mod-a": ({ editor: e }) => {
        if (!Fi(e.state, Yo.name))
          return !1;
        const { tr: n, selection: i } = e.state;
        if (TO(i))
          return !0;
        if (z0(i))
          return x5(n), e.view.dispatch(n), !0;
        let r = Hi(
          (s) => s.type.name === HS.name
        )(i);
        return r || (r = Hi(
          (s) => s.type.name === qS.name
        )(i)), r ? (e.commands.setNodeSelection(r.pos), !0) : !1;
      },
      Tab: ({ editor: e }) => {
        var o;
        const { state: n } = e;
        if (!xi(e.state, Yo.name))
          return !1;
        let i = e.view, r = e.state.tr, s = ZS(n);
        return s || e.chain().addRowAfter().command(({ tr: a, view: l, state: c }) => (i = l, r = a, s = ZS(c), !0)), s ? (r.setSelection(
          new ce(
            r.doc.resolve(s.start),
            r.doc.resolve(
              s.start + (((o = s.node) == null ? void 0 : o.nodeSize) || 0) - 4
            )
          )
        ), r.scrollIntoView(), i.dispatch(r), !0) : !1;
      },
      "Shift-Tab": ({ editor: e }) => {
        var r;
        const { tr: n } = e.state;
        if (!xi(e.state, Yo.name))
          return !1;
        const i = vee(e.state);
        return i && (n.setSelection(
          new ce(
            n.doc.resolve(i.start),
            n.doc.resolve(
              i.start + (((r = i.node) == null ? void 0 : r.nodeSize) || 0) - 4
            )
          )
        ), n.scrollIntoView(), e.view.dispatch(n)), !0;
      }
    };
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: i, tableMinWidth: r } = _5(
      t,
      this.options.cellMinWidth
    );
    return [
      "div",
      { style: "overflow-x: auto; overflow-y: hidden;" },
      [
        "table",
        Ee(this.options.HTMLAttributes, e, {
          style: i ? `width: ${i}` : `minWidth: ${r}`
        }),
        n,
        ["tbody", 0]
      ]
    ];
  },
  onTransaction() {
    MO = this.editor;
  }
}).configure({ resizable: !0 }), Eee = /^\s*(\[([( |x])?\])\s$/, Cee = wt.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e == null || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      Ee(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: n, editor: i }) => {
      const r = document.createElement("li"), s = document.createElement("label"), o = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
      return s.contentEditable = "false", a.type = "checkbox", a.addEventListener("change", (c) => {
        if (!i.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: u } = c.target;
        i.isEditable && typeof n == "function" && i.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: d }) => {
          const h = n(), f = d.doc.nodeAt(h);
          return d.setNodeMarkup(h, void 0, {
            ...f == null ? void 0 : f.attrs,
            checked: u
          }), !0;
        }).run(), !i.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, u) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([c, u]) => {
        r.setAttribute(c, u);
      }), r.dataset.checked = t.attrs.checked, t.attrs.checked && a.setAttribute("checked", "checked"), s.append(a, o), r.append(s, l), Object.entries(e).forEach(([c, u]) => {
        r.setAttribute(c, u);
      }), {
        dom: r,
        contentDOM: l,
        update: (c) => c.type !== this.type ? !1 : (r.dataset.checked = c.attrs.checked, c.attrs.checked ? a.setAttribute("checked", "checked") : a.removeAttribute("checked"), !0)
      };
    };
  },
  addInputRules() {
    return [
      Hl({
        find: Eee,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
}), Aee = wt.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Ee(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
}), Tee = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Mee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M21 19v-2H8v2zm0-6v-2H8v2zM8 7h13V5H8zM4 5v2h2V5zM3 5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm1 6v2h2v-2zm-1 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm1 6v2h2v-2zm-1 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z"
}, null, -1), Pee = [
  Mee
];
function Ree(t, e) {
  return P(), L("svg", Tee, [...Pee]);
}
const jS = { name: "mdi-format-list-checkbox", render: Ree }, $ee = Aee.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 150,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("taskList"),
            icon: R(jS),
            title: Q.global.t("editor.common.task_list"),
            action: () => e.chain().focus().toggleTaskList().run()
          }
        };
      },
      getCommandMenuItems() {
        return {
          priority: 150,
          icon: R(jS),
          title: "editor.common.task_list",
          keywords: ["tasklist", "renwuliebiao"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).toggleTaskList().run();
          }
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            let n = e;
            for (; n && n.tagName !== "LI"; )
              n = n.parentElement;
            return {
              el: n,
              dragDomOffset: {
                y: -1
              }
            };
          }
        };
      }
    };
  },
  addExtensions() {
    return [Cee];
  }
}), Nee = mt.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign || this.options.defaultAlignment;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign === this.options.defaultAlignment ? {} : { style: `text-align: ${t.textAlign}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), Dee = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Iee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 3h18v2H3zm4 4h10v2H7zm-4 4h18v2H3zm4 4h10v2H7zm-4 4h18v2H3z"
}, null, -1), Lee = [
  Iee
];
function Bee(t, e) {
  return P(), L("svg", Dee, [...Lee]);
}
const eh = { name: "mdi-format-align-center", render: Bee }, Qee = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Fee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 3h18v2H3zm0 4h18v2H3zm0 4h18v2H3zm0 4h18v2H3zm0 4h18v2H3z"
}, null, -1), zee = [
  Fee
];
function Uee(t, e) {
  return P(), L("svg", Qee, [...zee]);
}
const th = { name: "mdi-format-align-justify", render: Uee }, Wee = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Vee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 3h18v2H3zm0 4h12v2H3zm0 4h18v2H3zm0 4h12v2H3zm0 4h18v2H3z"
}, null, -1), Zee = [
  Vee
];
function Hee(t, e) {
  return P(), L("svg", Wee, [...Zee]);
}
const xc = { name: "mdi-format-align-left", render: Hee }, qee = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Xee = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 3h18v2H3zm6 4h12v2H9zm-6 4h18v2H3zm6 4h12v2H9zm-6 4h18v2H3z"
}, null, -1), jee = [
  Xee
];
function Yee(t, e) {
  return P(), L("svg", qee, [...jee]);
}
const nh = { name: "mdi-format-align-right", render: Yee }, Gee = {
  left: xc,
  center: eh,
  right: nh,
  justify: th
}, Kee = (t) => {
  let e = xc;
  return Object.entries(Gee).forEach(([n, i]) => {
    if (t.isActive({ textAlign: n })) {
      e = i;
      return;
    }
  }), e;
}, Jee = Nee.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 180,
          component: R($t),
          props: {
            editor: e,
            isActive: !1,
            icon: R(Kee(e)),
            title: Q.global.t("editor.common.align_method")
          },
          children: [
            {
              priority: 0,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive({ textAlign: "left" }),
                icon: R(xc),
                title: Q.global.t("editor.common.align_left"),
                action: () => e.chain().focus().setTextAlign("left").run()
              }
            },
            {
              priority: 10,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive({ textAlign: "center" }),
                icon: R(eh),
                title: Q.global.t("editor.common.align_center"),
                action: () => e.chain().focus().setTextAlign("center").run()
              }
            },
            {
              priority: 20,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive({ textAlign: "right" }),
                icon: R(nh),
                title: Q.global.t("editor.common.align_right"),
                action: () => e.chain().focus().setTextAlign("right").run()
              }
            },
            {
              priority: 30,
              component: R(Xn),
              props: {
                editor: e,
                isActive: e.isActive({ textAlign: "justify" }),
                icon: R(th),
                title: Q.global.t("editor.common.align_justify"),
                action: () => e.chain().focus().setTextAlign("justify").run()
              }
            }
          ]
        };
      }
    };
  }
}), ete = Tn.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", Ee(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), tte = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, nte = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M5 21h14v-2H5zm7-4a6 6 0 0 0 6-6V3h-2.5v8a3.5 3.5 0 0 1-3.5 3.5A3.5 3.5 0 0 1 8.5 11V3H6v8a6 6 0 0 0 6 6"
}, null, -1), ite = [
  nte
];
function rte(t, e) {
  return P(), L("svg", tte, [...ite]);
}
const k5 = { name: "mdi-format-underline", render: rte }, ste = ete.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 60,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("underline"),
            icon: R(k5),
            title: Q.global.t("editor.common.underline"),
            action: () => e.chain().focus().toggleUnderline().run()
          }
        };
      }
    };
  }
}), ote = /^```([a-z]+)?[\s\n]$/, ate = /^~~~([a-z]+)?[\s\n]$/, lte = wt.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, s = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((o) => o.startsWith(n)).map((o) => o.replace(n, ""))[0];
          return s || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      Ee(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: i, empty: r } = n;
        if (!r || i.parent.type !== this.type)
          return !1;
        const s = i.parentOffset === i.parent.nodeSize - 2, o = i.parent.textContent.endsWith(`

`);
        return !s || !o ? !1 : t.chain().command(({ tr: a }) => (a.delete(i.pos - 2, i.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: i } = e, { $from: r, empty: s } = n;
        if (!s || r.parent.type !== this.type || !(r.parentOffset === r.parent.nodeSize - 2))
          return !1;
        const a = r.after();
        return a === void 0 ? !1 : i.nodeAt(a) ? t.commands.command(({ tr: c }) => (c.setSelection(_e.near(i.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      dO({
        find: ote,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      dO({
        find: ate,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Ue({
        key: new Ke("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), i = e.clipboardData.getData("vscode-editor-data"), r = i ? JSON.parse(i) : void 0, s = r == null ? void 0 : r.mode;
            if (!n || !s)
              return !1;
            const { tr: o, schema: a } = t.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return o.replaceSelectionWith(this.type.create({ language: s }, l)), o.selection.$from.parent.type !== this.type && o.setSelection(ce.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", !0), t.dispatch(o), !0;
          }
        }
      })
    ];
  }
});
function cte(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function E5(t) {
  return t instanceof Map ? t.clear = t.delete = t.set = function() {
    throw new Error("map is read-only");
  } : t instanceof Set && (t.add = t.clear = t.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach((e) => {
    const n = t[e], i = typeof n;
    (i === "object" || i === "function") && !Object.isFrozen(n) && E5(n);
  }), t;
}
let YS = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
};
function C5(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function oo(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const i in t)
    n[i] = t[i];
  return e.forEach(function(i) {
    for (const r in i)
      n[r] = i[r];
  }), /** @type {T} */
  n;
}
const ute = "</span>", GS = (t) => !!t.scope, dte = (t, { prefix: e }) => {
  if (t.startsWith("language:"))
    return t.replace("language:", "language-");
  if (t.includes(".")) {
    const n = t.split(".");
    return [
      `${e}${n.shift()}`,
      ...n.map((i, r) => `${i}${"_".repeat(r + 1)}`)
    ].join(" ");
  }
  return `${e}${t}`;
};
let hte = class {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += C5(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!GS(e)) return;
    const n = dte(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    GS(e) && (this.buffer += ute);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
};
const KS = (t = {}) => {
  const e = { children: [] };
  return Object.assign(e, t), e;
};
let fte = class A5 {
  constructor() {
    this.rootNode = KS(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const n = KS({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((i) => this._walk(e, i)), e.closeNode(n)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      A5._collapse(n);
    }));
  }
}, pte = class extends fte {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const i = e.root;
    n && (i.scope = `language:${n}`), this.add(i);
  }
  toHTML() {
    return new hte(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
};
function rd(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function T5(t) {
  return Za("(?=", t, ")");
}
function mte(t) {
  return Za("(?:", t, ")*");
}
function gte(t) {
  return Za("(?:", t, ")?");
}
function Za(...t) {
  return t.map((n) => rd(n)).join("");
}
function bte(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function K2(...t) {
  return "(" + (bte(t).capture ? "" : "?:") + t.map((i) => rd(i)).join("|") + ")";
}
function M5(t) {
  return new RegExp(t.toString() + "|").exec("").length - 1;
}
function Ote(t, e) {
  const n = t && t.exec(e);
  return n && n.index === 0;
}
const yte = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function J2(t, { joinWith: e }) {
  let n = 0;
  return t.map((i) => {
    n += 1;
    const r = n;
    let s = rd(i), o = "";
    for (; s.length > 0; ) {
      const a = yte.exec(s);
      if (!a) {
        o += s;
        break;
      }
      o += s.substring(0, a.index), s = s.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? o += "\\" + String(Number(a[1]) + r) : (o += a[0], a[0] === "(" && n++);
    }
    return o;
  }).map((i) => `(${i})`).join(e);
}
const _te = /\b\B/, P5 = "[a-zA-Z]\\w*", e_ = "[a-zA-Z_]\\w*", R5 = "\\b\\d+(\\.\\d+)?", $5 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", N5 = "\\b(0b[01]+)", vte = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", xte = (t = {}) => {
  const e = /^#![ ]*\//;
  return t.binary && (t.begin = Za(
    e,
    /.*\b/,
    t.binary,
    /\b.*/
  )), oo({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, i) => {
      n.index !== 0 && i.ignoreMatch();
    }
  }, t);
}, sd = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, wte = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [sd]
}, Ste = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [sd]
}, kte = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, U0 = function(t, e, n = {}) {
  const i = oo(
    {
      scope: "comment",
      begin: t,
      end: e,
      contains: []
    },
    n
  );
  i.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const r = K2(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return i.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Za(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        r,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), i;
}, Ete = U0("//", "$"), Cte = U0("/\\*", "\\*/"), Ate = U0("#", "$"), Tte = {
  scope: "number",
  begin: R5,
  relevance: 0
}, Mte = {
  scope: "number",
  begin: $5,
  relevance: 0
}, Pte = {
  scope: "number",
  begin: N5,
  relevance: 0
}, Rte = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    sd,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [sd]
    }
  ]
}, $te = {
  scope: "title",
  begin: P5,
  relevance: 0
}, Nte = {
  scope: "title",
  begin: e_,
  relevance: 0
}, Dte = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + e_,
  relevance: 0
}, Ite = function(t) {
  return Object.assign(
    t,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, n) => {
        n.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch();
      }
    }
  );
};
var Xh = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: wte,
  BACKSLASH_ESCAPE: sd,
  BINARY_NUMBER_MODE: Pte,
  BINARY_NUMBER_RE: N5,
  COMMENT: U0,
  C_BLOCK_COMMENT_MODE: Cte,
  C_LINE_COMMENT_MODE: Ete,
  C_NUMBER_MODE: Mte,
  C_NUMBER_RE: $5,
  END_SAME_AS_BEGIN: Ite,
  HASH_COMMENT_MODE: Ate,
  IDENT_RE: P5,
  MATCH_NOTHING_RE: _te,
  METHOD_GUARD: Dte,
  NUMBER_MODE: Tte,
  NUMBER_RE: R5,
  PHRASAL_WORDS_MODE: kte,
  QUOTE_STRING_MODE: Ste,
  REGEXP_MODE: Rte,
  RE_STARTERS_RE: vte,
  SHEBANG: xte,
  TITLE_MODE: $te,
  UNDERSCORE_IDENT_RE: e_,
  UNDERSCORE_TITLE_MODE: Nte
});
function Lte(t, e) {
  t.input[t.index - 1] === "." && e.ignoreMatch();
}
function Bte(t, e) {
  t.className !== void 0 && (t.scope = t.className, delete t.className);
}
function Qte(t, e) {
  e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = Lte, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0));
}
function Fte(t, e) {
  Array.isArray(t.illegal) && (t.illegal = K2(...t.illegal));
}
function zte(t, e) {
  if (t.match) {
    if (t.begin || t.end) throw new Error("begin & end are not supported with match");
    t.begin = t.match, delete t.match;
  }
}
function Ute(t, e) {
  t.relevance === void 0 && (t.relevance = 1);
}
const Wte = (t, e) => {
  if (!t.beforeMatch) return;
  if (t.starts) throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t);
  Object.keys(t).forEach((i) => {
    delete t[i];
  }), t.keywords = n.keywords, t.begin = Za(n.beforeMatch, T5(n.begin)), t.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, t.relevance = 0, delete n.beforeMatch;
}, Vte = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], Zte = "keyword";
function D5(t, e, n = Zte) {
  const i = /* @__PURE__ */ Object.create(null);
  return typeof t == "string" ? r(n, t.split(" ")) : Array.isArray(t) ? r(n, t) : Object.keys(t).forEach(function(s) {
    Object.assign(
      i,
      D5(t[s], e, s)
    );
  }), i;
  function r(s, o) {
    e && (o = o.map((a) => a.toLowerCase())), o.forEach(function(a) {
      const l = a.split("|");
      i[l[0]] = [s, Hte(l[0], l[1])];
    });
  }
}
function Hte(t, e) {
  return e ? Number(e) : qte(t) ? 0 : 1;
}
function qte(t) {
  return Vte.includes(t.toLowerCase());
}
const JS = {}, _a = (t) => {
  console.error(t);
}, ek = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e);
}, il = (t, e) => {
  JS[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), JS[`${t}/${e}`] = !0);
}, bm = new Error();
function I5(t, e, { key: n }) {
  let i = 0;
  const r = t[n], s = {}, o = {};
  for (let a = 1; a <= e.length; a++)
    o[a + i] = r[a], s[a + i] = !0, i += M5(e[a - 1]);
  t[n] = o, t[n]._emit = s, t[n]._multi = !0;
}
function Xte(t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin)
      throw _a("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), bm;
    if (typeof t.beginScope != "object" || t.beginScope === null)
      throw _a("beginScope must be object"), bm;
    I5(t, t.begin, { key: "beginScope" }), t.begin = J2(t.begin, { joinWith: "" });
  }
}
function jte(t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd)
      throw _a("skip, excludeEnd, returnEnd not compatible with endScope: {}"), bm;
    if (typeof t.endScope != "object" || t.endScope === null)
      throw _a("endScope must be object"), bm;
    I5(t, t.end, { key: "endScope" }), t.end = J2(t.end, { joinWith: "" });
  }
}
function Yte(t) {
  t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
}
function Gte(t) {
  Yte(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), Xte(t), jte(t);
}
function Kte(t) {
  function e(o, a) {
    return new RegExp(
      rd(o),
      "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += M5(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = e(J2(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const c = l.findIndex((d, h) => h > 0 && d !== void 0), u = this.matchIndexes[c];
      return l.splice(0, c), Object.assign(l, u);
    }
  }
  class i {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a]) return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([c, u]) => l.addRule(c, u)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let c = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, c = u.exec(a);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function r(o) {
    const a = new i();
    return o.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && a.addRule(o.terminatorEnd, { type: "end" }), o.illegal && a.addRule(o.illegal, { type: "illegal" }), a;
  }
  function s(o, a) {
    const l = (
      /** @type CompiledMode */
      o
    );
    if (o.isCompiled) return l;
    [
      Bte,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      zte,
      Gte,
      Wte
    ].forEach((u) => u(o, a)), t.compilerExtensions.forEach((u) => u(o, a)), o.__beforeBegin = null, [
      Qte,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      Fte,
      // default to 1 relevance if not specified
      Ute
    ].forEach((u) => u(o, a)), o.isCompiled = !0;
    let c = null;
    return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), c = o.keywords.$pattern, delete o.keywords.$pattern), c = c || /\w+/, o.keywords && (o.keywords = D5(o.keywords, t.case_insensitive)), l.keywordPatternRe = e(c, !0), a && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = rd(l.end) || "", o.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + a.terminatorEnd)), o.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      o.illegal
    )), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function(u) {
      return Jte(u === "self" ? o : u);
    })), o.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        l
      );
    }), o.starts && s(o.starts, a), l.matcher = r(l), l;
  }
  if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t.classNameAliases = oo(t.classNameAliases || {}), s(
    /** @type Mode */
    t
  );
}
function L5(t) {
  return t ? t.endsWithParent || L5(t.starts) : !1;
}
function Jte(t) {
  return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function(e) {
    return oo(t, { variants: null }, e);
  })), t.cachedVariants ? t.cachedVariants : L5(t) ? oo(t, { starts: t.starts ? oo(t.starts) : null }) : Object.isFrozen(t) ? oo(t) : t;
}
var ene = "11.9.0";
let tne = class extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
};
const l1 = C5, tk = oo, nk = Symbol("nomatch"), nne = 7, B5 = function(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = [];
  let r = !0;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: pte
  };
  function l(k) {
    return a.noHighlightRe.test(k);
  }
  function c(k) {
    let N = k.className + " ";
    N += k.parentNode ? k.parentNode.className : "";
    const W = a.languageDetectRe.exec(N);
    if (W) {
      const X = S(W[1]);
      return X || (ek(s.replace("{}", W[1])), ek("Falling back to no-highlight mode for this block.", k)), X ? W[1] : "no-highlight";
    }
    return N.split(/\s+/).find((X) => l(X) || S(X));
  }
  function u(k, N, W) {
    let X = "", ee = "";
    typeof N == "object" ? (X = k, W = N.ignoreIllegals, ee = N.language) : (il("10.7.0", "highlight(lang, code, ...args) has been deprecated."), il("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ee = k, X = N), W === void 0 && (W = !0);
    const re = {
      code: X,
      language: ee
    };
    K("before:highlight", re);
    const xe = re.result ? re.result : d(re.language, re.code, W);
    return xe.code = re.code, K("after:highlight", xe), xe;
  }
  function d(k, N, W, X) {
    const ee = /* @__PURE__ */ Object.create(null);
    function re(E, z) {
      return E.keywords[z];
    }
    function xe() {
      if (!J.keywords) {
        C.addText(B);
        return;
      }
      let E = 0;
      J.keywordPatternRe.lastIndex = 0;
      let z = J.keywordPatternRe.exec(B), G = "";
      for (; z; ) {
        G += B.substring(E, z.index);
        const le = Qe.case_insensitive ? z[0].toLowerCase() : z[0], Ie = re(J, le);
        if (Ie) {
          const [dt, Uo] = Ie;
          if (C.addText(G), G = "", ee[le] = (ee[le] || 0) + 1, ee[le] <= nne && (oe += Uo), dt.startsWith("_"))
            G += z[0];
          else {
            const H = Qe.classNameAliases[dt] || dt;
            we(z[0], H);
          }
        } else
          G += z[0];
        E = J.keywordPatternRe.lastIndex, z = J.keywordPatternRe.exec(B);
      }
      G += B.substring(E), C.addText(G);
    }
    function $e() {
      if (B === "") return;
      let E = null;
      if (typeof J.subLanguage == "string") {
        if (!e[J.subLanguage]) {
          C.addText(B);
          return;
        }
        E = d(J.subLanguage, B, !0, M[J.subLanguage]), M[J.subLanguage] = /** @type {CompiledMode} */
        E._top;
      } else
        E = f(B, J.subLanguage.length ? J.subLanguage : null);
      J.relevance > 0 && (oe += E.relevance), C.__addSublanguage(E._emitter, E.language);
    }
    function be() {
      J.subLanguage != null ? $e() : xe(), B = "";
    }
    function we(E, z) {
      E !== "" && (C.startScope(z), C.addText(E), C.endScope());
    }
    function St(E, z) {
      let G = 1;
      const le = z.length - 1;
      for (; G <= le; ) {
        if (!E._emit[G]) {
          G++;
          continue;
        }
        const Ie = Qe.classNameAliases[E[G]] || E[G], dt = z[G];
        Ie ? we(dt, Ie) : (B = dt, xe(), B = ""), G++;
      }
    }
    function it(E, z) {
      return E.scope && typeof E.scope == "string" && C.openNode(Qe.classNameAliases[E.scope] || E.scope), E.beginScope && (E.beginScope._wrap ? (we(B, Qe.classNameAliases[E.beginScope._wrap] || E.beginScope._wrap), B = "") : E.beginScope._multi && (St(E.beginScope, z), B = "")), J = Object.create(E, { parent: { value: J } }), J;
    }
    function rt(E, z, G) {
      let le = Ote(E.endRe, G);
      if (le) {
        if (E["on:end"]) {
          const Ie = new YS(E);
          E["on:end"](z, Ie), Ie.isMatchIgnored && (le = !1);
        }
        if (le) {
          for (; E.endsParent && E.parent; )
            E = E.parent;
          return E;
        }
      }
      if (E.endsWithParent)
        return rt(E.parent, z, G);
    }
    function et(E) {
      return J.matcher.regexIndex === 0 ? (B += E[0], 1) : (U = !0, 0);
    }
    function It(E) {
      const z = E[0], G = E.rule, le = new YS(G), Ie = [G.__beforeBegin, G["on:begin"]];
      for (const dt of Ie)
        if (dt && (dt(E, le), le.isMatchIgnored))
          return et(z);
      return G.skip ? B += z : (G.excludeBegin && (B += z), be(), !G.returnBegin && !G.excludeBegin && (B = z)), it(G, E), G.returnBegin ? 0 : z.length;
    }
    function qt(E) {
      const z = E[0], G = N.substring(E.index), le = rt(J, E, G);
      if (!le)
        return nk;
      const Ie = J;
      J.endScope && J.endScope._wrap ? (be(), we(z, J.endScope._wrap)) : J.endScope && J.endScope._multi ? (be(), St(J.endScope, E)) : Ie.skip ? B += z : (Ie.returnEnd || Ie.excludeEnd || (B += z), be(), Ie.excludeEnd && (B = z));
      do
        J.scope && C.closeNode(), !J.skip && !J.subLanguage && (oe += J.relevance), J = J.parent;
      while (J !== le.parent);
      return le.starts && it(le.starts, E), Ie.returnEnd ? 0 : z.length;
    }
    function Te() {
      const E = [];
      for (let z = J; z !== Qe; z = z.parent)
        z.scope && E.unshift(z.scope);
      E.forEach((z) => C.openNode(z));
    }
    let gt = {};
    function kt(E, z) {
      const G = z && z[0];
      if (B += E, G == null)
        return be(), 0;
      if (gt.type === "begin" && z.type === "end" && gt.index === z.index && G === "") {
        if (B += N.slice(z.index, z.index + 1), !r) {
          const le = new Error(`0 width match regex (${k})`);
          throw le.languageName = k, le.badRule = gt.rule, le;
        }
        return 1;
      }
      if (gt = z, z.type === "begin")
        return It(z);
      if (z.type === "illegal" && !W) {
        const le = new Error('Illegal lexeme "' + G + '" for mode "' + (J.scope || "<unnamed>") + '"');
        throw le.mode = J, le;
      } else if (z.type === "end") {
        const le = qt(z);
        if (le !== nk)
          return le;
      }
      if (z.type === "illegal" && G === "")
        return 1;
      if (ye > 1e5 && ye > z.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return B += G, G.length;
    }
    const Qe = S(k);
    if (!Qe)
      throw _a(s.replace("{}", k)), new Error('Unknown language: "' + k + '"');
    const yn = Kte(Qe);
    let Gt = "", J = X || yn;
    const M = {}, C = new a.__emitter(a);
    Te();
    let B = "", oe = 0, Ce = 0, ye = 0, U = !1;
    try {
      if (Qe.__emitTokens)
        Qe.__emitTokens(N, C);
      else {
        for (J.matcher.considerAll(); ; ) {
          ye++, U ? U = !1 : J.matcher.considerAll(), J.matcher.lastIndex = Ce;
          const E = J.matcher.exec(N);
          if (!E) break;
          const z = N.substring(Ce, E.index), G = kt(z, E);
          Ce = E.index + G;
        }
        kt(N.substring(Ce));
      }
      return C.finalize(), Gt = C.toHTML(), {
        language: k,
        value: Gt,
        relevance: oe,
        illegal: !1,
        _emitter: C,
        _top: J
      };
    } catch (E) {
      if (E.message && E.message.includes("Illegal"))
        return {
          language: k,
          value: l1(N),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: E.message,
            index: Ce,
            context: N.slice(Ce - 100, Ce + 100),
            mode: E.mode,
            resultSoFar: Gt
          },
          _emitter: C
        };
      if (r)
        return {
          language: k,
          value: l1(N),
          illegal: !1,
          relevance: 0,
          errorRaised: E,
          _emitter: C,
          _top: J
        };
      throw E;
    }
  }
  function h(k) {
    const N = {
      value: l1(k),
      illegal: !1,
      relevance: 0,
      _top: o,
      _emitter: new a.__emitter(a)
    };
    return N._emitter.addText(k), N;
  }
  function f(k, N) {
    N = N || a.languages || Object.keys(e);
    const W = h(k), X = N.filter(S).filter(I).map(
      (be) => d(be, k, !1)
    );
    X.unshift(W);
    const ee = X.sort((be, we) => {
      if (be.relevance !== we.relevance) return we.relevance - be.relevance;
      if (be.language && we.language) {
        if (S(be.language).supersetOf === we.language)
          return 1;
        if (S(we.language).supersetOf === be.language)
          return -1;
      }
      return 0;
    }), [re, xe] = ee, $e = re;
    return $e.secondBest = xe, $e;
  }
  function p(k, N, W) {
    const X = N && n[N] || W;
    k.classList.add("hljs"), k.classList.add(`language-${X}`);
  }
  function m(k) {
    let N = null;
    const W = c(k);
    if (l(W)) return;
    if (K(
      "before:highlightElement",
      { el: k, language: W }
    ), k.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", k);
      return;
    }
    if (k.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(k)), a.throwUnescapedHTML))
      throw new tne(
        "One of your code blocks includes unescaped HTML.",
        k.innerHTML
      );
    N = k;
    const X = N.textContent, ee = W ? u(X, { language: W, ignoreIllegals: !0 }) : f(X);
    k.innerHTML = ee.value, k.dataset.highlighted = "yes", p(k, W, ee.language), k.result = {
      language: ee.language,
      // TODO: remove with version 11.0
      re: ee.relevance,
      relevance: ee.relevance
    }, ee.secondBest && (k.secondBest = {
      language: ee.secondBest.language,
      relevance: ee.secondBest.relevance
    }), K("after:highlightElement", { el: k, result: ee, text: X });
  }
  function g(k) {
    a = tk(a, k);
  }
  const b = () => {
    O(), il("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function _() {
    O(), il("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let y = !1;
  function O() {
    if (document.readyState === "loading") {
      y = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(m);
  }
  function x() {
    y && O();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", x, !1);
  function v(k, N) {
    let W = null;
    try {
      W = N(t);
    } catch (X) {
      if (_a("Language definition for '{}' could not be registered.".replace("{}", k)), r)
        _a(X);
      else
        throw X;
      W = o;
    }
    W.name || (W.name = k), e[k] = W, W.rawDefinition = N.bind(null, t), W.aliases && $(W.aliases, { languageName: k });
  }
  function w(k) {
    delete e[k];
    for (const N of Object.keys(n))
      n[N] === k && delete n[N];
  }
  function T() {
    return Object.keys(e);
  }
  function S(k) {
    return k = (k || "").toLowerCase(), e[k] || e[n[k]];
  }
  function $(k, { languageName: N }) {
    typeof k == "string" && (k = [k]), k.forEach((W) => {
      n[W.toLowerCase()] = N;
    });
  }
  function I(k) {
    const N = S(k);
    return N && !N.disableAutodetect;
  }
  function F(k) {
    k["before:highlightBlock"] && !k["before:highlightElement"] && (k["before:highlightElement"] = (N) => {
      k["before:highlightBlock"](
        Object.assign({ block: N.el }, N)
      );
    }), k["after:highlightBlock"] && !k["after:highlightElement"] && (k["after:highlightElement"] = (N) => {
      k["after:highlightBlock"](
        Object.assign({ block: N.el }, N)
      );
    });
  }
  function V(k) {
    F(k), i.push(k);
  }
  function q(k) {
    const N = i.indexOf(k);
    N !== -1 && i.splice(N, 1);
  }
  function K(k, N) {
    const W = k;
    i.forEach(function(X) {
      X[W] && X[W](N);
    });
  }
  function ie(k) {
    return il("10.7.0", "highlightBlock will be removed entirely in v12.0"), il("10.7.0", "Please use highlightElement now."), m(k);
  }
  Object.assign(t, {
    highlight: u,
    highlightAuto: f,
    highlightAll: O,
    highlightElement: m,
    // TODO: Remove with v12 API
    highlightBlock: ie,
    configure: g,
    initHighlighting: b,
    initHighlightingOnLoad: _,
    registerLanguage: v,
    unregisterLanguage: w,
    listLanguages: T,
    getLanguage: S,
    registerAliases: $,
    autoDetection: I,
    inherit: tk,
    addPlugin: V,
    removePlugin: q
  }), t.debugMode = function() {
    r = !1;
  }, t.safeMode = function() {
    r = !0;
  }, t.versionString = ene, t.regex = {
    concat: Za,
    lookahead: T5,
    either: K2,
    optional: gte,
    anyNumberOfTimes: mte
  };
  for (const k in Xh)
    typeof Xh[k] == "object" && E5(Xh[k]);
  return Object.assign(t, Xh), t;
}, Kl = B5({});
Kl.newInstance = () => B5({});
var ine = Kl;
Kl.HighlightJS = Kl;
Kl.default = Kl;
var rne = /* @__PURE__ */ cte(ine);
function Q5(t, e = []) {
  return t.map((n) => {
    const i = [...e, ...n.properties ? n.properties.className : []];
    return n.children ? Q5(n.children, i) : {
      text: n.value,
      classes: i
    };
  }).flat();
}
function ik(t) {
  return t.value || t.children || [];
}
function sne(t) {
  return !!rne.getLanguage(t);
}
function rk({ doc: t, name: e, lowlight: n, defaultLanguage: i }) {
  const r = [];
  return lO(t, (s) => s.type.name === e).forEach((s) => {
    let o = s.pos + 1;
    const a = s.node.attrs.language || i, l = n.listLanguages(), c = a && (l.includes(a) || sne(a)) ? ik(n.highlight(a, s.node.textContent)) : ik(n.highlightAuto(s.node.textContent));
    Q5(c).forEach((u) => {
      const d = o + u.text.length;
      if (u.classes.length) {
        const h = zt.inline(o, d, {
          class: u.classes.join(" ")
        });
        r.push(h);
      }
      o = d;
    });
  }), We.create(t, r);
}
function one(t) {
  return typeof t == "function";
}
function ane({ name: t, lowlight: e, defaultLanguage: n }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((r) => one(e[r])))
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  const i = new Ue({
    key: new Ke("lowlight"),
    state: {
      init: (r, { doc: s }) => rk({
        doc: s,
        name: t,
        lowlight: e,
        defaultLanguage: n
      }),
      apply: (r, s, o, a) => {
        const l = o.selection.$head.parent.type.name, c = a.selection.$head.parent.type.name, u = lO(o.doc, (h) => h.type.name === t), d = lO(a.doc, (h) => h.type.name === t);
        return r.docChanged && ([l, c].includes(t) || d.length !== u.length || r.steps.some((h) => (
          // @ts-ignore
          h.from !== void 0 && h.to !== void 0 && u.some((f) => (
            // @ts-ignore
            f.pos >= h.from && f.pos + f.node.nodeSize <= h.to
          ))
        ))) ? rk({
          doc: r.doc,
          name: t,
          lowlight: e,
          defaultLanguage: n
        }) : s.map(r.mapping, r.doc);
      }
    },
    props: {
      decorations(r) {
        return i.getState(r);
      }
    }
  });
  return i;
}
const jh = lte.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) === null || t === void 0 ? void 0 : t.call(this),
      lowlight: {},
      defaultLanguage: null
    };
  },
  addProseMirrorPlugins() {
    var t;
    return [
      ...((t = this.parent) === null || t === void 0 ? void 0 : t.call(this)) || [],
      ane({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ];
  }
}), lne = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, cne = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-8 5H9v2c0 1.1-.9 2-2 2c1.1 0 2 .9 2 2v2h2v2H9c-1.1 0-2-.9-2-2v-1c0-1.1-.9-2-2-2v-2c1.1 0 2-.9 2-2V8c0-1.1.9-2 2-2h2zm8 5c-1.1 0-2 .9-2 2v1c0 1.1-.9 2-2 2h-2v-2h2v-2c0-1.1.9-2 2-2c-1.1 0-2-.9-2-2V8h-2V6h2c1.1 0 2 .9 2 2v1c0 1.1.9 2 2 2z"
}, null, -1), une = [
  cne
];
function dne(t, e) {
  return P(), L("svg", lne, [...une]);
}
const c1 = { name: "mdi-code-braces-box", render: dne };
function hne(t) {
  return gD() ? (bD(t), !0) : !1;
}
function El(t) {
  return typeof t == "function" ? t() : Z(t);
}
const F5 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Om = () => {
};
function fne(t, e) {
  function n(...i) {
    return new Promise((r, s) => {
      Promise.resolve(t(() => e.apply(this, i), { fn: e, thisArg: this, args: i })).then(r).catch(s);
    });
  }
  return n;
}
function pne(t, e = {}) {
  let n, i, r = Om;
  const s = (a) => {
    clearTimeout(a), r(), r = Om;
  };
  return (a) => {
    const l = El(t), c = El(e.maxWait);
    return n && s(n), l <= 0 || c !== void 0 && c <= 0 ? (i && (s(i), i = null), Promise.resolve(a())) : new Promise((u, d) => {
      r = e.rejectOnCancel ? d : u, c && !i && (i = setTimeout(() => {
        n && s(n), i = null, u(a());
      }, c)), n = setTimeout(() => {
        i && s(i), i = null, u(a());
      }, l);
    });
  };
}
function z5(t) {
  return Bd();
}
function mne(t, e = 200, n = {}) {
  return fne(
    pne(e, n),
    t
  );
}
function gne(t, e = !0, n) {
  z5() ? Gi(t, n) : e ? t() : Il(t);
}
function bne(t, e) {
  z5() && Fy(t, e);
}
function One(t, e, n = {}) {
  const {
    immediate: i = !0
  } = n, r = pt(!1);
  let s = null;
  function o() {
    s && (clearTimeout(s), s = null);
  }
  function a() {
    r.value = !1, o();
  }
  function l(...c) {
    o(), r.value = !0, s = setTimeout(() => {
      r.value = !1, s = null, t(...c);
    }, El(e));
  }
  return i && (r.value = !0, F5 && l()), hne(a), {
    isPending: mD(r),
    start: l,
    stop: a
  };
}
function yne(t = 1e3, e = {}) {
  const {
    controls: n = !1,
    callback: i
  } = e, r = One(
    i ?? Om,
    t,
    e
  ), s = Be(() => !r.isPending.value);
  return n ? {
    ready: s,
    ...r
  } : s;
}
const _ne = F5 ? window.document : void 0;
function vne(t, e = Om, n = {}) {
  const {
    immediate: i = !0,
    manual: r = !1,
    type: s = "text/javascript",
    async: o = !0,
    crossOrigin: a,
    referrerPolicy: l,
    noModule: c,
    defer: u,
    document: d = _ne,
    attrs: h = {}
  } = n, f = pt(null);
  let p = null;
  const m = (_) => new Promise((y, O) => {
    const x = (T) => (f.value = T, y(T), T);
    if (!d) {
      y(!1);
      return;
    }
    let v = !1, w = d.querySelector(`script[src="${El(t)}"]`);
    w ? w.hasAttribute("data-loaded") && x(w) : (w = d.createElement("script"), w.type = s, w.async = o, w.src = El(t), u && (w.defer = u), a && (w.crossOrigin = a), c && (w.noModule = c), l && (w.referrerPolicy = l), Object.entries(h).forEach(([T, S]) => w == null ? void 0 : w.setAttribute(T, S)), v = !0), w.addEventListener("error", (T) => O(T)), w.addEventListener("abort", (T) => O(T)), w.addEventListener("load", () => {
      w.setAttribute("data-loaded", "true"), e(w), x(w);
    }), v && (w = d.head.appendChild(w)), _ || x(w);
  }), g = (_ = !0) => (p || (p = m(_)), p), b = () => {
    if (!d)
      return;
    p = null, f.value && (f.value = null);
    const _ = d.querySelector(`script[src="${El(t)}"]`);
    _ && d.head.removeChild(_);
  };
  return i && !r && gne(g), r || bne(b), { scriptTag: f, load: g, unload: b };
}
const xne = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, wne = /* @__PURE__ */ A("path", {
  d: "M14 8H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2V10c0-1.103-.897-2-2-2z",
  fill: "currentColor"
}, null, -1), Sne = /* @__PURE__ */ A("path", {
  d: "M20 2H10a2 2 0 0 0-2 2v2h8a2 2 0 0 1 2 2v8h2a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z",
  fill: "currentColor"
}, null, -1), kne = [
  wne,
  Sne
];
function Ene(t, e) {
  return P(), L("svg", xne, [...kne]);
}
const Cne = { name: "bx-bxs-copy", render: Ene }, Ane = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Tne = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m12 16l-6-6h12z"
}, null, -1), Mne = [
  Tne
];
function Pne(t, e) {
  return P(), L("svg", Ane, [...Mne]);
}
const Rne = { name: "ri-arrow-down-s-fill", render: Pne }, $ne = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Nne = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m16 12l-6 6V6z"
}, null, -1), Dne = [
  Nne
];
function Ine(t, e) {
  return P(), L("svg", $ne, [...Dne]);
}
const Lne = { name: "ri-arrow-right-s-fill", render: Ine }, Bne = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Qne = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10s-4.477 10-10 10m0-2a8 8 0 1 0 0-16a8 8 0 0 0 0 16m-.997-4L6.76 11.757l1.414-1.414l2.829 2.829l5.657-5.657l1.414 1.414z"
}, null, -1), Fne = [
  Qne
];
function zne(t, e) {
  return P(), L("svg", Bne, [...Fne]);
}
const Une = { name: "ri-checkbox-circle-line", render: zne };
function Wne(t) {
  const e = {
    className: "subst",
    variants: [{ begin: "\\$[A-Za-z0-9_]+" }]
  }, n = {
    className: "subst",
    variants: [
      {
        begin: /\$\{/,
        end: /\}/
      }
    ],
    keywords: "true false null this is new super"
  }, i = {
    className: "string",
    variants: [
      {
        begin: "r'''",
        end: "'''"
      },
      {
        begin: 'r"""',
        end: '"""'
      },
      {
        begin: "r'",
        end: "'",
        illegal: "\\n"
      },
      {
        begin: 'r"',
        end: '"',
        illegal: "\\n"
      },
      {
        begin: "'''",
        end: "'''",
        contains: [
          t.BACKSLASH_ESCAPE,
          e,
          n
        ]
      },
      {
        begin: '"""',
        end: '"""',
        contains: [
          t.BACKSLASH_ESCAPE,
          e,
          n
        ]
      },
      {
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [
          t.BACKSLASH_ESCAPE,
          e,
          n
        ]
      },
      {
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [
          t.BACKSLASH_ESCAPE,
          e,
          n
        ]
      }
    ]
  };
  n.contains = [
    t.C_NUMBER_MODE,
    i
  ];
  const r = [
    // dart:core
    "Comparable",
    "DateTime",
    "Duration",
    "Function",
    "Iterable",
    "Iterator",
    "List",
    "Map",
    "Match",
    "Object",
    "Pattern",
    "RegExp",
    "Set",
    "Stopwatch",
    "String",
    "StringBuffer",
    "StringSink",
    "Symbol",
    "Type",
    "Uri",
    "bool",
    "double",
    "int",
    "num",
    // dart:html
    "Element",
    "ElementList"
  ], s = r.map((l) => `${l}?`);
  return {
    name: "Dart",
    keywords: {
      keyword: [
        "abstract",
        "as",
        "assert",
        "async",
        "await",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "covariant",
        "default",
        "deferred",
        "do",
        "dynamic",
        "else",
        "enum",
        "export",
        "extends",
        "extension",
        "external",
        "factory",
        "false",
        "final",
        "finally",
        "for",
        "Function",
        "get",
        "hide",
        "if",
        "implements",
        "import",
        "in",
        "interface",
        "is",
        "late",
        "library",
        "mixin",
        "new",
        "null",
        "on",
        "operator",
        "part",
        "required",
        "rethrow",
        "return",
        "sealed",
        "set",
        "show",
        "static",
        "super",
        "switch",
        "sync",
        "this",
        "throw",
        "true",
        "try",
        "typedef",
        "var",
        "void",
        "when",
        "while",
        "with",
        "yield"
      ],
      built_in: r.concat(s).concat([
        // dart:core
        "Never",
        "Null",
        "dynamic",
        "print",
        // dart:html
        "document",
        "querySelector",
        "querySelectorAll",
        "window"
      ]),
      $pattern: /[A-Za-z][A-Za-z0-9_]*\??/
    },
    contains: [
      i,
      t.COMMENT(
        /\/\*\*(?!\/)/,
        /\*\//,
        {
          subLanguage: "markdown",
          relevance: 0
        }
      ),
      t.COMMENT(
        /\/{3,} ?/,
        /$/,
        { contains: [
          {
            subLanguage: "markdown",
            begin: ".",
            end: "$",
            relevance: 0
          }
        ] }
      ),
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "class",
        beginKeywords: "class interface",
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      t.C_NUMBER_MODE,
      {
        className: "meta",
        begin: "@[A-Za-z]+"
      },
      {
        begin: "=>"
        // No markup, just a relevance booster
      }
    ]
  };
}
function Vne(t) {
  const e = t.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), i = /[\p{L}0-9._:-]+/u, r = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, o = t.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), a = t.inherit(t.APOS_STRING_MODE, { className: "string" }), l = t.inherit(t.QUOTE_STRING_MODE, { className: "string" }), c = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: i,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [r]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [r]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          l,
          a,
          o,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  o,
                  l,
                  a
                ]
              }
            ]
          }
        ]
      },
      t.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      r,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: c
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function Zne(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), i = "decltype\\(auto\\)", r = "[a-zA-Z_]\\w*::", o = "(?!struct)(" + i + "|" + e.optional(r) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, h = {
    className: "title",
    begin: e.optional(r) + t.IDENT_RE,
    relevance: 0
  }, f = e.optional(r) + t.IDENT_RE + "\\s*\\(", p = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], m = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], b = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], O = {
    type: m,
    keyword: p,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, x = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: b
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, v = [
    x,
    d,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], w = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: O,
    contains: v.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: O,
        contains: v.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, T = {
    className: "function",
    begin: "(" + o + "[\\*&\\s]+)+" + f,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: O,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: i,
        keywords: O,
        relevance: 0
      },
      {
        begin: f,
        returnBegin: !0,
        contains: [h],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          u
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: O,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          u,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: O,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              u,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: O,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      w,
      T,
      x,
      v,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: O,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: t.IDENT_RE + "::",
          keywords: O
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function Hne(t) {
  const e = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  }, n = Zne(t), i = (
    /** @type {Record<string,any>} */
    n.keywords
  );
  return i.type = [
    ...i.type,
    ...e.type
  ], i.literal = [
    ...i.literal,
    ...e.literal
  ], i.built_in = [
    ...i.built_in,
    ...e.built_in
  ], i._hints = e._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
}
function qne(t) {
  const e = t.regex, n = {}, i = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [n]
      }
      // default values
    ]
  };
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      i
    ]
  });
  const r = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [t.BACKSLASH_ESCAPE]
  }, s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      t.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, o = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      n,
      r
    ]
  };
  r.contains.push(o);
  const a = {
    match: /\\"/
  }, l = {
    className: "string",
    begin: /'/,
    end: /'/
  }, c = {
    match: /\\'/
  }, u = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      t.NUMBER_MODE,
      n
    ]
  }, d = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], h = t.SHEBANG({
    binary: `(${d.join("|")})`,
    relevance: 10
  }), f = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [t.inherit(t.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, p = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], m = [
    "true",
    "false"
  ], g = { match: /(\/[a-z._-]+)+/ }, b = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], _ = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], y = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], O = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: p,
      literal: m,
      built_in: [
        ...b,
        ..._,
        // Shell modifiers
        "set",
        "shopt",
        ...y,
        ...O
      ]
    },
    contains: [
      h,
      // to catch known shells and boost relevancy
      t.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      f,
      u,
      t.HASH_COMMENT_MODE,
      s,
      g,
      o,
      a,
      l,
      c,
      n
    ]
  };
}
function Xne(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), i = "decltype\\(auto\\)", r = "[a-zA-Z_]\\w*::", o = "(" + i + "|" + e.optional(r) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, h = {
    className: "title",
    begin: e.optional(r) + t.IDENT_RE,
    relevance: 0
  }, f = e.optional(r) + t.IDENT_RE + "\\s*\\(", g = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal128",
      // modifiers
      "const",
      "static",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, b = [
    d,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], _ = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: g,
    contains: b.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: g,
        contains: b.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, y = {
    begin: "(" + o + "[\\*&\\s]+)+" + f,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: g,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: i,
        keywords: g,
        relevance: 0
      },
      {
        begin: f,
        returnBegin: !0,
        contains: [t.inherit(h, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: g,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          u,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: g,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              u,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: g,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      _,
      y,
      b,
      [
        d,
        {
          begin: t.IDENT_RE + "::",
          keywords: g
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            t.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: d,
      strings: c,
      keywords: g
    }
  };
}
function jne(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), i = "decltype\\(auto\\)", r = "[a-zA-Z_]\\w*::", o = "(?!struct)(" + i + "|" + e.optional(r) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, h = {
    className: "title",
    begin: e.optional(r) + t.IDENT_RE,
    relevance: 0
  }, f = e.optional(r) + t.IDENT_RE + "\\s*\\(", p = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], m = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], b = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], O = {
    type: m,
    keyword: p,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, x = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: b
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, v = [
    x,
    d,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], w = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: O,
    contains: v.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: O,
        contains: v.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, T = {
    className: "function",
    begin: "(" + o + "[\\*&\\s]+)+" + f,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: O,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: i,
        keywords: O,
        relevance: 0
      },
      {
        begin: f,
        returnBegin: !0,
        contains: [h],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          u
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: O,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          u,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: O,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              u,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: O,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      w,
      T,
      x,
      v,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
          end: ">",
          keywords: O,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: t.IDENT_RE + "::",
          keywords: O
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function Yne(t) {
  const e = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ], n = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ], i = [
    "default",
    "false",
    "null",
    "true"
  ], r = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ], s = [
    "add",
    "alias",
    "and",
    "ascending",
    "async",
    "await",
    "by",
    "descending",
    "equals",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "remove",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ], o = {
    keyword: r.concat(s),
    built_in: e,
    literal: i
  }, a = t.inherit(t.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, c = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }, u = t.inherit(c, { illegal: /\n/ }), d = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: o
  }, h = t.inherit(d, { illegal: /\n/ }), f = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      t.BACKSLASH_ESCAPE,
      h
    ]
  }, p = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      d
    ]
  }, m = t.inherit(p, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      h
    ]
  });
  d.contains = [
    p,
    f,
    c,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    l,
    t.C_BLOCK_COMMENT_MODE
  ], h.contains = [
    m,
    f,
    u,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    l,
    t.inherit(t.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const g = { variants: [
    p,
    f,
    c,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE
  ] }, b = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      a
    ]
  }, _ = t.IDENT_RE + "(<" + t.IDENT_RE + "(\\s*,\\s*" + t.IDENT_RE + ")*>)?(\\[\\])?", y = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + t.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: o,
    illegal: /::/,
    contains: [
      t.COMMENT(
        "///",
        "$",
        {
          returnBegin: !0,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      g,
      l,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          a,
          b,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          b,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + _ + "\\s+)+" + t.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: o,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: n.join(" "),
            relevance: 0
          },
          {
            begin: t.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [
              t.TITLE_MODE,
              b
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: o,
            relevance: 0,
            contains: [
              g,
              l,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      y
    ]
  };
}
const Gne = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), Kne = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], Jne = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], eie = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], tie = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], nie = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function iie(t) {
  const e = t.regex, n = Gne(t), i = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, r = "and or not only", s = /@-?\w[\w]*(-\w+)*/, o = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      n.BLOCK_COMMENT,
      i,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      n.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + o,
        relevance: 0
      },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + eie.join("|") + ")" },
          { begin: ":(:)?(" + tie.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      n.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + nie.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...a,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...a,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: e.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: s
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: r,
              attribute: Jne.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...a,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + Kne.join("|") + ")\\b"
      }
    ]
  };
}
function rie(t) {
  const e = t.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: e.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: e.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function sie(t) {
  const s = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: s,
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            begin: t.C_NUMBER_RE + "[i]",
            relevance: 1
          },
          t.C_NUMBER_MODE
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          t.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: s,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function oie(t) {
  const e = t.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      t.HASH_COMMENT_MODE,
      t.QUOTE_STRING_MODE,
      t.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: e.concat(n, e.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function aie(t) {
  const e = t.regex, n = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: t.NUMBER_RE }
    ]
  }, i = t.COMMENT();
  i.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const r = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, s = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, o = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, a = {
    begin: /\[/,
    end: /\]/,
    contains: [
      i,
      s,
      r,
      o,
      n,
      "self"
    ],
    relevance: 0
  }, l = /[A-Za-z0-9_-]+/, c = /"(\\"|[^"])*"/, u = /'[^']*'/, d = e.either(
    l,
    c,
    u
  ), h = e.concat(
    d,
    "(\\s*\\.\\s*",
    d,
    ")*",
    e.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      i,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: h,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            i,
            a,
            s,
            r,
            o,
            n
          ]
        }
      }
    ]
  };
}
var fl = "[0-9](_*[0-9])*", Yh = `\\.(${fl})`, Gh = "[0-9a-fA-F](_*[0-9a-fA-F])*", sk = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${fl})((${Yh})|\\.)?|(${Yh}))[eE][+-]?(${fl})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${fl})((${Yh})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Yh})[fFdD]?\\b` },
    { begin: `\\b(${fl})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Gh})\\.?|(${Gh})?\\.(${Gh}))[pP][+-]?(${fl})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Gh})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function U5(t, e, n) {
  return n === -1 ? "" : t.replace(e, (i) => U5(t, e, n - 1));
}
function lie(t) {
  const e = t.regex, n = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", i = n + U5("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, c = {
    className: "meta",
    begin: "@" + n,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, u = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: l,
    relevance: 0,
    contains: [t.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [t.BACKSLASH_ESCAPE]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          e.concat(/(?!else)/, n),
          /\s+/,
          n,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          u,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + i + "\\s+)",
          t.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              c,
              t.APOS_STRING_MODE,
              t.QUOTE_STRING_MODE,
              sk,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      sk,
      c
    ]
  };
}
const ok = "[A-Za-z$_][0-9A-Za-z$_]*", cie = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], uie = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], W5 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], V5 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Z5 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], die = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], hie = [].concat(
  Z5,
  W5,
  V5
);
function fie(t) {
  const e = t.regex, n = (N, { after: W }) => {
    const X = "</" + N[0].slice(1);
    return N.input.indexOf(X, W) !== -1;
  }, i = ok, r = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (N, W) => {
      const X = N[0].length + N.index, ee = N.input[X];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        ee === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        ee === ","
      ) {
        W.ignoreMatch();
        return;
      }
      ee === ">" && (n(N, { after: X }) || W.ignoreMatch());
      let re;
      const xe = N.input.substring(X);
      if (re = xe.match(/^\s*=/)) {
        W.ignoreMatch();
        return;
      }
      if ((re = xe.match(/^\s+extends\s+/)) && re.index === 0) {
        W.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: ok,
    keyword: cie,
    literal: uie,
    built_in: hie,
    "variable.language": die
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, h = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, f = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "xml"
    }
  }, p = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "css"
    }
  }, m = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      h
    ]
  }, _ = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: i + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, y = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    f,
    p,
    m,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  h.contains = y.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(y)
  });
  const O = [].concat(_, h.contains), x = O.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(O)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: x
  }, w = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          i,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(i, "(", e.concat(/\./, i), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          i
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, T = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...W5,
        ...V5
      ]
    }
  }, S = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, $ = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          i,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, I = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function F(N) {
    return e.concat("(?!", N.join("|"), ")");
  }
  const V = {
    match: e.concat(
      /\b/,
      F([
        ...Z5,
        "super",
        "import"
      ]),
      i,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, q = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(i, /(?![0-9A-Za-z$_(])/)
    )),
    end: i,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, K = {
    match: [
      /get|set/,
      /\s+/,
      i,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, ie = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", k = {
    match: [
      /const|var|let/,
      /\s+/,
      i,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(ie)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: T },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      S,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      f,
      p,
      m,
      g,
      _,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      T,
      {
        className: "attr",
        begin: i + e.lookahead(":"),
        relevance: 0
      },
      k,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          _,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: ie,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: x
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: r.begin, end: r.end },
              { match: s },
              {
                begin: o.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": o.isTrulyOpeningTag,
                end: o.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: o.begin,
                end: o.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      $,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          v,
          t.inherit(t.TITLE_MODE, { begin: i, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      q,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + i,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      V,
      I,
      w,
      K,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function pie(t) {
  const e = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, n = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, i = [
    "true",
    "false",
    "null"
  ], r = {
    scope: "literal",
    beginKeywords: i.join(" ")
  };
  return {
    name: "JSON",
    keywords: {
      literal: i
    },
    contains: [
      e,
      n,
      t.QUOTE_STRING_MODE,
      r,
      t.C_NUMBER_MODE,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var pl = "[0-9](_*[0-9])*", Kh = `\\.(${pl})`, Jh = "[0-9a-fA-F](_*[0-9a-fA-F])*", mie = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${pl})((${Kh})|\\.)?|(${Kh}))[eE][+-]?(${pl})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${pl})((${Kh})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Kh})[fFdD]?\\b` },
    { begin: `\\b(${pl})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Jh})\\.?|(${Jh})?\\.(${Jh}))[pP][+-]?(${pl})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Jh})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function gie(t) {
  const e = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, n = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, i = {
    className: "symbol",
    begin: t.UNDERSCORE_IDENT_RE + "@"
  }, r = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [t.C_NUMBER_MODE]
  }, s = {
    className: "variable",
    begin: "\\$" + t.UNDERSCORE_IDENT_RE
  }, o = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          s,
          r
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          t.BACKSLASH_ESCAPE,
          s,
          r
        ]
      }
    ]
  };
  r.contains.push(o);
  const a = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + t.UNDERSCORE_IDENT_RE + ")?"
  }, l = {
    className: "meta",
    begin: "@" + t.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          t.inherit(o, { className: "string" }),
          "self"
        ]
      }
    ]
  }, c = mie, u = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [t.C_BLOCK_COMMENT_MODE] }
  ), d = { variants: [
    {
      className: "type",
      begin: t.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, h = d;
  return h.variants[1].contains = [d], d.variants[1].contains = [h], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: e,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      t.C_LINE_COMMENT_MODE,
      u,
      n,
      i,
      a,
      l,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: e,
        relevance: 5,
        contains: [
          {
            begin: t.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [t.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: e,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  d,
                  t.C_LINE_COMMENT_MODE,
                  u
                ],
                relevance: 0
              },
              t.C_LINE_COMMENT_MODE,
              u,
              a,
              l,
              o,
              t.C_NUMBER_MODE
            ]
          },
          u
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          t.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          a,
          l
        ]
      },
      o,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      c
    ]
  };
}
const bie = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), Oie = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], yie = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], H5 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], q5 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], _ie = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse(), vie = H5.concat(q5);
function xie(t) {
  const e = bie(t), n = vie, i = "and or not only", r = "[\\w-]+", s = "(" + r + "|@\\{" + r + "\\})", o = [], a = [], l = function(y) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + y + ".*?" + y
    };
  }, c = function(y, O, x) {
    return {
      className: y,
      begin: O,
      relevance: x
    };
  }, u = {
    $pattern: /[a-z-]+/,
    keyword: i,
    attribute: yie.join(" ")
  }, d = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: a,
    keywords: u,
    relevance: 0
  };
  a.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    e.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    e.HEXCOLOR,
    d,
    c("variable", "@@?" + r, 10),
    c("variable", "@\\{" + r + "\\}"),
    c("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (its here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: r + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    e.IMPORTANT,
    { beginKeywords: "and not" },
    e.FUNCTION_DISPATCH
  );
  const h = a.concat({
    begin: /\{/,
    end: /\}/,
    contains: o
  }), f = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(a)
    // using this form to override VALUEs 'function' match
  }, p = {
    begin: s + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + _ie.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: a
        }
      }
    ]
  }, m = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: u,
      returnEnd: !0,
      contains: a,
      relevance: 0
    }
  }, g = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (well still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + r + "\\s*:",
        relevance: 15
      },
      { begin: "@" + r }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: h
    }
  }, b = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: s,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      f,
      c("keyword", "all\\b"),
      c("variable", "@\\{" + r + "\\}"),
      // otherwise its identified as tag
      {
        begin: "\\b(" + Oie.join("|") + ")\\b",
        className: "selector-tag"
      },
      e.CSS_NUMBER_MODE,
      c("selector-tag", s, 0),
      c("selector-id", "#" + s),
      c("selector-class", "\\." + s, 0),
      c("selector-tag", "&", 0),
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + H5.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + q5.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: h
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      e.FUNCTION_DISPATCH
    ]
  }, _ = {
    begin: r + `:(:)?(${n.join("|")})`,
    returnBegin: !0,
    contains: [b]
  };
  return o.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    m,
    g,
    _,
    p,
    b,
    f,
    e.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: o
  };
}
function wie(t) {
  const e = "\\[=*\\[", n = "\\]=*\\]", i = {
    begin: e,
    end: n,
    contains: ["self"]
  }, r = [
    t.COMMENT("--(?!" + e + ")", "$"),
    t.COMMENT(
      "--" + e,
      n,
      {
        contains: [i],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    keywords: {
      $pattern: t.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: r.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          t.inherit(t.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: r
          }
        ].concat(r)
      },
      t.C_NUMBER_MODE,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: e,
        end: n,
        contains: [i],
        relevance: 5
      }
    ])
  };
}
function Sie(t) {
  const e = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + t.UNDERSCORE_IDENT_RE + "\\)",
        contains: [t.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, n = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      e
    ]
  }, i = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [e]
  }, r = { begin: "^" + t.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, s = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, o = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [e]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      t.HASH_COMMENT_MODE,
      e,
      n,
      i,
      r,
      s,
      o
    ]
  };
}
function kie(t) {
  const e = t.regex, n = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, i = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, r = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, s = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, o = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, c = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, u = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, d = t.inherit(c, { contains: [] }), h = t.inherit(u, { contains: [] });
  c.contains.push(h), u.contains.push(d);
  let f = [
    n,
    l
  ];
  return [
    c,
    u,
    d,
    h
  ].forEach((g) => {
    g.contains = g.contains.concat(f);
  }), f = f.concat(c, u), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: f
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: f
              }
            ]
          }
        ]
      },
      n,
      s,
      c,
      u,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: f,
        end: "$"
      },
      r,
      i,
      l,
      o
    ]
  };
}
function Eie(t) {
  const e = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: n,
    keyword: [
      "while",
      "export",
      "sizeof",
      "typedef",
      "const",
      "struct",
      "for",
      "union",
      "volatile",
      "static",
      "mutable",
      "if",
      "do",
      "return",
      "goto",
      "enum",
      "else",
      "break",
      "extern",
      "asm",
      "case",
      "default",
      "register",
      "explicit",
      "typename",
      "switch",
      "continue",
      "inline",
      "readonly",
      "assign",
      "readwrite",
      "self",
      "@synchronized",
      "id",
      "typeof",
      "nonatomic",
      "IBOutlet",
      "IBAction",
      "strong",
      "weak",
      "copy",
      "in",
      "out",
      "inout",
      "bycopy",
      "byref",
      "oneway",
      "__strong",
      "__weak",
      "__block",
      "__autoreleasing",
      "@private",
      "@protected",
      "@public",
      "@try",
      "@property",
      "@end",
      "@throw",
      "@catch",
      "@finally",
      "@autoreleasepool",
      "@synthesize",
      "@dynamic",
      "@selector",
      "@optional",
      "@required",
      "@encode",
      "@package",
      "@import",
      "@defs",
      "@compatibility_alias",
      "__bridge",
      "__bridge_transfer",
      "__bridge_retained",
      "__bridge_retain",
      "__covariant",
      "__contravariant",
      "__kindof",
      "_Nonnull",
      "_Nullable",
      "_Null_unspecified",
      "__FUNCTION__",
      "__PRETTY_FUNCTION__",
      "__attribute__",
      "getter",
      "setter",
      "retain",
      "unsafe_unretained",
      "nonnull",
      "nullable",
      "null_unspecified",
      "null_resettable",
      "class",
      "instancetype",
      "NS_DESIGNATED_INITIALIZER",
      "NS_UNAVAILABLE",
      "NS_REQUIRES_SUPER",
      "NS_RETURNS_INNER_POINTER",
      "NS_INLINE",
      "NS_AVAILABLE",
      "NS_DEPRECATED",
      "NS_ENUM",
      "NS_OPTIONS",
      "NS_SWIFT_UNAVAILABLE",
      "NS_ASSUME_NONNULL_BEGIN",
      "NS_ASSUME_NONNULL_END",
      "NS_REFINED_FOR_SWIFT",
      "NS_SWIFT_NAME",
      "NS_SWIFT_NOTHROW",
      "NS_DURING",
      "NS_HANDLER",
      "NS_ENDHANDLER",
      "NS_VALUERETURN",
      "NS_VOIDRETURN"
    ],
    literal: [
      "false",
      "true",
      "FALSE",
      "TRUE",
      "nil",
      "YES",
      "NO",
      "NULL"
    ],
    built_in: [
      "dispatch_once_t",
      "dispatch_queue_t",
      "dispatch_sync",
      "dispatch_async",
      "dispatch_once"
    ],
    type: [
      "int",
      "float",
      "char",
      "unsigned",
      "signed",
      "short",
      "long",
      "double",
      "wchar_t",
      "unichar",
      "void",
      "bool",
      "BOOL",
      "id|0",
      "_Bool"
    ]
  }, l = {
    $pattern: n,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: a,
    illegal: "</",
    contains: [
      e,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      t.C_NUMBER_MODE,
      t.QUOTE_STRING_MODE,
      t.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [t.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t.inherit(t.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + l.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: l,
        contains: [t.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + t.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function Cie(t) {
  const e = t.regex, n = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], i = /[dualxmsipngr]{0,12}/, r = {
    $pattern: /[\w.]+/,
    keyword: n.join(" ")
  }, s = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: r
  }, o = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, a = { variants: [
    { begin: /\$\d/ },
    { begin: e.concat(
      /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
      // negative look-ahead tries to avoid matching patterns that are not
      // Perl at all like $ident$, @ident@, etc.
      "(?![A-Za-z])(?![@$%])"
    ) },
    {
      begin: /[$%@][^\s\w{]/,
      relevance: 0
    }
  ] }, l = [
    t.BACKSLASH_ESCAPE,
    s,
    a
  ], c = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], u = (f, p, m = "\\1") => {
    const g = m === "\\1" ? m : e.concat(m, p);
    return e.concat(
      e.concat("(?:", f, ")"),
      p,
      /(?:\\.|[^\\\/])*?/,
      g,
      /(?:\\.|[^\\\/])*?/,
      m,
      i
    );
  }, d = (f, p, m) => e.concat(
    e.concat("(?:", f, ")"),
    p,
    /(?:\\.|[^\\\/])*?/,
    m,
    i
  ), h = [
    a,
    t.HASH_COMMENT_MODE,
    t.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    o,
    {
      className: "string",
      contains: l,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    {
      className: "number",
      begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",
      relevance: 0
    },
    {
      // regexp container
      begin: "(\\/\\/|" + t.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        t.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: u("s|tr|y", e.either(...c, { capture: !0 })) },
            // and then paired delmis
            { begin: u("s|tr|y", "\\(", "\\)") },
            { begin: u("s|tr|y", "\\[", "\\]") },
            { begin: u("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: d("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: d("m|qr", e.either(...c, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: d("m|qr", /\(/, /\)/) },
            { begin: d("m|qr", /\[/, /\]/) },
            { begin: d("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [t.TITLE_MODE]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return s.contains = h, o.contains = h, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: r,
    contains: h
  };
}
function Aie(t) {
  const e = t.regex, n = /(?![A-Za-z0-9])(?![$])/, i = e.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    n
  ), r = e.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  ), s = {
    scope: "variable",
    match: "\\$+" + i
  }, o = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, a = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, l = t.inherit(t.APOS_STRING_MODE, { illegal: null }), c = t.inherit(t.QUOTE_STRING_MODE, {
    illegal: null,
    contains: t.QUOTE_STRING_MODE.contains.concat(a)
  }), u = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: t.QUOTE_STRING_MODE.contains.concat(a),
    "on:begin": (V, q) => {
      q.data._beginMatch = V[1] || V[2];
    },
    "on:end": (V, q) => {
      q.data._beginMatch !== V[1] && q.ignoreMatch();
    }
  }, d = t.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), h = `[ 	
]`, f = {
    scope: "string",
    variants: [
      c,
      l,
      u,
      d
    ]
  }, p = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, m = [
    "false",
    "null",
    "true"
  ], g = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], b = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], y = {
    keyword: g,
    literal: ((V) => {
      const q = [];
      return V.forEach((K) => {
        q.push(K), K.toLowerCase() === K ? q.push(K.toUpperCase()) : q.push(K.toLowerCase());
      }), q;
    })(m),
    built_in: b
  }, O = (V) => V.map((q) => q.replace(/\|\d+$/, "")), x = { variants: [
    {
      match: [
        /new/,
        e.concat(h, "+"),
        // to prevent built ins from being confused as the class constructor call
        e.concat("(?!", O(b).join("\\b|"), "\\b)"),
        r
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, v = e.concat(i, "\\b(?!\\()"), w = { variants: [
    {
      match: [
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        v
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        r,
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        v
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        r,
        e.concat(
          "::",
          e.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        r,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, T = {
    scope: "attr",
    match: e.concat(i, e.lookahead(":"), e.lookahead(/(?!::)/))
  }, S = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: y,
    contains: [
      T,
      s,
      w,
      t.C_BLOCK_COMMENT_MODE,
      f,
      p,
      x
    ]
  }, $ = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      e.concat("(?!fn\\b|function\\b|", O(g).join("\\b|"), "|", O(b).join("\\b|"), "\\b)"),
      i,
      e.concat(h, "*"),
      e.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [S]
  };
  S.contains.push($);
  const I = [
    T,
    w,
    t.C_BLOCK_COMMENT_MODE,
    f,
    p,
    x
  ], F = {
    begin: e.concat(/#\[\s*/, r),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: m,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: m,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...I
        ]
      },
      ...I,
      {
        scope: "meta",
        match: r
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: y,
    contains: [
      F,
      t.HASH_COMMENT_MODE,
      t.COMMENT("//", "$"),
      t.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: t.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      o,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      s,
      $,
      w,
      {
        match: [
          /const/,
          /\s/,
          i
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      x,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          t.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: y,
            contains: [
              "self",
              s,
              w,
              t.C_BLOCK_COMMENT_MODE,
              f,
              p
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [t.inherit(t.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      f,
      p
    ]
  };
}
function Tie(t) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: !0
          },
          {
            begin: 'b"',
            end: '"',
            skip: !0
          },
          {
            begin: "b'",
            end: "'",
            skip: !0
          },
          t.inherit(t.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          t.inherit(t.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  };
}
function Mie(t) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function Pie(t) {
  const e = t.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), i = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], a = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: i,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, l = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, c = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: a,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          t.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          t.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  }, h = "[0-9](_?[0-9])*", f = `(\\b(${h}))?\\.(${h})|\\b(${h})\\.`, p = `\\b|${i.join("|")}`, m = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${h})|(${f}))[eE][+-]?(${h})[jJ]?(?=${p})`
      },
      {
        begin: `(${f})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${p})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${p})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${p})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${p})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${h})[jJ](?=${p})`
      }
    ]
  }, g = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: a,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, b = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: a,
        contains: [
          "self",
          l,
          m,
          d,
          t.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return c.contains = [
    d,
    m,
    l
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: a,
    illegal: /(<\/|\?)|=>/,
    contains: [
      l,
      m,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      d,
      g,
      t.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          n
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [b]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              n,
              /\s*/,
              /\(\s*/,
              n,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              n
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          m,
          b,
          d
        ]
      }
    ]
  };
}
function Rie(t) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function $ie(t) {
  const e = t.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, i = e.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  ), r = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, s = e.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: n,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      t.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldnt be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: e.lookahead(e.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: !0
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: n },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      t.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [t.BACKSLASH_ESCAPE],
        variants: [
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              r,
              i
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              i
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              s,
              i
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              i
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          n,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: r },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: s
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function Nie(t) {
  const e = t.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", i = e.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), r = e.concat(i, /(::\w+)*/), o = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, a = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, l = {
    begin: "#<",
    end: ">"
  }, c = [
    t.COMMENT(
      "#",
      "$",
      { contains: [a] }
    ),
    t.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [a],
        relevance: 10
      }
    ),
    t.COMMENT("^__END__", t.MATCH_NOTHING_RE)
  ], u = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: o
  }, d = {
    className: "string",
    contains: [
      t.BACKSLASH_ESCAPE,
      u
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: e.concat(
          /<<[-~]?'?/,
          e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          t.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              t.BACKSLASH_ESCAPE,
              u
            ]
          })
        ]
      }
    ]
  }, h = "[1-9](_?[0-9])*|0", f = "[0-9](_?[0-9])*", p = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${h})(\\.(${f}))?([eE][+-]?(${f})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, m = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: o
      }
    ]
  }, v = [
    d,
    {
      variants: [
        {
          match: [
            /class\s+/,
            r,
            /\s+<\s+/,
            r
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            r
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: o
    },
    {
      match: [
        /(include|extend)\s+/,
        r
      ],
      scope: {
        2: "title.class"
      },
      keywords: o
    },
    {
      relevance: 0,
      match: [
        r,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: i,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        n
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        m
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: t.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: t.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        d,
        { begin: n }
      ],
      relevance: 0
    },
    p,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: o
    },
    {
      // regexp container
      begin: "(" + t.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            t.BACKSLASH_ESCAPE,
            u
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(l, c),
      relevance: 0
    }
  ].concat(l, c);
  u.contains = v, m.contains = v;
  const $ = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: v
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: o,
        contains: v
      }
    }
  ];
  return c.unshift(l), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: o,
    illegal: /\/\*/,
    contains: [t.SHEBANG({ binary: "ruby" })].concat($).concat(c).concat(v)
  };
}
function Die(t) {
  const e = t.regex, n = {
    className: "title.function.invoke",
    relevance: 0,
    begin: e.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      t.IDENT_RE,
      e.lookahead(/\s*\(/)
    )
  }, i = "([ui](8|16|32|64|128|size)|f(32|64))?", r = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], s = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], o = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], a = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: t.IDENT_RE + "!?",
      type: a,
      keyword: r,
      literal: s,
      built_in: o
    },
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      t.inherit(t.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }
        ]
      },
      {
        className: "symbol",
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + i },
          { begin: "\\b0o([0-7_]+)" + i },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + i },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + i }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: t.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: o,
          type: a
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      n
    ]
  };
}
const Iie = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), Lie = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "p",
  "q",
  "quote",
  "samp",
  "section",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], Bie = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
], Qie = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
], Fie = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
], zie = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function Uie(t) {
  const e = Iie(t), n = Fie, i = Qie, r = "@[a-z-]+", s = "and or not only", a = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      e.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + Lie.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + i.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + n.join("|") + ")"
      },
      a,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [e.CSS_NUMBER_MODE]
      },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + zie.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          e.BLOCK_COMMENT,
          a,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.IMPORTANT,
          e.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: r,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: s,
          attribute: Bie.join(" ")
        },
        contains: [
          {
            begin: r,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          a,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE
        ]
      },
      e.FUNCTION_DISPATCH
    ]
  };
}
function Wie(t) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function Vie(t) {
  const e = t.regex, n = t.COMMENT("--", "$"), i = {
    className: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ begin: /''/ }]
      }
    ]
  }, r = {
    begin: /"/,
    end: /"/,
    contains: [{ begin: /""/ }]
  }, s = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], o = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], a = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], l = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], c = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], u = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], d = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], h = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], f = u, p = [
    ...c,
    ...l
  ].filter((y) => !u.includes(y)), m = {
    className: "variable",
    begin: /@[a-z0-9][a-z0-9_]*/
  }, g = {
    className: "operator",
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, b = {
    begin: e.concat(/\b/, e.either(...f), /\s*\(/),
    relevance: 0,
    keywords: { built_in: f }
  };
  function _(y, {
    exceptions: O,
    when: x
  } = {}) {
    const v = x;
    return O = O || [], y.map((w) => w.match(/\|\d+$/) || O.includes(w) ? w : v(w) ? `${w}|0` : w);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: _(p, { when: (y) => y.length < 3 }),
      literal: s,
      type: a,
      built_in: d
    },
    contains: [
      {
        begin: e.either(...h),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: p.concat(h),
          literal: s,
          type: a
        }
      },
      {
        className: "type",
        begin: e.either(...o)
      },
      b,
      m,
      i,
      r,
      t.C_NUMBER_MODE,
      t.C_BLOCK_COMMENT_MODE,
      n,
      g
    ]
  };
}
function X5(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function ef(t) {
  return ht("(?=", t, ")");
}
function ht(...t) {
  return t.map((n) => X5(n)).join("");
}
function Zie(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function qn(...t) {
  return "(" + (Zie(t).capture ? "" : "?:") + t.map((i) => X5(i)).join("|") + ")";
}
const t_ = (t) => ht(
  /\b/,
  t,
  /\w$/.test(t) ? /\b/ : /\B/
), Hie = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(t_), ak = [
  "init",
  "self"
].map(t_), qie = [
  "Any",
  "Self"
], u1 = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], lk = [
  "false",
  "nil",
  "true"
], Xie = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], jie = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], ck = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], j5 = qn(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), Y5 = qn(
  j5,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), d1 = ht(j5, Y5, "*"), G5 = qn(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), ym = qn(
  G5,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), fs = ht(G5, ym, "*"), h1 = ht(/[A-Z]/, ym, "*"), Yie = [
  "attached",
  "autoclosure",
  ht(/convention\(/, qn("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  ht(/objc\(/, fs, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], Gie = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function Kie(t) {
  const e = {
    match: /\s+/,
    relevance: 0
  }, n = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), i = [
    t.C_LINE_COMMENT_MODE,
    n
  ], r = {
    match: [
      /\./,
      qn(...Hie, ...ak)
    ],
    className: { 2: "keyword" }
  }, s = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: ht(/\./, qn(...u1)),
    relevance: 0
  }, o = u1.filter((Te) => typeof Te == "string").concat(["_|0"]), a = u1.filter((Te) => typeof Te != "string").concat(qie).map(t_), l = { variants: [
    {
      className: "keyword",
      match: qn(...a, ...ak)
    }
  ] }, c = {
    $pattern: qn(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: o.concat(jie),
    literal: lk
  }, u = [
    r,
    s,
    l
  ], d = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: ht(/\./, qn(...ck)),
    relevance: 0
  }, h = {
    className: "built_in",
    match: ht(/\b/, qn(...ck), /(?=\()/)
  }, f = [
    d,
    h
  ], p = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, m = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: d1 },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${Y5})+`
      }
    ]
  }, g = [
    p,
    m
  ], b = "([0-9]_*)+", _ = "([0-9a-fA-F]_*)+", y = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${b})(\\.(${b}))?([eE][+-]?(${b}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${_})(\\.(${_}))?([pP][+-]?(${b}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, O = (Te = "") => ({
    className: "subst",
    variants: [
      { match: ht(/\\/, Te, /[0\\tnr"']/) },
      { match: ht(/\\/, Te, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), x = (Te = "") => ({
    className: "subst",
    match: ht(/\\/, Te, /[\t ]*(?:[\r\n]|\r\n)/)
  }), v = (Te = "") => ({
    className: "subst",
    label: "interpol",
    begin: ht(/\\/, Te, /\(/),
    end: /\)/
  }), w = (Te = "") => ({
    begin: ht(Te, /"""/),
    end: ht(/"""/, Te),
    contains: [
      O(Te),
      x(Te),
      v(Te)
    ]
  }), T = (Te = "") => ({
    begin: ht(Te, /"/),
    end: ht(/"/, Te),
    contains: [
      O(Te),
      v(Te)
    ]
  }), S = {
    className: "string",
    variants: [
      w(),
      w("#"),
      w("##"),
      w("###"),
      T(),
      T("#"),
      T("##"),
      T("###")
    ]
  }, $ = [
    t.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [t.BACKSLASH_ESCAPE]
    }
  ], I = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: $
  }, F = (Te) => {
    const gt = ht(Te, /\//), kt = ht(/\//, Te);
    return {
      begin: gt,
      end: kt,
      contains: [
        ...$,
        {
          scope: "comment",
          begin: `#(?!.*${kt})`,
          end: /$/
        }
      ]
    };
  }, V = {
    scope: "regexp",
    variants: [
      F("###"),
      F("##"),
      F("#"),
      I
    ]
  }, q = { match: ht(/`/, fs, /`/) }, K = {
    className: "variable",
    match: /\$\d+/
  }, ie = {
    className: "variable",
    match: `\\$${ym}+`
  }, k = [
    q,
    K,
    ie
  ], N = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: Gie,
        contains: [
          ...g,
          y,
          S
        ]
      }
    ] }
  }, W = {
    scope: "keyword",
    match: ht(/@/, qn(...Yie))
  }, X = {
    scope: "meta",
    match: ht(/@/, fs)
  }, ee = [
    N,
    W,
    X
  ], re = {
    match: ef(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: ht(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, ym, "+")
      },
      {
        // Type identifier
        className: "type",
        match: h1,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: ht(/\s+&\s+/, ef(h1)),
        relevance: 0
      }
    ]
  }, xe = {
    begin: /</,
    end: />/,
    keywords: c,
    contains: [
      ...i,
      ...u,
      ...ee,
      p,
      re
    ]
  };
  re.contains.push(xe);
  const $e = {
    match: ht(fs, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, be = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: c,
    contains: [
      "self",
      $e,
      ...i,
      V,
      ...u,
      ...f,
      ...g,
      y,
      S,
      ...k,
      ...ee,
      re
    ]
  }, we = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...i,
      re
    ]
  }, St = {
    begin: qn(
      ef(ht(fs, /\s*:/)),
      ef(ht(fs, /\s+/, fs, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: fs
      }
    ]
  }, it = {
    begin: /\(/,
    end: /\)/,
    keywords: c,
    contains: [
      St,
      ...i,
      ...u,
      ...g,
      y,
      S,
      ...ee,
      re,
      be
    ],
    endsParent: !0,
    illegal: /["']/
  }, rt = {
    match: [
      /(func|macro)/,
      /\s+/,
      qn(q.match, fs, d1)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      we,
      it,
      e
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, et = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      we,
      it,
      e
    ],
    illegal: /\[|%/
  }, It = {
    match: [
      /operator/,
      /\s+/,
      d1
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, qt = {
    begin: [
      /precedencegroup/,
      /\s+/,
      h1
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [re],
    keywords: [
      ...Xie,
      ...lk
    ],
    end: /}/
  };
  for (const Te of S.variants) {
    const gt = Te.contains.find((Qe) => Qe.label === "interpol");
    gt.keywords = c;
    const kt = [
      ...u,
      ...f,
      ...g,
      y,
      S,
      ...k
    ];
    gt.contains = [
      ...kt,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...kt
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: c,
    contains: [
      ...i,
      rt,
      et,
      {
        beginKeywords: "struct protocol class extension enum actor",
        end: "\\{",
        excludeEnd: !0,
        keywords: c,
        contains: [
          t.inherit(t.TITLE_MODE, {
            className: "title.class",
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }),
          ...u
        ]
      },
      It,
      qt,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...i],
        relevance: 0
      },
      V,
      ...u,
      ...f,
      ...g,
      y,
      S,
      ...k,
      ...ee,
      re,
      be
    ]
  };
}
const _m = "[A-Za-z$_][0-9A-Za-z$_]*", K5 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], J5 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], eR = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], tR = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], nR = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], iR = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], rR = [].concat(
  nR,
  eR,
  tR
);
function Jie(t) {
  const e = t.regex, n = (N, { after: W }) => {
    const X = "</" + N[0].slice(1);
    return N.input.indexOf(X, W) !== -1;
  }, i = _m, r = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (N, W) => {
      const X = N[0].length + N.index, ee = N.input[X];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        ee === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        ee === ","
      ) {
        W.ignoreMatch();
        return;
      }
      ee === ">" && (n(N, { after: X }) || W.ignoreMatch());
      let re;
      const xe = N.input.substring(X);
      if (re = xe.match(/^\s*=/)) {
        W.ignoreMatch();
        return;
      }
      if ((re = xe.match(/^\s+extends\s+/)) && re.index === 0) {
        W.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: _m,
    keyword: K5,
    literal: J5,
    built_in: rR,
    "variable.language": iR
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, h = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, f = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "xml"
    }
  }, p = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "css"
    }
  }, m = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        h
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      h
    ]
  }, _ = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: i + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, y = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    f,
    p,
    m,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  h.contains = y.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(y)
  });
  const O = [].concat(_, h.contains), x = O.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(O)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: x
  }, w = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          i,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(i, "(", e.concat(/\./, i), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          i
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, T = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...eR,
        ...tR
      ]
    }
  }, S = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, $ = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          i,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, I = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function F(N) {
    return e.concat("(?!", N.join("|"), ")");
  }
  const V = {
    match: e.concat(
      /\b/,
      F([
        ...nR,
        "super",
        "import"
      ]),
      i,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, q = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(i, /(?![0-9A-Za-z$_(])/)
    )),
    end: i,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, K = {
    match: [
      /get|set/,
      /\s+/,
      i,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, ie = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", k = {
    match: [
      /const|var|let/,
      /\s+/,
      i,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(ie)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: T },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      S,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      f,
      p,
      m,
      g,
      _,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      T,
      {
        className: "attr",
        begin: i + e.lookahead(":"),
        relevance: 0
      },
      k,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          _,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: ie,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: x
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: r.begin, end: r.end },
              { match: s },
              {
                begin: o.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": o.isTrulyOpeningTag,
                end: o.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: o.begin,
                end: o.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      $,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          v,
          t.inherit(t.TITLE_MODE, { begin: i, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      q,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + i,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      V,
      I,
      w,
      K,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function ere(t) {
  const e = Jie(t), n = _m, i = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], r = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: !0,
    contains: [e.exports.CLASS_REFERENCE]
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: i
    },
    contains: [e.exports.CLASS_REFERENCE]
  }, o = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, a = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], l = {
    $pattern: _m,
    keyword: K5.concat(a),
    literal: J5,
    built_in: rR.concat(i),
    "variable.language": iR
  }, c = {
    className: "meta",
    begin: "@" + n
  }, u = (h, f, p) => {
    const m = h.contains.findIndex((g) => g.label === f);
    if (m === -1)
      throw new Error("can not find mode to replace");
    h.contains.splice(m, 1, p);
  };
  Object.assign(e.keywords, l), e.exports.PARAMS_CONTAINS.push(c), e.contains = e.contains.concat([
    c,
    r,
    s
  ]), u(e, "shebang", t.SHEBANG()), u(e, "use_strict", o);
  const d = e.contains.find((h) => h.label === "func.def");
  return d.relevance = 0, Object.assign(e, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), e;
}
function tre(t) {
  const e = t.regex, n = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  }, i = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  }, r = /\d{1,2}\/\d{1,2}\/\d{4}/, s = /\d{4}-\d{1,2}-\d{1,2}/, o = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: e.concat(/# */, e.either(s, r), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: e.concat(/# */, a, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: e.concat(/# */, o, / *#/)
      },
      {
        // date plus time
        begin: e.concat(
          /# */,
          e.either(s, r),
          / +/,
          e.either(o, a),
          / *#/
        )
      }
    ]
  }, c = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  }, u = {
    className: "label",
    begin: /^\w+:/
  }, d = t.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] }), h = t.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      n,
      i,
      l,
      c,
      u,
      d,
      h,
      {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [h]
      }
    ]
  };
}
function nre(t) {
  t.regex;
  const e = t.COMMENT(/\(;/, /;\)/);
  e.contains.push("self");
  const n = t.COMMENT(/;;/, /$/), i = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ], r = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  }, s = {
    className: "variable",
    begin: /\$[\w_]+/
  }, o = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  }, a = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }, l = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  }, c = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: i
    },
    contains: [
      n,
      e,
      {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      },
      s,
      o,
      r,
      t.QUOTE_STRING_MODE,
      l,
      c,
      a
    ]
  };
}
function ire(t) {
  const e = t.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), i = /[\p{L}0-9._:-]+/u, r = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, o = t.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), a = t.inherit(t.APOS_STRING_MODE, { className: "string" }), l = t.inherit(t.QUOTE_STRING_MODE, { className: "string" }), c = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: i,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [r]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [r]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          l,
          a,
          o,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  o,
                  l,
                  a
                ]
              }
            ]
          }
        ]
      },
      t.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      r,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: c
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function rre(t) {
  const e = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", i = {
    className: "attr",
    variants: [
      { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
      {
        // double quoted keys
        begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
      },
      {
        // single quoted keys
        begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
      }
    ]
  }, r = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, s = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      t.BACKSLASH_ESCAPE,
      r
    ]
  }, o = t.inherit(s, { variants: [
    {
      begin: /'/,
      end: /'/
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), d = {
    className: "number",
    begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
  }, h = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: e,
    relevance: 0
  }, f = {
    begin: /\{/,
    end: /\}/,
    contains: [h],
    illegal: "\\n",
    relevance: 0
  }, p = {
    begin: "\\[",
    end: "\\]",
    contains: [h],
    illegal: "\\n",
    relevance: 0
  }, m = [
    i,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + n
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + n + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + n
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + n
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    t.HASH_COMMENT_MODE,
    {
      beginKeywords: e,
      keywords: { literal: e }
    },
    d,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: t.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    f,
    p,
    s
  ], g = [...m];
  return g.pop(), g.push(o), h.contains = g, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: m
  };
}
const sre = {
  arduino: Hne,
  bash: qne,
  c: Xne,
  cpp: jne,
  csharp: Yne,
  css: iie,
  diff: rie,
  go: sie,
  graphql: oie,
  ini: aie,
  java: lie,
  javascript: fie,
  json: pie,
  kotlin: gie,
  less: xie,
  lua: wie,
  makefile: Sie,
  markdown: kie,
  objectivec: Eie,
  perl: Cie,
  php: Aie,
  "php-template": Tie,
  plaintext: Mie,
  python: Pie,
  "python-repl": Rie,
  r: $ie,
  ruby: Nie,
  rust: Die,
  scss: Uie,
  shell: Wie,
  sql: Vie,
  swift: Kie,
  typescript: ere,
  vbnet: tre,
  wasm: nre,
  xml: ire,
  yaml: rre
};
function sR(t) {
  return t instanceof Map ? t.clear = t.delete = t.set = function() {
    throw new Error("map is read-only");
  } : t instanceof Set && (t.add = t.clear = t.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach((e) => {
    const n = t[e], i = typeof n;
    (i === "object" || i === "function") && !Object.isFrozen(n) && sR(n);
  }), t;
}
class uk {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function oR(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function ao(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const i in t)
    n[i] = t[i];
  return e.forEach(function(i) {
    for (const r in i)
      n[r] = i[r];
  }), /** @type {T} */
  n;
}
const ore = "</span>", dk = (t) => !!t.scope, are = (t, { prefix: e }) => {
  if (t.startsWith("language:"))
    return t.replace("language:", "language-");
  if (t.includes(".")) {
    const n = t.split(".");
    return [
      `${e}${n.shift()}`,
      ...n.map((i, r) => `${i}${"_".repeat(r + 1)}`)
    ].join(" ");
  }
  return `${e}${t}`;
};
class lre {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += oR(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!dk(e)) return;
    const n = are(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    dk(e) && (this.buffer += ore);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const hk = (t = {}) => {
  const e = { children: [] };
  return Object.assign(e, t), e;
};
class n_ {
  constructor() {
    this.rootNode = hk(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const n = hk({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((i) => this._walk(e, i)), e.closeNode(n)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      n_._collapse(n);
    }));
  }
}
class cre extends n_ {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const i = e.root;
    n && (i.scope = `language:${n}`), this.add(i);
  }
  toHTML() {
    return new lre(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function od(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function aR(t) {
  return Ha("(?=", t, ")");
}
function ure(t) {
  return Ha("(?:", t, ")*");
}
function dre(t) {
  return Ha("(?:", t, ")?");
}
function Ha(...t) {
  return t.map((n) => od(n)).join("");
}
function hre(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function i_(...t) {
  return "(" + (hre(t).capture ? "" : "?:") + t.map((i) => od(i)).join("|") + ")";
}
function lR(t) {
  return new RegExp(t.toString() + "|").exec("").length - 1;
}
function fre(t, e) {
  const n = t && t.exec(e);
  return n && n.index === 0;
}
const pre = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function r_(t, { joinWith: e }) {
  let n = 0;
  return t.map((i) => {
    n += 1;
    const r = n;
    let s = od(i), o = "";
    for (; s.length > 0; ) {
      const a = pre.exec(s);
      if (!a) {
        o += s;
        break;
      }
      o += s.substring(0, a.index), s = s.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? o += "\\" + String(Number(a[1]) + r) : (o += a[0], a[0] === "(" && n++);
    }
    return o;
  }).map((i) => `(${i})`).join(e);
}
const mre = /\b\B/, cR = "[a-zA-Z]\\w*", s_ = "[a-zA-Z_]\\w*", uR = "\\b\\d+(\\.\\d+)?", dR = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", hR = "\\b(0b[01]+)", gre = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", bre = (t = {}) => {
  const e = /^#![ ]*\//;
  return t.binary && (t.begin = Ha(
    e,
    /.*\b/,
    t.binary,
    /\b.*/
  )), ao({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, i) => {
      n.index !== 0 && i.ignoreMatch();
    }
  }, t);
}, ad = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, Ore = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [ad]
}, yre = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [ad]
}, _re = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, W0 = function(t, e, n = {}) {
  const i = ao(
    {
      scope: "comment",
      begin: t,
      end: e,
      contains: []
    },
    n
  );
  i.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const r = i_(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return i.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Ha(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        r,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), i;
}, vre = W0("//", "$"), xre = W0("/\\*", "\\*/"), wre = W0("#", "$"), Sre = {
  scope: "number",
  begin: uR,
  relevance: 0
}, kre = {
  scope: "number",
  begin: dR,
  relevance: 0
}, Ere = {
  scope: "number",
  begin: hR,
  relevance: 0
}, Cre = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    ad,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [ad]
    }
  ]
}, Are = {
  scope: "title",
  begin: cR,
  relevance: 0
}, Tre = {
  scope: "title",
  begin: s_,
  relevance: 0
}, Mre = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + s_,
  relevance: 0
}, Pre = function(t) {
  return Object.assign(
    t,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, n) => {
        n.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch();
      }
    }
  );
};
var tf = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: Ore,
  BACKSLASH_ESCAPE: ad,
  BINARY_NUMBER_MODE: Ere,
  BINARY_NUMBER_RE: hR,
  COMMENT: W0,
  C_BLOCK_COMMENT_MODE: xre,
  C_LINE_COMMENT_MODE: vre,
  C_NUMBER_MODE: kre,
  C_NUMBER_RE: dR,
  END_SAME_AS_BEGIN: Pre,
  HASH_COMMENT_MODE: wre,
  IDENT_RE: cR,
  MATCH_NOTHING_RE: mre,
  METHOD_GUARD: Mre,
  NUMBER_MODE: Sre,
  NUMBER_RE: uR,
  PHRASAL_WORDS_MODE: _re,
  QUOTE_STRING_MODE: yre,
  REGEXP_MODE: Cre,
  RE_STARTERS_RE: gre,
  SHEBANG: bre,
  TITLE_MODE: Are,
  UNDERSCORE_IDENT_RE: s_,
  UNDERSCORE_TITLE_MODE: Tre
});
function Rre(t, e) {
  t.input[t.index - 1] === "." && e.ignoreMatch();
}
function $re(t, e) {
  t.className !== void 0 && (t.scope = t.className, delete t.className);
}
function Nre(t, e) {
  e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = Rre, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0));
}
function Dre(t, e) {
  Array.isArray(t.illegal) && (t.illegal = i_(...t.illegal));
}
function Ire(t, e) {
  if (t.match) {
    if (t.begin || t.end) throw new Error("begin & end are not supported with match");
    t.begin = t.match, delete t.match;
  }
}
function Lre(t, e) {
  t.relevance === void 0 && (t.relevance = 1);
}
const Bre = (t, e) => {
  if (!t.beforeMatch) return;
  if (t.starts) throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t);
  Object.keys(t).forEach((i) => {
    delete t[i];
  }), t.keywords = n.keywords, t.begin = Ha(n.beforeMatch, aR(n.begin)), t.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, t.relevance = 0, delete n.beforeMatch;
}, Qre = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], Fre = "keyword";
function fR(t, e, n = Fre) {
  const i = /* @__PURE__ */ Object.create(null);
  return typeof t == "string" ? r(n, t.split(" ")) : Array.isArray(t) ? r(n, t) : Object.keys(t).forEach(function(s) {
    Object.assign(
      i,
      fR(t[s], e, s)
    );
  }), i;
  function r(s, o) {
    e && (o = o.map((a) => a.toLowerCase())), o.forEach(function(a) {
      const l = a.split("|");
      i[l[0]] = [s, zre(l[0], l[1])];
    });
  }
}
function zre(t, e) {
  return e ? Number(e) : Ure(t) ? 0 : 1;
}
function Ure(t) {
  return Qre.includes(t.toLowerCase());
}
const fk = {}, va = (t) => {
  console.error(t);
}, pk = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e);
}, rl = (t, e) => {
  fk[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), fk[`${t}/${e}`] = !0);
}, vm = new Error();
function pR(t, e, { key: n }) {
  let i = 0;
  const r = t[n], s = {}, o = {};
  for (let a = 1; a <= e.length; a++)
    o[a + i] = r[a], s[a + i] = !0, i += lR(e[a - 1]);
  t[n] = o, t[n]._emit = s, t[n]._multi = !0;
}
function Wre(t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin)
      throw va("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), vm;
    if (typeof t.beginScope != "object" || t.beginScope === null)
      throw va("beginScope must be object"), vm;
    pR(t, t.begin, { key: "beginScope" }), t.begin = r_(t.begin, { joinWith: "" });
  }
}
function Vre(t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd)
      throw va("skip, excludeEnd, returnEnd not compatible with endScope: {}"), vm;
    if (typeof t.endScope != "object" || t.endScope === null)
      throw va("endScope must be object"), vm;
    pR(t, t.end, { key: "endScope" }), t.end = r_(t.end, { joinWith: "" });
  }
}
function Zre(t) {
  t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
}
function Hre(t) {
  Zre(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), Wre(t), Vre(t);
}
function qre(t) {
  function e(o, a) {
    return new RegExp(
      od(o),
      "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += lR(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = e(r_(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const c = l.findIndex((d, h) => h > 0 && d !== void 0), u = this.matchIndexes[c];
      return l.splice(0, c), Object.assign(l, u);
    }
  }
  class i {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a]) return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([c, u]) => l.addRule(c, u)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let c = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, c = u.exec(a);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function r(o) {
    const a = new i();
    return o.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && a.addRule(o.terminatorEnd, { type: "end" }), o.illegal && a.addRule(o.illegal, { type: "illegal" }), a;
  }
  function s(o, a) {
    const l = (
      /** @type CompiledMode */
      o
    );
    if (o.isCompiled) return l;
    [
      $re,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      Ire,
      Hre,
      Bre
    ].forEach((u) => u(o, a)), t.compilerExtensions.forEach((u) => u(o, a)), o.__beforeBegin = null, [
      Nre,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      Dre,
      // default to 1 relevance if not specified
      Lre
    ].forEach((u) => u(o, a)), o.isCompiled = !0;
    let c = null;
    return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), c = o.keywords.$pattern, delete o.keywords.$pattern), c = c || /\w+/, o.keywords && (o.keywords = fR(o.keywords, t.case_insensitive)), l.keywordPatternRe = e(c, !0), a && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = od(l.end) || "", o.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + a.terminatorEnd)), o.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      o.illegal
    )), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function(u) {
      return Xre(u === "self" ? o : u);
    })), o.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        l
      );
    }), o.starts && s(o.starts, a), l.matcher = r(l), l;
  }
  if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t.classNameAliases = ao(t.classNameAliases || {}), s(
    /** @type Mode */
    t
  );
}
function mR(t) {
  return t ? t.endsWithParent || mR(t.starts) : !1;
}
function Xre(t) {
  return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function(e) {
    return ao(t, { variants: null }, e);
  })), t.cachedVariants ? t.cachedVariants : mR(t) ? ao(t, { starts: t.starts ? ao(t.starts) : null }) : Object.isFrozen(t) ? ao(t) : t;
}
var jre = "11.9.0";
class Yre extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
}
const f1 = oR, mk = ao, gk = Symbol("nomatch"), Gre = 7, gR = function(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = [];
  let r = !0;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: cre
  };
  function l(k) {
    return a.noHighlightRe.test(k);
  }
  function c(k) {
    let N = k.className + " ";
    N += k.parentNode ? k.parentNode.className : "";
    const W = a.languageDetectRe.exec(N);
    if (W) {
      const X = S(W[1]);
      return X || (pk(s.replace("{}", W[1])), pk("Falling back to no-highlight mode for this block.", k)), X ? W[1] : "no-highlight";
    }
    return N.split(/\s+/).find((X) => l(X) || S(X));
  }
  function u(k, N, W) {
    let X = "", ee = "";
    typeof N == "object" ? (X = k, W = N.ignoreIllegals, ee = N.language) : (rl("10.7.0", "highlight(lang, code, ...args) has been deprecated."), rl("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ee = k, X = N), W === void 0 && (W = !0);
    const re = {
      code: X,
      language: ee
    };
    K("before:highlight", re);
    const xe = re.result ? re.result : d(re.language, re.code, W);
    return xe.code = re.code, K("after:highlight", xe), xe;
  }
  function d(k, N, W, X) {
    const ee = /* @__PURE__ */ Object.create(null);
    function re(E, z) {
      return E.keywords[z];
    }
    function xe() {
      if (!J.keywords) {
        C.addText(B);
        return;
      }
      let E = 0;
      J.keywordPatternRe.lastIndex = 0;
      let z = J.keywordPatternRe.exec(B), G = "";
      for (; z; ) {
        G += B.substring(E, z.index);
        const le = Qe.case_insensitive ? z[0].toLowerCase() : z[0], Ie = re(J, le);
        if (Ie) {
          const [dt, Uo] = Ie;
          if (C.addText(G), G = "", ee[le] = (ee[le] || 0) + 1, ee[le] <= Gre && (oe += Uo), dt.startsWith("_"))
            G += z[0];
          else {
            const H = Qe.classNameAliases[dt] || dt;
            we(z[0], H);
          }
        } else
          G += z[0];
        E = J.keywordPatternRe.lastIndex, z = J.keywordPatternRe.exec(B);
      }
      G += B.substring(E), C.addText(G);
    }
    function $e() {
      if (B === "") return;
      let E = null;
      if (typeof J.subLanguage == "string") {
        if (!e[J.subLanguage]) {
          C.addText(B);
          return;
        }
        E = d(J.subLanguage, B, !0, M[J.subLanguage]), M[J.subLanguage] = /** @type {CompiledMode} */
        E._top;
      } else
        E = f(B, J.subLanguage.length ? J.subLanguage : null);
      J.relevance > 0 && (oe += E.relevance), C.__addSublanguage(E._emitter, E.language);
    }
    function be() {
      J.subLanguage != null ? $e() : xe(), B = "";
    }
    function we(E, z) {
      E !== "" && (C.startScope(z), C.addText(E), C.endScope());
    }
    function St(E, z) {
      let G = 1;
      const le = z.length - 1;
      for (; G <= le; ) {
        if (!E._emit[G]) {
          G++;
          continue;
        }
        const Ie = Qe.classNameAliases[E[G]] || E[G], dt = z[G];
        Ie ? we(dt, Ie) : (B = dt, xe(), B = ""), G++;
      }
    }
    function it(E, z) {
      return E.scope && typeof E.scope == "string" && C.openNode(Qe.classNameAliases[E.scope] || E.scope), E.beginScope && (E.beginScope._wrap ? (we(B, Qe.classNameAliases[E.beginScope._wrap] || E.beginScope._wrap), B = "") : E.beginScope._multi && (St(E.beginScope, z), B = "")), J = Object.create(E, { parent: { value: J } }), J;
    }
    function rt(E, z, G) {
      let le = fre(E.endRe, G);
      if (le) {
        if (E["on:end"]) {
          const Ie = new uk(E);
          E["on:end"](z, Ie), Ie.isMatchIgnored && (le = !1);
        }
        if (le) {
          for (; E.endsParent && E.parent; )
            E = E.parent;
          return E;
        }
      }
      if (E.endsWithParent)
        return rt(E.parent, z, G);
    }
    function et(E) {
      return J.matcher.regexIndex === 0 ? (B += E[0], 1) : (U = !0, 0);
    }
    function It(E) {
      const z = E[0], G = E.rule, le = new uk(G), Ie = [G.__beforeBegin, G["on:begin"]];
      for (const dt of Ie)
        if (dt && (dt(E, le), le.isMatchIgnored))
          return et(z);
      return G.skip ? B += z : (G.excludeBegin && (B += z), be(), !G.returnBegin && !G.excludeBegin && (B = z)), it(G, E), G.returnBegin ? 0 : z.length;
    }
    function qt(E) {
      const z = E[0], G = N.substring(E.index), le = rt(J, E, G);
      if (!le)
        return gk;
      const Ie = J;
      J.endScope && J.endScope._wrap ? (be(), we(z, J.endScope._wrap)) : J.endScope && J.endScope._multi ? (be(), St(J.endScope, E)) : Ie.skip ? B += z : (Ie.returnEnd || Ie.excludeEnd || (B += z), be(), Ie.excludeEnd && (B = z));
      do
        J.scope && C.closeNode(), !J.skip && !J.subLanguage && (oe += J.relevance), J = J.parent;
      while (J !== le.parent);
      return le.starts && it(le.starts, E), Ie.returnEnd ? 0 : z.length;
    }
    function Te() {
      const E = [];
      for (let z = J; z !== Qe; z = z.parent)
        z.scope && E.unshift(z.scope);
      E.forEach((z) => C.openNode(z));
    }
    let gt = {};
    function kt(E, z) {
      const G = z && z[0];
      if (B += E, G == null)
        return be(), 0;
      if (gt.type === "begin" && z.type === "end" && gt.index === z.index && G === "") {
        if (B += N.slice(z.index, z.index + 1), !r) {
          const le = new Error(`0 width match regex (${k})`);
          throw le.languageName = k, le.badRule = gt.rule, le;
        }
        return 1;
      }
      if (gt = z, z.type === "begin")
        return It(z);
      if (z.type === "illegal" && !W) {
        const le = new Error('Illegal lexeme "' + G + '" for mode "' + (J.scope || "<unnamed>") + '"');
        throw le.mode = J, le;
      } else if (z.type === "end") {
        const le = qt(z);
        if (le !== gk)
          return le;
      }
      if (z.type === "illegal" && G === "")
        return 1;
      if (ye > 1e5 && ye > z.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return B += G, G.length;
    }
    const Qe = S(k);
    if (!Qe)
      throw va(s.replace("{}", k)), new Error('Unknown language: "' + k + '"');
    const yn = qre(Qe);
    let Gt = "", J = X || yn;
    const M = {}, C = new a.__emitter(a);
    Te();
    let B = "", oe = 0, Ce = 0, ye = 0, U = !1;
    try {
      if (Qe.__emitTokens)
        Qe.__emitTokens(N, C);
      else {
        for (J.matcher.considerAll(); ; ) {
          ye++, U ? U = !1 : J.matcher.considerAll(), J.matcher.lastIndex = Ce;
          const E = J.matcher.exec(N);
          if (!E) break;
          const z = N.substring(Ce, E.index), G = kt(z, E);
          Ce = E.index + G;
        }
        kt(N.substring(Ce));
      }
      return C.finalize(), Gt = C.toHTML(), {
        language: k,
        value: Gt,
        relevance: oe,
        illegal: !1,
        _emitter: C,
        _top: J
      };
    } catch (E) {
      if (E.message && E.message.includes("Illegal"))
        return {
          language: k,
          value: f1(N),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: E.message,
            index: Ce,
            context: N.slice(Ce - 100, Ce + 100),
            mode: E.mode,
            resultSoFar: Gt
          },
          _emitter: C
        };
      if (r)
        return {
          language: k,
          value: f1(N),
          illegal: !1,
          relevance: 0,
          errorRaised: E,
          _emitter: C,
          _top: J
        };
      throw E;
    }
  }
  function h(k) {
    const N = {
      value: f1(k),
      illegal: !1,
      relevance: 0,
      _top: o,
      _emitter: new a.__emitter(a)
    };
    return N._emitter.addText(k), N;
  }
  function f(k, N) {
    N = N || a.languages || Object.keys(e);
    const W = h(k), X = N.filter(S).filter(I).map(
      (be) => d(be, k, !1)
    );
    X.unshift(W);
    const ee = X.sort((be, we) => {
      if (be.relevance !== we.relevance) return we.relevance - be.relevance;
      if (be.language && we.language) {
        if (S(be.language).supersetOf === we.language)
          return 1;
        if (S(we.language).supersetOf === be.language)
          return -1;
      }
      return 0;
    }), [re, xe] = ee, $e = re;
    return $e.secondBest = xe, $e;
  }
  function p(k, N, W) {
    const X = N && n[N] || W;
    k.classList.add("hljs"), k.classList.add(`language-${X}`);
  }
  function m(k) {
    let N = null;
    const W = c(k);
    if (l(W)) return;
    if (K(
      "before:highlightElement",
      { el: k, language: W }
    ), k.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", k);
      return;
    }
    if (k.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(k)), a.throwUnescapedHTML))
      throw new Yre(
        "One of your code blocks includes unescaped HTML.",
        k.innerHTML
      );
    N = k;
    const X = N.textContent, ee = W ? u(X, { language: W, ignoreIllegals: !0 }) : f(X);
    k.innerHTML = ee.value, k.dataset.highlighted = "yes", p(k, W, ee.language), k.result = {
      language: ee.language,
      // TODO: remove with version 11.0
      re: ee.relevance,
      relevance: ee.relevance
    }, ee.secondBest && (k.secondBest = {
      language: ee.secondBest.language,
      relevance: ee.secondBest.relevance
    }), K("after:highlightElement", { el: k, result: ee, text: X });
  }
  function g(k) {
    a = mk(a, k);
  }
  const b = () => {
    O(), rl("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function _() {
    O(), rl("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let y = !1;
  function O() {
    if (document.readyState === "loading") {
      y = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(m);
  }
  function x() {
    y && O();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", x, !1);
  function v(k, N) {
    let W = null;
    try {
      W = N(t);
    } catch (X) {
      if (va("Language definition for '{}' could not be registered.".replace("{}", k)), r)
        va(X);
      else
        throw X;
      W = o;
    }
    W.name || (W.name = k), e[k] = W, W.rawDefinition = N.bind(null, t), W.aliases && $(W.aliases, { languageName: k });
  }
  function w(k) {
    delete e[k];
    for (const N of Object.keys(n))
      n[N] === k && delete n[N];
  }
  function T() {
    return Object.keys(e);
  }
  function S(k) {
    return k = (k || "").toLowerCase(), e[k] || e[n[k]];
  }
  function $(k, { languageName: N }) {
    typeof k == "string" && (k = [k]), k.forEach((W) => {
      n[W.toLowerCase()] = N;
    });
  }
  function I(k) {
    const N = S(k);
    return N && !N.disableAutodetect;
  }
  function F(k) {
    k["before:highlightBlock"] && !k["before:highlightElement"] && (k["before:highlightElement"] = (N) => {
      k["before:highlightBlock"](
        Object.assign({ block: N.el }, N)
      );
    }), k["after:highlightBlock"] && !k["after:highlightElement"] && (k["after:highlightElement"] = (N) => {
      k["after:highlightBlock"](
        Object.assign({ block: N.el }, N)
      );
    });
  }
  function V(k) {
    F(k), i.push(k);
  }
  function q(k) {
    const N = i.indexOf(k);
    N !== -1 && i.splice(N, 1);
  }
  function K(k, N) {
    const W = k;
    i.forEach(function(X) {
      X[W] && X[W](N);
    });
  }
  function ie(k) {
    return rl("10.7.0", "highlightBlock will be removed entirely in v12.0"), rl("10.7.0", "Please use highlightElement now."), m(k);
  }
  Object.assign(t, {
    highlight: u,
    highlightAuto: f,
    highlightAll: O,
    highlightElement: m,
    // TODO: Remove with v12 API
    highlightBlock: ie,
    configure: g,
    initHighlighting: b,
    initHighlightingOnLoad: _,
    registerLanguage: v,
    unregisterLanguage: w,
    listLanguages: T,
    getLanguage: S,
    registerAliases: $,
    autoDetection: I,
    inherit: mk,
    addPlugin: V,
    removePlugin: q
  }), t.debugMode = function() {
    r = !1;
  }, t.safeMode = function() {
    r = !0;
  }, t.versionString = jre, t.regex = {
    concat: Ha,
    lookahead: aR,
    either: i_,
    optional: dre,
    anyNumberOfTimes: ure
  };
  for (const k in tf)
    typeof tf[k] == "object" && sR(tf[k]);
  return Object.assign(t, tf), t;
}, Jl = gR({});
Jl.newInstance = () => gR({});
var Kre = Jl;
Jl.HighlightJS = Jl;
Jl.default = Jl;
const Jre = /* @__PURE__ */ KP(Kre), bk = {}, ese = "hljs-";
function tse(t) {
  const e = Jre.newInstance();
  return t && s(t), {
    highlight: n,
    highlightAuto: i,
    listLanguages: r,
    register: s,
    registerAlias: o,
    registered: a
  };
  function n(l, c, u) {
    const d = u || bk, h = typeof d.prefix == "string" ? d.prefix : ese;
    if (!e.getLanguage(l))
      throw new Error("Unknown language: `" + l + "` is not registered");
    e.configure({ __emitter: nse, classPrefix: h });
    const f = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      e.highlight(c, { ignoreIllegals: !0, language: l })
    );
    if (f.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: f.errorRaised
      });
    const p = f._emitter.root, m = (
      /** @type {RootData} */
      p.data
    );
    return m.language = f.language, m.relevance = f.relevance, p;
  }
  function i(l, c) {
    const d = (c || bk).subset || r();
    let h = -1, f = 0, p;
    for (; ++h < d.length; ) {
      const m = d[h];
      if (!e.getLanguage(m)) continue;
      const g = n(m, l, c);
      g.data && g.data.relevance !== void 0 && g.data.relevance > f && (f = g.data.relevance, p = g);
    }
    return p || {
      type: "root",
      children: [],
      data: { language: void 0, relevance: f }
    };
  }
  function r() {
    return e.listLanguages();
  }
  function s(l, c) {
    if (typeof l == "string")
      e.registerLanguage(l, c);
    else {
      let u;
      for (u in l)
        Object.hasOwn(l, u) && e.registerLanguage(u, l[u]);
    }
  }
  function o(l, c) {
    if (typeof l == "string")
      e.registerAliases(
        // Note: copy needed because hljs doesnt accept readonly arrays yet.
        typeof c == "string" ? c : [...c],
        { languageName: l }
      );
    else {
      let u;
      for (u in l)
        if (Object.hasOwn(l, u)) {
          const d = l[u];
          e.registerAliases(
            // Note: copy needed because hljs doesnt accept readonly arrays yet.
            typeof d == "string" ? d : [...d],
            { languageName: u }
          );
        }
    }
  }
  function a(l) {
    return !!e.getLanguage(l);
  }
}
class nse {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(e) {
    this.options = e, this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(e) {
    if (e === "") return;
    const n = this.stack[this.stack.length - 1], i = n.children[n.children.length - 1];
    i && i.type === "text" ? i.value += e : n.children.push({ type: "text", value: e });
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(e) {
    this.openNode(String(e));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(e, n) {
    const i = this.stack[this.stack.length - 1], r = (
      /** @type {Array<ElementContent>} */
      e.root.children
    );
    n ? i.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [n] },
      children: r
    }) : i.children.push(...r);
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(e) {
    const n = this, i = e.split(".").map(function(o, a) {
      return a ? o + "_".repeat(a) : n.options.classPrefix + o;
    }), r = this.stack[this.stack.length - 1], s = {
      type: "element",
      tagName: "span",
      properties: { className: i },
      children: []
    };
    r.children.push(s), this.stack.push(s);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
const V0 = tse(sre);
V0.register("html", Vne);
V0.register("dart", Wne);
const ise = {
  contenteditable: "false",
  class: "bg-neutral-100 border-b-[1px] border-b-gray-100 py-1 flex items-center justify-between"
}, rse = { class: "pr-3 flex items-center" }, sse = /* @__PURE__ */ A("option", { value: null }, "auto", -1), ose = ["value"], ase = { class: "pr-3 flex items-center" }, lse = /* @__PURE__ */ ke({
  __name: "CodeBlockViewRenderer",
  props: {
    editor: {},
    node: {},
    decorations: {},
    selected: { type: Boolean },
    extension: {},
    getPos: { type: Function },
    updateAttributes: { type: Function },
    deleteNode: { type: Function }
  },
  setup(t) {
    const e = t, n = Be(() => V0.listLanguages()), i = Be({
      get: () => {
        var l;
        return (l = e.node) == null ? void 0 : l.attrs.language;
      },
      set: (l) => {
        e.updateAttributes({ language: l });
      }
    }), r = Be({
      get: () => e.node.attrs.collapsed || !1,
      set: (l) => {
        e.updateAttributes({ collapsed: l });
      }
    }), { ready: s, start: o } = yne(2e3, { controls: !0, immediate: !1 }), a = () => {
      if (!s.value) return;
      const l = e.node.textContent;
      navigator.clipboard.writeText(l).then(() => {
        o();
      });
    };
    return (l, c) => {
      const u = OD("tooltip");
      return P(), Re(Z(bc), {
        as: "div",
        class: "code-node border-[1px] rounded mt-3 overflow-hidden"
      }, {
        default: ze(() => [
          A("div", ise, [
            A("div", {
              class: "flex-1 flex items-center pl-3",
              onClick: c[2] || (c[2] = su((d) => r.value ? r.value = !1 : null, ["self"]))
            }, [
              A("div", rse, [
                A("div", {
                  class: "w-8 h-8 cursor-pointer rounded flex items-center justify-center hover:bg-zinc-200",
                  onClick: c[0] || (c[0] = su((d) => r.value = !r.value, ["stop"]))
                }, [
                  r.value ? (P(), Re(Z(Lne), { key: 0 })) : (P(), Re(Z(Rne), { key: 1 }))
                ])
              ]),
              ut(A("select", {
                "onUpdate:modelValue": c[1] || (c[1] = (d) => i.value = d),
                class: "block !leading-8 text-sm text-gray-900 border select-none border-transparent rounded-md bg-transparent focus:ring-blue-500 focus:border-blue-500 cursor-pointer hover:bg-zinc-200"
              }, [
                sse,
                (P(!0), L(Yt, null, Fr(n.value, (d, h) => (P(), L("option", {
                  key: h,
                  value: d
                }, Ft(d), 9, ose))), 128))
              ], 512), [
                [ZA, i.value]
              ])
            ]),
            A("div", ase, [
              ut((P(), L("div", {
                class: Ot(["w-8 h-8 cursor-pointer rounded flex items-center justify-center", { "hover:bg-zinc-200": Z(s) }]),
                onClick: a
              }, [
                Z(s) ? (P(), Re(Z(Cne), {
                  key: 1,
                  class: "w-4 h-4 text-gray-500"
                })) : (P(), Re(Z(Une), {
                  key: 0,
                  class: "w-4 h-4 text-green-500"
                }))
              ], 2)), [
                [
                  u,
                  Z(s) ? Z(Q).global.t("editor.common.codeblock.copy_code") : Z(Q).global.t("editor.common.codeblock.copy_code_success")
                ]
              ])
            ])
          ]),
          ut(A("pre", null, [
            fe(Z(aq), {
              as: "code",
              class: "hljs"
            })
          ], 512), [
            [HA, !r.value]
          ])
        ]),
        _: 1
      });
    };
  }
}), Ok = (t, e) => {
  const { doc: n, selection: i } = t;
  if (!n || !i || !(i instanceof ce))
    return t;
  const { from: r, to: s } = i;
  return n.nodesBetween(r, s, (o, a) => {
    if (r - s == 0 && e === "indent")
      return t.insertText("  ", r, s), !1;
    const c = n.textBetween(a + 1, r, `
`).lastIndexOf(`
`), u = c === -1 ? a + 1 : a + c + 1, d = n.textBetween(u, s, `
`);
    if (e === "indent") {
      let h = d.replace(/\n/g, `
  `);
      u === a + 1 && (h = "  " + h), t.insertText(h, u, s);
    } else {
      let h = d.replace(/\n {2}/g, `
`);
      u === a + 1 && h.indexOf("  ") == 0 && (h = h.replace("  ", "")), t.insertText(h, u, s);
    }
    return !1;
  }), t;
}, yk = (t) => {
  let e = t;
  for (e.nodeName === "#text" && (e = t.parentElement); e && e.classList && !e.classList.contains("code-node"); )
    e = e.parentElement;
  return e;
}, cse = jh.extend({
  allowGapCursor: !0,
  // It needs to have a higher priority than range-selection,
  // otherwise the Mod-a shortcut key will be overridden.
  priority: 110,
  fakeSelection: !0,
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      collapsed: {
        default: !1,
        parseHTML: (e) => !!e.getAttribute("collapsed"),
        renderHTML: (e) => e.collapsed ? {
          collapsed: e.collapsed
        } : {}
      }
    };
  },
  addCommands() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      codeIndent: () => ({ tr: e, state: n, dispatch: i }) => {
        const { selection: r } = n;
        return e = e.setSelection(r), e = Ok(e, "indent"), e.docChanged && i ? (i(e), !0) : !1;
      },
      codeOutdent: () => ({ tr: e, state: n, dispatch: i }) => {
        const { selection: r } = n;
        return e = e.setSelection(r), e = Ok(e, "outdent"), e.docChanged && i ? (i(e), !0) : !1;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Backspace: ({ editor: t }) => {
        if (!Fi(t.state, this.name))
          return !1;
        const { selection: e } = t.state;
        if (!e.empty)
          return t.chain().focus().deleteSelection().setTextSelection(e.$from.pos).run(), !0;
        const { $anchor: n } = e;
        return n.parentOffset === 0 || !n.parent.textContent.length;
      },
      Tab: () => this.editor.isActive("codeBlock") ? this.editor.chain().focus().codeIndent().run() : !1,
      "Shift-Tab": () => this.editor.isActive("codeBlock") ? this.editor.chain().focus().codeOutdent().run() : !1,
      "Mod-a": () => {
        if (this.editor.isActive("codeBlock")) {
          const { tr: t, selection: e } = this.editor.state, n = Hi(
            (a) => a.type.name === jh.name
          )(e);
          if (!n)
            return !1;
          const i = n.start, r = n.start + n.node.nodeSize - 1, s = t.doc.resolve(i), o = t.doc.resolve(r);
          return this.editor.view.dispatch(
            t.setSelection(new ce(s, o))
          ), !0;
        }
        return !1;
      }
    };
  },
  addNodeView() {
    return Oc(lse);
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        return {
          priority: 160,
          component: R($t),
          props: {
            editor: e,
            isActive: e.isActive("codeBlock"),
            icon: R(c1),
            title: Q.global.t("editor.common.codeblock.title"),
            action: () => e.chain().focus().toggleCodeBlock().run()
          }
        };
      },
      getCommandMenuItems() {
        return {
          priority: 80,
          icon: R(c1),
          title: "editor.common.codeblock.title",
          keywords: ["codeblock", "daimakuai"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).setCodeBlock().run();
          }
        };
      },
      getToolboxItems({ editor: e }) {
        return [
          {
            priority: 50,
            component: R(Qo),
            props: {
              editor: e,
              icon: R(c1),
              title: Q.global.t("editor.common.codeblock.title"),
              action: () => {
                e.chain().focus().setCodeBlock().run();
              }
            }
          }
        ];
      },
      getBubbleMenu() {
        return {
          pluginKey: "codeBlockBubbleMenu",
          shouldShow: ({ state: e }) => xi(e, jh.name),
          getRenderContainer: (e) => yk(e),
          items: [
            {
              priority: 10,
              props: {
                icon: R(Ua),
                title: Q.global.t("editor.common.button.delete"),
                action: ({ editor: e }) => vc(jh.name, e)
              }
            }
          ]
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            return {
              el: yk(e)
            };
          }
        };
      }
    };
  },
  addProseMirrorPlugins() {
    var t;
    return [
      // Solve the paste problem. Because the upstream has not been
      // able to deal with this problem for a long time, it is
      // handled manually locally.
      // see: https://github.com/ueberdosis/tiptap/pull/3606
      new Ue({
        key: new Ke("codeBlockVSCodeHandlerFixPaste"),
        props: {
          handlePaste: (e, n) => {
            if (!n.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const i = n.clipboardData.getData("text/plain"), r = n.clipboardData.getData("vscode-editor-data"), s = r ? JSON.parse(r) : void 0, o = s == null ? void 0 : s.mode;
            if (!i || !o)
              return !1;
            const { tr: a, schema: l } = e.state, c = l.text(i.replace(/\r\n?/g, `
`));
            a.replaceSelectionWith(
              this.type.create({ language: o }, c)
            );
            const { selection: u } = a;
            let d = Math.max(0, u.from - 1);
            for (; d > 0 && a.doc.resolve(d).parent.type.name !== this.type.name; )
              d--;
            return a.setSelection(ce.near(a.doc.resolve(d))), a.setMeta("paste", !0), e.dispatch(a), !0;
          }
        }
      }),
      ...((t = this.parent) == null ? void 0 : t.call(this)) || []
    ];
  }
});
function use(t) {
  var e;
  const { char: n, allowSpaces: i, allowedPrefixes: r, startOfLine: s, $position: o } = t, a = EZ(n), l = new RegExp(`\\s${a}$`), c = s ? "^" : "", u = i ? new RegExp(`${c}${a}.*?(?=\\s${a}|$)`, "gm") : new RegExp(`${c}(?:^)?${a}[^\\s${a}]*`, "gm"), d = ((e = o.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && o.nodeBefore.text;
  if (!d)
    return null;
  const h = o.pos - d.length, f = Array.from(d.matchAll(u)).pop();
  if (!f || f.input === void 0 || f.index === void 0)
    return null;
  const p = f.input.slice(Math.max(0, f.index - 1), f.index), m = new RegExp(`^[${r == null ? void 0 : r.join("")}\0]?$`).test(p);
  if (r !== null && !m)
    return null;
  const g = h + f.index;
  let b = g + f[0].length;
  return i && l.test(d.slice(b - 1, b + 1)) && (f[0] += " ", b += 1), g < o.pos && b >= o.pos ? {
    range: {
      from: g,
      to: b
    },
    query: f[0].slice(n.length),
    text: f[0]
  } : null;
}
const dse = new Ke("suggestion");
function hse({ pluginKey: t = dse, editor: e, char: n = "@", allowSpaces: i = !1, allowedPrefixes: r = [" "], startOfLine: s = !1, decorationTag: o = "span", decorationClass: a = "suggestion", command: l = () => null, items: c = () => [], render: u = () => ({}), allow: d = () => !0, findSuggestionMatch: h = use }) {
  let f;
  const p = u == null ? void 0 : u(), m = new Ue({
    key: t,
    view() {
      return {
        update: async (g, b) => {
          var _, y, O, x, v, w, T;
          const S = (_ = this.key) === null || _ === void 0 ? void 0 : _.getState(b), $ = (y = this.key) === null || y === void 0 ? void 0 : y.getState(g.state), I = S.active && $.active && S.range.from !== $.range.from, F = !S.active && $.active, V = S.active && !$.active, q = !F && !V && S.query !== $.query, K = F, ie = q || I, k = V;
          if (!K && !ie && !k)
            return;
          const N = k && !K ? S : $, W = g.dom.querySelector(`[data-decoration-id="${N.decorationId}"]`);
          f = {
            editor: e,
            range: N.range,
            query: N.query,
            text: N.text,
            items: [],
            command: (X) => l({
              editor: e,
              range: N.range,
              props: X
            }),
            decorationNode: W,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: W ? () => {
              var X;
              const { decorationId: ee } = (X = this.key) === null || X === void 0 ? void 0 : X.getState(e.state), re = g.dom.querySelector(`[data-decoration-id="${ee}"]`);
              return (re == null ? void 0 : re.getBoundingClientRect()) || null;
            } : null
          }, K && ((O = p == null ? void 0 : p.onBeforeStart) === null || O === void 0 || O.call(p, f)), ie && ((x = p == null ? void 0 : p.onBeforeUpdate) === null || x === void 0 || x.call(p, f)), (ie || K) && (f.items = await c({
            editor: e,
            query: N.query
          })), k && ((v = p == null ? void 0 : p.onExit) === null || v === void 0 || v.call(p, f)), ie && ((w = p == null ? void 0 : p.onUpdate) === null || w === void 0 || w.call(p, f)), K && ((T = p == null ? void 0 : p.onStart) === null || T === void 0 || T.call(p, f));
        },
        destroy: () => {
          var g;
          f && ((g = p == null ? void 0 : p.onExit) === null || g === void 0 || g.call(p, f));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(g, b, _, y) {
        const { isEditable: O } = e, { composing: x } = e.view, { selection: v } = g, { empty: w, from: T } = v, S = { ...b };
        if (S.composing = x, O && (w || e.view.composing)) {
          (T < b.range.from || T > b.range.to) && !x && !b.composing && (S.active = !1);
          const $ = h({
            char: n,
            allowSpaces: i,
            allowedPrefixes: r,
            startOfLine: s,
            $position: v.$from
          }), I = `id_${Math.floor(Math.random() * 4294967295)}`;
          $ && d({
            editor: e,
            state: y,
            range: $.range,
            isActive: b.active
          }) ? (S.active = !0, S.decorationId = b.decorationId ? b.decorationId : I, S.range = $.range, S.query = $.query, S.text = $.text) : S.active = !1;
        } else
          S.active = !1;
        return S.active || (S.decorationId = null, S.range = { from: 0, to: 0 }, S.query = null, S.text = null), S;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(g, b) {
        var _;
        const { active: y, range: O } = m.getState(g.state);
        return y && ((_ = p == null ? void 0 : p.onKeyDown) === null || _ === void 0 ? void 0 : _.call(p, { view: g, event: b, range: O })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(g) {
        const { active: b, range: _, decorationId: y } = m.getState(g);
        return b ? We.create(g.doc, [
          zt.inline(_.from, _.to, {
            nodeName: o,
            class: a,
            "data-decoration-id": y
          })
        ]) : null;
      }
    }
  });
  return m;
}
const _k = (t) => typeof t == "object" && t != null && t.nodeType === 1, vk = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip", p1 = (t, e) => {
  if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
    const n = getComputedStyle(t, null);
    return vk(n.overflowY, e) || vk(n.overflowX, e) || ((i) => {
      const r = ((s) => {
        if (!s.ownerDocument || !s.ownerDocument.defaultView) return null;
        try {
          return s.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(i);
      return !!r && (r.clientHeight < i.scrollHeight || r.clientWidth < i.scrollWidth);
    })(t);
  }
  return !1;
}, nf = (t, e, n, i, r, s, o, a) => s < t && o > e || s > t && o < e ? 0 : s <= t && a <= n || o >= e && a >= n ? s - t - i : o > e && a < n || s < t && a > n ? o - e + r : 0, fse = (t) => {
  const e = t.parentElement;
  return e ?? (t.getRootNode().host || null);
}, xk = (t, e) => {
  var n, i, r, s;
  if (typeof document > "u") return [];
  const { scrollMode: o, block: a, inline: l, boundary: c, skipOverflowHiddenElements: u } = e, d = typeof c == "function" ? c : (ie) => ie !== c;
  if (!_k(t)) throw new TypeError("Invalid target");
  const h = document.scrollingElement || document.documentElement, f = [];
  let p = t;
  for (; _k(p) && d(p); ) {
    if (p = fse(p), p === h) {
      f.push(p);
      break;
    }
    p != null && p === document.body && p1(p) && !p1(document.documentElement) || p != null && p1(p, u) && f.push(p);
  }
  const m = (i = (n = window.visualViewport) == null ? void 0 : n.width) != null ? i : innerWidth, g = (s = (r = window.visualViewport) == null ? void 0 : r.height) != null ? s : innerHeight, { scrollX: b, scrollY: _ } = window, { height: y, width: O, top: x, right: v, bottom: w, left: T } = t.getBoundingClientRect(), { top: S, right: $, bottom: I, left: F } = ((ie) => {
    const k = window.getComputedStyle(ie);
    return { top: parseFloat(k.scrollMarginTop) || 0, right: parseFloat(k.scrollMarginRight) || 0, bottom: parseFloat(k.scrollMarginBottom) || 0, left: parseFloat(k.scrollMarginLeft) || 0 };
  })(t);
  let V = a === "start" || a === "nearest" ? x - S : a === "end" ? w + I : x + y / 2 - S + I, q = l === "center" ? T + O / 2 - F + $ : l === "end" ? v + $ : T - F;
  const K = [];
  for (let ie = 0; ie < f.length; ie++) {
    const k = f[ie], { height: N, width: W, top: X, right: ee, bottom: re, left: xe } = k.getBoundingClientRect();
    if (o === "if-needed" && x >= 0 && T >= 0 && w <= g && v <= m && x >= X && w <= re && T >= xe && v <= ee) return K;
    const $e = getComputedStyle(k), be = parseInt($e.borderLeftWidth, 10), we = parseInt($e.borderTopWidth, 10), St = parseInt($e.borderRightWidth, 10), it = parseInt($e.borderBottomWidth, 10);
    let rt = 0, et = 0;
    const It = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - be - St : 0, qt = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - we - it : 0, Te = "offsetWidth" in k ? k.offsetWidth === 0 ? 0 : W / k.offsetWidth : 0, gt = "offsetHeight" in k ? k.offsetHeight === 0 ? 0 : N / k.offsetHeight : 0;
    if (h === k) rt = a === "start" ? V : a === "end" ? V - g : a === "nearest" ? nf(_, _ + g, g, we, it, _ + V, _ + V + y, y) : V - g / 2, et = l === "start" ? q : l === "center" ? q - m / 2 : l === "end" ? q - m : nf(b, b + m, m, be, St, b + q, b + q + O, O), rt = Math.max(0, rt + _), et = Math.max(0, et + b);
    else {
      rt = a === "start" ? V - X - we : a === "end" ? V - re + it + qt : a === "nearest" ? nf(X, re, N, we, it + qt, V, V + y, y) : V - (X + N / 2) + qt / 2, et = l === "start" ? q - xe - be : l === "center" ? q - (xe + W / 2) + It / 2 : l === "end" ? q - ee + St + It : nf(xe, ee, W, be, St + It, q, q + O, O);
      const { scrollLeft: kt, scrollTop: Qe } = k;
      rt = gt === 0 ? 0 : Math.max(0, Math.min(Qe + rt / gt, k.scrollHeight - N / gt + qt)), et = Te === 0 ? 0 : Math.max(0, Math.min(kt + et / Te, k.scrollWidth - W / Te + It)), V += Qe - rt, q += kt - et;
    }
    K.push({ el: k, top: rt, left: et });
  }
  return K;
}, pse = (t) => t === !1 ? { block: "end", inline: "nearest" } : ((e) => e === Object(e) && Object.keys(e).length !== 0)(t) ? t : { block: "start", inline: "nearest" };
function bR(t, e) {
  if (!t.isConnected || !((r) => {
    let s = r;
    for (; s && s.parentNode; ) {
      if (s.parentNode === document) return !0;
      s = s.parentNode instanceof ShadowRoot ? s.parentNode.host : s.parentNode;
    }
    return !1;
  })(t)) return;
  const n = ((r) => {
    const s = window.getComputedStyle(r);
    return { top: parseFloat(s.scrollMarginTop) || 0, right: parseFloat(s.scrollMarginRight) || 0, bottom: parseFloat(s.scrollMarginBottom) || 0, left: parseFloat(s.scrollMarginLeft) || 0 };
  })(t);
  if (((r) => typeof r == "object" && typeof r.behavior == "function")(e)) return e.behavior(xk(t, e));
  const i = typeof e == "boolean" || e == null ? void 0 : e.behavior;
  for (const { el: r, top: s, left: o } of xk(t, pse(e))) {
    const a = s - n.top + n.bottom, l = o - n.left + n.right;
    r.scroll({ top: a, left: l, behavior: i });
  }
}
const mse = { class: "command-items" }, gse = ["id", "onClick"], bse = { class: "command-title group-hover:text-gray-900 group-hover:font-medium" }, Ose = {
  key: 1,
  class: "command-empty"
}, yse = /* @__PURE__ */ ke({
  __name: "CommandsView",
  props: {
    items: {
      type: Array,
      required: !0
    },
    command: {
      type: Function,
      required: !0
    }
  },
  setup(t, { expose: e }) {
    const n = t, i = pt(0);
    In(
      () => n.items,
      () => {
        console.log("items changed", n.items), i.value = 0;
      }
    );
    function r({ event: c }) {
      return c.key === "ArrowUp" || c.key === "k" && c.ctrlKey ? (s(), !0) : c.key === "ArrowDown" || c.key === "j" && c.ctrlKey ? (o(), !0) : c.key === "Enter" ? (a(), !0) : !1;
    }
    function s() {
      i.value = (i.value + n.items.length - 1) % n.items.length;
    }
    function o() {
      i.value = (i.value + 1) % n.items.length;
    }
    function a() {
      l(i.value);
    }
    function l(c) {
      const u = n.items[c];
      u && n.command(u);
    }
    return In(
      () => i.value,
      () => {
        const c = document.getElementById(
          `command-item-${i.value}`
        );
        c && bR(c, { behavior: "smooth", scrollMode: "if-needed" });
      }
    ), e({
      onKeyDown: r
    }), (c, u) => (P(), L("div", mse, [
      t.items.length ? (P(!0), L(Yt, { key: 0 }, Fr(t.items, (d, h) => (P(), L("div", {
        id: `command-item-${h}`,
        key: h,
        class: Ot([{ "is-selected": h === i.value }, "command-item group hover:bg-gray-100"]),
        onClick: (f) => l(h)
      }, [
        (P(), Re(Ni(d.icon), { class: "command-icon group-hover:!bg-white" })),
        A("span", bse, Ft(Z(Q).global.t(d.title)), 1)
      ], 10, gse))), 128)) : (P(), L("div", Ose, [
        A("span", null, Ft(Z(Q).global.t("editor.extensions.commands_menu.no_results")), 1)
      ]))
    ]));
  }
}), _se = mt.create({
  name: "commands-menu",
  addProseMirrorPlugins() {
    const t = vse(
      this.editor
    );
    return [
      hse({
        editor: this.editor,
        char: "/",
        // @ts-ignore
        command: ({
          editor: e,
          range: n,
          props: i
        }) => {
          i.command({ editor: e, range: n });
        },
        items: ({ query: e }) => t.filter(
          (n) => [...n.keywords, n.title].some(
            (i) => i.includes(e)
          )
        ),
        render: () => {
          let e, n;
          return {
            onStart: (i) => {
              e = new ZP(yse, {
                props: i,
                editor: i.editor
              }), i.clientRect && (n = Bo("body", {
                getReferenceClientRect: i.clientRect,
                appendTo: () => document.body,
                content: e.element,
                showOnCreate: !0,
                interactive: !0,
                trigger: "manual",
                placement: "bottom-start"
              }));
            },
            onUpdate(i) {
              e.updateProps(i), i.clientRect && n[0].setProps({
                getReferenceClientRect: i.clientRect
              });
            },
            onKeyDown(i) {
              var r;
              return i.event.key === "Escape" ? (n[0].hide(), !0) : (r = e.ref) == null ? void 0 : r.onKeyDown(i);
            },
            onExit() {
              n[0].destroy(), e.destroy();
            }
          };
        }
      })
    ];
  }
});
function vse(t) {
  return (t == null ? void 0 : t.extensionManager).extensions.reduce((n, i) => {
    const { getCommandMenuItems: r } = i.options;
    if (!r)
      return n;
    const s = r();
    return Array.isArray(s) ? [...n, ...s] : [...n, s];
  }, []).sort((n, i) => n.priority - i.priority);
}
const xse = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, wse = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M10.59 13.41c.41.39.41 1.03 0 1.42c-.39.39-1.03.39-1.42 0a5.003 5.003 0 0 1 0-7.07l3.54-3.54a5.003 5.003 0 0 1 7.07 0a5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.98 2.98 0 0 0 0-4.24a2.98 2.98 0 0 0-4.24 0l-3.53 3.53a2.98 2.98 0 0 0 0 4.24m2.82-4.24c.39-.39 1.03-.39 1.42 0a5.003 5.003 0 0 1 0 7.07l-3.54 3.54a5.003 5.003 0 0 1-7.07 0a5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.98 2.98 0 0 0 0 4.24a2.98 2.98 0 0 0 4.24 0l3.53-3.53a2.98 2.98 0 0 0 0-4.24a.973.973 0 0 1 0-1.42"
}, null, -1), Sse = [
  wse
];
function kse(t, e) {
  return P(), L("svg", xse, [...Sse]);
}
const ih = { name: "mdi-link-variant", render: kse }, Ese = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Cse = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M22 12c0-5.54-4.46-10-10-10c-1.17 0-2.3.19-3.38.56l.7 1.94c.85-.34 1.74-.53 2.68-.53c4.41 0 8.03 3.62 8.03 8.03s-3.62 8.03-8.03 8.03S3.97 16.41 3.97 12c0-.94.19-1.88.53-2.72l-1.94-.66C2.19 9.7 2 10.83 2 12c0 5.54 4.46 10 10 10s10-4.46 10-10M5.47 3.97c.85 0 1.53.71 1.53 1.5C7 6.32 6.32 7 5.47 7c-.79 0-1.5-.68-1.5-1.53c0-.79.71-1.5 1.5-1.5M18 12c0-3.33-2.67-6-6-6s-6 2.67-6 6s2.67 6 6 6s6-2.67 6-6m-3 0l-5 3V9"
}, null, -1), Ase = [
  Cse
];
function Tse(t, e) {
  return P(), L("svg", Ese, [...Ase]);
}
const OR = { name: "mdi-motion-play", render: Tse }, Mse = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Pse = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m10 16.5l6-4.5l-6-4.5M22 12c0-5.54-4.46-10-10-10c-1.17 0-2.3.19-3.38.56l.7 1.94c.85-.34 1.74-.53 2.68-.53c4.41 0 8.03 3.62 8.03 8.03s-3.62 8.03-8.03 8.03S3.97 16.41 3.97 12c0-.94.19-1.88.53-2.72l-1.94-.66C2.19 9.7 2 10.83 2 12c0 5.54 4.46 10 10 10s10-4.46 10-10M5.47 3.97c.85 0 1.53.71 1.53 1.5C7 6.32 6.32 7 5.47 7c-.79 0-1.5-.68-1.5-1.53c0-.79.71-1.5 1.5-1.5"
}, null, -1), Rse = [
  Pse
];
function $se(t, e) {
  return P(), L("svg", Mse, [...Rse]);
}
const yR = { name: "mdi-motion-play-outline", render: $se }, Nse = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Dse = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M16 9h-3v5.5a2.5 2.5 0 0 1-2.5 2.5A2.5 2.5 0 0 1 8 14.5a2.5 2.5 0 0 1 2.5-2.5c.57 0 1.08.19 1.5.5V7h4zm-4-7a10 10 0 0 1 10 10a10 10 0 0 1-10 10A10 10 0 0 1 2 12A10 10 0 0 1 12 2m0 2a8 8 0 0 0-8 8a8 8 0 0 0 8 8a8 8 0 0 0 8-8a8 8 0 0 0-8-8"
}, null, -1), Ise = [
  Dse
];
function Lse(t, e) {
  return P(), L("svg", Nse, [...Ise]);
}
const wk = { name: "mdi-music-circle-outline", render: Lse }, Bse = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Qse = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M10 16.5v-9l6 4.5M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2"
}, null, -1), Fse = [
  Qse
];
function zse(t, e) {
  return P(), L("svg", Bse, [...Fse]);
}
const _R = { name: "mdi-play-circle", render: zse }, Use = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Wse = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M12 20c-4.41 0-8-3.59-8-8s3.59-8 8-8s8 3.59 8 8s-3.59 8-8 8m0-18A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2m-2 14.5l6-4.5l-6-4.5z"
}, null, -1), Vse = [
  Wse
];
function Zse(t, e) {
  return P(), L("svg", Use, [...Vse]);
}
const vR = { name: "mdi-play-circle-outline", render: Zse }, Hse = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, qse = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m21 12l-7-7v4C7 10 4 15 3 20c2.5-3.5 6-5.1 11-5.1V19z"
}, null, -1), Xse = [
  qse
];
function jse(t, e) {
  return P(), L("svg", Hse, [...Xse]);
}
const rh = { name: "mdi-share", render: jse }, Yse = { class: "inline-block overflow-hidden transition-all text-center relative h-full w-full" }, Gse = {
  key: 0,
  class: "p-1.5"
}, Kse = ["placeholder"], Jse = ["autoplay", "loop", "src"], eoe = /* @__PURE__ */ ke({
  __name: "AudioView",
  props: {
    editor: {},
    node: {},
    decorations: {},
    selected: { type: Boolean },
    extension: {},
    getPos: { type: Function },
    updateAttributes: { type: Function },
    deleteNode: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => {
        var a;
        return (a = e.node) == null ? void 0 : a.attrs.src;
      },
      set: (a) => {
        e.updateAttributes({ src: a });
      }
    }), i = Be(() => e.node.attrs.autoplay), r = Be(() => e.node.attrs.loop);
    function s() {
      e.editor.commands.setNodeSelection(e.getPos());
    }
    const o = pt();
    return Gi(() => {
      n.value || o.value.focus();
    }), (a, l) => (P(), Re(Z(bc), {
      as: "div",
      class: "inline-block w-full"
    }, {
      default: ze(() => [
        A("div", Yse, [
          n.value ? (P(), L("audio", {
            key: 1,
            controls: "",
            autoplay: i.value,
            loop: r.value,
            src: a.node.attrs.src,
            onMouseenter: s
          }, null, 40, Jse)) : (P(), L("div", Gse, [
            ut(A("input", {
              ref_key: "inputRef",
              ref: o,
              "onUpdate:modelValue": l[0] || (l[0] = (c) => n.value = c),
              class: "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
              placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
              tabindex: "-1",
              onFocus: s
            }, null, 40, Kse), [
              [
                Fn,
                n.value,
                void 0,
                { lazy: !0 }
              ]
            ])
          ]))
        ])
      ]),
      _: 1
    }));
  }
}), toe = ["placeholder"], noe = /* @__PURE__ */ ke({
  __name: "BubbleItemAudioLink",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => {
        var i;
        return (i = e.editor.getAttributes(_n.name)) == null ? void 0 : i.src;
      },
      set: (i) => {
        e.editor.chain().updateAttributes(_n.name, { src: i }).setNodeSelection(e.editor.state.selection.from).focus().run();
      }
    });
    return (i, r) => ut((P(), L("input", {
      "onUpdate:modelValue": r[0] || (r[0] = (s) => n.value = s),
      placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
      class: "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
    }, null, 8, toe)), [
      [
        Fn,
        n.value,
        void 0,
        { lazy: !0 }
      ]
    ]);
  }
}), _n = wt.create({
  name: "audio",
  fakeSelection: !0,
  inline() {
    return !0;
  },
  group() {
    return "inline";
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      src: {
        default: null,
        parseHTML: (e) => e.getAttribute("src")
      },
      autoplay: {
        default: null,
        parseHTML: (e) => e.getAttribute("autoplay"),
        renderHTML: (e) => ({
          autoplay: e.autoplay
        })
      },
      controls: {
        default: !0,
        parseHTML: (e) => e.getAttribute("controls"),
        renderHTML: (e) => ({
          controls: e.controls
        })
      },
      loop: {
        default: null,
        parseHTML: (e) => e.getAttribute("loop"),
        renderHTML: (e) => ({
          loop: e.loop
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "audio"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["audio", Ee(t)];
  },
  addCommands() {
    return {
      setAudio: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      jd({
        find: /^\$audio\$$/,
        type: this.type,
        getAttributes: () => ({ width: "100%" })
      })
    ];
  },
  addNodeView() {
    return Oc(eoe);
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getCommandMenuItems() {
        return {
          priority: 110,
          icon: R(wk),
          title: "editor.extensions.commands_menu.audio",
          keywords: ["audio", "yinpin"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).insertContent([
              { type: "audio", attrs: { src: "" } },
              { type: "paragraph", content: "" }
            ]).run();
          }
        };
      },
      getToolboxItems({ editor: e }) {
        return {
          priority: 20,
          component: R(Qo),
          props: {
            editor: e,
            icon: R(wk),
            title: Q.global.t("editor.extensions.commands_menu.audio"),
            action: () => {
              e.chain().focus().insertContent([{ type: "audio", attrs: { src: "" } }]).run();
            }
          }
        };
      },
      getBubbleMenu({ editor: e }) {
        return {
          pluginKey: "audioBubbleMenu",
          shouldShow: ({ state: n }) => xi(n, _n.name),
          items: [
            {
              priority: 10,
              props: {
                isActive: () => e.getAttributes(_n.name).autoplay,
                icon: R(
                  e.getAttributes(_n.name).autoplay ? _R : vR
                ),
                action: () => {
                  e.chain().updateAttributes(_n.name, {
                    autoplay: e.getAttributes(_n.name).autoplay ? null : !0
                  }).setNodeSelection(e.state.selection.from).focus().run();
                },
                title: e.getAttributes(_n.name).autoplay ? Q.global.t("editor.extensions.audio.disable_autoplay") : Q.global.t("editor.extensions.audio.enable_autoplay")
              }
            },
            {
              priority: 20,
              props: {
                isActive: () => e.getAttributes(_n.name).loop,
                icon: R(
                  e.getAttributes(_n.name).loop ? OR : yR
                ),
                action: () => {
                  e.chain().updateAttributes(_n.name, {
                    loop: e.getAttributes(_n.name).loop ? null : !0
                  }).setNodeSelection(e.state.selection.from).focus().run();
                },
                title: e.getAttributes(_n.name).loop ? Q.global.t("editor.extensions.audio.disable_loop") : Q.global.t("editor.extensions.audio.enable_loop")
              }
            },
            {
              priority: 30,
              component: R(Qt)
            },
            {
              priority: 40,
              props: {
                icon: R(ih),
                title: Q.global.t("editor.common.button.edit_link"),
                action: () => R(noe)
              }
            },
            {
              priority: 50,
              props: {
                icon: R(rh),
                title: Q.global.t("editor.common.tooltip.open_link"),
                action: () => {
                  window.open(e.getAttributes(_n.name).src, "_blank");
                }
              }
            },
            {
              priority: 60,
              component: R(Qt)
            },
            {
              priority: 70,
              props: {
                icon: R(Ua),
                title: Q.global.t("editor.common.button.delete"),
                action: ({ editor: n }) => {
                  vc(_n.name, n);
                }
              }
            }
          ]
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e }) {
            let n = e;
            for (; n && !n.hasAttribute("data-node-view-wrapper"); )
              n = n.parentElement;
            return {
              el: n
            };
          }
        };
      }
    };
  }
}), ioe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, roe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "m16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.01 4.01 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0M4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53l-4.95-4.95z"
}, null, -1), soe = [
  roe
];
function ooe(t, e) {
  return P(), L("svg", ioe, [...soe]);
}
const aoe = { name: "mdi-eraser", render: ooe }, loe = mt.create({
  addOptions() {
    return {
      getToolbarItems({ editor: t }) {
        return {
          priority: 23,
          component: R($t),
          props: {
            editor: t,
            isActive: !1,
            icon: R(aoe),
            title: Q.global.t("editor.common.clear_format"),
            action: () => t.chain().focus().unsetAllMarks().run()
          }
        };
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-\\": () => this.editor.chain().focus().unsetAllMarks().run()
    };
  }
}), o_ = wt.create({
  name: "column",
  content: "block+",
  isolating: !0,
  fakeSelection: !0,
  addOptions() {
    return {
      HTMLAttributes: {
        class: "column"
      }
    };
  },
  addAttributes() {
    return {
      index: {
        default: 0,
        parseHTML: (t) => t.getAttribute("index")
      },
      style: {
        default: "min-width: 0;padding: 12px;flex: 1 1;box-sizing: border-box;",
        parseHTML: (t) => t.getAttribute("style")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[class=column]"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "div",
      Ee(this.options.HTMLAttributes, t),
      0
    ];
  }
}), coe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, uoe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M5 3c-1.11 0-2 .89-2 2v14c0 1.11.89 2 2 2h6V3m2 0v8h8V5c0-1.11-.89-2-2-2m-6 10v8h6c1.11 0 2-.89 2-2v-6"
}, null, -1), doe = [
  uoe
];
function hoe(t, e) {
  return P(), L("svg", coe, [...doe]);
}
const Sk = { name: "mdi-collage", render: hoe }, foe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, poe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M12 3a1 1 0 0 1 1 1v8a5 5 0 1 1 .213 8.152L13 20a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm-1 2H7v14h4zm8 10h-6v2h6z"
}, null, -1), moe = [
  poe
];
function goe(t, e) {
  return P(), L("svg", foe, [...moe]);
}
const boe = { name: "ri-delete-column", render: goe }, Ooe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, yoe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M20 3a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm-1 2h-4v14h4zM6 7a5 5 0 1 1 0 10A5 5 0 0 1 6 7m1 2H5v1.999L3 11v2l2-.001V15h2v-2.001L9 13v-2l-2-.001z"
}, null, -1), _oe = [
  yoe
];
function voe(t, e) {
  return P(), L("svg", Ooe, [..._oe]);
}
const xoe = { name: "ri-insert-column-left", render: voe }, woe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Soe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M10 3a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zM9 5H5v14h4zm9 2a5 5 0 1 1 0 10a5 5 0 0 1 0-10m1 2h-2v1.999L15 11v2l2-.001V15h2v-2.001L21 13v-2l-2-.001z"
}, null, -1), koe = [
  Soe
];
function Eoe(t, e) {
  return P(), L("svg", woe, [...koe]);
}
const Coe = { name: "ri-insert-column-right", render: Eoe }, Aoe = (t, e) => {
  const n = Toe(t), i = [];
  for (let r = 0; r < e; r += 1) {
    const s = n.column.createAndFill({ index: r });
    s && i.push(s);
  }
  return n.columns.createChecked({ cols: e }, i);
}, Toe = (t) => {
  if (t.cached.columnsNodeTypes)
    return t.cached.columnsNodeTypes;
  const e = {
    columns: t.nodes.columns,
    column: t.nodes.column
  };
  return t.cached.columnsNodeTypes = e, e;
}, m1 = (t, e, n) => {
  const i = Hi(
    (s) => s.type.name === ld.name
  )(e.selection), r = Hi((s) => s.type.name === o_.name)(
    e.selection
  );
  if (t && i && r) {
    const s = i.node, o = r.node.attrs.index, a = s.toJSON();
    let l = o;
    n === "delete" ? (l = o - 1, a.content.splice(o, 1)) : (l = n === "addBefore" ? o : o + 1, a.content.splice(l, 0, {
      type: "column",
      attrs: {
        index: o
      },
      content: [
        {
          type: "paragraph"
        }
      ]
    })), a.attrs.cols = a.content.length, a.content.forEach((h, f) => {
      h.attrs.index = f;
    });
    const c = Wr.fromJSON(e.schema, a);
    let u = i.pos;
    c.content.forEach((h, f, p) => {
      p < l && (u += h.nodeSize);
    });
    const d = e.tr.setTime(Date.now());
    d.replaceWith(
      i.pos,
      i.pos + i.node.nodeSize,
      c
    ).setSelection(ce.near(d.doc.resolve(u))), t(d);
  }
  return !0;
}, kk = (t, e, n) => {
  const i = Hi(
    (s) => s.type.name === ld.name
  )(t.selection), r = Hi((s) => s.type.name === o_.name)(
    t.selection
  );
  if (e && i && r) {
    const s = i.node, o = r.node.attrs.index;
    let a = 0;
    n === "before" ? a = (o - 1 + s.attrs.cols) % s.attrs.cols : a = (o + 1) % s.attrs.cols;
    let l = i.pos;
    s.content.forEach((u, d, h) => {
      h < a && (l += u.nodeSize);
    });
    const c = t.tr.setTime(Date.now());
    return c.setSelection(ce.near(c.doc.resolve(l))), e(c), !0;
  }
  return !1;
}, ld = wt.create({
  name: "columns",
  group: "block",
  priority: 10,
  defining: !0,
  isolating: !0,
  allowGapCursor: !0,
  content: "column{1,}",
  fakeSelection: !1,
  addOptions() {
    return {
      HTMLAttributes: {
        class: "columns"
      },
      getToolboxItems({ editor: t }) {
        return [
          {
            priority: 50,
            component: R(Qo),
            props: {
              editor: t,
              icon: R(Sk),
              title: Q.global.t("editor.extensions.commands_menu.columns"),
              action: () => {
                t.chain().focus().insertColumns({
                  cols: 2
                }).run();
              }
            }
          }
        ];
      },
      getCommandMenuItems() {
        return {
          priority: 70,
          icon: R(Sk),
          title: "editor.extensions.commands_menu.columns",
          keywords: ["fenlan", "columns"],
          command: ({ editor: t, range: e }) => {
            t.chain().focus().deleteRange(e).insertColumns({
              cols: 2
            }).run();
          }
        };
      },
      getBubbleMenu() {
        return {
          pluginKey: "columnsBubbleMenu",
          shouldShow: ({ state: t }) => xi(t, ld.name),
          getRenderContainer: (t) => {
            let e = t;
            for (e.nodeName === "#text" && (e = t.parentElement); e && e.classList && !e.classList.contains("column"); )
              e = e.parentElement;
            return e;
          },
          items: [
            {
              priority: 10,
              props: {
                icon: R(xoe),
                title: Q.global.t(
                  "editor.extensions.columns.add_column_before"
                ),
                action: ({ editor: t }) => {
                  t.chain().focus().addColBefore().run();
                }
              }
            },
            {
              priority: 20,
              props: {
                icon: R(Coe),
                title: Q.global.t(
                  "editor.extensions.columns.add_column_after"
                ),
                action: ({ editor: t }) => {
                  t.chain().focus().addColAfter().run();
                }
              }
            },
            {
              priority: 30,
              props: {
                icon: R(boe),
                title: Q.global.t("editor.extensions.columns.delete_column"),
                action: ({ editor: t }) => {
                  t.chain().focus().deleteCol().run();
                }
              }
            },
            {
              priority: 40,
              component: R(Qt)
            },
            {
              priority: 50,
              props: {
                icon: R(Ua),
                title: Q.global.t("editor.common.button.delete"),
                action: ({ editor: t }) => {
                  vc(ld.name, t);
                }
              }
            }
          ]
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: t }) {
            let e = t;
            for (; e && !e.classList.contains("columns"); )
              e = e.parentElement;
            return {
              el: e,
              dragDomOffset: {
                y: -5
              }
            };
          },
          allowPropagationDownward: !0
        };
      }
    };
  },
  addAttributes() {
    return {
      cols: {
        default: 2,
        parseHTML: (t) => t.getAttribute("cols")
      },
      style: {
        default: "display: flex;width: 100%;grid-gap: 8px;gap: 8px;",
        parseHTML: (t) => t.getAttribute("style")
      }
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "div",
      Ee(this.options.HTMLAttributes, t),
      0
    ];
  },
  addCommands() {
    return {
      insertColumns: (t) => ({ tr: e, dispatch: n, editor: i }) => {
        const r = Aoe(i.schema, t && t.cols || 3);
        if (n) {
          const s = e.selection.anchor + 1;
          e.replaceSelectionWith(r).scrollIntoView().setSelection(ce.near(e.doc.resolve(s)));
        }
        return !0;
      },
      addColBefore: () => ({ dispatch: t, state: e }) => m1(t, e, "addBefore"),
      addColAfter: () => ({ dispatch: t, state: e }) => m1(t, e, "addAfter"),
      deleteCol: () => ({ dispatch: t, state: e }) => m1(t, e, "delete")
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-G": () => this.editor.commands.insertColumns(),
      Tab: () => kk(this.editor.state, this.editor.view.dispatch, "after"),
      "Shift-Tab": () => kk(this.editor.state, this.editor.view.dispatch, "before")
    };
  }
});
let Ai, Ve = null, bi, Lt = null, xa = null, Kf, cd = !1, sh = !1;
const Moe = () => {
  const t = document.createElement("div");
  return t.classList.add("draggable"), t.draggable = !0, t.setAttribute("data-drag-handle", "true"), t;
}, xR = () => {
  var t, e;
  (t = Ve == null ? void 0 : Ve.classList) == null || t.add("show"), (e = Ve == null ? void 0 : Ve.classList) == null || e.remove("hide");
}, jc = () => {
  var t, e, n;
  (t = Ve == null ? void 0 : Ve.classList) == null || t.remove("show"), (e = Ve == null ? void 0 : Ve.classList) == null || e.remove("active"), (n = Ve == null ? void 0 : Ve.classList) == null || n.add("hide");
}, Poe = (t, e) => {
  const n = t.dom.parentElement;
  if (!n || !Ve)
    return;
  const i = e == null ? void 0 : e.el;
  if (!i)
    return;
  const r = i.getBoundingClientRect(), s = n.getBoundingClientRect(), o = Ve.getBoundingClientRect(), a = r.left - s.left - o.width - 5 + e.domOffsetLeft, l = r.top - s.top + o.height / 2 + n.scrollTop + e.domOffsetTop;
  Ve.style.left = `${a}px`, Ve.style.top = `${l - 2}px`, xR();
}, Ek = () => {
  Lt && (sh = !0, bi.dispatch(bi.state.tr), clearTimeout(Kf), xR());
}, Ck = () => {
  Lt && (sh = !1, bi.dispatch(bi.state.tr), jc());
}, Ak = () => {
  if (!Lt)
    return null;
  if (sh = !1, bi.dispatch(bi.state.tr), ge.isSelectable(Lt.node)) {
    const t = ge.create(
      bi.state.doc,
      Lt.$pos.pos - Lt.offset
    );
    return bi.dispatch(
      bi.state.tr.setSelection(t)
    ), bi.focus(), xa = t, t;
  }
  return null;
}, Tk = () => {
  cd && (cd = !1, xa = null, Lt = null);
}, Mk = (t) => {
  if (cd = !0, sh = !1, t.dataTransfer && Lt && xa) {
    const e = xa.content();
    t.dataTransfer.effectAllowed = "move";
    const { dom: n, text: i } = HB(bi, e);
    t.dataTransfer.clearData(), t.dataTransfer.setData("text/html", n.innerHTML), t.dataTransfer.setData("text/plain", i), t.dataTransfer.setDragImage(Lt == null ? void 0 : Lt.el, 0, 0), bi.dragging = {
      slice: e,
      move: !0
    };
  }
}, Roe = (t, e, n) => {
  const { node: i } = t.domAtPos(n.pos);
  let r = i, s = r.parentElement;
  for (; s && s !== e && n.pos === t.posAtDOM(s, 0); )
    r = s, s = s.parentElement;
  return r;
}, wR = (t, e) => {
  const n = t.posAtDOM(e, 0);
  return n < 0 ? null : t.state.doc.resolve(n);
}, SR = (t, e) => {
  const n = e.dom.parentElement;
  if (!n)
    return null;
  const i = wR(e, t);
  if (!i)
    return null;
  const r = i.node(), s = Roe(e, n, i);
  return { node: r, $pos: i, el: s, offset: 1, domOffsetLeft: 0, domOffsetTop: 0 };
}, $oe = (t, e) => {
  var r, s;
  const n = t.extensionManager.extensions.find((o) => o.name === e.type.name);
  return n ? (s = (r = n.options).getDraggable) == null ? void 0 : s.call(r, {
    editor: t
  }) : void 0;
}, kR = (t, e, n) => {
  var s, o, a;
  const i = (s = e == null ? void 0 : e.getRenderContainer) == null ? void 0 : s.call(e, { dom: n, view: t }), r = SR((i == null ? void 0 : i.el) || n, t);
  return {
    el: (i == null ? void 0 : i.el) || n,
    node: (i == null ? void 0 : i.node) || (r == null ? void 0 : r.node),
    $pos: (i == null ? void 0 : i.$pos) || (r == null ? void 0 : r.$pos),
    offset: (i == null ? void 0 : i.nodeOffset) || (r == null ? void 0 : r.offset),
    domOffsetLeft: ((o = i == null ? void 0 : i.dragDomOffset) == null ? void 0 : o.x) || 0,
    domOffsetTop: ((a = i == null ? void 0 : i.dragDomOffset) == null ? void 0 : a.y) || 0
  };
}, Noe = (t, e, n = 1) => {
  const i = wR(t, e);
  if (!i)
    return;
  if (n > i.depth) {
    if (n - i.depth == 1) {
      const s = i.node();
      if (s.firstChild && !s.firstChild.type.isBlock)
        return s.firstChild;
    }
    return;
  }
  const r = i.node(n);
  if (r)
    return r;
}, PO = ({
  editor: t,
  view: e,
  dom: n,
  event: i,
  depth: r = 1
}) => {
  const s = Noe(e, n, r);
  if (!s)
    return;
  const o = $oe(t, s);
  if (o) {
    if (typeof o == "boolean")
      return o;
    const a = kR(e, o, n), l = { left: i.clientX, top: i.clientY }, c = e.posAtCoords(l);
    if (c && (c.inside == -1 || !(c.inside >= a.$pos.start() && c.inside <= a.$pos.end())))
      return o;
    if (o.allowPropagationDownward) {
      const u = PO({
        editor: t,
        view: e,
        dom: n,
        event: i,
        depth: ++r
      });
      if (u)
        return u;
    }
    return o;
  }
  return PO({
    editor: t,
    view: e,
    dom: n,
    event: i,
    depth: ++r
  });
}, Doe = (t, e, n) => {
  var s, o;
  const i = t.resolve(e);
  if (!n.content.size)
    return e;
  let r = n.content;
  for (let a = 0; a < n.openStart; a++)
    r = (s = r == null ? void 0 : r.firstChild) == null ? void 0 : s.content;
  for (let a = 1; a <= (n.openStart == 0 && n.size ? 2 : 1); a++)
    for (let l = i.depth; l >= 0; l--) {
      const c = l == i.depth ? 0 : i.pos <= (i.start(l + 1) + i.end(l + 1)) / 2 ? -1 : 1, u = i.index(l) + (c > 0 ? 1 : 0), d = i.node(l);
      let h = !1;
      if (a == 1)
        h = d.canReplace(u, u, r);
      else {
        const f = d.contentMatchAt(u).findWrapping((o = r == null ? void 0 : r.firstChild) == null ? void 0 : o.type);
        h = f && d.canReplaceWith(u, u, f[0]) || !1;
      }
      if (h)
        return c == 0 ? i.pos : c < 0 ? i.before(l + 1) : i.after(l + 1);
    }
  return null;
}, fxe = mt.create({
  name: "draggable",
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("node-draggable"),
        view: (t) => {
          Ve = Moe(), Ve.addEventListener(
            "mouseenter",
            Ek
          ), Ve.addEventListener(
            "mouseleave",
            Ck
          ), Ve.addEventListener(
            "mousedown",
            Ak
          ), Ve.addEventListener("mouseup", Tk), Ve.addEventListener(
            "dragstart",
            Mk
          );
          const e = t.dom.parentNode;
          return e.appendChild(Ve), e.style.position = "relative", {
            update: (n) => {
              bi = n;
            },
            destroy: () => {
              Ve && (clearTimeout(Kf), Ve.removeEventListener(
                "mouseenter",
                Ek
              ), Ve.removeEventListener(
                "mouseleave",
                Ck
              ), Ve.removeEventListener(
                "mousedown",
                Ak
              ), Ve.removeEventListener(
                "mouseup",
                Tk
              ), Ve.removeEventListener(
                "dragstart",
                Mk
              ), Ve.remove());
            }
          };
        },
        props: {
          handleDOMEvents: {
            // @ts-ignore
            mousemove: (t, e) => {
              var l;
              const n = { left: e.clientX, top: e.clientY }, i = t.posAtCoords(n);
              if (!i || !i.pos) return !1;
              const r = i.inside > -1 ? i.inside : i.pos, s = t.nodeDOM(r) || ((l = t.domAtPos(r)) == null ? void 0 : l.node) || e.target;
              if (!s)
                return jc(), !1;
              let o = s;
              for (; o && o.nodeType === 3; )
                o = o.parentElement;
              if (!(o instanceof HTMLElement))
                return jc(), !1;
              const a = this.editor;
              if (Ai = PO({
                // @ts-ignore
                editor: a,
                view: t,
                dom: o,
                event: e
              }), !Ai)
                return !1;
              if (typeof Ai == "boolean" ? Lt = SR(o, t) : Lt = kR(t, Ai, o), !!Lt)
                return Poe(t, Lt), !1;
            },
            mouseleave: () => (clearTimeout(Kf), Kf = setTimeout(() => {
              jc();
            }, 400), !1)
          },
          handleKeyDown() {
            return Ve && (Ai = void 0, jc()), !1;
          },
          handleDrop: (t, e, n) => {
            var a;
            if (!Ve || !xa)
              return !1;
            const i = t.posAtCoords({
              left: e.clientX,
              top: e.clientY
            });
            if (!i)
              return !0;
            const r = t.state.doc.resolve(i.pos), s = Doe(t.state.doc, r.pos, n);
            if (!s)
              return !1;
            let o = !1;
            if (cd && typeof Ai != "boolean") {
              const l = (a = Ai == null ? void 0 : Ai.handleDrop) == null ? void 0 : a.call(Ai, {
                view: t,
                event: e,
                slice: n,
                insertPos: s,
                node: Lt == null ? void 0 : Lt.node,
                selection: xa
              });
              typeof l == "boolean" && (o = l);
            }
            return cd = !1, Ai = void 0, xa = null, Lt = null, o;
          },
          decorations: (t) => {
            if (!sh || !Lt)
              return We.empty;
            const { $pos: e } = Lt;
            return We.create(t.doc, [
              zt.node(e.before(), e.after(), {
                class: "has-draggable-handle"
              })
            ]);
          }
        }
      })
    ];
  }
}), Ioe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Loe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M8 3C5.79 3 4 4.79 4 7v7c0 1.1.9 2 2 2h3v4c0 1.1.9 2 2 2h2c1.1 0 2-.9 2-2v-4h3c1.1 0 2-.9 2-2V3zm0 2h4v2h2V5h1v4h2V5h1v5H6V7c0-1.1.9-2 2-2m-2 9v-2h12v2z"
}, null, -1), Boe = [
  Loe
];
function Qoe(t, e) {
  return P(), L("svg", Ioe, [...Boe]);
}
const Foe = { name: "mdi-brush-variant", render: Qoe }, zoe = (t) => {
  const e = [], { doc: n, selection: i } = t, { from: r, to: s, empty: o } = i;
  if (o)
    return e;
  let a = !1;
  return n.nodesBetween(r, s, (l, c) => {
    if (!(!l || (l == null ? void 0 : l.nodeSize) === void 0) && l.isText && !a)
      return a = !0, e.push(
        ...l.marks.map((u) => ({
          from: c,
          to: c + l.nodeSize,
          mark: u
        }))
      ), !1;
  }), e;
}, Uoe = (t, e, n) => {
  const { selection: i } = t, r = n || t.tr, { from: s, to: o } = i;
  return i instanceof at ? i.ranges.forEach((a) => {
    const l = {
      from: a.$from.pos,
      to: a.$to.pos
    };
    Pk(r, t, l, e);
  }) : Pk(
    r,
    t,
    {
      from: s,
      to: o
    },
    e
  ), r;
}, Pk = (t, e, n, i) => {
  const { from: r, to: s } = n;
  e.doc.nodesBetween(r, s, (o, a) => {
    if (!(!o || (o == null ? void 0 : o.nodeSize) === void 0)) {
      if (o.isText) {
        const l = {
          from: Math.max(a, r),
          to: Math.min(a + o.nodeSize, s)
        };
        o.marks.forEach((c) => {
          t.step(new ar(l.from, l.to, c));
        }), i.forEach((c) => {
          t.step(new _s(l.from, l.to, c.mark));
        });
      }
      return !0;
    }
  });
}, Woe = mt.create({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolbarItems({ editor: e }) {
        const n = e.view.dom.classList.contains("format-brush-mode");
        return {
          priority: 25,
          component: R($t),
          props: {
            editor: e,
            isActive: n,
            icon: R(Foe),
            title: n ? Q.global.t(
              "editor.extensions.format_brush.toolbar_item.cancel"
            ) : Q.global.t(
              "editor.extensions.format_brush.toolbar_item.title"
            ),
            action: () => {
              n ? e.commands.pasteFormatBrush() : e.commands.copyFormatBrush();
            }
          }
        };
      }
    };
  },
  addCommands() {
    return {
      copyFormatBrush: () => ({ state: t }) => {
        const e = zoe(t);
        return this.storage.formatBrushMarks = e, this.storage.formatBrush = !0, this.editor.view.dom.classList.add("format-brush-mode"), !0;
      },
      pasteFormatBrush: () => () => (this.storage.formatBrushMarks = [], this.storage.formatBrush = !1, this.editor.view.dom.classList.remove("format-brush-mode"), !0)
    };
  },
  addStorage() {
    return {
      formatBrush: !1,
      formatBrushMarks: []
    };
  },
  addProseMirrorPlugins() {
    const t = this.storage, e = this.editor;
    return [
      new Ue({
        key: new Ke("formatBrushPlugin"),
        props: {
          handleDOMEvents: {
            mouseup(n) {
              t.formatBrush && e.chain().command(({ tr: i }) => (Uoe(n.state, t.formatBrushMarks, i), !0)).pasteFormatBrush().run();
            }
          }
        }
      })
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Shift-Mod-c": () => (this.editor.commands.copyFormatBrush(), !0)
    };
  }
});
class yt extends _e {
  constructor(n) {
    super(n, n);
    Pe(this, "start", !1);
    this.start = Hoe(n);
  }
  map(n, i) {
    const r = n.resolve(i.map(this.head));
    return yt.valid(r) ? new yt(r) : _e.near(r);
  }
  content() {
    return ne.empty;
  }
  eq(n) {
    return n instanceof yt && n.head == this.head;
  }
  toJSON() {
    return { type: "node-gap-cursor", pos: this.head };
  }
  get isStart() {
    return this.start;
  }
  static fromJSON(n, i) {
    if (typeof i.pos != "number")
      throw new RangeError("Invalid input for GapCursorSelection.fromJSON");
    return new yt(n.resolve(i.pos));
  }
  getBookmark() {
    return new a_(this.anchor);
  }
  /**
   * Validates if a GapCursor can be placed at the given position
   *
   * This function checks whether a GapCursor can be placed at the specified position in the document.
   * It ensures that the position is not within a text block, and that the node at the position allows a GapCursor.
   *
   * @param {ResolvedPos} $pos - The resolved position in the document to validate.
   * @returns {boolean} - Returns true if a GapCursor can be placed at the given position, false otherwise.
   */
  static valid(n) {
    if (n.depth < 1)
      return !1;
    const r = n.doc.childBefore(n.pos).node;
    return !r || n.parent.isTextblock || !Voe(n) && !Zoe(n) || !r.type.spec.allowGapCursor ? !1 : !r.type.inlineContent;
  }
  static findGapCursorFrom(n, i, r = !1) {
    let s = !0;
    for (; s; ) {
      if (!r && yt.valid(n))
        return n;
      let o = n.pos, a = null;
      for (let l = n.depth; l >= 0; l--) {
        const c = n.node(l), u = i > 0 ? n.indexAfter(l) : n.index(l) - 1;
        if (i > 0 ? u < c.childCount : u >= 0) {
          a = c.child(u);
          break;
        }
        if (l == 0)
          return null;
        o += i;
        const d = n.doc.resolve(o);
        if (yt.valid(d))
          return d;
      }
      for (; a; ) {
        const l = i > 0 ? a.firstChild : a.lastChild;
        if (!l) {
          if (a.isAtom && !a.isText && !ge.isSelectable(a)) {
            n = n.doc.resolve(o + a.nodeSize * i), r = !1;
            break;
          }
          s = !1;
          break;
        }
        a = l, o += i;
        const c = n.doc.resolve(o);
        if (yt.valid(c))
          return c;
      }
      a || (s = !1);
    }
    return null;
  }
}
yt.prototype.visible = !1;
yt.findFrom = yt.findGapCursorFrom;
_e.jsonID("node-gap-cursor", yt);
class a_ {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new a_(e.map(this.pos));
  }
  resolve(e) {
    const n = e.resolve(this.pos);
    return yt.valid(n) ? new yt(n) : _e.near(n);
  }
}
function Voe(t) {
  for (let e = t.depth; e >= 0; e--) {
    const n = t.index(e), i = t.node(e);
    if (n === 0) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    if (ER(i.child(n - 1), !1))
      return !0;
  }
  return !0;
}
function Zoe(t) {
  for (let e = t.depth; e >= 0; e--) {
    const n = t.indexAfter(e), i = t.node(e);
    if (n === i.childCount) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    if (ER(i.child(n), !0))
      return !0;
  }
  return !0;
}
function ER(t, e) {
  for (; t; ) {
    if (t.childCount === 0 && !t.inlineContent || t.isAtom || t.type.spec.isolating)
      return !0;
    if (t.inlineContent)
      return !1;
    t = e ? t.firstChild : t.lastChild;
  }
  return !1;
}
function Hoe(t) {
  if (t.depth < 1)
    return null;
  const e = t.start(1), n = t.end(1);
  return t.pos < e + (n - e) / 2;
}
const qoe = mt.create({
  priority: 9999,
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("custom-gap-cursor"),
        props: {
          decorations: Yoe,
          // If a GapCursor can be created at the current position, use GapCursor instead of other selection types
          createSelectionBetween(t, e, n) {
            return e.pos == n.pos && yt.valid(n) ? new yt(n) : null;
          },
          handleClick(t, e, n) {
            if (!t || !t.editable)
              return !1;
            const i = t.posAtCoords({
              left: n.clientX,
              top: n.clientY
            });
            if (i && i.inside > -1)
              return !1;
            const r = t.state.doc.resolve(e);
            return yt.valid(r) ? (t.dispatch(
              t.state.tr.setSelection(new yt(r))
            ), !0) : !1;
          },
          handleKeyDown: m0({
            ArrowLeft: rf("horiz", -1),
            ArrowRight: rf("horiz", 1),
            ArrowUp: rf("vert", -1),
            ArrowDown: rf("vert", 1),
            Enter: (t, e) => {
              const n = sf(t, !1);
              return n && e ? (e(n), !0) : !1;
            },
            Backspace: (t, e) => {
              const { selection: n, tr: i } = t;
              if (xi(t, "paragraph") && n5(t.selection.$from.parent) && n instanceof ce && n.empty) {
                const { $from: c } = n;
                return td(c)(i), e && CR(-1, "left", t)(i) ? (e(i), !0) : !1;
              }
              if (!(n instanceof yt) || !e)
                return !1;
              const { isStart: r, $from: s } = n, o = t.doc.childBefore(s.pos), a = o.index, l = t.doc.resolve(0).posAtIndex(a);
              return r ? Xoe(l, t, e) : o.node && td(t.doc.resolve(l))(i) ? (e(i), !0) : !1;
            },
            Tab: (t, e) => {
              const n = sf(t);
              return n && e ? (e(n), !0) : !1;
            }
          }),
          handleTextInput(t) {
            const { state: e, dispatch: n } = t, i = sf(e);
            return i && n && n(i), !1;
          },
          handleDOMEvents: {
            /**
             * Solve the issue of inserting text during composition input events, e.g., Chinese input
             */
            beforeinput: (t, e) => {
              const { state: n, dispatch: i } = t;
              if (e.inputType != "insertCompositionText" || !(n.selection instanceof yt))
                return !1;
              const r = sf(n);
              return r && i && i(r), !1;
            }
          }
        }
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: Ne(he(t, "allowGapCursor", e)) ?? null
    };
  }
});
function Xoe(t, e, n) {
  const { tr: i } = e;
  if (t == 0)
    return !1;
  const r = e.doc.resolve(t - 1), s = r.parent;
  return s.inlineContent || s.isTextblock ? joe(r, e, n) : yt.valid(r) && n ? (n(i.setSelection(new yt(r))), !0) : td(r)(i) && n ? (n(i), !0) : !1;
}
function joe(t, e, n) {
  return t.parentOffset == 0 && t.pos > 1 && n ? (n(e.tr.delete(t.pos - 1, t.pos)), !0) : (n && n(
    e.tr.setSelection(ce.create(e.doc, t.pos))
  ), !0);
}
function rf(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return (i, r, s) => {
    const { tr: o } = i;
    return CR(e, n, i, s)(o) && r ? (r(o), !0) : !1;
  };
}
const CR = (t, e, n, i) => (r) => {
  const s = n.selection;
  let o = t > 0 ? s.$to : s.$from, a = s.empty;
  if (s instanceof ce) {
    if (o.depth == 0 || i && !i.endOfTextblock(e))
      return;
    if (a = !1, o = n.doc.resolve(t > 0 ? o.after() : o.before()), o.depth > 0) {
      const c = o.pos, u = o.start(1) + 1, d = o.end(1) - 1;
      if (c != u && c != d)
        return;
    }
  }
  if (s instanceof yt)
    return;
  const l = yt.findGapCursorFrom(o, t, a);
  if (l)
    return r.setSelection(new yt(l)), l;
};
function sf(t, e = !0) {
  const { tr: n } = t;
  if (!(t.selection instanceof yt))
    return;
  const { isStart: i, $from: r } = t.selection;
  if (t.selection instanceof ri || r.parent.inlineContent)
    return;
  const s = t.doc.resolve(0), o = t.doc.childBefore(r.pos), a = i ? o.index : o.index + 1, l = s.posAtIndex(a);
  return n.insert(l, t.schema.nodes.paragraph.create()), (e || !i) && (n.setSelection(ce.create(n.doc, l + 1)), n.scrollIntoView()), n;
}
function Yoe(t) {
  if (!(t.selection instanceof yt))
    return null;
  const e = t.selection.$head;
  if (e.depth < 1)
    return null;
  const n = e.node(1), i = e.start(1) - 1, r = t.selection.isStart;
  return We.create(t.doc, [
    zt.node(i, i + n.nodeSize, {
      key: "node-gap-cursor",
      class: `card-gap-cursor ${r ? "start" : "end"}-card-gap-cursor`
    })
  ]);
}
const Goe = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g, Koe = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
function xm(t) {
  return !t || t.replace(Goe, "").match(Koe);
}
const Joe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, eae = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3 21V3h18v18zM5 5v14h14V5z"
}, null, -1), tae = [
  eae
];
function nae(t, e) {
  return P(), L("svg", Joe, [...tae]);
}
const iae = { name: "mdi-border-all-variant", render: nae }, rae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, sae = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M15 5h2V3h-2m0 18h2v-2h-2M11 5h2V3h-2m8 2h2V3h-2m0 6h2V7h-2m0 14h2v-2h-2m0-6h2v-2h-2m0 6h2v-2h-2M3 5h2V3H3m0 6h2V7H3m0 6h2v-2H3m0 6h2v-2H3m0 6h2v-2H3m8 2h2v-2h-2m-4 2h2v-2H7M7 5h2V3H7z"
}, null, -1), oae = [
  sae
];
function aae(t, e) {
  return P(), L("svg", rae, [...oae]);
}
const lae = { name: "mdi-border-none-variant", render: aae }, cae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, uae = /* @__PURE__ */ A("path", {
  d: "M16 18H7V4h9m-4.5 18a1.5 1.5 0 0 1-1.5-1.5a1.5 1.5 0 0 1 1.5-1.5a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m4-21h-8A2.5 2.5 0 0 0 5 3.5v17A2.5 2.5 0 0 0 7.5 23h8a2.5 2.5 0 0 0 2.5-2.5v-17A2.5 2.5 0 0 0 15.5 1z",
  fill: "currentColor"
}, null, -1), dae = [
  uae
];
function hae(t, e) {
  return P(), L("svg", cae, [...dae]);
}
const fae = { name: "mdi-cellphone-iphone", render: hae }, pae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, mae = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M21 14H3V4h18m0-2H3c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h7l-2 3v1h8v-1l-2-3h7a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2Z"
}, null, -1), gae = [
  mae
];
function bae(t, e) {
  return P(), L("svg", pae, [...gae]);
}
const Oae = { name: "mdi-desktop-mac", render: bae }, yae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, _ae = /* @__PURE__ */ A("path", {
  d: "M19 19H4V3h15m-7.5 20a1.5 1.5 0 0 1-1.5-1.5a1.5 1.5 0 0 1 1.5-1.5a1.5 1.5 0 0 1 1.5 1.5a1.5 1.5 0 0 1-1.5 1.5m7-23h-14A2.5 2.5 0 0 0 2 2.5v19A2.5 2.5 0 0 0 4.5 24h14a2.5 2.5 0 0 0 2.5-2.5v-19A2.5 2.5 0 0 0 18.5 0z",
  fill: "currentColor"
}, null, -1), vae = [
  _ae
];
function xae(t, e) {
  return P(), L("svg", yae, [...vae]);
}
const Rk = { name: "mdi-tablet-ipad", render: xae }, wae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Sae = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M16.36 14c.08-.66.14-1.32.14-2s-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2m-5.15 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95a8.03 8.03 0 0 1-4.33 3.56M14.34 14H9.66c-.1-.66-.16-1.32-.16-2s.06-1.35.16-2h4.68c.09.65.16 1.32.16 2s-.07 1.34-.16 2M12 19.96c-.83-1.2-1.5-2.53-1.91-3.96h3.82c-.41 1.43-1.08 2.76-1.91 3.96M8 8H5.08A7.92 7.92 0 0 1 9.4 4.44C8.8 5.55 8.35 6.75 8 8m-2.92 8H8c.35 1.25.8 2.45 1.4 3.56A8 8 0 0 1 5.08 16m-.82-2C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2M12 4.03c.83 1.2 1.5 2.54 1.91 3.97h-3.82c.41-1.43 1.08-2.77 1.91-3.97M18.92 8h-2.95a15.7 15.7 0 0 0-1.38-3.56c1.84.63 3.37 1.9 4.33 3.56M12 2C6.47 2 2 6.5 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2"
}, null, -1), kae = [
  Sae
];
function Eae(t, e) {
  return P(), L("svg", wae, [...kae]);
}
const $k = { name: "mdi-web", render: Eae }, Cae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Aae = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M16.5 11.74c0-.59-.07-1.16-.14-1.74h3.38c.08.33.15.67.19 1c.72.07 1.41.23 2.07.5C21.71 6.21 17.35 2 12 2C6.47 2 2 6.5 2 12s4.5 10 10 10c.87 0 1.71-.12 2.5-.33a6.6 6.6 0 0 1-1.46-3.47c-.31.61-.65 1.2-1.04 1.76c-.83-1.2-1.5-2.53-1.91-3.96h3.09c.17-.72.46-1.39.85-2H9.66c-.1-.66-.16-1.32-.16-2s.06-1.35.16-2h4.68c.09.65.16 1.32.16 2c0 .5-.04 1-.1 1.5a6.4 6.4 0 0 1 2.1-1.76M4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2zm.82 2H8c.35 1.25.8 2.45 1.4 3.56A8 8 0 0 1 5.08 16M8 8H5.08A7.92 7.92 0 0 1 9.4 4.44C8.8 5.55 8.35 6.75 8 8m2.09 0c.41-1.43 1.08-2.77 1.91-3.97c.83 1.2 1.5 2.54 1.91 3.97zm8.83 0h-2.95a15.7 15.7 0 0 0-1.38-3.56c1.84.63 3.37 1.9 4.33 3.56M23 17.5c0 .82-.25 1.58-.67 2.21l-1.09-1.09c.17-.34.26-.72.26-1.12A2.5 2.5 0 0 0 19 15v1.5l-2.25-2.25L19 12v1.5c2.21 0 4 1.79 4 4m-4 1l2.25 2.25L19 23v-1.5c-2.21 0-4-1.79-4-4c0-.82.25-1.58.67-2.21l1.09 1.09c-.17.34-.26.72-.26 1.12A2.5 2.5 0 0 0 19 20z"
}, null, -1), Tae = [
  Aae
];
function Mae(t, e) {
  return P(), L("svg", Cae, [...Tae]);
}
const Pae = { name: "mdi-web-sync", render: Mae }, Rae = ["placeholder"], $ae = /* @__PURE__ */ ke({
  __name: "BubbleItemIframeLink",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => e.editor.getAttributes(Jt.name).src,
      set: (i) => {
        !i || !xm(i) || e.editor.chain().updateAttributes(Jt.name, { src: i }).run();
      }
    });
    return (i, r) => ut((P(), L("input", {
      "onUpdate:modelValue": r[0] || (r[0] = (s) => n.value = s),
      placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
      class: "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
    }, null, 8, Rae)), [
      [
        Fn,
        n.value,
        void 0,
        { lazy: !0 }
      ]
    ]);
  }
}), Nae = /* @__PURE__ */ ke({
  __name: "BubbleItemIframeSize",
  props: {
    editor: {}
  },
  setup(t) {
    const e = t, n = Be({
      get: () => e.editor.getAttributes(Jt.name).width,
      set: (s) => {
        r(s, i.value);
      }
    }), i = Be({
      get: () => e.editor.getAttributes(Jt.name).height,
      set: (s) => {
        r(n.value, s);
      }
    }), r = (s, o) => {
      e.editor.chain().updateAttributes(Jt.name, { width: s, height: o }).focus().setNodeSelection(e.editor.state.selection.from).run();
    };
    return (s, o) => (P(), L(Yt, null, [
      fe(Z(Ll), {
        modelValue: n.value,
        "onUpdate:modelValue": o[0] || (o[0] = (a) => n.value = a),
        modelModifiers: { lazy: !0, trim: !0 },
        tooltip: Z(Q).global.t("editor.common.tooltip.custom_width_input")
      }, null, 8, ["modelValue", "tooltip"]),
      fe(Z(Ll), {
        modelValue: i.value,
        "onUpdate:modelValue": o[1] || (o[1] = (a) => i.value = a),
        modelModifiers: { lazy: !0, trim: !0 },
        tooltip: Z(Q).global.t("editor.common.tooltip.custom_height_input")
      }, null, 8, ["modelValue", "tooltip"]),
      fe(Z(Qt))
    ], 64));
  }
}), Dae = {
  key: 0,
  class: "p-1.5"
}, Iae = ["placeholder"], Lae = ["src", "width", "height", "frameborder"], Bae = /* @__PURE__ */ ke({
  __name: "IframeView",
  props: {
    editor: {},
    node: {},
    decorations: {},
    selected: { type: Boolean },
    extension: {},
    getPos: { type: Function },
    updateAttributes: { type: Function },
    deleteNode: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => {
        var o;
        return (o = e.node) == null ? void 0 : o.attrs.src;
      },
      set: (o) => {
        !o || !xm(o) || e.updateAttributes({ src: o });
      }
    }), i = Be(() => e.node.attrs.frameborder);
    function r() {
      e.editor.commands.setNodeSelection(e.getPos());
    }
    const s = pt();
    return Gi(() => {
      n.value || s.value.focus();
    }), (o, a) => (P(), Re(Z(bc), {
      as: "div",
      class: "inline-block w-full"
    }, {
      default: ze(() => [
        A("div", {
          class: "inline-block overflow-hidden transition-all text-center relative h-full max-w-full",
          style: sn({
            width: o.node.attrs.width
          })
        }, [
          n.value ? (P(), L("iframe", {
            key: 1,
            class: Ot(["rounded-md", {
              "border-2": i.value === "1"
            }]),
            src: o.node.attrs.src,
            width: o.node.attrs.width,
            height: o.node.attrs.height,
            scrolling: "yes",
            frameborder: i.value,
            framespacing: "0",
            allowfullscreen: "true",
            onMouseenter: r
          }, null, 42, Lae)) : (P(), L("div", Dae, [
            ut(A("input", {
              ref_key: "inputRef",
              ref: s,
              "onUpdate:modelValue": a[0] || (a[0] = (l) => n.value = l),
              class: "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
              placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
              tabindex: "-1",
              onFocus: r
            }, null, 40, Iae), [
              [
                Fn,
                n.value,
                void 0,
                { lazy: !0 }
              ]
            ])
          ]))
        ], 4)
      ]),
      _: 1
    }));
  }
}), Jt = wt.create({
  name: "iframe",
  fakeSelection: !0,
  inline() {
    return !0;
  },
  group() {
    return "inline";
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      src: {
        default: null,
        parseHTML: (e) => e.getAttribute("src")
      },
      width: {
        default: "100%",
        parseHTML: (e) => e.getAttribute("width"),
        renderHTML(e) {
          return {
            width: e.width
          };
        }
      },
      height: {
        default: "300px",
        parseHTML: (e) => e.getAttribute("height"),
        renderHTML: (e) => ({
          height: e.height
        })
      },
      scrolling: {
        default: null,
        parseHTML: (e) => e.getAttribute("scrolling"),
        renderHTML: (e) => ({
          scrolling: e.scrolling
        })
      },
      frameborder: {
        default: "0",
        parseHTML: (e) => e.getAttribute("frameborder"),
        renderHTML: (e) => ({
          frameborder: e.frameborder
        })
      },
      allowfullscreen: {
        default: !0,
        parseHTML: (e) => e.getAttribute("allowfullscreen"),
        renderHTML: (e) => ({
          allowfullscreen: e.allowfullscreen
        })
      },
      framespacing: {
        default: 0,
        parseHTML: (e) => {
          const n = e.getAttribute("framespacing");
          return n ? parseInt(n, 10) : null;
        },
        renderHTML: (e) => ({
          framespacing: e.framespacing
        })
      },
      style: {
        renderHTML() {
          return {
            style: "display: inline-block"
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "iframe",
        getAttrs: (t) => {
          const e = t.getAttribute("src");
          return !e || !xm(e) ? !1 : { src: e };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return xm(t.src) ? ["iframe", Ee(t)] : ["iframe", Ee({ ...t, src: "" })];
  },
  addCommands() {
    return {
      setIframe: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      jd({
        find: /^\$iframe\$$/,
        type: this.type,
        getAttributes: () => ({ width: "100%" })
      })
    ];
  },
  addPasteRules() {
    return [
      CZ({
        find: /<iframe.*?src="(.*?)".*?<\/iframe>/g,
        type: this.type,
        getAttributes: (t) => {
          const n = document.createRange().createContextualFragment(t[0]).querySelector("iframe");
          if (n)
            return {
              src: n.src,
              width: n.width || "100%",
              height: n.height || "300px"
            };
        }
      })
    ];
  },
  addNodeView() {
    return Oc(Bae);
  },
  addOptions() {
    return {
      getCommandMenuItems() {
        return {
          priority: 90,
          icon: R($k),
          title: "editor.extensions.commands_menu.iframe",
          keywords: ["iframe", "qianruwangye"],
          command: ({ editor: t, range: e }) => {
            t.chain().focus().deleteRange(e).insertContent([{ type: "iframe", attrs: { src: "" } }]).run();
          }
        };
      },
      getToolboxItems({ editor: t }) {
        return [
          {
            priority: 40,
            component: R(Qo),
            props: {
              editor: t,
              icon: R($k),
              title: Q.global.t("editor.extensions.commands_menu.iframe"),
              action: () => {
                t.chain().focus().insertContent([{ type: "iframe", attrs: { src: "" } }]).run();
              }
            }
          }
        ];
      },
      getBubbleMenu({ editor: t }) {
        return {
          pluginKey: "iframeBubbleMenu",
          shouldShow: ({ state: e }) => xi(e, Jt.name),
          items: [
            {
              priority: 10,
              props: {
                isActive: () => t.getAttributes(Jt.name).frameborder === "1",
                icon: R(
                  t.getAttributes(Jt.name).frameborder === "1" ? iae : lae
                ),
                action: () => {
                  t.chain().updateAttributes(Jt.name, {
                    frameborder: t.getAttributes(Jt.name).frameborder === "1" ? "0" : "1"
                  }).focus().setNodeSelection(t.state.selection.from).run();
                },
                title: t.getAttributes(Jt.name).frameborder === "1" ? Q.global.t(
                  "editor.extensions.iframe.disable_frameborder"
                ) : Q.global.t(
                  "editor.extensions.iframe.enable_frameborder"
                )
              }
            },
            {
              priority: 20,
              component: R(Qt)
            },
            {
              priority: 30,
              component: R(Nae)
            },
            {
              priority: 40,
              props: {
                isActive: () => of(t, "390px", "844px"),
                icon: R(fae),
                action: () => {
                  af(t, "390px", "844px");
                },
                title: Q.global.t("editor.extensions.iframe.phone_size")
              }
            },
            {
              priority: 50,
              props: {
                isActive: () => of(t, "834px", "1194px"),
                icon: R(Rk),
                action: () => {
                  af(t, "834px", "1194px");
                },
                title: Q.global.t(
                  "editor.extensions.iframe.tablet_vertical_size"
                )
              }
            },
            {
              priority: 60,
              props: {
                isActive: () => of(t, "1194px", "834px"),
                icon: R(Rk),
                iconStyle: "transform: rotate(90deg)",
                action: () => {
                  af(t, "1194px", "834px");
                },
                title: Q.global.t(
                  "editor.extensions.iframe.tablet_horizontal_size"
                )
              }
            },
            {
              priority: 70,
              props: {
                isActive: () => of(t, "100%", "834px"),
                icon: R(Oae),
                action: () => {
                  af(t, "100%", "834px");
                },
                title: Q.global.t("editor.extensions.iframe.desktop_size")
              }
            },
            {
              priority: 80,
              component: R(Qt)
            },
            {
              priority: 90,
              props: {
                isActive: () => t.isActive({ textAlign: "left" }),
                icon: R(xc),
                action: () => lf(t, "left")
              }
            },
            {
              priority: 100,
              props: {
                isActive: () => t.isActive({ textAlign: "center" }),
                icon: R(eh),
                action: () => lf(t, "center")
              }
            },
            {
              priority: 110,
              props: {
                isActive: () => t.isActive({ textAlign: "right" }),
                icon: R(nh),
                action: () => lf(t, "right")
              }
            },
            {
              priority: 120,
              props: {
                isActive: () => t.isActive({ textAlign: "justify" }),
                icon: R(th),
                action: () => lf(t, "justify")
              }
            },
            {
              priority: 130,
              component: R(Qt)
            },
            {
              priority: 140,
              props: {
                icon: R(Pae),
                action: () => {
                  t.chain().updateAttributes(Jt.name, {
                    src: t.getAttributes(Jt.name).src
                  }).run();
                }
              }
            },
            {
              priority: 150,
              props: {
                icon: R(ih),
                title: Q.global.t("editor.common.button.edit_link"),
                action: () => R($ae)
              }
            },
            {
              priority: 160,
              props: {
                icon: R(rh),
                title: Q.global.t("editor.common.tooltip.open_link"),
                action: () => {
                  window.open(t.getAttributes(Jt.name).src, "_blank");
                }
              }
            },
            {
              priority: 190,
              props: {
                icon: R(Ua),
                title: Q.global.t("editor.common.button.delete"),
                action: ({ editor: e }) => {
                  vc(Jt.name, e);
                }
              }
            }
          ]
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: t, view: e }) {
            var r;
            let n = t;
            for (; n && n.tagName !== "P"; )
              n = n.parentElement;
            n && (n = (r = n.firstElementChild) == null ? void 0 : r.firstElementChild);
            let i;
            if (n.firstElementChild) {
              const s = e.posAtDOM(n.firstElementChild, 0);
              i = e.state.doc.resolve(s).node();
            }
            return {
              node: i,
              el: n
            };
          }
        };
      }
    };
  }
}), of = (t, e, n) => {
  const i = t.getAttributes(Jt.name);
  return e === i.width && n === i.height;
}, af = (t, e, n) => {
  t.chain().updateAttributes(Jt.name, { width: e, height: n }).focus().setNodeSelection(t.state.selection.from).run();
}, lf = (t, e) => {
  t.chain().focus().setTextAlign(e).run();
}, Qae = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, Fae = wt.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", Ee(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      jd({
        find: Qae,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, i] = t;
          return { src: n, alt: e, title: i };
        }
      })
    ];
  }
}), zae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Uae = /* @__PURE__ */ A("path", {
  d: "M8.5 13.498l2.5 3.006l3.5-4.506l4.5 6H5m16 1v-14a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z",
  fill: "currentColor"
}, null, -1), Wae = [
  Uae
];
function Vae(t, e) {
  return P(), L("svg", zae, [...Wae]);
}
const Zae = { name: "mdi-file-image-box", render: Vae }, Hae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, qae = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7a5 5 0 0 0-5 5a5 5 0 0 0 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1M8 13h8v-2H8zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4a5 5 0 0 0 5-5a5 5 0 0 0-5-5"
}, null, -1), Xae = [
  qae
];
function jae(t, e) {
  return P(), L("svg", Hae, [...Xae]);
}
const Yae = { name: "mdi-link", render: jae }, Gae = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Kae = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M10 21H5c-1.11 0-2-.89-2-2V5c0-1.11.89-2 2-2h14c1.11 0 2 .89 2 2v5.33c-.3-.12-.63-.19-.96-.19c-.37 0-.72.08-1.04.23V5H5v14h5.11l-.11.11zM7 9h10V7H7zm0 8h5.11L14 15.12V15H7zm0-4h9.12l.88-.88V11H7zm14.7.58l-1.28-1.28a.55.55 0 0 0-.77 0l-1 1l2.05 2.05l1-1a.55.55 0 0 0 0-.77M12 22h2.06l6.05-6.07l-2.05-2.05L12 19.94z"
}, null, -1), Jae = [
  Kae
];
function ele(t, e) {
  return P(), L("svg", Gae, [...Jae]);
}
const tle = { name: "mdi-text-box-edit-outline", render: ele }, nle = ["placeholder"], ile = /* @__PURE__ */ ke({
  __name: "BubbleItemImageAlt",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => e.editor.getAttributes(wn.name).alt,
      set: (i) => {
        e.editor.chain().updateAttributes(wn.name, { alt: i }).setNodeSelection(e.editor.state.selection.from).focus().run();
      }
    });
    return (i, r) => ut((P(), L("input", {
      "onUpdate:modelValue": r[0] || (r[0] = (s) => n.value = s),
      placeholder: Z(Q).global.t("editor.common.placeholder.alt_input"),
      class: "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
    }, null, 8, nle)), [
      [
        Fn,
        n.value,
        void 0,
        { lazy: !0 }
      ]
    ]);
  }
}), rle = ["placeholder"], sle = { class: "inline-flex items-center mt-2" }, ole = { class: "ml-2 text-sm text-gray-500" }, ale = /* @__PURE__ */ ke({
  __name: "BubbleItemImageHref",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => {
        const r = e.editor.getAttributes(EO.name);
        return (r == null ? void 0 : r.href) || e.editor.getAttributes(wn.name).href;
      },
      set: (r) => {
        e.editor.commands.setLink({ href: r, target: "_blank" });
      }
    }), i = Be({
      get() {
        const r = e.editor.getAttributes(EO.name);
        return (r == null ? void 0 : r.target) === "_blank";
      },
      set(r) {
        e.editor.commands.setLink({
          href: n.value,
          target: r ? "_blank" : "_self"
        });
      }
    });
    return (r, s) => (P(), L(Yt, null, [
      ut(A("input", {
        "onUpdate:modelValue": s[0] || (s[0] = (o) => n.value = o),
        placeholder: Z(Q).global.t("editor.common.placeholder.alt_href"),
        class: "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
      }, null, 8, rle), [
        [
          Fn,
          n.value,
          void 0,
          { lazy: !0 }
        ]
      ]),
      A("label", sle, [
        ut(A("input", {
          "onUpdate:modelValue": s[1] || (s[1] = (o) => i.value = o),
          type: "checkbox",
          class: "form-checkbox text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
        }, null, 512), [
          [qA, i.value]
        ]),
        A("span", ole, Ft(Z(Q).global.t("editor.extensions.link.open_in_new_window")), 1)
      ])
    ], 64));
  }
}), lle = ["placeholder"], cle = /* @__PURE__ */ ke({
  __name: "BubbleItemImageLink",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => e.editor.getAttributes(wn.name).src,
      set: (i) => {
        e.editor.chain().updateAttributes(wn.name, { src: i }).setNodeSelection(e.editor.state.selection.from).focus().run();
      }
    });
    return (i, r) => ut((P(), L("input", {
      "onUpdate:modelValue": r[0] || (r[0] = (s) => n.value = s),
      placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
      class: "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
    }, null, 8, lle)), [
      [
        Fn,
        n.value,
        void 0,
        { lazy: !0 }
      ]
    ]);
  }
}), ule = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, dle = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M12 3a9 9 0 0 0-9 9H0l4 4l4-4H5a7 7 0 0 1 7-7a7 7 0 0 1 7 7a7 7 0 0 1-7 7c-1.5 0-2.91-.5-4.06-1.3L6.5 19.14A9.1 9.1 0 0 0 12 21a9 9 0 0 0 9-9a9 9 0 0 0-9-9m2 9a2 2 0 0 0-2-2a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2"
}, null, -1), hle = [
  dle
];
function fle(t, e) {
  return P(), L("svg", ule, [...hle]);
}
const ple = { name: "mdi-backup-restore", render: fle }, mle = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, gle = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M21 3H3C2 3 1 4 1 5v14a2 2 0 0 0 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2M5 17l3.5-4.5l2.5 3l3.5-4.5l4.5 6z"
}, null, -1), ble = [
  gle
];
function Ole(t, e) {
  return P(), L("svg", mle, [...ble]);
}
const AR = { name: "mdi-image-size-select-actual", render: Ole }, yle = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, _le = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M21 15h2v2h-2zm0-4h2v2h-2zm2 8h-2v2c1 0 2-1 2-2M13 3h2v2h-2zm8 4h2v2h-2zm0-4v2h2c0-1-1-2-2-2M1 7h2v2H1zm16-4h2v2h-2zm0 16h2v2h-2zM3 3C2 3 1 4 1 5h2zm6 0h2v2H9zM5 3h2v2H5zm-4 8v8a2 2 0 0 0 2 2h12V11zm2 8l2.5-3.21l1.79 2.15l2.5-3.22L13 19z"
}, null, -1), vle = [
  _le
];
function xle(t, e) {
  return P(), L("svg", yle, [...vle]);
}
const TR = { name: "mdi-image-size-select-large", render: xle }, wle = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Sle = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M23 15h-2v2h2zm0-4h-2v2h2zm0 8h-2v2c1 0 2-1 2-2M15 3h-2v2h2zm8 4h-2v2h2zm-2-4v2h2c0-1-1-2-2-2M3 21h8v-6H1v4a2 2 0 0 0 2 2M3 7H1v2h2zm12 12h-2v2h2zm4-16h-2v2h2zm0 16h-2v2h2zM3 3C2 3 1 4 1 5h2zm0 8H1v2h2zm8-8H9v2h2zM7 3H5v2h2z"
}, null, -1), kle = [
  Sle
];
function Ele(t, e) {
  return P(), L("svg", wle, [...kle]);
}
const MR = { name: "mdi-image-size-select-small", render: Ele }, Cle = /* @__PURE__ */ ke({
  __name: "BubbleItemImageSize",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => e.editor.getAttributes(wn.name).width,
      set: (s) => {
        r(s, i.value);
      }
    }), i = Be({
      get: () => e.editor.getAttributes(wn.name).height,
      set: (s) => {
        r(n.value, s);
      }
    });
    function r(s, o) {
      e.editor.chain().updateAttributes(wn.name, { width: s, height: o }).setNodeSelection(e.editor.state.selection.from).focus().run();
    }
    return (s, o) => (P(), L(Yt, null, [
      fe(Z(Ll), {
        modelValue: n.value,
        "onUpdate:modelValue": o[0] || (o[0] = (a) => n.value = a),
        modelModifiers: { lazy: !0, trim: !0 },
        tooltip: Z(Q).global.t("editor.common.tooltip.custom_width_input")
      }, null, 8, ["modelValue", "tooltip"]),
      fe(Z(Ll), {
        modelValue: i.value,
        "onUpdate:modelValue": o[1] || (o[1] = (a) => i.value = a),
        modelModifiers: { lazy: !0, trim: !0 },
        tooltip: Z(Q).global.t("editor.common.tooltip.custom_height_input")
      }, null, 8, ["modelValue", "tooltip"]),
      fe(Z(Qt)),
      fe(Z(Ol), {
        tooltip: Z(Q).global.t("editor.extensions.image.small_size"),
        selected: s.editor.getAttributes(Z(wn).name).width === "25%",
        onClick: o[2] || (o[2] = (a) => r("25%", "auto"))
      }, {
        icon: ze(() => [
          fe(Z(MR))
        ]),
        _: 1
      }, 8, ["tooltip", "selected"]),
      fe(Z(Ol), {
        tooltip: Z(Q).global.t("editor.extensions.image.medium_size"),
        selected: s.editor.getAttributes(Z(wn).name).width === "50%",
        onClick: o[3] || (o[3] = (a) => r("50%", "auto"))
      }, {
        icon: ze(() => [
          fe(Z(TR))
        ]),
        _: 1
      }, 8, ["tooltip", "selected"]),
      fe(Z(Ol), {
        tooltip: Z(Q).global.t("editor.extensions.image.large_size"),
        selected: s.editor.getAttributes(Z(wn).name).width === "100%",
        onClick: o[4] || (o[4] = (a) => r("100%", "100%"))
      }, {
        icon: ze(() => [
          fe(Z(AR))
        ]),
        _: 1
      }, 8, ["tooltip", "selected"]),
      fe(Z(Ol), {
        tooltip: Z(Q).global.t("editor.extensions.image.restore_size"),
        onClick: o[5] || (o[5] = (a) => r(void 0, void 0))
      }, {
        icon: ze(() => [
          fe(Z(ple))
        ]),
        _: 1
      }, 8, ["tooltip"]),
      fe(Z(Qt))
    ], 64));
  }
}), Ale = {
  key: 0,
  class: "p-1.5 w-full"
}, Tle = ["placeholder"], Mle = ["src", "title", "alt", "href"], Ple = /* @__PURE__ */ ke({
  __name: "ImageView",
  props: {
    editor: {},
    node: {},
    decorations: {},
    selected: { type: Boolean },
    extension: {},
    getPos: { type: Function },
    updateAttributes: { type: Function },
    deleteNode: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => {
        var u;
        return (u = e.node) == null ? void 0 : u.attrs.src;
      },
      set: (u) => {
        e.updateAttributes({
          src: u
        });
      }
    }), i = Be({
      get: () => {
        var u;
        return (u = e.node) == null ? void 0 : u.attrs.alt;
      },
      set: (u) => {
        e.updateAttributes({ alt: u });
      }
    }), r = Be({
      get: () => {
        var u;
        return (u = e.node) == null ? void 0 : u.attrs.href;
      },
      set: (u) => {
        e.updateAttributes({ href: u });
      }
    });
    function s() {
      e.editor.commands.setNodeSelection(e.getPos());
    }
    const o = pt(0), a = pt(), l = pt();
    function c() {
      l.value && (o.value = l.value.clientWidth / l.value.clientHeight);
    }
    return Gi(() => {
      if (!n.value) {
        a.value.focus();
        return;
      }
      if (!l.value) return;
      let u, d;
      l.value.addEventListener("mousedown", function(p) {
        var m;
        u = p.clientX, d = ((m = l.value) == null ? void 0 : m.clientWidth) || 1, document.documentElement.addEventListener("mousemove", h, !1), document.documentElement.addEventListener("mouseup", f, !1);
      });
      function h(p) {
        var _;
        if (!l.value) return;
        const m = Math.min(
          d + p.clientX - u,
          ((_ = l.value.parentElement) == null ? void 0 : _.clientWidth) || 0
        ), g = m.toFixed(0) + "px", b = (m / o.value).toFixed(0) + "px";
        e.editor.chain().updateAttributes(wn.name, { width: g, height: b }).setNodeSelection(e.getPos()).focus().run();
      }
      function f() {
        document.documentElement.removeEventListener("mousemove", h, !1), document.documentElement.removeEventListener("mouseup", f, !1);
      }
    }), (u, d) => (P(), Re(Z(bc), {
      as: "div",
      class: "inline-block w-full"
    }, {
      default: ze(() => [
        n.value ? (P(), L("div", {
          key: 1,
          ref_key: "resizeRef",
          ref: l,
          class: Ot(["resize-x inline-block overflow-hidden text-center relative rounded-md max-w-full", {
            "ring-2 rounded": u.selected
          }]),
          style: sn({
            width: u.node.attrs.width,
            height: u.node.attrs.height
          })
        }, [
          A("img", {
            src: n.value,
            title: u.node.attrs.title,
            alt: i.value,
            href: r.value,
            class: "w-full h-full",
            onLoad: c
          }, null, 40, Mle)
        ], 6)) : (P(), L("div", Ale, [
          ut(A("input", {
            ref_key: "inputRef",
            ref: a,
            "onUpdate:modelValue": d[0] || (d[0] = (h) => n.value = h),
            class: "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
            placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
            tabindex: "-1",
            onFocus: s
          }, null, 40, Tle), [
            [
              Fn,
              n.value,
              void 0,
              { lazy: !0 }
            ]
          ])
        ]))
      ]),
      _: 1
    }));
  }
}), wn = Fae.extend({
  fakeSelection: !0,
  inline() {
    return !0;
  },
  group() {
    return "inline";
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      width: {
        default: void 0,
        parseHTML: (e) => e.getAttribute("width") || e.style.width || null,
        renderHTML: (e) => ({
          width: e.width
        })
      },
      height: {
        default: void 0,
        parseHTML: (e) => e.getAttribute("height") || e.style.height || null,
        renderHTML: (e) => ({
          height: e.height
        })
      },
      href: {
        default: null,
        parseHTML: (e) => e.getAttribute("href") || null,
        renderHTML: (e) => ({
          href: e.href
        })
      },
      style: {
        renderHTML() {
          return {
            style: "display: inline-block"
          };
        }
      }
    };
  },
  addNodeView() {
    return Oc(Ple);
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolboxItems({ editor: e }) {
        return [
          {
            priority: 10,
            component: R(Qo),
            props: {
              editor: e,
              icon: R(Zae),
              title: Q.global.t("editor.common.image"),
              action: () => {
                e.chain().focus().insertContent([{ type: "image", attrs: { src: "" } }]).run();
              }
            }
          }
        ];
      },
      getBubbleMenu({ editor: e }) {
        return {
          pluginKey: "imageBubbleMenu",
          shouldShow: ({ state: n }) => xi(n, wn.name),
          defaultAnimation: !1,
          items: [
            {
              priority: 10,
              component: R(Cle)
            },
            {
              priority: 20,
              props: {
                isActive: () => e.isActive({ textAlign: "left" }),
                icon: R(xc),
                action: () => cf(e, "left")
              }
            },
            {
              priority: 30,
              props: {
                isActive: () => e.isActive({ textAlign: "center" }),
                icon: R(eh),
                action: () => cf(e, "center")
              }
            },
            {
              priority: 40,
              props: {
                isActive: () => e.isActive({ textAlign: "right" }),
                icon: R(nh),
                action: () => cf(e, "right")
              }
            },
            {
              priority: 50,
              props: {
                isActive: () => e.isActive({ textAlign: "justify" }),
                icon: R(th),
                action: () => cf(e, "justify")
              }
            },
            {
              priority: 60,
              component: R(Qt)
            },
            {
              priority: 70,
              props: {
                icon: R(ih),
                title: Q.global.t("editor.common.button.edit_link"),
                action: () => R(cle)
              }
            },
            {
              priority: 80,
              props: {
                icon: R(rh),
                title: Q.global.t("editor.common.tooltip.open_link"),
                action: () => {
                  window.open(e.getAttributes(wn.name).src, "_blank");
                }
              }
            },
            {
              priority: 90,
              props: {
                icon: R(tle),
                title: Q.global.t("editor.extensions.image.edit_alt"),
                action: () => R(ile)
              }
            },
            {
              priority: 100,
              props: {
                icon: R(Yae),
                title: Q.global.t("editor.extensions.image.edit_href"),
                action: () => R(ale)
              }
            },
            {
              priority: 110,
              component: R(Qt)
            },
            {
              priority: 120,
              props: {
                icon: R(Ua),
                title: Q.global.t("editor.common.button.delete"),
                action: ({ editor: n }) => {
                  vc(wn.name, n);
                }
              }
            }
          ]
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e, view: n }) {
            var s;
            let i = e;
            for (; i && i.tagName !== "P"; )
              i = i.parentElement;
            i && (i = (s = i.firstElementChild) == null ? void 0 : s.firstElementChild);
            let r;
            if (i.firstElementChild) {
              const o = n.posAtDOM(i.firstElementChild, 0);
              r = n.state.doc.resolve(o).node();
            }
            return {
              node: r,
              el: i,
              dragDomOffset: {
                y: -5
              }
            };
          }
        };
      }
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    return t.href ? [
      "a",
      { href: t.href },
      ["img", Ee(t)]
    ] : ["img", Ee(t)];
  }
}), cf = (t, e) => {
  t.chain().focus().setTextAlign(e).run();
}, Rle = mt.create({
  name: "indent",
  addOptions() {
    return {
      names: ["heading", "paragraph"],
      indentRange: 24,
      minIndentLevel: 0,
      maxIndentLevel: 24 * 10,
      defaultIndentLevel: 0,
      HTMLAttributes: {}
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.names,
        attributes: {
          indent: {
            default: this.options.defaultIndentLevel,
            renderHTML: (t) => ({
              style: t.indent != 0 ? `margin-left: ${t.indent}px!important;` : ""
            }),
            parseHTML: (t) => parseInt(t.style.marginLeft, 10) || this.options.defaultIndentLevel
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      indent: () => ({ tr: t, state: e, dispatch: n, editor: i }) => {
        const { selection: r } = e;
        return t = t.setSelection(r), t = Nk(
          t,
          this.options,
          i.extensionManager.extensions,
          "indent"
        ), t.docChanged && n ? (n(t), !0) : !1;
      },
      outdent: () => ({ tr: t, state: e, dispatch: n, editor: i }) => {
        const { selection: r } = e;
        return t = t.setSelection(r), t = Nk(
          t,
          this.options,
          i.extensionManager.extensions,
          "outdent"
        ), t.docChanged && n ? (n(t), !0) : !1;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: Dk(),
      "Shift-Tab": Ik(),
      "Mod-]": Dk(),
      "Mod-[": Ik()
    };
  },
  onUpdate() {
    const { editor: t } = this;
    if (t.isActive("listItem")) {
      const e = t.state.selection.$head.node();
      e.attrs.indent && t.commands.updateAttributes(e.type.name, { indent: 0 });
    }
  }
}), $le = (t, e, n) => t < e ? e : t > n ? n : t;
function Nle(t, e, n, i, r) {
  if (!t.doc) return t;
  const s = t.doc.nodeAt(e);
  if (!s) return t;
  const o = $le((s.attrs.indent || 0) + n, i, r);
  if (o === s.attrs.indent) return t;
  const a = {
    ...s.attrs,
    indent: o
  };
  return t.setNodeMarkup(e, s.type, a, s.marks);
}
const Nk = (t, e, n, i) => {
  const { doc: r, selection: s } = t;
  if (!r || !s || !(s instanceof ce))
    return t;
  const { from: o, to: a } = s;
  return r.nodesBetween(o, a, (l, c) => e.names.includes(l.type.name) ? (Dle(t, c) && i === "indent" ? t.insertText("	", o, a) : t = Nle(
    t,
    c,
    e.indentRange * (i === "indent" ? 1 : -1),
    e.minIndentLevel,
    e.maxIndentLevel
  ), !1) : !uO(l.type.name, n)), t;
}, Dle = (t, e) => {
  const { selection: n } = t, { from: i, to: r } = n;
  return i == 0 ? !1 : i - r == 0 && e != i - 1;
}, PR = (t) => t.isActive("bulletList") || t.isActive("orderedList") || t.isActive("taskList"), RR = (t) => t.isActive("table") || t.isActive("columns"), Dk = () => ({ editor: t }) => {
  if (RR(t))
    return !1;
  if (PR(t)) {
    const e = t.can().sinkListItem("listItem") ? "listItem" : "taskItem";
    return t.chain().focus().sinkListItem(e).run();
  }
  return t.chain().focus().indent().run();
}, Ik = (t) => ({ editor: e }) => {
  if (RR(e))
    return !1;
  if (PR(e)) {
    const n = e.can().liftListItem("listItem") ? "listItem" : "taskItem";
    return e.chain().focus().liftListItem(n).run();
  }
  return e.chain().focus().outdent().run();
}, Ile = mt.create({
  name: "nodeSelected",
  addOptions() {
    return {
      className: "has-node-selected"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("nodeSelected"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: i } = this.editor, { anchor: r } = e, s = [];
            return !n || !i ? We.create(t, []) : (t.descendants((o, a) => {
              if (o.isText || !(r >= a && r <= a + o.nodeSize - 1))
                return !1;
              s.push(
                zt.node(a, a + o.nodeSize, {
                  class: this.options.className
                })
              );
            }), We.create(t, s));
          }
        }
      })
    ];
  }
});
class Jn extends _e {
  /**
   * Creates a RangeSelection between the specified positions.
   *
   * @param $anchor - The starting position of the selection.
   * @param $head - The ending position of the selection.
   */
  constructor(e, n) {
    Lk(e, n), super(e, n);
  }
  map(e, n) {
    const i = e.resolve(n.map(this.head)), r = e.resolve(n.map(this.anchor));
    return new Jn(r, i);
  }
  eq(e) {
    return e instanceof Jn && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new l_(this.anchor, this.head);
  }
  toJSON() {
    return { type: "range", anchor: this.anchor, head: this.head };
  }
  /**
   * Validates if the given positions can form a valid RangeSelection in the given state.
   *
   * @param state - The editor state.
   * @param anchor - The starting position.
   * @param head - The ending position.
   * @returns True if the positions form a valid RangeSelection, otherwise false.
   */
  static valid(e, n, i) {
    const r = Bk(
      e.doc.resolve(n),
      e.doc.resolve(i)
    );
    return !(r.length === 0 || r.reverse()[0].pos < 0);
  }
  /**
   * Returns a RangeSelection spanning the given positions.
   *
   * When the given range includes block-level content, if only a part is included,
   * the selection will be expanded to encompass the block-level content at the corresponding depth.
   *
   * Expansion: If the selection includes all depth nodes of the current block-level content but not the entire last node,
   * the selection will be expanded to include the node at that depth.
   *
   * @param $anchor - The starting position of the selection.
   * @param $head - The ending position of the selection.
   * @returns A new RangeSelection that spans the given positions.
   */
  static between(e, n) {
    Lk(e, n);
    const i = e.doc, r = e.pos < n.pos ? 1 : -1, s = r > 0 ? e.pos : n.pos, o = r > 0 ? n.pos : e.pos, a = Bk(e, n);
    if (a.length === 0)
      return null;
    const l = a[a.length - 1];
    if (l.pos < 0)
      return null;
    let c = 0;
    a.forEach(({ pos: f }) => {
      f < 0 && (c = f);
    });
    const u = o - s - l.pos - l.node.nodeSize, d = r > 0 ? s + c : o - (u > 0 ? 0 : u), h = r > 0 ? o - (u > 0 ? 0 : u) : s + c;
    return new Jn(i.resolve(d), i.resolve(h));
  }
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for RangeSelection.fromJSON");
    return new Jn(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, i) {
    return new this(e.resolve(n), e.resolve(i));
  }
  static allRange(e) {
    return new Jn(e.resolve(0), e.resolve(e.content.size));
  }
}
_e.jsonID("range", Jn);
class l_ {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new l_(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return new Jn(e.resolve(this.anchor), e.resolve(this.head));
  }
}
function Lk(t, e) {
  t.pos === e.pos && console.warn("The RangeSelection cannot be empty.");
}
function Bk(t, e) {
  const n = t.doc, i = t.pos < e.pos ? 1 : -1, r = i > 0 ? t.pos : e.pos, s = i > 0 ? e.pos : t.pos, o = [];
  return n.nodesBetween(
    r,
    s,
    (a, l, c, u) => {
      if (a.isText || a.type.name === "paragraph")
        return !0;
      o.push({ node: a, pos: l, parent: c, index: u });
    },
    -r
  ), o;
}
const Zn = {
  anchor: 0,
  head: 0,
  enable: !1
}, Lle = mt.create({
  priority: 100,
  name: "rangeSelectionExtension",
  addProseMirrorPlugins() {
    return [
      new Ue({
        key: new Ke("rangeSelectionPlugin"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: i } = this.editor;
            if (!n || !i || !(e instanceof Jn))
              return null;
            const { $from: r, $to: s } = e, o = [];
            return t.nodesBetween(r.pos, s.pos, (a, l) => {
              a.isText || a.type.name === "paragraph" || a.type.spec.fakeSelection && o.push(
                zt.node(l, l + a.nodeSize, {
                  class: "no-selection range-fake-selection"
                })
              );
            }), We.create(t, o);
          },
          createSelectionBetween: (t, e, n) => e.pos === n.pos ? null : Jn.valid(t.state, e.pos, n.pos) ? new Jn(e, n) : null,
          handleDOMEvents: {
            mousedown: (t, e) => {
              const n = { left: e.clientX, top: e.clientY }, i = t.posAtCoords(n);
              !i || !i.pos || (Zn.enable = !0, Zn.anchor = i.pos);
            },
            mousemove: (t, e) => {
              if (!Zn.enable)
                return;
              const n = { left: e.clientX, top: e.clientY }, i = t.posAtCoords(n);
              if (!i || !i.pos || i.pos === Zn.anchor || i.pos === Zn.head)
                return;
              Zn.head = i.pos;
              const r = Jn.between(
                t.state.doc.resolve(Zn.anchor),
                t.state.doc.resolve(Zn.head)
              );
              r && t.dispatch(t.state.tr.setSelection(r));
            },
            mouseup: () => {
              Zn.enable = !1, Zn.anchor = 0, Zn.head = 0;
            },
            mouseleave: () => {
              Zn.enable = !1, Zn.anchor = 0, Zn.head = 0;
            }
          }
        }
      })
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-a": ({ editor: t }) => (t.view.dispatch(
        t.view.state.tr.setSelection(
          Jn.allRange(t.view.state.doc)
        )
      ), !0)
    };
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      fakeSelection: Ne(he(t, "fakeSelection", e)) ?? !1
    };
  }
}), Ble = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Qle = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M15.5 12c2.5 0 4.5 2 4.5 4.5c0 .88-.25 1.71-.69 2.4l3.08 3.1L21 23.39l-3.12-3.07c-.69.43-1.51.68-2.38.68c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5m0 2a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5M5 3h14c1.11 0 2 .89 2 2v8.03c-.5-.8-1.19-1.49-2-2.03V5H5v14h4.5c.31.75.76 1.42 1.31 2H5c-1.11 0-2-.89-2-2V5c0-1.11.89-2 2-2m2 4h10v2H7zm0 4h5.03c-.8.5-1.49 1.19-2.03 2H7zm0 4h2.17c-.11.5-.17 1-.17 1.5v.5H7z"
}, null, -1), Fle = [
  Qle
];
function zle(t, e) {
  return P(), L("svg", Ble, [...Fle]);
}
const Ule = { name: "mdi-text-box-search-outline", render: zle }, Wle = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Vle = /* @__PURE__ */ A("g", {
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
}, [
  /* @__PURE__ */ A("path", { d: "M14 4c0-1.1.9-2 2-2m4 0c1.1 0 2 .9 2 2m0 4c0 1.1-.9 2-2 2m-4 0c-1.1 0-2-.9-2-2M3 7l3 3l3-3" }),
  /* @__PURE__ */ A("path", { d: "M6 10V5c0-1.7 1.3-3 3-3h1" }),
  /* @__PURE__ */ A("rect", {
    width: "8",
    height: "8",
    x: "2",
    y: "14",
    rx: "2"
  })
], -1), Zle = [
  Vle
];
function Hle(t, e) {
  return P(), L("svg", Wle, [...Zle]);
}
const qle = { name: "lucide-replace", render: Hle }, Xle = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, jle = /* @__PURE__ */ yD('<g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M14 4c0-1.1.9-2 2-2m4 0c1.1 0 2 .9 2 2m0 4c0 1.1-.9 2-2 2m-4 0c-1.1 0-2-.9-2-2M3 7l3 3l3-3"></path><path d="M6 10V5c0-1.7 1.3-3 3-3h1"></path><rect width="8" height="8" x="2" y="14" rx="2"></rect><path d="M14 14c1.1 0 2 .9 2 2v4c0 1.1-.9 2-2 2m6-8c1.1 0 2 .9 2 2v4c0 1.1-.9 2-2 2"></path></g>', 1), Yle = [
  jle
];
function Gle(t, e) {
  return P(), L("svg", Xle, [...Yle]);
}
const Kle = { name: "lucide-replace-all", render: Gle }, Jle = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, ece = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M11 4h2v12l5.5-5.5l1.42 1.42L12 19.84l-7.92-7.92L5.5 10.5L11 16z"
}, null, -1), tce = [
  ece
];
function nce(t, e) {
  return P(), L("svg", Jle, [...tce]);
}
const ice = { name: "mdi-arrow-down", render: nce }, rce = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, sce = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M13 20h-2V8l-5.5 5.5l-1.42-1.42L12 4.16l7.92 7.92l-1.42 1.42L13 8z"
}, null, -1), oce = [
  sce
];
function ace(t, e) {
  return P(), L("svg", rce, [...oce]);
}
const lce = { name: "mdi-arrow-up", render: ace }, cce = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, uce = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
}, null, -1), dce = [
  uce
];
function hce(t, e) {
  return P(), L("svg", cce, [...dce]);
}
const fce = { name: "mdi-close", render: hce }, pce = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, mce = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M20.06 18a4 4 0 0 1-.2-.89c-.67.7-1.48 1.05-2.41 1.05c-.83 0-1.52-.24-2.05-.71c-.53-.45-.8-1.06-.8-1.79c0-.88.33-1.56 1-2.05s1.61-.73 2.83-.73h1.4v-.64q0-.735-.45-1.17c-.3-.29-.75-.43-1.33-.43c-.52 0-.95.12-1.3.36c-.35.25-.52.54-.52.89h-1.46c0-.43.15-.84.45-1.24c.28-.4.71-.71 1.22-.94c.51-.21 1.06-.35 1.69-.35c.98 0 1.74.24 2.29.73s.84 1.16.86 2.02V16c0 .8.1 1.42.3 1.88V18zm-2.4-1.12c.45 0 .88-.11 1.29-.32c.4-.21.7-.49.88-.83v-1.57H18.7c-1.77 0-2.66.47-2.66 1.41c0 .43.15.73.46.96c.3.23.68.35 1.16.35m-12.2-3.17h4.07L7.5 8.29zM6.64 6h1.72l4.71 12h-1.93l-.97-2.57H4.82L3.86 18H1.93z"
}, null, -1), gce = [
  mce
];
function bce(t, e) {
  return P(), L("svg", pce, [...gce]);
}
const Oce = { name: "mdi-format-letter-case", render: bce }, yce = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, _ce = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M11.14 4L6.43 16h1.93l.96-2.57h5.35l.97 2.57h1.93L12.86 4M12 6.29l2.03 5.42H9.96M20 14v4H4v-3H2v5h20v-6Z"
}, null, -1), vce = [
  _ce
];
function xce(t, e) {
  return P(), L("svg", yce, [...vce]);
}
const wce = { name: "mdi-format-letter-matches", render: xce }, Sce = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, kce = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M16 16.92c-.33.05-.66.08-1 .08s-.67-.03-1-.08v-3.51l-2.5 2.48c-.5-.39-1-.89-1.39-1.39l2.48-2.5H9.08c-.05-.33-.08-.66-.08-1s.03-.67.08-1h3.51l-2.48-2.5c.19-.25.39-.5.65-.74c.24-.26.49-.46.74-.65L14 8.59V5.08c.33-.05.66-.08 1-.08s.67.03 1 .08v3.51l2.5-2.48c.5.39 1 .89 1.39 1.39L17.41 10h3.51c.05.33.08.66.08 1s-.03.67-.08 1h-3.51l2.48 2.5c-.19.25-.39.5-.65.74c-.24.26-.49.46-.74.65L16 13.41zM5 19a2 2 0 0 1 2-2a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2"
}, null, -1), Ece = [
  kce
];
function Cce(t, e) {
  return P(), L("svg", Sce, [...Ece]);
}
const Ace = { name: "mdi-regex", render: Cce }, Tce = ["onKeydown"], Mce = { class: "w-full flex flex-col gap-1" }, Pce = { class: "flex items-center relative" }, Rce = { class: "relative w-full max-w-[55%]" }, $ce = ["placeholder", "onKeydown"], Nce = { class: "absolute inset-y-0 end-0 flex items-center pr-1 gap-1" }, Dce = ["title"], Ice = ["title"], Lce = ["title"], Bce = { class: "min-w-[130px] text-sm mx-2" }, Qce = { key: 0 }, Fce = { key: 1 }, zce = { class: "h-full flex items-center absolute right-0" }, Uce = ["title", "disabled"], Wce = ["title", "disabled"], Vce = ["title"], Zce = { class: "flex items-center" }, Hce = { class: "relative w-full max-w-[55%]" }, qce = ["placeholder", "onKeydown"], Xce = { class: "flex items-center gap-2 mx-2" }, jce = ["title", "disabled"], Yce = ["title", "disabled"], Gce = /* @__PURE__ */ ke({
  __name: "SearchAndReplace",
  props: {
    editor: {
      type: Object,
      required: !0
    },
    pluginKey: {
      type: Object,
      required: !0
    },
    visible: {
      type: Boolean,
      default: !1
    }
  },
  setup(t) {
    const e = t, n = pt(""), i = pt(""), r = pt(!1), s = pt(!1), o = pt(!1), a = pt(!1), l = Be(() => {
      a.value;
      const { editor: g, pluginKey: b } = e;
      if (!g || !b)
        return {
          findIndex: 0,
          findCount: 0
        };
      const _ = b.getState(g.state);
      return {
        findIndex: (_ == null ? void 0 : _.findIndex) || 0,
        findCount: (_ == null ? void 0 : _.findCount) || 0
      };
    }), c = () => {
      e.editor.commands.findNext();
    }, u = () => {
      e.editor.commands.findPrevious();
    }, d = (g) => {
      const { editor: b, pluginKey: _ } = e;
      if (!b || !_)
        return;
      const y = b.state.tr;
      y.setMeta(_, g), b.view.dispatch(y), a.value = !a.value;
    }, h = () => {
      e.editor.commands.replace(), a.value = !a.value;
    }, f = () => {
      e.editor.commands.replaceAll(), a.value = !a.value;
    }, p = () => {
      e.editor.commands.closeSearch();
    };
    In(
      () => n.value.trim(),
      (g, b) => {
        g !== b && d({
          setSearchTerm: g
        });
      }
    ), In(
      () => i.value.trim(),
      (g, b) => {
        g !== b && d({
          setReplaceTerm: g
        });
      }
    ), In(
      () => r.value,
      (g, b) => {
        g !== b && d({
          setRegex: g
        });
      }
    ), In(
      () => s.value,
      (g, b) => {
        g !== b && d({
          setCaseSensitive: g
        });
      }
    ), In(
      () => o.value,
      (g, b) => {
        g !== b && d({
          setMatchWord: g
        });
      }
    );
    const m = pt(null);
    return In(
      () => e.visible,
      (g) => {
        g && Il(() => {
          var b;
          (b = m.value) == null || b.focus();
        });
      }
    ), (g, b) => ut((P(), Re(_D, {
      appear: "",
      name: "slide"
    }, {
      default: ze(() => [
        A("div", {
          class: "absolute float-right top-0 right-5 z-50 flex justify-end bg-white shadow p-1 !pt-2 rounded min-w-[500px]",
          onKeydown: Qf(su(p, ["prevent"]), ["escape"])
        }, [
          A("section", Mce, [
            A("div", Pce, [
              A("div", Rce, [
                ut(A("input", {
                  ref_key: "searchInput",
                  ref: m,
                  "onUpdate:modelValue": b[0] || (b[0] = (_) => n.value = _),
                  type: "text",
                  class: "block w-full p-1 ps-2 !pr-[5.5rem] bg-gray-50 rounded border !border-solid !text-sm !leading-7 border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500",
                  placeholder: Z(Q).global.t(
                    "editor.extensions.search_and_replace.search_placeholder"
                  ),
                  tabindex: "2",
                  onKeydown: Qf(su(c, ["prevent"]), ["enter"])
                }, null, 40, $ce), [
                  [Fn, n.value]
                ]),
                A("div", Nce, [
                  A("button", {
                    title: Z(Q).global.t(
                      "editor.extensions.search_and_replace.case_sensitive"
                    ),
                    type: "button",
                    class: Ot(["p-0.5 rounded-sm hover:bg-gray-200", {
                      "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200": s.value
                    }]),
                    onClick: b[1] || (b[1] = (_) => s.value = !s.value)
                  }, [
                    fe(Z(Oce))
                  ], 10, Dce),
                  A("button", {
                    title: Z(Q).global.t(
                      "editor.extensions.search_and_replace.match_word"
                    ),
                    type: "button",
                    class: Ot(["p-0.5 rounded-sm hover:bg-gray-200", {
                      "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200": o.value
                    }]),
                    onClick: b[2] || (b[2] = (_) => o.value = !o.value)
                  }, [
                    fe(Z(wce))
                  ], 10, Ice),
                  A("button", {
                    title: Z(Q).global.t(
                      "editor.extensions.search_and_replace.use_regex"
                    ),
                    type: "button",
                    class: Ot(["p-0.5 rounded-sm hover:bg-gray-200", {
                      "!bg-blue-200 outline outline-1 outline-blue-500 hover:!bg-blue-200": r.value
                    }]),
                    onClick: b[3] || (b[3] = (_) => r.value = !r.value)
                  }, [
                    fe(Z(Ace))
                  ], 10, Lce)
                ])
              ]),
              A("div", Bce, [
                l.value.findCount === 0 ? (P(), L("div", Qce, [
                  A("span", {
                    class: Ot({ "text-red-600": n.value.length > 0 })
                  }, Ft(Z(Q).global.t("editor.extensions.search_and_replace.not_found")), 3)
                ])) : (P(), L("div", Fce, [
                  A("span", null, Ft(Z(Q).global.t(
                    "editor.extensions.search_and_replace.occurrence_found",
                    {
                      index: l.value.findIndex + 1,
                      total: l.value.findCount
                    }
                  )), 1)
                ]))
              ]),
              A("div", zce, [
                A("button", {
                  title: Z(Q).global.t(
                    "editor.extensions.search_and_replace.find_previous"
                  ),
                  type: "button",
                  class: Ot(["p-0.5 rounded-sm opacity-50", {
                    "hover:!bg-gray-200 !opacity-100": l.value.findCount > 0
                  }]),
                  disabled: l.value.findCount === 0,
                  onClick: u
                }, [
                  fe(Z(lce))
                ], 10, Uce),
                A("button", {
                  title: Z(Q).global.t("editor.extensions.search_and_replace.find_next"),
                  type: "button",
                  class: Ot(["p-0.5 rounded-sm opacity-50", {
                    "hover:!bg-gray-200 !opacity-100": l.value.findCount > 0
                  }]),
                  disabled: l.value.findCount === 0,
                  onClick: c
                }, [
                  fe(Z(ice))
                ], 10, Wce),
                A("button", {
                  title: Z(Q).global.t("editor.extensions.search_and_replace.close"),
                  type: "button",
                  class: "p-0.5 rounded-sm hover:bg-gray-200",
                  onClick: p
                }, [
                  fe(Z(fce))
                ], 8, Vce)
              ])
            ]),
            A("div", Zce, [
              A("div", Hce, [
                ut(A("input", {
                  "onUpdate:modelValue": b[4] || (b[4] = (_) => i.value = _),
                  type: "text",
                  class: "block w-full p-1 ps-2 rounded bg-gray-50 border !border-solid !text-sm !leading-7 border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500",
                  placeholder: Z(Q).global.t(
                    "editor.extensions.search_and_replace.replace_placeholder"
                  ),
                  tabindex: "2",
                  onKeydown: Qf(su(h, ["prevent"]), ["enter"])
                }, null, 40, qce), [
                  [Fn, i.value]
                ])
              ]),
              A("div", Xce, [
                A("button", {
                  title: Z(Q).global.t("editor.extensions.search_and_replace.replace"),
                  type: "button",
                  class: Ot(["p-0.5 rounded-sm opacity-50", {
                    "hover:!bg-gray-200 !opacity-100": l.value.findCount > 0
                  }]),
                  disabled: l.value.findCount === 0,
                  onClick: h
                }, [
                  fe(Z(qle))
                ], 10, jce),
                A("button", {
                  title: Z(Q).global.t(
                    "editor.extensions.search_and_replace.replace_all"
                  ),
                  type: "button",
                  class: Ot(["p-0.5 rounded-sm opacity-50", {
                    "hover:!bg-gray-200 !opacity-100": l.value.findCount > 0
                  }]),
                  disabled: l.value.findCount === 0,
                  onClick: f
                }, [
                  fe(Z(Kle))
                ], 10, Yce)
              ])
            ])
          ])
        ], 40, Tce)
      ]),
      _: 1
    }, 512)), [
      [HA, t.visible]
    ]);
  }
}), Dn = new Ke("searchAndReplace");
class Kce {
  constructor({ view: e, editor: n, element: i }) {
    Pe(this, "editor");
    Pe(this, "view");
    Pe(this, "containerElement");
    Pe(this, "init");
    this.editor = n, this.view = e, this.containerElement = i, this.init = !1;
  }
  update() {
    const { parentElement: e } = this.editor.options.element;
    return !this.init && e && (e.insertAdjacentElement(
      "afterbegin",
      this.containerElement
    ), this.init = !0), !1;
  }
  destroy() {
    return !1;
  }
}
class Jce {
  constructor({
    editor: e,
    enable: n,
    regex: i,
    caseSensitive: r,
    wholeWord: s
  }) {
    Pe(this, "_findIndex");
    Pe(this, "editor");
    Pe(this, "enable");
    // Whether it is necessary to reset the findIndex based on the cursor position.
    Pe(this, "findIndexFlag");
    Pe(this, "findCount");
    Pe(this, "searchTerm");
    Pe(this, "replaceTerm");
    Pe(this, "regex");
    Pe(this, "caseSensitive");
    Pe(this, "wholeWord");
    Pe(this, "results", []);
    Pe(this, "searchResultDecorations", []);
    Pe(this, "findIndexDecoration");
    /**
     * Get the regular expression object based on the current search term.
     *
     * @returns Regular expression object
     */
    Pe(this, "getRegex", () => {
      const { searchTerm: e, regex: n, caseSensitive: i, wholeWord: r } = this;
      let s = n ? e : e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      return r && (s = `\\b${s}\\b`), new RegExp(s, i ? "gu" : "gui");
    });
    this.editor = e, this.enable = n || !1, this.searchTerm = "", this.replaceTerm = "", this.regex = i || !1, this.caseSensitive = r || !1, this.wholeWord = s || !1, this._findIndex = 0, this.findCount = 0, this.searchResultDecorations = [], this.findIndexDecoration = void 0, this.results = [], this.findIndexFlag = !0;
  }
  get findIndex() {
    return this._findIndex;
  }
  set findIndex(e) {
    this._findIndex = this.verifySetIndex(e);
  }
  apply(e) {
    const n = e.getMeta(Dn);
    if (n && "setEnable" in n && (n.setEnable && !this.enable && (n.setSearchTerm = this.searchTerm), this.enable = n.setEnable), !this.enable)
      return this;
    if (n && n.refresh && this.processSearches(e), n && "setReplaceTerm" in n && (this.replaceTerm = n.setReplaceTerm), n && "setFindIndex" in n) {
      const { setFindIndex: i } = n;
      this.findIndex = i, this.processFindIndexDecoration();
    }
    return n && this.scrollIntoFindIndexView(), n && "setRegex" in n && this.regex !== n.setRegex && (this.regex = n.setRegex, n.setSearchTerm = this.searchTerm), n && "setWholeWord" in n && this.wholeWord !== n.setWholeWord && (this.wholeWord = n.setWholeWord, n.setSearchTerm = this.searchTerm), n && "setCaseSensitive" in n && this.caseSensitive !== n.setCaseSensitive && (this.caseSensitive = n.setCaseSensitive, n.setSearchTerm = this.searchTerm), n && "setSearchTerm" in n ? (this.searchTerm = n.setSearchTerm, this.findIndexFlag = !0, this.processSearches(e), this.scrollIntoFindIndexView(), this) : e.docChanged ? this.processSearches(e) : (e.getMeta("pointer") && (this.getNearestResultBySelection(e.selection), this.processFindIndexDecoration()), this);
  }
  scrollIntoFindIndexView() {
    const { results: e, editor: n, _findIndex: i } = this;
    if (e.length > i && i >= 0) {
      const r = e[i];
      if (r) {
        const { pos: s } = r, { view: o } = n;
        let a = o.nodeDOM(s - 1);
        a instanceof HTMLElement || (a = o.domAtPos(s, 0).node), a instanceof HTMLElement && bR(a, {
          behavior: "smooth",
          scrollMode: "if-needed"
        });
      }
    }
  }
  /**
   * Validate if findIndex is within the range
   * If results.length === 0, take 0
   * If less than or equal to -1, take results.length - 1
   * If greater than results.length - 1, take 0
   *
   * @param index new findIndex
   * @returns validated findIndex
   */
  verifySetIndex(e) {
    const { results: n } = this;
    return n.length === 0 ? 0 : e <= -1 ? n.length - 1 : e > n.length - 1 ? 0 : e;
  }
  /**
   * Execute full-text search functionality.
   *
   * @param Transaction
   * @returns
   * @memberof SearchAndReplacePluginState
   */
  processSearches({
    doc: e,
    selection: n
  }) {
    const i = this.getFullText(e), r = this.getRegex();
    this.results.length = 0;
    for (let s = 0; s < i.length; s += 1) {
      const { text: o, pos: a, index: l } = i[s], c = Array.from(o.matchAll(r)).filter(
        ([u]) => u.trim()
      );
      for (let u = 0; u < c.length; u += 1) {
        const d = c[u];
        if (d[0] === "")
          break;
        d.index !== void 0 && this.results.push({
          pos: a,
          index: l,
          from: a + d.index,
          to: a + d.index + d[0].length
        });
      }
    }
    return this.processResultDecorations(), this.findIndexFlag && (this.getNearestResultBySelection(n), this.findIndexFlag = !1), this.processFindIndexDecoration(), this;
  }
  /**
   * Highlight the current result based on findIndex.
   *
   * @memberof SearchAndReplacePluginState
   */
  processFindIndexDecoration() {
    const { results: e, findIndex: n } = this, i = e[n];
    i && (this.findIndexDecoration = zt.inline(i.from, i.to, {
      class: "search-result-current"
    }));
  }
  /**
   * Generate highlighted results based on the 'results'.
   *
   * @memberof SearchAndReplacePluginState
   */
  processResultDecorations() {
    const { results: e } = this;
    this.findCount = e.length, this.searchResultDecorations.length = 0;
    for (let n = 0; n < e.length; n += 1) {
      const i = e[n];
      this.searchResultDecorations.push(
        zt.inline(i.from, i.to, {
          class: "search-result"
        })
      );
    }
  }
  /**
   * Reset findIndex based on the current cursor position.
   *
   * @param selection Current cursor position.
   */
  getNearestResultBySelection(e) {
    const { results: n } = this;
    for (let i = 0; i < n.length; i += 1) {
      const r = n[i];
      if (e && e.to <= r.from) {
        this.findIndex = i;
        break;
      }
    }
  }
  /**
   * Convert the entire text into flattened text with positions.
   *
   * @param doc The entire document
   * @returns Flattened text with positions
   */
  getFullText(e) {
    const n = [];
    return e.descendants((i, r, s, o) => {
      i.isText && n.push({
        text: `${i.text}`,
        pos: r,
        index: o
      });
    }), n;
  }
}
const eue = (t) => new Ue({
  key: Dn,
  view: (e) => new Kce({ view: e, ...t }),
  state: {
    init: () => new Jce({ ...t }),
    apply: (e, n) => n.apply(e)
  },
  props: {
    decorations: (e) => {
      const n = Dn.getState(e);
      if (n) {
        const { searchResultDecorations: i, findIndexDecoration: r, enable: s } = n;
        if (!s)
          return We.empty;
        const o = [...i];
        if (r && o.push(r), o.length > 0)
          return We.create(e.doc, o);
      }
      return We.empty;
    }
  }
}), ml = li(Gce);
function tue() {
  const t = ml.component;
  return t ? t.props.visible : !1;
}
const nue = mt.create({
  name: "searchAndReplace",
  // @ts-ignore
  addOptions() {
    return {
      getToolbarItems({ editor: t }) {
        return [
          {
            priority: 230,
            component: R($t),
            props: {
              editor: t,
              isActive: tue(),
              icon: R(Ule),
              title: Q.global.t(
                "editor.extensions.search_and_replace.title"
              ),
              action: () => {
                const e = ml.component;
                e && (e.props.visible ? t.commands.closeSearch() : t.commands.openSearch());
              }
            }
          }
        ];
      }
    };
  },
  addCommands() {
    return {
      replace: () => ({
        state: t,
        dispatch: e
      }) => {
        const n = Dn.getState(t);
        if (!n)
          return !1;
        const { replaceTerm: i, results: r, findIndex: s } = n, o = r[s];
        if (!o)
          return !1;
        const { from: a, to: l } = o;
        if (e) {
          const c = t.tr;
          c.insertText(i, a, l), c.setMeta(Dn, {
            setFindIndex: s,
            refresh: !0
          }), e(c);
        }
        return !1;
      },
      replaceAll: () => ({
        state: t,
        dispatch: e
      }) => {
        const n = Dn.getState(t);
        if (!n)
          return !1;
        const { replaceTerm: i, results: r } = n, s = t.tr;
        let o = 0;
        return r.forEach((a) => {
          const { from: l, to: c } = a;
          s.insertText(i, o + l, o + c), o = o + i.length - (c - l);
        }), e && e(s), !1;
      },
      findNext: () => ({
        state: t,
        dispatch: e
      }) => {
        if (e) {
          const n = t.tr, i = Dn.getState(t);
          if (!i)
            return !1;
          const { findIndex: r } = i;
          n.setMeta(Dn, {
            setFindIndex: r + 1
          }), e(n);
        }
        return !1;
      },
      findPrevious: () => ({
        state: t,
        dispatch: e
      }) => {
        if (e) {
          const n = Dn.getState(t);
          if (!n)
            return !1;
          const { findIndex: i } = n, r = t.tr;
          r.setMeta(Dn, {
            setFindIndex: i - 1
          }), e(r);
        }
        return !1;
      },
      openSearch: () => ({
        state: t,
        dispatch: e
      }) => {
        if (!Dn.getState(t))
          return !1;
        const i = ml.component;
        if (i) {
          i.props.visible = !0;
          const r = t.tr;
          r.setMeta(Dn, {
            setEnable: !0
          }), e && e(r);
        }
        return !1;
      },
      closeSearch: () => ({
        state: t,
        dispatch: e
      }) => {
        if (!Dn.getState(t))
          return !1;
        const i = ml.component;
        if (i) {
          i.props.visible = !1;
          const r = t.tr;
          r.setMeta(Dn, {
            setEnable: !1
          }), e && e(r);
        }
        return !1;
      }
    };
  },
  addProseMirrorPlugins() {
    const t = document.createElement("div");
    return t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "50", ml.props = {
      editor: this.editor,
      pluginKey: Dn,
      visible: !1
    }, Mu(ml, t), [
      eue({
        editor: this.editor,
        element: t
      })
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-f": () => (this.editor.commands.openSearch(), !0)
    };
  }
}), iue = { class: "p-1" }, rue = /* @__PURE__ */ A("div", { class: "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300 bg-black" }, null, -1), sue = { class: "text-xs text-gray-600" }, oue = /* @__PURE__ */ ke({
  __name: "ColorBubbleItem",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t;
    function n(r) {
      var s;
      r && ((s = e.editor) == null || s.chain().focus().setColor(r).run());
    }
    function i() {
      var r;
      (r = e.editor) == null || r.chain().focus().unsetColor().run();
    }
    return (r, s) => (P(), Re(B0, { "onUpdate:modelValue": n }, {
      prefix: ze(() => [
        A("div", iue, [
          A("div", {
            class: "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
            onClick: i
          }, [
            rue,
            A("span", sue, Ft(Z(Q).global.t("editor.common.button.restore_default")), 1)
          ])
        ])
      ]),
      default: ze(() => [
        fe(Z(Ky), sr(e, { editor: r.editor }), null, 16, ["editor"])
      ]),
      _: 1
    }));
  }
}), aue = { class: "p-1" }, lue = { class: "inline-flex items-center gap-2" }, cue = { class: "text-xs text-gray-600" }, uue = { class: "p-1" }, due = /* @__PURE__ */ A("div", {
  class: "h-5 w-5 rounded-sm cursor-pointer hover:ring-1 ring-offset-1 ring-gray-300",
  style: { "background-color": "#fff8c5" }
}, null, -1), hue = { class: "text-xs text-gray-600" }, fue = /* @__PURE__ */ ke({
  __name: "HighlightBubbleItem",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t;
    function n(r) {
      var s;
      r && ((s = e.editor) == null || s.chain().focus().toggleHighlight({ color: r }).run());
    }
    function i() {
      var r;
      (r = e.editor) == null || r.chain().focus().unsetHighlight().run();
    }
    return (r, s) => (P(), Re(B0, { "onUpdate:modelValue": n }, {
      prefix: ze(() => [
        A("div", aue, [
          A("div", {
            class: "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
            onClick: i
          }, [
            A("div", lue, [
              fe(Z(r5)),
              A("span", cue, Ft(Z(Q).global.t("editor.extensions.highlight.unset")), 1)
            ])
          ])
        ]),
        A("div", uue, [
          A("div", {
            class: "flex items-center gap-2 rounded cursor-pointer hover:bg-gray-100 p-1",
            onClick: s[1] || (s[1] = (o) => n())
          }, [
            due,
            A("span", hue, Ft(Z(Q).global.t("editor.common.button.restore_default")), 1)
          ])
        ])
      ]),
      default: ze(() => [
        fe(Z(Ky), sr(e, {
          onClick: s[0] || (s[0] = (o) => n())
        }), null, 16)
      ]),
      _: 1
    }));
  }
}), pue = { class: "relative rounded-md bg-white overflow-hidden drop-shadow w-96 p-1 max-h-72 overflow-y-auto" }, mue = ["placeholder"], gue = { class: "inline-flex items-center mt-2" }, bue = { class: "ml-2 text-sm text-gray-500" }, Oue = /* @__PURE__ */ ke({
  __name: "LinkBubbleButton",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get() {
        const s = e.editor.getAttributes("link");
        return s == null ? void 0 : s.href;
      },
      set(s) {
        e.editor.commands.setLink({
          href: s,
          target: i.value ? "_blank" : "_self"
        });
      }
    }), i = Be({
      get() {
        const s = e.editor.getAttributes("link");
        return (s == null ? void 0 : s.target) === "_blank";
      },
      set(s) {
        e.editor.commands.setLink({
          href: n.value,
          target: s ? "_blank" : "_self"
        });
      }
    }), r = () => {
      var l;
      if (e.isActive({ editor: e.editor }))
        return;
      const { state: s } = e.editor, { selection: o } = s, { empty: a } = o;
      if (o instanceof ce) {
        if (a)
          return !1;
        const { content: c } = o.content();
        if (!c || c.childCount !== 1)
          return !1;
        const u = (l = c.firstChild) == null ? void 0 : l.textContent;
        u && dK(u, "url") && e.editor.commands.setLink({
          href: u,
          target: "_self"
        });
      }
    };
    return (s, o) => (P(), Re(Z(Iu), {
      class: "inline-flex",
      triggers: ["click"],
      distance: 10,
      onClick: r
    }, {
      popper: ze(() => [
        A("div", pue, [
          ut(A("input", {
            "onUpdate:modelValue": o[0] || (o[0] = (a) => n.value = a),
            placeholder: Z(Q).global.t("editor.extensions.link.placeholder"),
            class: "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
          }, null, 8, mue), [
            [
              Fn,
              n.value,
              void 0,
              { lazy: !0 }
            ]
          ]),
          A("label", gue, [
            ut(A("input", {
              "onUpdate:modelValue": o[1] || (o[1] = (a) => i.value = a),
              type: "checkbox",
              class: "form-checkbox text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            }, null, 512), [
              [qA, i.value]
            ]),
            A("span", bue, Ft(Z(Q).global.t("editor.extensions.link.open_in_new_window")), 1)
          ])
        ])
      ]),
      default: ze(() => [
        ut((P(), L("button", {
          class: Ot(["text-gray-600 text-lg hover:bg-gray-100 p-2 rounded-md", { "bg-gray-200 !text-black": s.isActive({ editor: s.editor }) }])
        }, [
          fe(Z(ih))
        ], 2)), [
          [
            Z(mo),
            s.isActive({ editor: s.editor }) ? Z(Q).global.t("editor.extensions.link.edit_link") : Z(Q).global.t("editor.extensions.link.add_link")
          ]
        ])
      ]),
      _: 1
    }));
  }
}), yue = wt.create({
  name: "text",
  group: "inline"
}), _ue = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, vue = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M2 5.27L3.28 4L20 20.72L18.73 22l-4.83-4.83l-2.61 2.61a5.003 5.003 0 0 1-7.07 0a5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.98 2.98 0 0 0 0 4.24a2.98 2.98 0 0 0 4.24 0l2.62-2.6l-1.62-1.61c-.01.24-.11.49-.29.68c-.39.39-1.03.39-1.42 0A4.97 4.97 0 0 1 7.72 11zm10.71-1.05a5.003 5.003 0 0 1 7.07 0a5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.98 2.98 0 0 0 0-4.24a2.98 2.98 0 0 0-4.24 0l-3.33 3.33l-1.41-1.42zm.7 4.95c.39-.39 1.03-.39 1.42 0a5 5 0 0 1 1.23 5.06l-1.78-1.77c-.05-.68-.34-1.35-.87-1.87a.973.973 0 0 1 0-1.42"
}, null, -1), xue = [
  vue
];
function wue(t, e) {
  return P(), L("svg", _ue, [...xue]);
}
const Sue = { name: "mdi-link-variant-off", render: wue }, kue = [
  "audio",
  "video",
  "image",
  "iframe",
  "codeBlock"
], Eue = yue.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getBubbleMenu() {
        return {
          pluginKey: "textBubbleMenu",
          shouldShow: ({ state: e, from: n, to: i }) => {
            const { doc: r, selection: s } = e, { empty: o } = s;
            return !(o || kue.some(
              (l) => xi(e, l)
            ) || r.textBetween(n || 0, i || 0).length === 0 || !qd(s) && !(s instanceof Jn));
          },
          tippyOptions: {
            fixed: !1
          },
          defaultAnimation: !1,
          items: [
            {
              priority: 10,
              props: {
                isActive: ({ editor: e }) => e.isActive("bold"),
                icon: R(qP),
                title: Q.global.t("editor.common.bold"),
                action: ({ editor: e }) => {
                  e.chain().focus().toggleBold().run();
                }
              }
            },
            {
              priority: 20,
              props: {
                isActive: ({ editor: e }) => e.isActive("italic"),
                icon: R(s5),
                title: Q.global.t("editor.common.italic"),
                action: ({ editor: e }) => {
                  e.chain().focus().toggleItalic().run();
                }
              }
            },
            {
              priority: 30,
              props: {
                isActive: ({ editor: e }) => e.isActive("underline"),
                icon: R(k5),
                title: Q.global.t("editor.common.underline"),
                action: ({ editor: e }) => e.chain().focus().toggleUnderline().run()
              }
            },
            {
              priority: 40,
              props: {
                isActive: ({ editor: e }) => e.isActive("strike"),
                icon: R(b5),
                title: Q.global.t("editor.common.strike"),
                action: ({ editor: e }) => e.chain().focus().toggleStrike().run()
              }
            },
            {
              priority: 50,
              component: R(fue),
              props: {
                isActive: ({ editor: e }) => e.isActive("highlight"),
                icon: R(i5),
                title: Q.global.t("editor.common.highlight")
              }
            },
            {
              priority: 60,
              component: R(oue),
              props: {
                isActive: ({ editor: e }) => e.isActive("color"),
                icon: R(YP),
                title: Q.global.t("editor.common.color")
              }
            },
            {
              priority: 70,
              props: {
                isActive: ({ editor: e }) => e.isActive("code"),
                icon: R(jP),
                title: Q.global.t("editor.common.code"),
                action: ({ editor: e }) => e.chain().focus().toggleCode().run()
              }
            },
            {
              priority: 80,
              props: {
                isActive: ({ editor: e }) => e.isActive("superscript"),
                icon: R(y5),
                title: Q.global.t("editor.common.superscript"),
                action: ({ editor: e }) => e.chain().focus().toggleSuperscript().run()
              }
            },
            {
              priority: 90,
              props: {
                isActive: ({ editor: e }) => e.isActive("subscript"),
                icon: R(O5),
                title: Q.global.t("editor.common.subscript"),
                action: ({ editor: e }) => e.chain().focus().toggleSubscript().run()
              }
            },
            {
              priority: 100,
              component: R(Oue),
              props: {
                isActive: ({ editor: e }) => e.isActive("link")
              }
            },
            {
              priority: 110,
              props: {
                isActive: () => !1,
                visible: ({ editor: e }) => e.isActive("link"),
                icon: R(Sue),
                title: Q.global.t("editor.extensions.link.cancel_link"),
                action: ({ editor: e }) => e.commands.unsetLink()
              }
            },
            {
              priority: 120,
              props: {
                isActive: () => !1,
                visible: ({ editor: e }) => e.isActive("link"),
                icon: R(rh),
                title: Q.global.t("editor.common.tooltip.open_link"),
                action: ({ editor: e }) => {
                  const n = e.getAttributes("link");
                  n != null && n.href && window.open(n.href, "_blank");
                }
              }
            }
          ]
        };
      }
    };
  }
});
function Qk({ types: t, node: e }) {
  return Array.isArray(t) && t.includes(e.type) || e.type === t;
}
const Cue = mt.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: ["paragraph"]
    };
  },
  addProseMirrorPlugins() {
    const t = new Ke(this.name), e = Object.entries(this.editor.schema.nodes).map(([, i]) => i).filter((i) => this.options.notAfter.includes(i.name)), n = this.editor.isEditable;
    return [
      new Ue({
        key: t,
        appendTransaction: (i, r, s) => {
          if (!n) return;
          const { doc: o, tr: a, schema: l } = s, c = t.getState(s), u = o.content.size, d = l.nodes[this.options.node];
          if (c)
            return a.insert(u, d.create());
        },
        state: {
          init: (i, r) => {
            if (!n) return !1;
            const s = r.tr.doc.lastChild;
            return !Qk({ node: s, types: e });
          },
          apply: (i, r) => {
            if (!n || !i.docChanged)
              return r;
            const s = i.doc.lastChild;
            return !Qk({ node: s, types: e });
          }
        }
      })
    ];
  }
}), Aue = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Tue = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M13.53 22H10c-.25 0-.46-.18-.5-.42l-.37-2.65c-.63-.25-1.17-.59-1.69-.99l-2.49 1.01c-.22.08-.49 0-.61-.22l-2-3.46a.493.493 0 0 1 .12-.64l2.11-1.66c-.04-.32-.07-.64-.07-.97s.03-.66.07-1L2.46 9.37a.493.493 0 0 1-.12-.64l2-3.46c.12-.22.39-.31.61-.22l2.49 1c.52-.39 1.06-.73 1.69-.98l.37-2.65c.04-.24.25-.42.5-.42h4c.25 0 .46.18.5.42l.37 2.65c.63.25 1.17.59 1.69.98l2.49-1c.22-.09.49 0 .61.22l2 3.46c.12.22.07.49-.12.64L19.43 11c.04.34.07.67.07 1v.19c-.5-.12-1-.19-1.5-.19c-.92 0-1.78.21-2.56.58c.03-.19.06-.38.06-.58c0-1.93-1.57-3.5-3.5-3.5S8.5 10.07 8.5 12s1.57 3.5 3.5 3.5c.2 0 .39-.03.58-.06a5.97 5.97 0 0 0 .95 6.56M16 15v6l5-3z"
}, null, -1), Mue = [
  Tue
];
function Pue(t, e) {
  return P(), L("svg", Aue, [...Mue]);
}
const Rue = { name: "mdi-cog-play", render: Pue }, $ue = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Nue = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M13.54 22H10c-.25 0-.46-.18-.5-.42l-.37-2.65c-.63-.25-1.17-.59-1.69-.99l-2.49 1.01c-.22.08-.49 0-.61-.22l-2-3.46a.493.493 0 0 1 .12-.64l2.11-1.66L4.5 12l.07-1l-2.11-1.63a.493.493 0 0 1-.12-.64l2-3.46c.12-.22.39-.31.61-.22l2.49 1c.52-.39 1.06-.73 1.69-.98l.37-2.65c.04-.24.25-.42.5-.42h4c.25 0 .46.18.5.42l.37 2.65c.63.25 1.17.59 1.69.98l2.49-1c.22-.09.49 0 .61.22l2 3.46c.13.22.07.49-.12.64L19.43 11l.07 1v.19c-.5-.12-1-.19-1.5-.19c-.17 0-.34 0-.5.03c0-.62-.1-1.24-.3-1.83l2.11-1.55l-.75-1.3l-2.41 1.04a5.42 5.42 0 0 0-3.03-1.77L12.75 4h-1.5l-.37 2.61c-1.2.25-2.26.89-3.03 1.78L5.44 7.35l-.75 1.3L6.8 10.2a5.55 5.55 0 0 0 0 3.6l-2.12 1.56l.75 1.3l2.43-1.04c.77.88 1.82 1.52 3.01 1.76l.37 2.62h1.11c.26.75.65 1.42 1.19 2m2.42-9.64c.04-.12.04-.24.04-.36c0-2.21-1.79-4-4-4s-4 1.79-4 4s1.79 4 4 4c.12 0 .24 0 .36-.04a6.05 6.05 0 0 1 3.6-3.6M12 14c-1.1 0-2-.89-2-2s.9-2 2-2s2 .9 2 2s-.89 2-2 2m4 1v6l5-3z"
}, null, -1), Due = [
  Nue
];
function Iue(t, e) {
  return P(), L("svg", $ue, [...Due]);
}
const Lue = { name: "mdi-cog-play-outline", render: Iue }, Bue = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Que = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4v-11z"
}, null, -1), Fue = [
  Que
];
function zue(t, e) {
  return P(), L("svg", Bue, [...Fue]);
}
const Fk = { name: "mdi-video", render: zue }, Uue = ["placeholder"], Wue = /* @__PURE__ */ ke({
  __name: "BubbleItemVideoLink",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => e.editor.getAttributes(ft.name).src,
      set: (i) => {
        e.editor.chain().updateAttributes(ft.name, { src: i }).run();
      }
    });
    return (i, r) => ut((P(), L("input", {
      "onUpdate:modelValue": r[0] || (r[0] = (s) => n.value = s),
      placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
      class: "bg-gray-50 rounded-md hover:bg-gray-100 block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
    }, null, 8, Uue)), [
      [
        Fn,
        n.value,
        void 0,
        { lazy: !0 }
      ]
    ]);
  }
}), Vue = /* @__PURE__ */ ke({
  __name: "BubbleItemVideoSize",
  props: {
    editor: {},
    isActive: { type: Function },
    visible: { type: Function },
    icon: {},
    title: {},
    action: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => e.editor.getAttributes(ft.name).width,
      set: (s) => {
        r(s, i.value);
      }
    }), i = Be({
      get: () => e.editor.getAttributes(ft.name).height,
      set: (s) => {
        r(n.value, s);
      }
    });
    function r(s, o) {
      e.editor.chain().updateAttributes(ft.name, { width: s, height: o }).setNodeSelection(e.editor.state.selection.from).focus().run();
    }
    return (s, o) => (P(), L(Yt, null, [
      fe(Z(Ll), {
        modelValue: n.value,
        "onUpdate:modelValue": o[0] || (o[0] = (a) => n.value = a),
        modelModifiers: { lazy: !0, trim: !0 },
        tooltip: Z(Q).global.t("editor.common.tooltip.custom_width_input")
      }, null, 8, ["modelValue", "tooltip"]),
      fe(Z(Ll), {
        modelValue: i.value,
        "onUpdate:modelValue": o[1] || (o[1] = (a) => i.value = a),
        modelModifiers: { lazy: !0, trim: !0 },
        tooltip: Z(Q).global.t("editor.common.tooltip.custom_height_input")
      }, null, 8, ["modelValue", "tooltip"])
    ], 64));
  }
}), Zue = {
  key: 0,
  class: "p-1.5"
}, Hue = ["placeholder"], que = ["controls", "autoplay", "loop", "src"], Xue = /* @__PURE__ */ ke({
  __name: "VideoView",
  props: {
    editor: {},
    node: {},
    decorations: {},
    selected: { type: Boolean },
    extension: {},
    getPos: { type: Function },
    updateAttributes: { type: Function },
    deleteNode: { type: Function }
  },
  setup(t) {
    const e = t, n = Be({
      get: () => {
        var l;
        return (l = e.node) == null ? void 0 : l.attrs.src;
      },
      set: (l) => {
        e.updateAttributes({ src: l });
      }
    }), i = Be(() => e.node.attrs.controls), r = Be(() => e.node.attrs.autoplay), s = Be(() => e.node.attrs.loop);
    function o() {
      e.editor.commands.setNodeSelection(e.getPos());
    }
    const a = pt();
    return Gi(() => {
      n.value || a.value.focus();
    }), (l, c) => (P(), Re(Z(bc), {
      as: "div",
      class: "inline-block w-full"
    }, {
      default: ze(() => [
        A("div", {
          class: "inline-block overflow-hidden transition-all text-center relative h-full max-w-full",
          style: sn({
            width: l.node.attrs.width
          })
        }, [
          n.value ? (P(), L("video", {
            key: 1,
            controls: i.value,
            autoplay: r.value,
            loop: s.value,
            class: "rounded-md m-0",
            src: l.node.attrs.src,
            style: sn({
              width: l.node.attrs.width,
              height: l.node.attrs.height
            }),
            onMouseenter: o
          }, null, 44, que)) : (P(), L("div", Zue, [
            ut(A("input", {
              ref_key: "inputRef",
              ref: a,
              "onUpdate:modelValue": c[0] || (c[0] = (u) => n.value = u),
              class: "block px-2 w-full py-1.5 text-sm text-gray-900 border border-gray-300 rounded-md bg-gray-50 focus:ring-blue-500 focus:border-blue-500",
              placeholder: Z(Q).global.t("editor.common.placeholder.link_input"),
              tabindex: "-1",
              onFocus: o
            }, null, 40, Hue), [
              [
                Fn,
                n.value,
                void 0,
                { lazy: !0 }
              ]
            ])
          ]))
        ], 4)
      ]),
      _: 1
    }));
  }
}), ft = wt.create({
  name: "video",
  fakeSelection: !0,
  inline() {
    return !0;
  },
  group() {
    return "inline";
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      src: {
        default: null,
        parseHTML: (e) => e.getAttribute("src")
      },
      width: {
        default: "100%",
        parseHTML: (e) => e.getAttribute("width"),
        renderHTML(e) {
          return {
            width: e.width
          };
        }
      },
      height: {
        default: "auto",
        parseHTML: (e) => e.getAttribute("height"),
        renderHTML: (e) => ({
          height: e.height
        })
      },
      autoplay: {
        default: null,
        parseHTML: (e) => e.getAttribute("autoplay"),
        renderHTML: (e) => ({
          autoplay: e.autoplay
        })
      },
      controls: {
        default: !0,
        parseHTML: (e) => e.getAttribute("controls"),
        renderHTML: (e) => ({
          controls: e.controls
        })
      },
      loop: {
        default: null,
        parseHTML: (e) => e.getAttribute("loop"),
        renderHTML: (e) => ({
          loop: e.loop
        })
      },
      textAlign: {
        default: null,
        parseHTML: (e) => e.getAttribute("text-align"),
        renderHTML: (e) => ({
          "text-align": e.textAlign
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "video"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["video", Ee(t)];
  },
  addCommands() {
    return {
      setVideo: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      jd({
        find: /^\$video\$$/,
        type: this.type,
        getAttributes: () => ({ width: "100%" })
      })
    ];
  },
  addNodeView() {
    return Oc(Xue);
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getCommandMenuItems() {
        return {
          priority: 100,
          icon: R(Fk),
          title: "editor.extensions.commands_menu.video",
          keywords: ["video", "shipin"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).insertContent([
              { type: "video", attrs: { src: "" } },
              { type: "paragraph", content: "" }
            ]).run();
          }
        };
      },
      getToolboxItems({ editor: e }) {
        return [
          {
            priority: 20,
            component: R(Qo),
            props: {
              editor: e,
              icon: R(Fk),
              title: Q.global.t("editor.extensions.commands_menu.video"),
              action: () => {
                e.chain().focus().insertContent([{ type: "video", attrs: { src: "" } }]).run();
              }
            }
          }
        ];
      },
      getBubbleMenu({ editor: e }) {
        return {
          pluginKey: "videoBubbleMenu",
          shouldShow: ({ state: n }) => xi(n, ft.name),
          items: [
            {
              priority: 10,
              props: {
                isActive: () => e.getAttributes(ft.name).controls,
                icon: R(
                  e.getAttributes(ft.name).controls ? Rue : Lue
                ),
                action: () => e.chain().updateAttributes(ft.name, {
                  controls: e.getAttributes(ft.name).controls ? null : !0
                }).setNodeSelection(e.state.selection.from).focus().run(),
                title: e.getAttributes(ft.name).controls ? Q.global.t("editor.extensions.video.disable_controls") : Q.global.t("editor.extensions.video.enable_controls")
              }
            },
            {
              priority: 20,
              props: {
                isActive: () => e.getAttributes(ft.name).autoplay,
                icon: R(
                  e.getAttributes(ft.name).autoplay ? _R : vR
                ),
                action: () => e.chain().updateAttributes(ft.name, {
                  autoplay: e.getAttributes(ft.name).autoplay ? null : !0
                }).setNodeSelection(e.state.selection.from).focus().run(),
                title: e.getAttributes(ft.name).autoplay ? Q.global.t("editor.extensions.video.disable_autoplay") : Q.global.t("editor.extensions.video.enable_autoplay")
              }
            },
            {
              priority: 30,
              props: {
                isActive: () => e.getAttributes(ft.name).loop,
                icon: R(
                  e.getAttributes(ft.name).loop ? OR : yR
                ),
                action: () => {
                  e.chain().updateAttributes(ft.name, {
                    loop: e.getAttributes(ft.name).loop ? null : !0
                  }).setNodeSelection(e.state.selection.from).focus().run();
                },
                title: e.getAttributes(ft.name).loop ? Q.global.t("editor.extensions.video.disable_loop") : Q.global.t("editor.extensions.video.enable_loop")
              }
            },
            {
              priority: 40,
              component: R(Qt)
            },
            {
              priority: 50,
              component: R(Vue)
            },
            {
              priority: 60,
              component: R(Qt)
            },
            {
              priority: 70,
              props: {
                isActive: () => e.getAttributes(ft.name).width === "25%",
                icon: R(MR),
                action: () => g1(e, "25%", "auto"),
                title: Q.global.t("editor.extensions.video.small_size")
              }
            },
            {
              priority: 80,
              props: {
                isActive: () => e.getAttributes(ft.name).width === "50%",
                icon: R(TR),
                action: () => g1(e, "50%", "auto"),
                title: Q.global.t("editor.extensions.video.medium_size")
              }
            },
            {
              priority: 90,
              props: {
                isActive: () => e.getAttributes(ft.name).width === "100%",
                icon: R(AR),
                action: () => g1(e, "100%", "auto"),
                title: Q.global.t("editor.extensions.video.large_size")
              }
            },
            {
              priority: 100,
              component: R(Qt)
            },
            {
              priority: 110,
              props: {
                isActive: () => e.isActive({ textAlign: "left" }),
                icon: R(xc),
                action: () => uf(e, "left")
              }
            },
            {
              priority: 120,
              props: {
                isActive: () => e.isActive({ textAlign: "center" }),
                icon: R(eh),
                action: () => uf(e, "center")
              }
            },
            {
              priority: 130,
              props: {
                isActive: () => e.isActive({ textAlign: "right" }),
                icon: R(nh),
                action: () => uf(e, "right")
              }
            },
            {
              priority: 140,
              props: {
                isActive: () => e.isActive({ textAlign: "justify" }),
                icon: R(th),
                action: () => uf(e, "justify")
              }
            },
            {
              priority: 150,
              component: R(Qt)
            },
            {
              priority: 160,
              props: {
                icon: R(ih),
                title: Q.global.t("editor.common.button.edit_link"),
                action: () => R(Wue)
              }
            },
            {
              priority: 170,
              props: {
                icon: R(rh),
                title: Q.global.t("editor.common.tooltip.open_link"),
                action: () => {
                  window.open(e.getAttributes(ft.name).src, "_blank");
                }
              }
            },
            {
              priority: 180,
              component: R(Qt)
            },
            {
              priority: 190,
              props: {
                icon: R(Ua),
                title: Q.global.t("editor.common.button.delete"),
                action: ({ editor: n }) => {
                  vc(ft.name, n);
                }
              }
            }
          ]
        };
      },
      getDraggable() {
        return {
          getRenderContainer({ dom: e, view: n }) {
            var s;
            let i = e;
            for (; i && i.tagName !== "P"; )
              i = i.parentElement;
            i && (i = (s = i.firstElementChild) == null ? void 0 : s.firstElementChild);
            let r;
            if (i.firstElementChild) {
              const o = n.posAtDOM(i.firstElementChild, 0);
              r = n.state.doc.resolve(o).node();
            }
            return {
              node: r,
              el: i
            };
          }
        };
      }
    };
  }
}), g1 = (t, e, n) => {
  t.chain().updateAttributes(ft.name, { width: e, height: n }).setNodeSelection(t.state.selection.from).focus().run();
}, uf = (t, e) => {
  t.chain().focus().setTextAlign(e).run();
};
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const jue = 4, zk = 0, Uk = 1, Yue = 2;
function wc(t) {
  let e = t.length;
  for (; --e >= 0; )
    t[e] = 0;
}
const Gue = 0, $R = 1, Kue = 2, Jue = 3, ede = 258, c_ = 29, oh = 256, ud = oh + 1 + c_, Cl = 30, u_ = 19, NR = 2 * ud + 1, aa = 15, b1 = 16, tde = 7, d_ = 256, DR = 16, IR = 17, LR = 18, RO = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), Jf = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), nde = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), BR = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ide = 512, gs = new Array((ud + 2) * 2);
wc(gs);
const xu = new Array(Cl * 2);
wc(xu);
const dd = new Array(ide);
wc(dd);
const hd = new Array(ede - Jue + 1);
wc(hd);
const h_ = new Array(c_);
wc(h_);
const wm = new Array(Cl);
wc(wm);
function O1(t, e, n, i, r) {
  this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = i, this.max_length = r, this.has_stree = t && t.length;
}
let QR, FR, zR;
function y1(t, e) {
  this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
}
const UR = (t) => t < 256 ? dd[t] : dd[256 + (t >>> 7)], fd = (t, e) => {
  t.pending_buf[t.pending++] = e & 255, t.pending_buf[t.pending++] = e >>> 8 & 255;
}, ti = (t, e, n) => {
  t.bi_valid > b1 - n ? (t.bi_buf |= e << t.bi_valid & 65535, fd(t, t.bi_buf), t.bi_buf = e >> b1 - t.bi_valid, t.bi_valid += n - b1) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n);
}, Pr = (t, e, n) => {
  ti(
    t,
    n[e * 2],
    n[e * 2 + 1]
    /*.Len*/
  );
}, WR = (t, e) => {
  let n = 0;
  do
    n |= t & 1, t >>>= 1, n <<= 1;
  while (--e > 0);
  return n >>> 1;
}, rde = (t) => {
  t.bi_valid === 16 ? (fd(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = t.bi_buf & 255, t.bi_buf >>= 8, t.bi_valid -= 8);
}, sde = (t, e) => {
  const n = e.dyn_tree, i = e.max_code, r = e.stat_desc.static_tree, s = e.stat_desc.has_stree, o = e.stat_desc.extra_bits, a = e.stat_desc.extra_base, l = e.stat_desc.max_length;
  let c, u, d, h, f, p, m = 0;
  for (h = 0; h <= aa; h++)
    t.bl_count[h] = 0;
  for (n[t.heap[t.heap_max] * 2 + 1] = 0, c = t.heap_max + 1; c < NR; c++)
    u = t.heap[c], h = n[n[u * 2 + 1] * 2 + 1] + 1, h > l && (h = l, m++), n[u * 2 + 1] = h, !(u > i) && (t.bl_count[h]++, f = 0, u >= a && (f = o[u - a]), p = n[u * 2], t.opt_len += p * (h + f), s && (t.static_len += p * (r[u * 2 + 1] + f)));
  if (m !== 0) {
    do {
      for (h = l - 1; t.bl_count[h] === 0; )
        h--;
      t.bl_count[h]--, t.bl_count[h + 1] += 2, t.bl_count[l]--, m -= 2;
    } while (m > 0);
    for (h = l; h !== 0; h--)
      for (u = t.bl_count[h]; u !== 0; )
        d = t.heap[--c], !(d > i) && (n[d * 2 + 1] !== h && (t.opt_len += (h - n[d * 2 + 1]) * n[d * 2], n[d * 2 + 1] = h), u--);
  }
}, VR = (t, e, n) => {
  const i = new Array(aa + 1);
  let r = 0, s, o;
  for (s = 1; s <= aa; s++)
    r = r + n[s - 1] << 1, i[s] = r;
  for (o = 0; o <= e; o++) {
    let a = t[o * 2 + 1];
    a !== 0 && (t[o * 2] = WR(i[a]++, a));
  }
}, ode = () => {
  let t, e, n, i, r;
  const s = new Array(aa + 1);
  for (n = 0, i = 0; i < c_ - 1; i++)
    for (h_[i] = n, t = 0; t < 1 << RO[i]; t++)
      hd[n++] = i;
  for (hd[n - 1] = i, r = 0, i = 0; i < 16; i++)
    for (wm[i] = r, t = 0; t < 1 << Jf[i]; t++)
      dd[r++] = i;
  for (r >>= 7; i < Cl; i++)
    for (wm[i] = r << 7, t = 0; t < 1 << Jf[i] - 7; t++)
      dd[256 + r++] = i;
  for (e = 0; e <= aa; e++)
    s[e] = 0;
  for (t = 0; t <= 143; )
    gs[t * 2 + 1] = 8, t++, s[8]++;
  for (; t <= 255; )
    gs[t * 2 + 1] = 9, t++, s[9]++;
  for (; t <= 279; )
    gs[t * 2 + 1] = 7, t++, s[7]++;
  for (; t <= 287; )
    gs[t * 2 + 1] = 8, t++, s[8]++;
  for (VR(gs, ud + 1, s), t = 0; t < Cl; t++)
    xu[t * 2 + 1] = 5, xu[t * 2] = WR(t, 5);
  QR = new O1(gs, RO, oh + 1, ud, aa), FR = new O1(xu, Jf, 0, Cl, aa), zR = new O1(new Array(0), nde, 0, u_, tde);
}, ZR = (t) => {
  let e;
  for (e = 0; e < ud; e++)
    t.dyn_ltree[e * 2] = 0;
  for (e = 0; e < Cl; e++)
    t.dyn_dtree[e * 2] = 0;
  for (e = 0; e < u_; e++)
    t.bl_tree[e * 2] = 0;
  t.dyn_ltree[d_ * 2] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0;
}, HR = (t) => {
  t.bi_valid > 8 ? fd(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
}, Wk = (t, e, n, i) => {
  const r = e * 2, s = n * 2;
  return t[r] < t[s] || t[r] === t[s] && i[e] <= i[n];
}, _1 = (t, e, n) => {
  const i = t.heap[n];
  let r = n << 1;
  for (; r <= t.heap_len && (r < t.heap_len && Wk(e, t.heap[r + 1], t.heap[r], t.depth) && r++, !Wk(e, i, t.heap[r], t.depth)); )
    t.heap[n] = t.heap[r], n = r, r <<= 1;
  t.heap[n] = i;
}, Vk = (t, e, n) => {
  let i, r, s = 0, o, a;
  if (t.sym_next !== 0)
    do
      i = t.pending_buf[t.sym_buf + s++] & 255, i += (t.pending_buf[t.sym_buf + s++] & 255) << 8, r = t.pending_buf[t.sym_buf + s++], i === 0 ? Pr(t, r, e) : (o = hd[r], Pr(t, o + oh + 1, e), a = RO[o], a !== 0 && (r -= h_[o], ti(t, r, a)), i--, o = UR(i), Pr(t, o, n), a = Jf[o], a !== 0 && (i -= wm[o], ti(t, i, a)));
    while (s < t.sym_next);
  Pr(t, d_, e);
}, $O = (t, e) => {
  const n = e.dyn_tree, i = e.stat_desc.static_tree, r = e.stat_desc.has_stree, s = e.stat_desc.elems;
  let o, a, l = -1, c;
  for (t.heap_len = 0, t.heap_max = NR, o = 0; o < s; o++)
    n[o * 2] !== 0 ? (t.heap[++t.heap_len] = l = o, t.depth[o] = 0) : n[o * 2 + 1] = 0;
  for (; t.heap_len < 2; )
    c = t.heap[++t.heap_len] = l < 2 ? ++l : 0, n[c * 2] = 1, t.depth[c] = 0, t.opt_len--, r && (t.static_len -= i[c * 2 + 1]);
  for (e.max_code = l, o = t.heap_len >> 1; o >= 1; o--)
    _1(t, n, o);
  c = s;
  do
    o = t.heap[
      1
      /*SMALLEST*/
    ], t.heap[
      1
      /*SMALLEST*/
    ] = t.heap[t.heap_len--], _1(
      t,
      n,
      1
      /*SMALLEST*/
    ), a = t.heap[
      1
      /*SMALLEST*/
    ], t.heap[--t.heap_max] = o, t.heap[--t.heap_max] = a, n[c * 2] = n[o * 2] + n[a * 2], t.depth[c] = (t.depth[o] >= t.depth[a] ? t.depth[o] : t.depth[a]) + 1, n[o * 2 + 1] = n[a * 2 + 1] = c, t.heap[
      1
      /*SMALLEST*/
    ] = c++, _1(
      t,
      n,
      1
      /*SMALLEST*/
    );
  while (t.heap_len >= 2);
  t.heap[--t.heap_max] = t.heap[
    1
    /*SMALLEST*/
  ], sde(t, e), VR(n, l, t.bl_count);
}, Zk = (t, e, n) => {
  let i, r = -1, s, o = e[0 * 2 + 1], a = 0, l = 7, c = 4;
  for (o === 0 && (l = 138, c = 3), e[(n + 1) * 2 + 1] = 65535, i = 0; i <= n; i++)
    s = o, o = e[(i + 1) * 2 + 1], !(++a < l && s === o) && (a < c ? t.bl_tree[s * 2] += a : s !== 0 ? (s !== r && t.bl_tree[s * 2]++, t.bl_tree[DR * 2]++) : a <= 10 ? t.bl_tree[IR * 2]++ : t.bl_tree[LR * 2]++, a = 0, r = s, o === 0 ? (l = 138, c = 3) : s === o ? (l = 6, c = 3) : (l = 7, c = 4));
}, Hk = (t, e, n) => {
  let i, r = -1, s, o = e[0 * 2 + 1], a = 0, l = 7, c = 4;
  for (o === 0 && (l = 138, c = 3), i = 0; i <= n; i++)
    if (s = o, o = e[(i + 1) * 2 + 1], !(++a < l && s === o)) {
      if (a < c)
        do
          Pr(t, s, t.bl_tree);
        while (--a !== 0);
      else s !== 0 ? (s !== r && (Pr(t, s, t.bl_tree), a--), Pr(t, DR, t.bl_tree), ti(t, a - 3, 2)) : a <= 10 ? (Pr(t, IR, t.bl_tree), ti(t, a - 3, 3)) : (Pr(t, LR, t.bl_tree), ti(t, a - 11, 7));
      a = 0, r = s, o === 0 ? (l = 138, c = 3) : s === o ? (l = 6, c = 3) : (l = 7, c = 4);
    }
}, ade = (t) => {
  let e;
  for (Zk(t, t.dyn_ltree, t.l_desc.max_code), Zk(t, t.dyn_dtree, t.d_desc.max_code), $O(t, t.bl_desc), e = u_ - 1; e >= 3 && t.bl_tree[BR[e] * 2 + 1] === 0; e--)
    ;
  return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
}, lde = (t, e, n, i) => {
  let r;
  for (ti(t, e - 257, 5), ti(t, n - 1, 5), ti(t, i - 4, 4), r = 0; r < i; r++)
    ti(t, t.bl_tree[BR[r] * 2 + 1], 3);
  Hk(t, t.dyn_ltree, e - 1), Hk(t, t.dyn_dtree, n - 1);
}, cde = (t) => {
  let e = 4093624447, n;
  for (n = 0; n <= 31; n++, e >>>= 1)
    if (e & 1 && t.dyn_ltree[n * 2] !== 0)
      return zk;
  if (t.dyn_ltree[9 * 2] !== 0 || t.dyn_ltree[10 * 2] !== 0 || t.dyn_ltree[13 * 2] !== 0)
    return Uk;
  for (n = 32; n < oh; n++)
    if (t.dyn_ltree[n * 2] !== 0)
      return Uk;
  return zk;
};
let qk = !1;
const ude = (t) => {
  qk || (ode(), qk = !0), t.l_desc = new y1(t.dyn_ltree, QR), t.d_desc = new y1(t.dyn_dtree, FR), t.bl_desc = new y1(t.bl_tree, zR), t.bi_buf = 0, t.bi_valid = 0, ZR(t);
}, qR = (t, e, n, i) => {
  ti(t, (Gue << 1) + (i ? 1 : 0), 3), HR(t), fd(t, n), fd(t, ~n), n && t.pending_buf.set(t.window.subarray(e, e + n), t.pending), t.pending += n;
}, dde = (t) => {
  ti(t, $R << 1, 3), Pr(t, d_, gs), rde(t);
}, hde = (t, e, n, i) => {
  let r, s, o = 0;
  t.level > 0 ? (t.strm.data_type === Yue && (t.strm.data_type = cde(t)), $O(t, t.l_desc), $O(t, t.d_desc), o = ade(t), r = t.opt_len + 3 + 7 >>> 3, s = t.static_len + 3 + 7 >>> 3, s <= r && (r = s)) : r = s = n + 5, n + 4 <= r && e !== -1 ? qR(t, e, n, i) : t.strategy === jue || s === r ? (ti(t, ($R << 1) + (i ? 1 : 0), 3), Vk(t, gs, xu)) : (ti(t, (Kue << 1) + (i ? 1 : 0), 3), lde(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), Vk(t, t.dyn_ltree, t.dyn_dtree)), ZR(t), i && HR(t);
}, fde = (t, e, n) => (t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = n, e === 0 ? t.dyn_ltree[n * 2]++ : (t.matches++, e--, t.dyn_ltree[(hd[n] + oh + 1) * 2]++, t.dyn_dtree[UR(e) * 2]++), t.sym_next === t.sym_end);
var pde = ude, mde = qR, gde = hde, bde = fde, Ode = dde, yde = {
  _tr_init: pde,
  _tr_stored_block: mde,
  _tr_flush_block: gde,
  _tr_tally: bde,
  _tr_align: Ode
};
const _de = (t, e, n, i) => {
  let r = t & 65535 | 0, s = t >>> 16 & 65535 | 0, o = 0;
  for (; n !== 0; ) {
    o = n > 2e3 ? 2e3 : n, n -= o;
    do
      r = r + e[i++] | 0, s = s + r | 0;
    while (--o);
    r %= 65521, s %= 65521;
  }
  return r | s << 16 | 0;
};
var pd = _de;
const vde = () => {
  let t, e = [];
  for (var n = 0; n < 256; n++) {
    t = n;
    for (var i = 0; i < 8; i++)
      t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
    e[n] = t;
  }
  return e;
}, xde = new Uint32Array(vde()), wde = (t, e, n, i) => {
  const r = xde, s = i + n;
  t ^= -1;
  for (let o = i; o < s; o++)
    t = t >>> 8 ^ r[(t ^ e[o]) & 255];
  return t ^ -1;
};
var en = wde, Ma = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, qa = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: Sde, _tr_stored_block: NO, _tr_flush_block: kde, _tr_tally: yo, _tr_align: Ede } = yde, {
  Z_NO_FLUSH: _o,
  Z_PARTIAL_FLUSH: Cde,
  Z_FULL_FLUSH: Ade,
  Z_FINISH: Ri,
  Z_BLOCK: Xk,
  Z_OK: un,
  Z_STREAM_END: jk,
  Z_STREAM_ERROR: Hr,
  Z_DATA_ERROR: Tde,
  Z_BUF_ERROR: v1,
  Z_DEFAULT_COMPRESSION: Mde,
  Z_FILTERED: Pde,
  Z_HUFFMAN_ONLY: df,
  Z_RLE: Rde,
  Z_FIXED: $de,
  Z_DEFAULT_STRATEGY: Nde,
  Z_UNKNOWN: Dde,
  Z_DEFLATED: Z0
} = qa, Ide = 9, Lde = 15, Bde = 8, Qde = 29, Fde = 256, DO = Fde + 1 + Qde, zde = 30, Ude = 19, Wde = 2 * DO + 1, Vde = 15, Ze = 3, lo = 258, qr = lo + Ze + 1, Zde = 32, ec = 42, f_ = 57, IO = 69, LO = 73, BO = 91, QO = 103, la = 113, Yc = 666, Ln = 1, Sc = 2, Pa = 3, kc = 4, Hde = 3, ca = (t, e) => (t.msg = Ma[e], e), Yk = (t) => t * 2 - (t > 4 ? 9 : 0), Js = (t) => {
  let e = t.length;
  for (; --e >= 0; )
    t[e] = 0;
}, qde = (t) => {
  let e, n, i, r = t.w_size;
  e = t.hash_size, i = e;
  do
    n = t.head[--i], t.head[i] = n >= r ? n - r : 0;
  while (--e);
  e = r, i = e;
  do
    n = t.prev[--i], t.prev[i] = n >= r ? n - r : 0;
  while (--e);
};
let Xde = (t, e, n) => (e << t.hash_shift ^ n) & t.hash_mask, vo = Xde;
const mi = (t) => {
  const e = t.state;
  let n = e.pending;
  n > t.avail_out && (n = t.avail_out), n !== 0 && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + n), t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, e.pending === 0 && (e.pending_out = 0));
}, _i = (t, e) => {
  kde(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, mi(t.strm);
}, tt = (t, e) => {
  t.pending_buf[t.pending++] = e;
}, Nc = (t, e) => {
  t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = e & 255;
}, FO = (t, e, n, i) => {
  let r = t.avail_in;
  return r > i && (r = i), r === 0 ? 0 : (t.avail_in -= r, e.set(t.input.subarray(t.next_in, t.next_in + r), n), t.state.wrap === 1 ? t.adler = pd(t.adler, e, r, n) : t.state.wrap === 2 && (t.adler = en(t.adler, e, r, n)), t.next_in += r, t.total_in += r, r);
}, XR = (t, e) => {
  let n = t.max_chain_length, i = t.strstart, r, s, o = t.prev_length, a = t.nice_match;
  const l = t.strstart > t.w_size - qr ? t.strstart - (t.w_size - qr) : 0, c = t.window, u = t.w_mask, d = t.prev, h = t.strstart + lo;
  let f = c[i + o - 1], p = c[i + o];
  t.prev_length >= t.good_match && (n >>= 2), a > t.lookahead && (a = t.lookahead);
  do
    if (r = e, !(c[r + o] !== p || c[r + o - 1] !== f || c[r] !== c[i] || c[++r] !== c[i + 1])) {
      i += 2, r++;
      do
        ;
      while (c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && c[++i] === c[++r] && i < h);
      if (s = lo - (h - i), i = h - lo, s > o) {
        if (t.match_start = e, o = s, s >= a)
          break;
        f = c[i + o - 1], p = c[i + o];
      }
    }
  while ((e = d[e & u]) > l && --n !== 0);
  return o <= t.lookahead ? o : t.lookahead;
}, tc = (t) => {
  const e = t.w_size;
  let n, i, r;
  do {
    if (i = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - qr) && (t.window.set(t.window.subarray(e, e + e - i), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, t.insert > t.strstart && (t.insert = t.strstart), qde(t), i += e), t.strm.avail_in === 0)
      break;
    if (n = FO(t.strm, t.window, t.strstart + t.lookahead, i), t.lookahead += n, t.lookahead + t.insert >= Ze)
      for (r = t.strstart - t.insert, t.ins_h = t.window[r], t.ins_h = vo(t, t.ins_h, t.window[r + 1]); t.insert && (t.ins_h = vo(t, t.ins_h, t.window[r + Ze - 1]), t.prev[r & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = r, r++, t.insert--, !(t.lookahead + t.insert < Ze)); )
        ;
  } while (t.lookahead < qr && t.strm.avail_in !== 0);
}, jR = (t, e) => {
  let n = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5, i, r, s, o = 0, a = t.strm.avail_in;
  do {
    if (i = 65535, s = t.bi_valid + 42 >> 3, t.strm.avail_out < s || (s = t.strm.avail_out - s, r = t.strstart - t.block_start, i > r + t.strm.avail_in && (i = r + t.strm.avail_in), i > s && (i = s), i < n && (i === 0 && e !== Ri || e === _o || i !== r + t.strm.avail_in)))
      break;
    o = e === Ri && i === r + t.strm.avail_in ? 1 : 0, NO(t, 0, 0, o), t.pending_buf[t.pending - 4] = i, t.pending_buf[t.pending - 3] = i >> 8, t.pending_buf[t.pending - 2] = ~i, t.pending_buf[t.pending - 1] = ~i >> 8, mi(t.strm), r && (r > i && (r = i), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + r), t.strm.next_out), t.strm.next_out += r, t.strm.avail_out -= r, t.strm.total_out += r, t.block_start += r, i -= r), i && (FO(t.strm, t.strm.output, t.strm.next_out, i), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i);
  } while (o === 0);
  return a -= t.strm.avail_in, a && (a >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= a && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - a, t.strm.next_in), t.strstart), t.strstart += a, t.insert += a > t.w_size - t.insert ? t.w_size - t.insert : a), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), o ? kc : e !== _o && e !== Ri && t.strm.avail_in === 0 && t.strstart === t.block_start ? Sc : (s = t.window_size - t.strstart, t.strm.avail_in > s && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, s += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), s > t.strm.avail_in && (s = t.strm.avail_in), s && (FO(t.strm, t.window, t.strstart, s), t.strstart += s, t.insert += s > t.w_size - t.insert ? t.w_size - t.insert : s), t.high_water < t.strstart && (t.high_water = t.strstart), s = t.bi_valid + 42 >> 3, s = t.pending_buf_size - s > 65535 ? 65535 : t.pending_buf_size - s, n = s > t.w_size ? t.w_size : s, r = t.strstart - t.block_start, (r >= n || (r || e === Ri) && e !== _o && t.strm.avail_in === 0 && r <= s) && (i = r > s ? s : r, o = e === Ri && t.strm.avail_in === 0 && i === r ? 1 : 0, NO(t, t.block_start, i, o), t.block_start += i, mi(t.strm)), o ? Pa : Ln);
}, x1 = (t, e) => {
  let n, i;
  for (; ; ) {
    if (t.lookahead < qr) {
      if (tc(t), t.lookahead < qr && e === _o)
        return Ln;
      if (t.lookahead === 0)
        break;
    }
    if (n = 0, t.lookahead >= Ze && (t.ins_h = vo(t, t.ins_h, t.window[t.strstart + Ze - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), n !== 0 && t.strstart - n <= t.w_size - qr && (t.match_length = XR(t, n)), t.match_length >= Ze)
      if (i = yo(t, t.strstart - t.match_start, t.match_length - Ze), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= Ze) {
        t.match_length--;
        do
          t.strstart++, t.ins_h = vo(t, t.ins_h, t.window[t.strstart + Ze - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
        while (--t.match_length !== 0);
        t.strstart++;
      } else
        t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = vo(t, t.ins_h, t.window[t.strstart + 1]);
    else
      i = yo(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
    if (i && (_i(t, !1), t.strm.avail_out === 0))
      return Ln;
  }
  return t.insert = t.strstart < Ze - 1 ? t.strstart : Ze - 1, e === Ri ? (_i(t, !0), t.strm.avail_out === 0 ? Pa : kc) : t.sym_next && (_i(t, !1), t.strm.avail_out === 0) ? Ln : Sc;
}, sl = (t, e) => {
  let n, i, r;
  for (; ; ) {
    if (t.lookahead < qr) {
      if (tc(t), t.lookahead < qr && e === _o)
        return Ln;
      if (t.lookahead === 0)
        break;
    }
    if (n = 0, t.lookahead >= Ze && (t.ins_h = vo(t, t.ins_h, t.window[t.strstart + Ze - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = Ze - 1, n !== 0 && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - qr && (t.match_length = XR(t, n), t.match_length <= 5 && (t.strategy === Pde || t.match_length === Ze && t.strstart - t.match_start > 4096) && (t.match_length = Ze - 1)), t.prev_length >= Ze && t.match_length <= t.prev_length) {
      r = t.strstart + t.lookahead - Ze, i = yo(t, t.strstart - 1 - t.prev_match, t.prev_length - Ze), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
      do
        ++t.strstart <= r && (t.ins_h = vo(t, t.ins_h, t.window[t.strstart + Ze - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
      while (--t.prev_length !== 0);
      if (t.match_available = 0, t.match_length = Ze - 1, t.strstart++, i && (_i(t, !1), t.strm.avail_out === 0))
        return Ln;
    } else if (t.match_available) {
      if (i = yo(t, 0, t.window[t.strstart - 1]), i && _i(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0)
        return Ln;
    } else
      t.match_available = 1, t.strstart++, t.lookahead--;
  }
  return t.match_available && (i = yo(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < Ze - 1 ? t.strstart : Ze - 1, e === Ri ? (_i(t, !0), t.strm.avail_out === 0 ? Pa : kc) : t.sym_next && (_i(t, !1), t.strm.avail_out === 0) ? Ln : Sc;
}, jde = (t, e) => {
  let n, i, r, s;
  const o = t.window;
  for (; ; ) {
    if (t.lookahead <= lo) {
      if (tc(t), t.lookahead <= lo && e === _o)
        return Ln;
      if (t.lookahead === 0)
        break;
    }
    if (t.match_length = 0, t.lookahead >= Ze && t.strstart > 0 && (r = t.strstart - 1, i = o[r], i === o[++r] && i === o[++r] && i === o[++r])) {
      s = t.strstart + lo;
      do
        ;
      while (i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && i === o[++r] && r < s);
      t.match_length = lo - (s - r), t.match_length > t.lookahead && (t.match_length = t.lookahead);
    }
    if (t.match_length >= Ze ? (n = yo(t, 1, t.match_length - Ze), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = yo(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), n && (_i(t, !1), t.strm.avail_out === 0))
      return Ln;
  }
  return t.insert = 0, e === Ri ? (_i(t, !0), t.strm.avail_out === 0 ? Pa : kc) : t.sym_next && (_i(t, !1), t.strm.avail_out === 0) ? Ln : Sc;
}, Yde = (t, e) => {
  let n;
  for (; ; ) {
    if (t.lookahead === 0 && (tc(t), t.lookahead === 0)) {
      if (e === _o)
        return Ln;
      break;
    }
    if (t.match_length = 0, n = yo(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, n && (_i(t, !1), t.strm.avail_out === 0))
      return Ln;
  }
  return t.insert = 0, e === Ri ? (_i(t, !0), t.strm.avail_out === 0 ? Pa : kc) : t.sym_next && (_i(t, !1), t.strm.avail_out === 0) ? Ln : Sc;
};
function yr(t, e, n, i, r) {
  this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = i, this.func = r;
}
const Gc = [
  /*      good lazy nice chain */
  new yr(0, 0, 0, 0, jR),
  /* 0 store only */
  new yr(4, 4, 8, 4, x1),
  /* 1 max speed, no lazy matches */
  new yr(4, 5, 16, 8, x1),
  /* 2 */
  new yr(4, 6, 32, 32, x1),
  /* 3 */
  new yr(4, 4, 16, 16, sl),
  /* 4 lazy matches */
  new yr(8, 16, 32, 32, sl),
  /* 5 */
  new yr(8, 16, 128, 128, sl),
  /* 6 */
  new yr(8, 32, 128, 256, sl),
  /* 7 */
  new yr(32, 128, 258, 1024, sl),
  /* 8 */
  new yr(32, 258, 258, 4096, sl)
  /* 9 max compression */
], Gde = (t) => {
  t.window_size = 2 * t.w_size, Js(t.head), t.max_lazy_match = Gc[t.level].max_lazy, t.good_match = Gc[t.level].good_length, t.nice_match = Gc[t.level].nice_length, t.max_chain_length = Gc[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = Ze - 1, t.match_available = 0, t.ins_h = 0;
};
function Kde() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z0, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Wde * 2), this.dyn_dtree = new Uint16Array((2 * zde + 1) * 2), this.bl_tree = new Uint16Array((2 * Ude + 1) * 2), Js(this.dyn_ltree), Js(this.dyn_dtree), Js(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Vde + 1), this.heap = new Uint16Array(2 * DO + 1), Js(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * DO + 1), Js(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const ah = (t) => {
  if (!t)
    return 1;
  const e = t.state;
  return !e || e.strm !== t || e.status !== ec && //#ifdef GZIP
  e.status !== f_ && //#endif
  e.status !== IO && e.status !== LO && e.status !== BO && e.status !== QO && e.status !== la && e.status !== Yc ? 1 : 0;
}, YR = (t) => {
  if (ah(t))
    return ca(t, Hr);
  t.total_in = t.total_out = 0, t.data_type = Dde;
  const e = t.state;
  return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = //#ifdef GZIP
  e.wrap === 2 ? f_ : (
    //#endif
    e.wrap ? ec : la
  ), t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = -2, Sde(e), un;
}, GR = (t) => {
  const e = YR(t);
  return e === un && Gde(t.state), e;
}, Jde = (t, e) => ah(t) || t.state.wrap !== 2 ? Hr : (t.state.gzhead = e, un), KR = (t, e, n, i, r, s) => {
  if (!t)
    return Hr;
  let o = 1;
  if (e === Mde && (e = 6), i < 0 ? (o = 0, i = -i) : i > 15 && (o = 2, i -= 16), r < 1 || r > Ide || n !== Z0 || i < 8 || i > 15 || e < 0 || e > 9 || s < 0 || s > $de || i === 8 && o !== 1)
    return ca(t, Hr);
  i === 8 && (i = 9);
  const a = new Kde();
  return t.state = a, a.strm = t, a.status = ec, a.wrap = o, a.gzhead = null, a.w_bits = i, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = r + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + Ze - 1) / Ze), a.window = new Uint8Array(a.w_size * 2), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << r + 6, a.pending_buf_size = a.lit_bufsize * 4, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = (a.lit_bufsize - 1) * 3, a.level = e, a.strategy = s, a.method = n, GR(t);
}, ehe = (t, e) => KR(t, e, Z0, Lde, Bde, Nde), the = (t, e) => {
  if (ah(t) || e > Xk || e < 0)
    return t ? ca(t, Hr) : Hr;
  const n = t.state;
  if (!t.output || t.avail_in !== 0 && !t.input || n.status === Yc && e !== Ri)
    return ca(t, t.avail_out === 0 ? v1 : Hr);
  const i = n.last_flush;
  if (n.last_flush = e, n.pending !== 0) {
    if (mi(t), t.avail_out === 0)
      return n.last_flush = -1, un;
  } else if (t.avail_in === 0 && Yk(e) <= Yk(i) && e !== Ri)
    return ca(t, v1);
  if (n.status === Yc && t.avail_in !== 0)
    return ca(t, v1);
  if (n.status === ec && n.wrap === 0 && (n.status = la), n.status === ec) {
    let r = Z0 + (n.w_bits - 8 << 4) << 8, s = -1;
    if (n.strategy >= df || n.level < 2 ? s = 0 : n.level < 6 ? s = 1 : n.level === 6 ? s = 2 : s = 3, r |= s << 6, n.strstart !== 0 && (r |= Zde), r += 31 - r % 31, Nc(n, r), n.strstart !== 0 && (Nc(n, t.adler >>> 16), Nc(n, t.adler & 65535)), t.adler = 1, n.status = la, mi(t), n.pending !== 0)
      return n.last_flush = -1, un;
  }
  if (n.status === f_) {
    if (t.adler = 0, tt(n, 31), tt(n, 139), tt(n, 8), n.gzhead)
      tt(
        n,
        (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)
      ), tt(n, n.gzhead.time & 255), tt(n, n.gzhead.time >> 8 & 255), tt(n, n.gzhead.time >> 16 & 255), tt(n, n.gzhead.time >> 24 & 255), tt(n, n.level === 9 ? 2 : n.strategy >= df || n.level < 2 ? 4 : 0), tt(n, n.gzhead.os & 255), n.gzhead.extra && n.gzhead.extra.length && (tt(n, n.gzhead.extra.length & 255), tt(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (t.adler = en(t.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = IO;
    else if (tt(n, 0), tt(n, 0), tt(n, 0), tt(n, 0), tt(n, 0), tt(n, n.level === 9 ? 2 : n.strategy >= df || n.level < 2 ? 4 : 0), tt(n, Hde), n.status = la, mi(t), n.pending !== 0)
      return n.last_flush = -1, un;
  }
  if (n.status === IO) {
    if (n.gzhead.extra) {
      let r = n.pending, s = (n.gzhead.extra.length & 65535) - n.gzindex;
      for (; n.pending + s > n.pending_buf_size; ) {
        let a = n.pending_buf_size - n.pending;
        if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + a), n.pending), n.pending = n.pending_buf_size, n.gzhead.hcrc && n.pending > r && (t.adler = en(t.adler, n.pending_buf, n.pending - r, r)), n.gzindex += a, mi(t), n.pending !== 0)
          return n.last_flush = -1, un;
        r = 0, s -= a;
      }
      let o = new Uint8Array(n.gzhead.extra);
      n.pending_buf.set(o.subarray(n.gzindex, n.gzindex + s), n.pending), n.pending += s, n.gzhead.hcrc && n.pending > r && (t.adler = en(t.adler, n.pending_buf, n.pending - r, r)), n.gzindex = 0;
    }
    n.status = LO;
  }
  if (n.status === LO) {
    if (n.gzhead.name) {
      let r = n.pending, s;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > r && (t.adler = en(t.adler, n.pending_buf, n.pending - r, r)), mi(t), n.pending !== 0)
            return n.last_flush = -1, un;
          r = 0;
        }
        n.gzindex < n.gzhead.name.length ? s = n.gzhead.name.charCodeAt(n.gzindex++) & 255 : s = 0, tt(n, s);
      } while (s !== 0);
      n.gzhead.hcrc && n.pending > r && (t.adler = en(t.adler, n.pending_buf, n.pending - r, r)), n.gzindex = 0;
    }
    n.status = BO;
  }
  if (n.status === BO) {
    if (n.gzhead.comment) {
      let r = n.pending, s;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > r && (t.adler = en(t.adler, n.pending_buf, n.pending - r, r)), mi(t), n.pending !== 0)
            return n.last_flush = -1, un;
          r = 0;
        }
        n.gzindex < n.gzhead.comment.length ? s = n.gzhead.comment.charCodeAt(n.gzindex++) & 255 : s = 0, tt(n, s);
      } while (s !== 0);
      n.gzhead.hcrc && n.pending > r && (t.adler = en(t.adler, n.pending_buf, n.pending - r, r));
    }
    n.status = QO;
  }
  if (n.status === QO) {
    if (n.gzhead.hcrc) {
      if (n.pending + 2 > n.pending_buf_size && (mi(t), n.pending !== 0))
        return n.last_flush = -1, un;
      tt(n, t.adler & 255), tt(n, t.adler >> 8 & 255), t.adler = 0;
    }
    if (n.status = la, mi(t), n.pending !== 0)
      return n.last_flush = -1, un;
  }
  if (t.avail_in !== 0 || n.lookahead !== 0 || e !== _o && n.status !== Yc) {
    let r = n.level === 0 ? jR(n, e) : n.strategy === df ? Yde(n, e) : n.strategy === Rde ? jde(n, e) : Gc[n.level].func(n, e);
    if ((r === Pa || r === kc) && (n.status = Yc), r === Ln || r === Pa)
      return t.avail_out === 0 && (n.last_flush = -1), un;
    if (r === Sc && (e === Cde ? Ede(n) : e !== Xk && (NO(n, 0, 0, !1), e === Ade && (Js(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), mi(t), t.avail_out === 0))
      return n.last_flush = -1, un;
  }
  return e !== Ri ? un : n.wrap <= 0 ? jk : (n.wrap === 2 ? (tt(n, t.adler & 255), tt(n, t.adler >> 8 & 255), tt(n, t.adler >> 16 & 255), tt(n, t.adler >> 24 & 255), tt(n, t.total_in & 255), tt(n, t.total_in >> 8 & 255), tt(n, t.total_in >> 16 & 255), tt(n, t.total_in >> 24 & 255)) : (Nc(n, t.adler >>> 16), Nc(n, t.adler & 65535)), mi(t), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? un : jk);
}, nhe = (t) => {
  if (ah(t))
    return Hr;
  const e = t.state.status;
  return t.state = null, e === la ? ca(t, Tde) : un;
}, ihe = (t, e) => {
  let n = e.length;
  if (ah(t))
    return Hr;
  const i = t.state, r = i.wrap;
  if (r === 2 || r === 1 && i.status !== ec || i.lookahead)
    return Hr;
  if (r === 1 && (t.adler = pd(t.adler, e, n, 0)), i.wrap = 0, n >= i.w_size) {
    r === 0 && (Js(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
    let l = new Uint8Array(i.w_size);
    l.set(e.subarray(n - i.w_size, n), 0), e = l, n = i.w_size;
  }
  const s = t.avail_in, o = t.next_in, a = t.input;
  for (t.avail_in = n, t.next_in = 0, t.input = e, tc(i); i.lookahead >= Ze; ) {
    let l = i.strstart, c = i.lookahead - (Ze - 1);
    do
      i.ins_h = vo(i, i.ins_h, i.window[l + Ze - 1]), i.prev[l & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = l, l++;
    while (--c);
    i.strstart = l, i.lookahead = Ze - 1, tc(i);
  }
  return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = Ze - 1, i.match_available = 0, t.next_in = o, t.input = a, t.avail_in = s, i.wrap = r, un;
};
var rhe = ehe, she = KR, ohe = GR, ahe = YR, lhe = Jde, che = the, uhe = nhe, dhe = ihe, hhe = "pako deflate (from Nodeca project)", wu = {
  deflateInit: rhe,
  deflateInit2: she,
  deflateReset: ohe,
  deflateResetKeep: ahe,
  deflateSetHeader: lhe,
  deflate: che,
  deflateEnd: uhe,
  deflateSetDictionary: dhe,
  deflateInfo: hhe
};
const fhe = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var phe = function(t) {
  const e = Array.prototype.slice.call(arguments, 1);
  for (; e.length; ) {
    const n = e.shift();
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be non-object");
      for (const i in n)
        fhe(n, i) && (t[i] = n[i]);
    }
  }
  return t;
}, mhe = (t) => {
  let e = 0;
  for (let i = 0, r = t.length; i < r; i++)
    e += t[i].length;
  const n = new Uint8Array(e);
  for (let i = 0, r = 0, s = t.length; i < s; i++) {
    let o = t[i];
    n.set(o, r), r += o.length;
  }
  return n;
}, H0 = {
  assign: phe,
  flattenChunks: mhe
};
let JR = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  JR = !1;
}
const md = new Uint8Array(256);
for (let t = 0; t < 256; t++)
  md[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
md[254] = md[254] = 1;
var ghe = (t) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(t);
  let e, n, i, r, s, o = t.length, a = 0;
  for (r = 0; r < o; r++)
    n = t.charCodeAt(r), (n & 64512) === 55296 && r + 1 < o && (i = t.charCodeAt(r + 1), (i & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (i - 56320), r++)), a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
  for (e = new Uint8Array(a), s = 0, r = 0; s < a; r++)
    n = t.charCodeAt(r), (n & 64512) === 55296 && r + 1 < o && (i = t.charCodeAt(r + 1), (i & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (i - 56320), r++)), n < 128 ? e[s++] = n : n < 2048 ? (e[s++] = 192 | n >>> 6, e[s++] = 128 | n & 63) : n < 65536 ? (e[s++] = 224 | n >>> 12, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | n & 63) : (e[s++] = 240 | n >>> 18, e[s++] = 128 | n >>> 12 & 63, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | n & 63);
  return e;
};
const bhe = (t, e) => {
  if (e < 65534 && t.subarray && JR)
    return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
  let n = "";
  for (let i = 0; i < e; i++)
    n += String.fromCharCode(t[i]);
  return n;
};
var Ohe = (t, e) => {
  const n = e || t.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(t.subarray(0, e));
  let i, r;
  const s = new Array(n * 2);
  for (r = 0, i = 0; i < n; ) {
    let o = t[i++];
    if (o < 128) {
      s[r++] = o;
      continue;
    }
    let a = md[o];
    if (a > 4) {
      s[r++] = 65533, i += a - 1;
      continue;
    }
    for (o &= a === 2 ? 31 : a === 3 ? 15 : 7; a > 1 && i < n; )
      o = o << 6 | t[i++] & 63, a--;
    if (a > 1) {
      s[r++] = 65533;
      continue;
    }
    o < 65536 ? s[r++] = o : (o -= 65536, s[r++] = 55296 | o >> 10 & 1023, s[r++] = 56320 | o & 1023);
  }
  return bhe(s, r);
}, yhe = (t, e) => {
  e = e || t.length, e > t.length && (e = t.length);
  let n = e - 1;
  for (; n >= 0 && (t[n] & 192) === 128; )
    n--;
  return n < 0 || n === 0 ? e : n + md[t[n]] > e ? n : e;
}, gd = {
  string2buf: ghe,
  buf2string: Ohe,
  utf8border: yhe
};
function _he() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var e4 = _he;
const t4 = Object.prototype.toString, {
  Z_NO_FLUSH: vhe,
  Z_SYNC_FLUSH: xhe,
  Z_FULL_FLUSH: whe,
  Z_FINISH: She,
  Z_OK: Sm,
  Z_STREAM_END: khe,
  Z_DEFAULT_COMPRESSION: Ehe,
  Z_DEFAULT_STRATEGY: Che,
  Z_DEFLATED: Ahe
} = qa;
function lh(t) {
  this.options = H0.assign({
    level: Ehe,
    method: Ahe,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Che
  }, t || {});
  let e = this.options;
  e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new e4(), this.strm.avail_out = 0;
  let n = wu.deflateInit2(
    this.strm,
    e.level,
    e.method,
    e.windowBits,
    e.memLevel,
    e.strategy
  );
  if (n !== Sm)
    throw new Error(Ma[n]);
  if (e.header && wu.deflateSetHeader(this.strm, e.header), e.dictionary) {
    let i;
    if (typeof e.dictionary == "string" ? i = gd.string2buf(e.dictionary) : t4.call(e.dictionary) === "[object ArrayBuffer]" ? i = new Uint8Array(e.dictionary) : i = e.dictionary, n = wu.deflateSetDictionary(this.strm, i), n !== Sm)
      throw new Error(Ma[n]);
    this._dict_set = !0;
  }
}
lh.prototype.push = function(t, e) {
  const n = this.strm, i = this.options.chunkSize;
  let r, s;
  if (this.ended)
    return !1;
  for (e === ~~e ? s = e : s = e === !0 ? She : vhe, typeof t == "string" ? n.input = gd.string2buf(t) : t4.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    if (n.avail_out === 0 && (n.output = new Uint8Array(i), n.next_out = 0, n.avail_out = i), (s === xhe || s === whe) && n.avail_out <= 6) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (r = wu.deflate(n, s), r === khe)
      return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), r = wu.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === Sm;
    if (n.avail_out === 0) {
      this.onData(n.output);
      continue;
    }
    if (s > 0 && n.next_out > 0) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (n.avail_in === 0) break;
  }
  return !0;
};
lh.prototype.onData = function(t) {
  this.chunks.push(t);
};
lh.prototype.onEnd = function(t) {
  t === Sm && (this.result = H0.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
function p_(t, e) {
  const n = new lh(e);
  if (n.push(t, !0), n.err)
    throw n.msg || Ma[n.err];
  return n.result;
}
function The(t, e) {
  return e = e || {}, e.raw = !0, p_(t, e);
}
function Mhe(t, e) {
  return e = e || {}, e.gzip = !0, p_(t, e);
}
var Phe = lh, Rhe = p_, $he = The, Nhe = Mhe, Dhe = qa, Ihe = {
  Deflate: Phe,
  deflate: Rhe,
  deflateRaw: $he,
  gzip: Nhe,
  constants: Dhe
};
const hf = 16209, Lhe = 16191;
var Bhe = function(e, n) {
  let i, r, s, o, a, l, c, u, d, h, f, p, m, g, b, _, y, O, x, v, w, T, S, $;
  const I = e.state;
  i = e.next_in, S = e.input, r = i + (e.avail_in - 5), s = e.next_out, $ = e.output, o = s - (n - e.avail_out), a = s + (e.avail_out - 257), l = I.dmax, c = I.wsize, u = I.whave, d = I.wnext, h = I.window, f = I.hold, p = I.bits, m = I.lencode, g = I.distcode, b = (1 << I.lenbits) - 1, _ = (1 << I.distbits) - 1;
  e:
    do {
      p < 15 && (f += S[i++] << p, p += 8, f += S[i++] << p, p += 8), y = m[f & b];
      t:
        for (; ; ) {
          if (O = y >>> 24, f >>>= O, p -= O, O = y >>> 16 & 255, O === 0)
            $[s++] = y & 65535;
          else if (O & 16) {
            x = y & 65535, O &= 15, O && (p < O && (f += S[i++] << p, p += 8), x += f & (1 << O) - 1, f >>>= O, p -= O), p < 15 && (f += S[i++] << p, p += 8, f += S[i++] << p, p += 8), y = g[f & _];
            n:
              for (; ; ) {
                if (O = y >>> 24, f >>>= O, p -= O, O = y >>> 16 & 255, O & 16) {
                  if (v = y & 65535, O &= 15, p < O && (f += S[i++] << p, p += 8, p < O && (f += S[i++] << p, p += 8)), v += f & (1 << O) - 1, v > l) {
                    e.msg = "invalid distance too far back", I.mode = hf;
                    break e;
                  }
                  if (f >>>= O, p -= O, O = s - o, v > O) {
                    if (O = v - O, O > u && I.sane) {
                      e.msg = "invalid distance too far back", I.mode = hf;
                      break e;
                    }
                    if (w = 0, T = h, d === 0) {
                      if (w += c - O, O < x) {
                        x -= O;
                        do
                          $[s++] = h[w++];
                        while (--O);
                        w = s - v, T = $;
                      }
                    } else if (d < O) {
                      if (w += c + d - O, O -= d, O < x) {
                        x -= O;
                        do
                          $[s++] = h[w++];
                        while (--O);
                        if (w = 0, d < x) {
                          O = d, x -= O;
                          do
                            $[s++] = h[w++];
                          while (--O);
                          w = s - v, T = $;
                        }
                      }
                    } else if (w += d - O, O < x) {
                      x -= O;
                      do
                        $[s++] = h[w++];
                      while (--O);
                      w = s - v, T = $;
                    }
                    for (; x > 2; )
                      $[s++] = T[w++], $[s++] = T[w++], $[s++] = T[w++], x -= 3;
                    x && ($[s++] = T[w++], x > 1 && ($[s++] = T[w++]));
                  } else {
                    w = s - v;
                    do
                      $[s++] = $[w++], $[s++] = $[w++], $[s++] = $[w++], x -= 3;
                    while (x > 2);
                    x && ($[s++] = $[w++], x > 1 && ($[s++] = $[w++]));
                  }
                } else if (O & 64) {
                  e.msg = "invalid distance code", I.mode = hf;
                  break e;
                } else {
                  y = g[(y & 65535) + (f & (1 << O) - 1)];
                  continue n;
                }
                break;
              }
          } else if (O & 64)
            if (O & 32) {
              I.mode = Lhe;
              break e;
            } else {
              e.msg = "invalid literal/length code", I.mode = hf;
              break e;
            }
          else {
            y = m[(y & 65535) + (f & (1 << O) - 1)];
            continue t;
          }
          break;
        }
    } while (i < r && s < a);
  x = p >> 3, i -= x, p -= x << 3, f &= (1 << p) - 1, e.next_in = i, e.next_out = s, e.avail_in = i < r ? 5 + (r - i) : 5 - (i - r), e.avail_out = s < a ? 257 + (a - s) : 257 - (s - a), I.hold = f, I.bits = p;
};
const ol = 15, Gk = 852, Kk = 592, Jk = 0, w1 = 1, eE = 2, Qhe = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), Fhe = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), zhe = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), Uhe = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), Whe = (t, e, n, i, r, s, o, a) => {
  const l = a.bits;
  let c = 0, u = 0, d = 0, h = 0, f = 0, p = 0, m = 0, g = 0, b = 0, _ = 0, y, O, x, v, w, T = null, S;
  const $ = new Uint16Array(ol + 1), I = new Uint16Array(ol + 1);
  let F = null, V, q, K;
  for (c = 0; c <= ol; c++)
    $[c] = 0;
  for (u = 0; u < i; u++)
    $[e[n + u]]++;
  for (f = l, h = ol; h >= 1 && $[h] === 0; h--)
    ;
  if (f > h && (f = h), h === 0)
    return r[s++] = 1 << 24 | 64 << 16 | 0, r[s++] = 1 << 24 | 64 << 16 | 0, a.bits = 1, 0;
  for (d = 1; d < h && $[d] === 0; d++)
    ;
  for (f < d && (f = d), g = 1, c = 1; c <= ol; c++)
    if (g <<= 1, g -= $[c], g < 0)
      return -1;
  if (g > 0 && (t === Jk || h !== 1))
    return -1;
  for (I[1] = 0, c = 1; c < ol; c++)
    I[c + 1] = I[c] + $[c];
  for (u = 0; u < i; u++)
    e[n + u] !== 0 && (o[I[e[n + u]]++] = u);
  if (t === Jk ? (T = F = o, S = 20) : t === w1 ? (T = Qhe, F = Fhe, S = 257) : (T = zhe, F = Uhe, S = 0), _ = 0, u = 0, c = d, w = s, p = f, m = 0, x = -1, b = 1 << f, v = b - 1, t === w1 && b > Gk || t === eE && b > Kk)
    return 1;
  for (; ; ) {
    V = c - m, o[u] + 1 < S ? (q = 0, K = o[u]) : o[u] >= S ? (q = F[o[u] - S], K = T[o[u] - S]) : (q = 96, K = 0), y = 1 << c - m, O = 1 << p, d = O;
    do
      O -= y, r[w + (_ >> m) + O] = V << 24 | q << 16 | K | 0;
    while (O !== 0);
    for (y = 1 << c - 1; _ & y; )
      y >>= 1;
    if (y !== 0 ? (_ &= y - 1, _ += y) : _ = 0, u++, --$[c] === 0) {
      if (c === h)
        break;
      c = e[n + o[u]];
    }
    if (c > f && (_ & v) !== x) {
      for (m === 0 && (m = f), w += d, p = c - m, g = 1 << p; p + m < h && (g -= $[p + m], !(g <= 0)); )
        p++, g <<= 1;
      if (b += 1 << p, t === w1 && b > Gk || t === eE && b > Kk)
        return 1;
      x = _ & v, r[x] = f << 24 | p << 16 | w - s | 0;
    }
  }
  return _ !== 0 && (r[w + _] = c - m << 24 | 64 << 16 | 0), a.bits = f, 0;
};
var Su = Whe;
const Vhe = 0, n4 = 1, i4 = 2, {
  Z_FINISH: tE,
  Z_BLOCK: Zhe,
  Z_TREES: ff,
  Z_OK: Ra,
  Z_STREAM_END: Hhe,
  Z_NEED_DICT: qhe,
  Z_STREAM_ERROR: ji,
  Z_DATA_ERROR: r4,
  Z_MEM_ERROR: s4,
  Z_BUF_ERROR: Xhe,
  Z_DEFLATED: nE
} = qa, q0 = 16180, iE = 16181, rE = 16182, sE = 16183, oE = 16184, aE = 16185, lE = 16186, cE = 16187, uE = 16188, dE = 16189, km = 16190, us = 16191, S1 = 16192, hE = 16193, k1 = 16194, fE = 16195, pE = 16196, mE = 16197, gE = 16198, pf = 16199, mf = 16200, bE = 16201, OE = 16202, yE = 16203, _E = 16204, vE = 16205, E1 = 16206, xE = 16207, wE = 16208, Tt = 16209, o4 = 16210, a4 = 16211, jhe = 852, Yhe = 592, Ghe = 15, Khe = Ghe, SE = (t) => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);
function Jhe() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Xa = (t) => {
  if (!t)
    return 1;
  const e = t.state;
  return !e || e.strm !== t || e.mode < q0 || e.mode > a4 ? 1 : 0;
}, l4 = (t) => {
  if (Xa(t))
    return ji;
  const e = t.state;
  return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = e.wrap & 1), e.mode = q0, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(jhe), e.distcode = e.distdyn = new Int32Array(Yhe), e.sane = 1, e.back = -1, Ra;
}, c4 = (t) => {
  if (Xa(t))
    return ji;
  const e = t.state;
  return e.wsize = 0, e.whave = 0, e.wnext = 0, l4(t);
}, u4 = (t, e) => {
  let n;
  if (Xa(t))
    return ji;
  const i = t.state;
  return e < 0 ? (n = 0, e = -e) : (n = (e >> 4) + 5, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? ji : (i.window !== null && i.wbits !== e && (i.window = null), i.wrap = n, i.wbits = e, c4(t));
}, d4 = (t, e) => {
  if (!t)
    return ji;
  const n = new Jhe();
  t.state = n, n.strm = t, n.window = null, n.mode = q0;
  const i = u4(t, e);
  return i !== Ra && (t.state = null), i;
}, efe = (t) => d4(t, Khe);
let kE = !0, C1, A1;
const tfe = (t) => {
  if (kE) {
    C1 = new Int32Array(512), A1 = new Int32Array(32);
    let e = 0;
    for (; e < 144; )
      t.lens[e++] = 8;
    for (; e < 256; )
      t.lens[e++] = 9;
    for (; e < 280; )
      t.lens[e++] = 7;
    for (; e < 288; )
      t.lens[e++] = 8;
    for (Su(n4, t.lens, 0, 288, C1, 0, t.work, { bits: 9 }), e = 0; e < 32; )
      t.lens[e++] = 5;
    Su(i4, t.lens, 0, 32, A1, 0, t.work, { bits: 5 }), kE = !1;
  }
  t.lencode = C1, t.lenbits = 9, t.distcode = A1, t.distbits = 5;
}, h4 = (t, e, n, i) => {
  let r;
  const s = t.state;
  return s.window === null && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), i >= s.wsize ? (s.window.set(e.subarray(n - s.wsize, n), 0), s.wnext = 0, s.whave = s.wsize) : (r = s.wsize - s.wnext, r > i && (r = i), s.window.set(e.subarray(n - i, n - i + r), s.wnext), i -= r, i ? (s.window.set(e.subarray(n - i, n), 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += r, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += r))), 0;
}, nfe = (t, e) => {
  let n, i, r, s, o, a, l, c, u, d, h, f, p, m, g = 0, b, _, y, O, x, v, w, T;
  const S = new Uint8Array(4);
  let $, I;
  const F = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (Xa(t) || !t.output || !t.input && t.avail_in !== 0)
    return ji;
  n = t.state, n.mode === us && (n.mode = S1), o = t.next_out, r = t.output, l = t.avail_out, s = t.next_in, i = t.input, a = t.avail_in, c = n.hold, u = n.bits, d = a, h = l, T = Ra;
  e:
    for (; ; )
      switch (n.mode) {
        case q0:
          if (n.wrap === 0) {
            n.mode = S1;
            break;
          }
          for (; u < 16; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          if (n.wrap & 2 && c === 35615) {
            n.wbits === 0 && (n.wbits = 15), n.check = 0, S[0] = c & 255, S[1] = c >>> 8 & 255, n.check = en(n.check, S, 2, 0), c = 0, u = 0, n.mode = iE;
            break;
          }
          if (n.head && (n.head.done = !1), !(n.wrap & 1) || /* check if zlib header allowed */
          (((c & 255) << 8) + (c >> 8)) % 31) {
            t.msg = "incorrect header check", n.mode = Tt;
            break;
          }
          if ((c & 15) !== nE) {
            t.msg = "unknown compression method", n.mode = Tt;
            break;
          }
          if (c >>>= 4, u -= 4, w = (c & 15) + 8, n.wbits === 0 && (n.wbits = w), w > 15 || w > n.wbits) {
            t.msg = "invalid window size", n.mode = Tt;
            break;
          }
          n.dmax = 1 << n.wbits, n.flags = 0, t.adler = n.check = 1, n.mode = c & 512 ? dE : us, c = 0, u = 0;
          break;
        case iE:
          for (; u < 16; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          if (n.flags = c, (n.flags & 255) !== nE) {
            t.msg = "unknown compression method", n.mode = Tt;
            break;
          }
          if (n.flags & 57344) {
            t.msg = "unknown header flags set", n.mode = Tt;
            break;
          }
          n.head && (n.head.text = c >> 8 & 1), n.flags & 512 && n.wrap & 4 && (S[0] = c & 255, S[1] = c >>> 8 & 255, n.check = en(n.check, S, 2, 0)), c = 0, u = 0, n.mode = rE;
        case rE:
          for (; u < 32; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          n.head && (n.head.time = c), n.flags & 512 && n.wrap & 4 && (S[0] = c & 255, S[1] = c >>> 8 & 255, S[2] = c >>> 16 & 255, S[3] = c >>> 24 & 255, n.check = en(n.check, S, 4, 0)), c = 0, u = 0, n.mode = sE;
        case sE:
          for (; u < 16; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          n.head && (n.head.xflags = c & 255, n.head.os = c >> 8), n.flags & 512 && n.wrap & 4 && (S[0] = c & 255, S[1] = c >>> 8 & 255, n.check = en(n.check, S, 2, 0)), c = 0, u = 0, n.mode = oE;
        case oE:
          if (n.flags & 1024) {
            for (; u < 16; ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            n.length = c, n.head && (n.head.extra_len = c), n.flags & 512 && n.wrap & 4 && (S[0] = c & 255, S[1] = c >>> 8 & 255, n.check = en(n.check, S, 2, 0)), c = 0, u = 0;
          } else n.head && (n.head.extra = null);
          n.mode = aE;
        case aE:
          if (n.flags & 1024 && (f = n.length, f > a && (f = a), f && (n.head && (w = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(
            i.subarray(
              s,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              s + f
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            w
          )), n.flags & 512 && n.wrap & 4 && (n.check = en(n.check, i, f, s)), a -= f, s += f, n.length -= f), n.length))
            break e;
          n.length = 0, n.mode = lE;
        case lE:
          if (n.flags & 2048) {
            if (a === 0)
              break e;
            f = 0;
            do
              w = i[s + f++], n.head && w && n.length < 65536 && (n.head.name += String.fromCharCode(w));
            while (w && f < a);
            if (n.flags & 512 && n.wrap & 4 && (n.check = en(n.check, i, f, s)), a -= f, s += f, w)
              break e;
          } else n.head && (n.head.name = null);
          n.length = 0, n.mode = cE;
        case cE:
          if (n.flags & 4096) {
            if (a === 0)
              break e;
            f = 0;
            do
              w = i[s + f++], n.head && w && n.length < 65536 && (n.head.comment += String.fromCharCode(w));
            while (w && f < a);
            if (n.flags & 512 && n.wrap & 4 && (n.check = en(n.check, i, f, s)), a -= f, s += f, w)
              break e;
          } else n.head && (n.head.comment = null);
          n.mode = uE;
        case uE:
          if (n.flags & 512) {
            for (; u < 16; ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            if (n.wrap & 4 && c !== (n.check & 65535)) {
              t.msg = "header crc mismatch", n.mode = Tt;
              break;
            }
            c = 0, u = 0;
          }
          n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = us;
          break;
        case dE:
          for (; u < 32; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          t.adler = n.check = SE(c), c = 0, u = 0, n.mode = km;
        case km:
          if (n.havedict === 0)
            return t.next_out = o, t.avail_out = l, t.next_in = s, t.avail_in = a, n.hold = c, n.bits = u, qhe;
          t.adler = n.check = 1, n.mode = us;
        case us:
          if (e === Zhe || e === ff)
            break e;
        case S1:
          if (n.last) {
            c >>>= u & 7, u -= u & 7, n.mode = E1;
            break;
          }
          for (; u < 3; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          switch (n.last = c & 1, c >>>= 1, u -= 1, c & 3) {
            case 0:
              n.mode = hE;
              break;
            case 1:
              if (tfe(n), n.mode = pf, e === ff) {
                c >>>= 2, u -= 2;
                break e;
              }
              break;
            case 2:
              n.mode = pE;
              break;
            case 3:
              t.msg = "invalid block type", n.mode = Tt;
          }
          c >>>= 2, u -= 2;
          break;
        case hE:
          for (c >>>= u & 7, u -= u & 7; u < 32; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          if ((c & 65535) !== (c >>> 16 ^ 65535)) {
            t.msg = "invalid stored block lengths", n.mode = Tt;
            break;
          }
          if (n.length = c & 65535, c = 0, u = 0, n.mode = k1, e === ff)
            break e;
        case k1:
          n.mode = fE;
        case fE:
          if (f = n.length, f) {
            if (f > a && (f = a), f > l && (f = l), f === 0)
              break e;
            r.set(i.subarray(s, s + f), o), a -= f, s += f, l -= f, o += f, n.length -= f;
            break;
          }
          n.mode = us;
          break;
        case pE:
          for (; u < 14; ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          if (n.nlen = (c & 31) + 257, c >>>= 5, u -= 5, n.ndist = (c & 31) + 1, c >>>= 5, u -= 5, n.ncode = (c & 15) + 4, c >>>= 4, u -= 4, n.nlen > 286 || n.ndist > 30) {
            t.msg = "too many length or distance symbols", n.mode = Tt;
            break;
          }
          n.have = 0, n.mode = mE;
        case mE:
          for (; n.have < n.ncode; ) {
            for (; u < 3; ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            n.lens[F[n.have++]] = c & 7, c >>>= 3, u -= 3;
          }
          for (; n.have < 19; )
            n.lens[F[n.have++]] = 0;
          if (n.lencode = n.lendyn, n.lenbits = 7, $ = { bits: n.lenbits }, T = Su(Vhe, n.lens, 0, 19, n.lencode, 0, n.work, $), n.lenbits = $.bits, T) {
            t.msg = "invalid code lengths set", n.mode = Tt;
            break;
          }
          n.have = 0, n.mode = gE;
        case gE:
          for (; n.have < n.nlen + n.ndist; ) {
            for (; g = n.lencode[c & (1 << n.lenbits) - 1], b = g >>> 24, _ = g >>> 16 & 255, y = g & 65535, !(b <= u); ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            if (y < 16)
              c >>>= b, u -= b, n.lens[n.have++] = y;
            else {
              if (y === 16) {
                for (I = b + 2; u < I; ) {
                  if (a === 0)
                    break e;
                  a--, c += i[s++] << u, u += 8;
                }
                if (c >>>= b, u -= b, n.have === 0) {
                  t.msg = "invalid bit length repeat", n.mode = Tt;
                  break;
                }
                w = n.lens[n.have - 1], f = 3 + (c & 3), c >>>= 2, u -= 2;
              } else if (y === 17) {
                for (I = b + 3; u < I; ) {
                  if (a === 0)
                    break e;
                  a--, c += i[s++] << u, u += 8;
                }
                c >>>= b, u -= b, w = 0, f = 3 + (c & 7), c >>>= 3, u -= 3;
              } else {
                for (I = b + 7; u < I; ) {
                  if (a === 0)
                    break e;
                  a--, c += i[s++] << u, u += 8;
                }
                c >>>= b, u -= b, w = 0, f = 11 + (c & 127), c >>>= 7, u -= 7;
              }
              if (n.have + f > n.nlen + n.ndist) {
                t.msg = "invalid bit length repeat", n.mode = Tt;
                break;
              }
              for (; f--; )
                n.lens[n.have++] = w;
            }
          }
          if (n.mode === Tt)
            break;
          if (n.lens[256] === 0) {
            t.msg = "invalid code -- missing end-of-block", n.mode = Tt;
            break;
          }
          if (n.lenbits = 9, $ = { bits: n.lenbits }, T = Su(n4, n.lens, 0, n.nlen, n.lencode, 0, n.work, $), n.lenbits = $.bits, T) {
            t.msg = "invalid literal/lengths set", n.mode = Tt;
            break;
          }
          if (n.distbits = 6, n.distcode = n.distdyn, $ = { bits: n.distbits }, T = Su(i4, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, $), n.distbits = $.bits, T) {
            t.msg = "invalid distances set", n.mode = Tt;
            break;
          }
          if (n.mode = pf, e === ff)
            break e;
        case pf:
          n.mode = mf;
        case mf:
          if (a >= 6 && l >= 258) {
            t.next_out = o, t.avail_out = l, t.next_in = s, t.avail_in = a, n.hold = c, n.bits = u, Bhe(t, h), o = t.next_out, r = t.output, l = t.avail_out, s = t.next_in, i = t.input, a = t.avail_in, c = n.hold, u = n.bits, n.mode === us && (n.back = -1);
            break;
          }
          for (n.back = 0; g = n.lencode[c & (1 << n.lenbits) - 1], b = g >>> 24, _ = g >>> 16 & 255, y = g & 65535, !(b <= u); ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          if (_ && !(_ & 240)) {
            for (O = b, x = _, v = y; g = n.lencode[v + ((c & (1 << O + x) - 1) >> O)], b = g >>> 24, _ = g >>> 16 & 255, y = g & 65535, !(O + b <= u); ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            c >>>= O, u -= O, n.back += O;
          }
          if (c >>>= b, u -= b, n.back += b, n.length = y, _ === 0) {
            n.mode = vE;
            break;
          }
          if (_ & 32) {
            n.back = -1, n.mode = us;
            break;
          }
          if (_ & 64) {
            t.msg = "invalid literal/length code", n.mode = Tt;
            break;
          }
          n.extra = _ & 15, n.mode = bE;
        case bE:
          if (n.extra) {
            for (I = n.extra; u < I; ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            n.length += c & (1 << n.extra) - 1, c >>>= n.extra, u -= n.extra, n.back += n.extra;
          }
          n.was = n.length, n.mode = OE;
        case OE:
          for (; g = n.distcode[c & (1 << n.distbits) - 1], b = g >>> 24, _ = g >>> 16 & 255, y = g & 65535, !(b <= u); ) {
            if (a === 0)
              break e;
            a--, c += i[s++] << u, u += 8;
          }
          if (!(_ & 240)) {
            for (O = b, x = _, v = y; g = n.distcode[v + ((c & (1 << O + x) - 1) >> O)], b = g >>> 24, _ = g >>> 16 & 255, y = g & 65535, !(O + b <= u); ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            c >>>= O, u -= O, n.back += O;
          }
          if (c >>>= b, u -= b, n.back += b, _ & 64) {
            t.msg = "invalid distance code", n.mode = Tt;
            break;
          }
          n.offset = y, n.extra = _ & 15, n.mode = yE;
        case yE:
          if (n.extra) {
            for (I = n.extra; u < I; ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            n.offset += c & (1 << n.extra) - 1, c >>>= n.extra, u -= n.extra, n.back += n.extra;
          }
          if (n.offset > n.dmax) {
            t.msg = "invalid distance too far back", n.mode = Tt;
            break;
          }
          n.mode = _E;
        case _E:
          if (l === 0)
            break e;
          if (f = h - l, n.offset > f) {
            if (f = n.offset - f, f > n.whave && n.sane) {
              t.msg = "invalid distance too far back", n.mode = Tt;
              break;
            }
            f > n.wnext ? (f -= n.wnext, p = n.wsize - f) : p = n.wnext - f, f > n.length && (f = n.length), m = n.window;
          } else
            m = r, p = o - n.offset, f = n.length;
          f > l && (f = l), l -= f, n.length -= f;
          do
            r[o++] = m[p++];
          while (--f);
          n.length === 0 && (n.mode = mf);
          break;
        case vE:
          if (l === 0)
            break e;
          r[o++] = n.length, l--, n.mode = mf;
          break;
        case E1:
          if (n.wrap) {
            for (; u < 32; ) {
              if (a === 0)
                break e;
              a--, c |= i[s++] << u, u += 8;
            }
            if (h -= l, t.total_out += h, n.total += h, n.wrap & 4 && h && (t.adler = n.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            n.flags ? en(n.check, r, h, o - h) : pd(n.check, r, h, o - h)), h = l, n.wrap & 4 && (n.flags ? c : SE(c)) !== n.check) {
              t.msg = "incorrect data check", n.mode = Tt;
              break;
            }
            c = 0, u = 0;
          }
          n.mode = xE;
        case xE:
          if (n.wrap && n.flags) {
            for (; u < 32; ) {
              if (a === 0)
                break e;
              a--, c += i[s++] << u, u += 8;
            }
            if (n.wrap & 4 && c !== (n.total & 4294967295)) {
              t.msg = "incorrect length check", n.mode = Tt;
              break;
            }
            c = 0, u = 0;
          }
          n.mode = wE;
        case wE:
          T = Hhe;
          break e;
        case Tt:
          T = r4;
          break e;
        case o4:
          return s4;
        case a4:
        default:
          return ji;
      }
  return t.next_out = o, t.avail_out = l, t.next_in = s, t.avail_in = a, n.hold = c, n.bits = u, (n.wsize || h !== t.avail_out && n.mode < Tt && (n.mode < E1 || e !== tE)) && h4(t, t.output, t.next_out, h - t.avail_out), d -= t.avail_in, h -= t.avail_out, t.total_in += d, t.total_out += h, n.total += h, n.wrap & 4 && h && (t.adler = n.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  n.flags ? en(n.check, r, h, t.next_out - h) : pd(n.check, r, h, t.next_out - h)), t.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === us ? 128 : 0) + (n.mode === pf || n.mode === k1 ? 256 : 0), (d === 0 && h === 0 || e === tE) && T === Ra && (T = Xhe), T;
}, ife = (t) => {
  if (Xa(t))
    return ji;
  let e = t.state;
  return e.window && (e.window = null), t.state = null, Ra;
}, rfe = (t, e) => {
  if (Xa(t))
    return ji;
  const n = t.state;
  return n.wrap & 2 ? (n.head = e, e.done = !1, Ra) : ji;
}, sfe = (t, e) => {
  const n = e.length;
  let i, r, s;
  return Xa(t) || (i = t.state, i.wrap !== 0 && i.mode !== km) ? ji : i.mode === km && (r = 1, r = pd(r, e, n, 0), r !== i.check) ? r4 : (s = h4(t, e, n, n), s ? (i.mode = o4, s4) : (i.havedict = 1, Ra));
};
var ofe = c4, afe = u4, lfe = l4, cfe = efe, ufe = d4, dfe = nfe, hfe = ife, ffe = rfe, pfe = sfe, mfe = "pako inflate (from Nodeca project)", bs = {
  inflateReset: ofe,
  inflateReset2: afe,
  inflateResetKeep: lfe,
  inflateInit: cfe,
  inflateInit2: ufe,
  inflate: dfe,
  inflateEnd: hfe,
  inflateGetHeader: ffe,
  inflateSetDictionary: pfe,
  inflateInfo: mfe
};
function gfe() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var bfe = gfe;
const f4 = Object.prototype.toString, {
  Z_NO_FLUSH: Ofe,
  Z_FINISH: yfe,
  Z_OK: bd,
  Z_STREAM_END: T1,
  Z_NEED_DICT: M1,
  Z_STREAM_ERROR: _fe,
  Z_DATA_ERROR: EE,
  Z_MEM_ERROR: vfe
} = qa;
function ch(t) {
  this.options = H0.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, t || {});
  const e = this.options;
  e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(t && t.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15 || (e.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new e4(), this.strm.avail_out = 0;
  let n = bs.inflateInit2(
    this.strm,
    e.windowBits
  );
  if (n !== bd)
    throw new Error(Ma[n]);
  if (this.header = new bfe(), bs.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = gd.string2buf(e.dictionary) : f4.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = bs.inflateSetDictionary(this.strm, e.dictionary), n !== bd)))
    throw new Error(Ma[n]);
}
ch.prototype.push = function(t, e) {
  const n = this.strm, i = this.options.chunkSize, r = this.options.dictionary;
  let s, o, a;
  if (this.ended) return !1;
  for (e === ~~e ? o = e : o = e === !0 ? yfe : Ofe, f4.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    for (n.avail_out === 0 && (n.output = new Uint8Array(i), n.next_out = 0, n.avail_out = i), s = bs.inflate(n, o), s === M1 && r && (s = bs.inflateSetDictionary(n, r), s === bd ? s = bs.inflate(n, o) : s === EE && (s = M1)); n.avail_in > 0 && s === T1 && n.state.wrap > 0 && t[n.next_in] !== 0; )
      bs.inflateReset(n), s = bs.inflate(n, o);
    switch (s) {
      case _fe:
      case EE:
      case M1:
      case vfe:
        return this.onEnd(s), this.ended = !0, !1;
    }
    if (a = n.avail_out, n.next_out && (n.avail_out === 0 || s === T1))
      if (this.options.to === "string") {
        let l = gd.utf8border(n.output, n.next_out), c = n.next_out - l, u = gd.buf2string(n.output, l);
        n.next_out = c, n.avail_out = i - c, c && n.output.set(n.output.subarray(l, l + c), 0), this.onData(u);
      } else
        this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
    if (!(s === bd && a === 0)) {
      if (s === T1)
        return s = bs.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
      if (n.avail_in === 0) break;
    }
  }
  return !0;
};
ch.prototype.onData = function(t) {
  this.chunks.push(t);
};
ch.prototype.onEnd = function(t) {
  t === bd && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = H0.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
function m_(t, e) {
  const n = new ch(e);
  if (n.push(t), n.err) throw n.msg || Ma[n.err];
  return n.result;
}
function xfe(t, e) {
  return e = e || {}, e.raw = !0, m_(t, e);
}
var wfe = ch, Sfe = m_, kfe = xfe, Efe = m_, Cfe = qa, Afe = {
  Inflate: wfe,
  inflate: Sfe,
  inflateRaw: kfe,
  ungzip: Efe,
  constants: Cfe
};
const { Deflate: Tfe, deflate: Mfe, deflateRaw: Pfe, gzip: Rfe } = Ihe, { Inflate: $fe, inflate: Nfe, inflateRaw: Dfe, ungzip: Ife } = Afe;
var Lfe = Tfe, Bfe = Mfe, Qfe = Pfe, Ffe = Rfe, zfe = $fe, Ufe = Nfe, Wfe = Dfe, Vfe = Ife, Zfe = qa, Hfe = {
  Deflate: Lfe,
  deflate: Bfe,
  deflateRaw: Qfe,
  gzip: Ffe,
  Inflate: zfe,
  inflate: Ufe,
  inflateRaw: Wfe,
  ungzip: Vfe,
  constants: Zfe
};
function qfe(t) {
  const e = unescape(encodeURIComponent(t));
  console.log("UTF-8:" + e);
  const n = Hfe.deflateRaw(e, {
    level: 9
  }), i = new Uint16Array(n), r = new TextDecoder("utf-16").decode(i);
  return `https://www.plantuml.com/plantuml/svg/${Xfe(r)}`;
}
function Xfe(t) {
  let e = "";
  for (let n = 0; n < t.length; n += 3)
    n + 2 == t.length ? e += P1(t.charCodeAt(n), t.charCodeAt(n + 1), 0) : n + 1 == t.length ? e += P1(t.charCodeAt(n), 0, 0) : e += P1(
      t.charCodeAt(n),
      t.charCodeAt(n + 1),
      t.charCodeAt(n + 2)
    );
  return e;
}
function P1(t, e, n) {
  const i = t >> 2, r = (t & 3) << 4 | e >> 4, s = (e & 15) << 2 | n >> 6, o = n & 63;
  let a = "";
  return a += gf(i & 63), a += gf(r & 63), a += gf(s & 63), a += gf(o & 63), a;
}
function gf(t) {
  return t < 10 ? String.fromCharCode(48 + t) : (t -= 10, t < 26 ? String.fromCharCode(65 + t) : (t -= 26, t < 26 ? String.fromCharCode(97 + t) : (t -= 26, t == 0 ? "-" : t == 1 ? "_" : "?")));
}
const jfe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, Yfe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M7 20h4c0 1.1-.9 2-2 2s-2-.9-2-2m-2-1h8v-2H5zm11.5-9.5c0 3.82-2.66 5.86-3.77 6.5H5.27c-1.11-.64-3.77-2.68-3.77-6.5C1.5 5.36 4.86 2 9 2s7.5 3.36 7.5 7.5m-2 0C14.5 6.47 12.03 4 9 4S3.5 6.47 3.5 9.5c0 2.47 1.49 3.89 2.35 4.5h6.3c.86-.61 2.35-2.03 2.35-4.5m6.87-2.13L20 8l1.37.63L22 10l.63-1.37L24 8l-1.37-.63L22 6zM19 6l.94-2.06L22 3l-2.06-.94L19 0l-.94 2.06L16 3l2.06.94z"
}, null, -1), Gfe = [
  Yfe
];
function Kfe(t, e) {
  return P(), L("svg", jfe, [...Gfe]);
}
const Jfe = { name: "ic-outline-tips-and-updates", render: Kfe }, epe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, tpe = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M7 14H5v5h5v-2H7zm-2-4h2V7h3V5H5zm12 7h-3v2h5v-5h-2zM14 5v2h3v3h2V5z"
}, null, -1), npe = [
  tpe
];
function ipe(t, e) {
  return P(), L("svg", epe, [...npe]);
}
const rpe = { name: "ic-outline-fullscreen", render: ipe }, spe = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, ope = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"
}, null, -1), ape = [
  ope
];
function lpe(t, e) {
  return P(), L("svg", spe, [...ape]);
}
const cpe = { name: "ic-outline-fullscreen-exit", render: lpe }, p4 = 1024;
let upe = 0, Ii = class {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
};
class De {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = upe++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Mn.match(e)), (n) => {
      let i = e(n);
      return i === void 0 ? null : [this, i];
    };
  }
}
De.closedBy = new De({ deserialize: (t) => t.split(" ") });
De.openedBy = new De({ deserialize: (t) => t.split(" ") });
De.group = new De({ deserialize: (t) => t.split(" ") });
De.isolate = new De({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
De.contextHash = new De({ perNode: !0 });
De.lookAhead = new De({ perNode: !0 });
De.mounted = new De({ perNode: !0 });
class Od {
  constructor(e, n, i) {
    this.tree = e, this.overlay = n, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[De.mounted.id];
  }
}
const dpe = /* @__PURE__ */ Object.create(null);
class Mn {
  /**
  @internal
  */
  constructor(e, n, i, r = 0) {
    this.name = e, this.props = n, this.id = i, this.flags = r;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : dpe, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), r = new Mn(e.name || "", n, e.id, i);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(r)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[s[0].id] = s[1];
        }
    }
    return r;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let n = this.prop(De.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let r of i.split(" "))
        n[r] = e[i];
    return (i) => {
      for (let r = i.prop(De.group), s = -1; s < (r ? r.length : 0); s++) {
        let o = n[s < 0 ? i.name : r[s]];
        if (o)
          return o;
      }
    };
  }
}
Mn.none = new Mn(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class X0 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let n = [];
    for (let i of this.types) {
      let r = null;
      for (let s of e) {
        let o = s(i);
        o && (r || (r = Object.assign({}, i.props)), r[o[0].id] = o[1]);
      }
      n.push(r ? new Mn(i.name, r, i.id, i.flags) : i);
    }
    return new X0(n);
  }
}
const bf = /* @__PURE__ */ new WeakMap(), CE = /* @__PURE__ */ new WeakMap();
var vt;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(vt || (vt = {}));
class ot {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, n, i, r, s) {
    if (this.type = e, this.children = n, this.positions = i, this.length = r, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of s)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Od.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let i of this.children) {
      let r = i.toString();
      r && (n && (n += ","), n += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Em(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, n = 0, i = 0) {
    let r = bf.get(this) || this.topNode, s = new Em(r);
    return s.moveTo(e, n), bf.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Cn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, n = 0) {
    let i = yd(bf.get(this) || this.topNode, e, n, !1);
    return bf.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, n = 0) {
    let i = yd(CE.get(this) || this.topNode, e, n, !0);
    return CE.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, n = 0) {
    return ppe(this, e, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: n, leave: i, from: r = 0, to: s = this.length } = e, o = e.mode || 0, a = (o & vt.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | vt.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= s && l.to >= r && (!a && l.type.isAnonymous || n(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && i && (a || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : O_(Mn.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, i, r) => new ot(this.type, n, i, r, this.propValues), e.makeTree || ((n, i, r) => new ot(Mn.none, n, i, r)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return mpe(e);
  }
}
ot.empty = new ot(Mn.none, [], [], 0);
class g_ {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new g_(this.buffer, this.index);
  }
}
class Co {
  /**
  Create a tree buffer.
  */
  constructor(e, n, i) {
    this.buffer = e, this.length = n, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return Mn.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let n = this.buffer[e], i = this.buffer[e + 3], r = this.set.types[n], s = r.name;
    if (/\W/.test(s) && !r.isError && (s = JSON.stringify(s)), e += 4, i == e)
      return s;
    let o = [];
    for (; e < i; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, n, i, r, s) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != n && !(m4(s, r, o[l + 1], o[l + 2]) && (a = l, i > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, n, i) {
    let r = this.buffer, s = new Uint16Array(n - e), o = 0;
    for (let a = e, l = 0; a < n; ) {
      s[l++] = r[a++], s[l++] = r[a++] - i;
      let c = s[l++] = r[a++] - i;
      s[l++] = r[a++] - e, o = Math.max(o, c);
    }
    return new Co(s, o, this.set);
  }
}
function m4(t, e, n, i) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return i >= e && n < e;
    case 0:
      return n < e && i > e;
    case 1:
      return n <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function yd(t, e, n, i) {
  for (var r; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let o = !i && t instanceof Cn && t.index < 0 ? null : t.parent;
    if (!o)
      return t;
    t = o;
  }
  let s = i ? 0 : vt.IgnoreOverlays;
  if (i)
    for (let o = t, a = o.parent; a; o = a, a = o.parent)
      o instanceof Cn && o.index < 0 && ((r = a.enter(e, n, s)) === null || r === void 0 ? void 0 : r.from) != o.from && (t = a);
  for (; ; ) {
    let o = t.enter(e, n, s);
    if (!o)
      return t;
    t = o;
  }
}
class g4 {
  cursor(e = 0) {
    return new Em(this, e);
  }
  getChild(e, n = null, i = null) {
    let r = AE(this, e, n, i);
    return r.length ? r[0] : null;
  }
  getChildren(e, n = null, i = null) {
    return AE(this, e, n, i);
  }
  resolve(e, n = 0) {
    return yd(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return yd(this, e, n, !0);
  }
  matchContext(e) {
    return zO(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), i = this;
    for (; n; ) {
      let r = n.lastChild;
      if (!r || r.to != n.to)
        break;
      r.type.isError && r.from == r.to ? (i = n, n = r.prevSibling) : n = r;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Cn extends g4 {
  constructor(e, n, i, r) {
    super(), this._tree = e, this.from = n, this.index = i, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, i, r, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = n > 0 ? a.length : -1; e != c; e += n) {
        let u = a[e], d = l[e] + o.from;
        if (m4(r, i, d, d + u.length)) {
          if (u instanceof Co) {
            if (s & vt.ExcludeBuffers)
              continue;
            let h = u.findChild(0, u.buffer.length, n, i - d, r);
            if (h > -1)
              return new Lr(new hpe(o, u, e, d), null, h);
          } else if (s & vt.IncludeAnonymous || !u.type.isAnonymous || b_(u)) {
            let h;
            if (!(s & vt.IgnoreMounts) && (h = Od.get(u)) && !h.overlay)
              return new Cn(h.tree, d, e, o);
            let f = new Cn(u, d, e, o);
            return s & vt.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(n < 0 ? u.children.length - 1 : 0, n, i, r);
          }
        }
      }
      if (s & vt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + n : e = n < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, i = 0) {
    let r;
    if (!(i & vt.IgnoreOverlays) && (r = Od.get(this._tree)) && r.overlay) {
      let s = e - this.from;
      for (let { from: o, to: a } of r.overlay)
        if ((n > 0 ? o <= s : o < s) && (n < 0 ? a >= s : a > s))
          return new Cn(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function AE(t, e, n, i) {
  let r = t.cursor(), s = [];
  if (!r.firstChild())
    return s;
  if (n != null) {
    for (let o = !1; !o; )
      if (o = r.type.is(n), !r.nextSibling())
        return s;
  }
  for (; ; ) {
    if (i != null && r.type.is(i))
      return s;
    if (r.type.is(e) && s.push(r.node), !r.nextSibling())
      return i == null ? s : [];
  }
}
function zO(t, e, n = e.length - 1) {
  for (let i = t.parent; n >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[n] && e[n] != i.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class hpe {
  constructor(e, n, i, r) {
    this.parent = e, this.buffer = n, this.index = i, this.start = r;
  }
}
class Lr extends g4 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, i) {
    super(), this.context = e, this._parent = n, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, n, i) {
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, n - this.context.start, i);
    return s < 0 ? null : new Lr(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, i = 0) {
    if (i & vt.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return s < 0 ? null : new Lr(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Lr(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Lr(this.context, this._parent, e.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: i } = this.context, r = this.index + 4, s = i.buffer[this.index + 3];
    if (s > r) {
      let o = i.buffer[this.index + 1];
      e.push(i.slice(r, s, o)), n.push(0);
    }
    return new ot(this.type, e, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function b4(t) {
  if (!t.length)
    return null;
  let e = 0, n = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > n.from || o.to < n.to) && (n = o, e = s);
  }
  let i = n instanceof Cn && n.index < 0 ? null : n.parent, r = t.slice();
  return i ? r[e] = i : r.splice(e, 1), new fpe(r, n);
}
class fpe {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return b4(this.heads);
  }
}
function ppe(t, e, n) {
  let i = t.resolveInner(e, n), r = null;
  for (let s = i instanceof Cn ? i : i.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (r || (r = [i])).push(o.resolve(e, n)), s = o;
    } else {
      let o = Od.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new Cn(o.tree, o.overlay[0].from + s.from, -1, s);
        (r || (r = [i])).push(yd(a, e, n, !1));
      }
    }
  return r ? b4(r) : i;
}
class Em {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Cn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: i, buffer: r } = this.buffer;
    return this.type = n || r.set.types[r.buffer[e]], this.from = i + r.buffer[e + 1], this.to = i + r.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Cn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, n, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, i, this.mode));
    let { buffer: r } = this.buffer, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, n - this.buffer.start, i);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, n, i = this.mode) {
    return this.buffer ? i & vt.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & vt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & vt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let r = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != r)
        return this.yieldBuf(n.findChild(
          r,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let r = n.buffer[this.index + 3];
      if (r < (i < 0 ? n.buffer.length : n.buffer[this.stack[i] + 3]))
        return this.yieldBuf(r);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, i, { buffer: r } = this;
    if (r) {
      if (e > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (r.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: n, parent: i } = r);
    } else
      ({ index: n, _parent: i } = this._tree);
    for (; i; { index: n, _parent: i } = i)
      if (n > -1)
        for (let s = n + e, o = e < 0 ? -1 : i._tree.children.length; s != o; s += e) {
          let a = i._tree.children[s];
          if (this.mode & vt.IncludeAnonymous || a instanceof Co || !a.type.isAnonymous || b_(a))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, i = 0;
    if (e && e.context == this.buffer)
      e: for (let r = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == r) {
            if (r == this.index)
              return o;
            n = o, i = s + 1;
            break e;
          }
        r = this.stack[--s];
      }
    for (let r = i; r < this.stack.length; r++)
      n = new Lr(this.buffer, n, this.stack[r]);
    return this.bufferNode = new Lr(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, n) {
    for (let i = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; r && n && n(this), r = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, r = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return zO(this.node, e);
    let { buffer: n } = this.buffer, { types: i } = n.set;
    for (let r = e.length - 1, s = this.stack.length - 1; r >= 0; s--) {
      if (s < 0)
        return zO(this.node, e, r);
      let o = i[n.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[r] && e[r] != o.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}
function b_(t) {
  return t.children.some((e) => e instanceof Co || !e.type.isAnonymous || b_(e));
}
function mpe(t) {
  var e;
  let { buffer: n, nodeSet: i, maxBufferLength: r = p4, reused: s = [], minRepeatType: o = i.types.length } = t, a = Array.isArray(n) ? new g_(n, n.length) : n, l = i.types, c = 0, u = 0;
  function d(x, v, w, T, S, $) {
    let { id: I, start: F, end: V, size: q } = a, K = u;
    for (; q < 0; )
      if (a.next(), q == -1) {
        let X = s[I];
        w.push(X), T.push(F - x);
        return;
      } else if (q == -3) {
        c = I;
        return;
      } else if (q == -4) {
        u = I;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${q}`);
    let ie = l[I], k, N, W = F - x;
    if (V - F <= r && (N = g(a.pos - v, S))) {
      let X = new Uint16Array(N.size - N.skip), ee = a.pos - N.size, re = X.length;
      for (; a.pos > ee; )
        re = b(N.start, X, re);
      k = new Co(X, V - N.start, i), W = N.start - x;
    } else {
      let X = a.pos - q;
      a.next();
      let ee = [], re = [], xe = I >= o ? I : -1, $e = 0, be = V;
      for (; a.pos > X; )
        xe >= 0 && a.id == xe && a.size >= 0 ? (a.end <= be - r && (p(ee, re, F, $e, a.end, be, xe, K), $e = ee.length, be = a.end), a.next()) : $ > 2500 ? h(F, X, ee, re) : d(F, X, ee, re, xe, $ + 1);
      if (xe >= 0 && $e > 0 && $e < ee.length && p(ee, re, F, $e, F, be, xe, K), ee.reverse(), re.reverse(), xe > -1 && $e > 0) {
        let we = f(ie);
        k = O_(ie, ee, re, 0, ee.length, 0, V - F, we, we);
      } else
        k = m(ie, ee, re, V - F, K - V);
    }
    w.push(k), T.push(W);
  }
  function h(x, v, w, T) {
    let S = [], $ = 0, I = -1;
    for (; a.pos > v; ) {
      let { id: F, start: V, end: q, size: K } = a;
      if (K > 4)
        a.next();
      else {
        if (I > -1 && V < I)
          break;
        I < 0 && (I = q - r), S.push(F, V, q), $++, a.next();
      }
    }
    if ($) {
      let F = new Uint16Array($ * 4), V = S[S.length - 2];
      for (let q = S.length - 3, K = 0; q >= 0; q -= 3)
        F[K++] = S[q], F[K++] = S[q + 1] - V, F[K++] = S[q + 2] - V, F[K++] = K;
      w.push(new Co(F, S[2] - V, i)), T.push(V - x);
    }
  }
  function f(x) {
    return (v, w, T) => {
      let S = 0, $ = v.length - 1, I, F;
      if ($ >= 0 && (I = v[$]) instanceof ot) {
        if (!$ && I.type == x && I.length == T)
          return I;
        (F = I.prop(De.lookAhead)) && (S = w[$] + I.length + F);
      }
      return m(x, v, w, T, S);
    };
  }
  function p(x, v, w, T, S, $, I, F) {
    let V = [], q = [];
    for (; x.length > T; )
      V.push(x.pop()), q.push(v.pop() + w - S);
    x.push(m(i.types[I], V, q, $ - S, F - $)), v.push(S - w);
  }
  function m(x, v, w, T, S = 0, $) {
    if (c) {
      let I = [De.contextHash, c];
      $ = $ ? [I].concat($) : [I];
    }
    if (S > 25) {
      let I = [De.lookAhead, S];
      $ = $ ? [I].concat($) : [I];
    }
    return new ot(x, v, w, T, $);
  }
  function g(x, v) {
    let w = a.fork(), T = 0, S = 0, $ = 0, I = w.end - r, F = { size: 0, start: 0, skip: 0 };
    e: for (let V = w.pos - x; w.pos > V; ) {
      let q = w.size;
      if (w.id == v && q >= 0) {
        F.size = T, F.start = S, F.skip = $, $ += 4, T += 4, w.next();
        continue;
      }
      let K = w.pos - q;
      if (q < 0 || K < V || w.start < I)
        break;
      let ie = w.id >= o ? 4 : 0, k = w.start;
      for (w.next(); w.pos > K; ) {
        if (w.size < 0)
          if (w.size == -3)
            ie += 4;
          else
            break e;
        else w.id >= o && (ie += 4);
        w.next();
      }
      S = k, T += q, $ += ie;
    }
    return (v < 0 || T == x) && (F.size = T, F.start = S, F.skip = $), F.size > 4 ? F : void 0;
  }
  function b(x, v, w) {
    let { id: T, start: S, end: $, size: I } = a;
    if (a.next(), I >= 0 && T < o) {
      let F = w;
      if (I > 4) {
        let V = a.pos - (I - 4);
        for (; a.pos > V; )
          w = b(x, v, w);
      }
      v[--w] = F, v[--w] = $ - x, v[--w] = S - x, v[--w] = T;
    } else I == -3 ? c = T : I == -4 && (u = T);
    return w;
  }
  let _ = [], y = [];
  for (; a.pos > 0; )
    d(t.start || 0, t.bufferStart || 0, _, y, -1, 0);
  let O = (e = t.length) !== null && e !== void 0 ? e : _.length ? y[0] + _[0].length : 0;
  return new ot(l[t.topID], _.reverse(), y.reverse(), O);
}
const TE = /* @__PURE__ */ new WeakMap();
function ep(t, e) {
  if (!t.isAnonymous || e instanceof Co || e.type != t)
    return 1;
  let n = TE.get(e);
  if (n == null) {
    n = 1;
    for (let i of e.children) {
      if (i.type != t || !(i instanceof ot)) {
        n = 1;
        break;
      }
      n += ep(t, i);
    }
    TE.set(e, n);
  }
  return n;
}
function O_(t, e, n, i, r, s, o, a, l) {
  let c = 0;
  for (let p = i; p < r; p++)
    c += ep(t, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], h = [];
  function f(p, m, g, b, _) {
    for (let y = g; y < b; ) {
      let O = y, x = m[y], v = ep(t, p[y]);
      for (y++; y < b; y++) {
        let w = ep(t, p[y]);
        if (v + w >= u)
          break;
        v += w;
      }
      if (y == O + 1) {
        if (v > u) {
          let w = p[O];
          f(w.children, w.positions, 0, w.children.length, m[O] + _);
          continue;
        }
        d.push(p[O]);
      } else {
        let w = m[y - 1] + p[y - 1].length - x;
        d.push(O_(t, p, m, O, y, x, w, null, l));
      }
      h.push(x + _ - s);
    }
  }
  return f(e, n, i, r, 0), (a || l)(d, h, o);
}
class O4 {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, n, i) {
    let r = this.map.get(e);
    r || this.map.set(e, r = /* @__PURE__ */ new Map()), r.set(n, i);
  }
  getBuffer(e, n) {
    let i = this.map.get(e);
    return i && i.get(n);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, n) {
    e instanceof Lr ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof Cn && this.map.set(e.tree, n);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Lr ? this.getBuffer(e.context.buffer, e.index) : e instanceof Cn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Es {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, n, i, r, s = !1, o = !1) {
    this.from = e, this.to = n, this.tree = i, this.offset = r, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, n = [], i = !1) {
    let r = [new Es(0, e.length, e, 0, !1, i)];
    for (let s of n)
      s.to > e.length && r.push(s);
    return r;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, n, i = 128) {
    if (!n.length)
      return e;
    let r = [], s = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < n.length ? n[a] : null, d = u ? u.fromA : 1e9;
      if (d - l >= i)
        for (; o && o.from < d; ) {
          let h = o;
          if (l >= h.from || d <= h.to || c) {
            let f = Math.max(h.from, l) - c, p = Math.min(h.to, d) - c;
            h = f >= p ? null : new Es(f, p, h.tree, h.offset + c, a > 0, !!u);
          }
          if (h && r.push(h), o.to > d)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return r;
  }
}
class y_ {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, n, i) {
    return typeof e == "string" && (e = new gpe(e)), i = i ? i.length ? i.map((r) => new Ii(r.from, r.to)) : [new Ii(0, 0)] : [new Ii(0, e.length)], this.createParse(e, n || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, n, i) {
    let r = this.startParse(e, n, i);
    for (; ; ) {
      let s = r.advance();
      if (s)
        return s;
    }
  }
}
class gpe {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
function bpe(t) {
  return (e, n, i, r) => new ype(e, t, n, i, r);
}
class ME {
  constructor(e, n, i, r, s) {
    this.parser = e, this.parse = n, this.overlay = i, this.target = r, this.from = s;
  }
}
function PE(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class Ope {
  constructor(e, n, i, r, s, o, a) {
    this.parser = e, this.predicate = n, this.mounts = i, this.index = r, this.start = s, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const UO = new De({ perNode: !0 });
class ype {
  constructor(e, n, i, r, s) {
    this.nest = n, this.input = i, this.fragments = r, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let r of this.inner)
          r.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new ot(i.type, i.children, i.positions, i.length, i.propValues.concat([[UO, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], n = e.parse.advance();
    if (n) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[De.mounted.id] = new Od(n, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++)
      this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let n = this.innerDone; n < this.inner.length; n++)
        this.inner[n].parse.stopAt(e);
  }
  startInner() {
    let e = new xpe(this.fragments), n = null, i = null, r = new Em(new Cn(this.baseTree, this.ranges[0].from, 0, null), vt.IncludeAnonymous | vt.IgnoreMounts);
    e: for (let s, o; ; ) {
      let a = !0, l;
      if (this.stoppedAt != null && r.from >= this.stoppedAt)
        a = !1;
      else if (e.hasNode(r)) {
        if (n) {
          let c = n.mounts.find((u) => u.frag.from <= r.from && u.frag.to >= r.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let d = u.from + c.pos, h = u.to + c.pos;
              d >= r.from && h <= r.to && !n.ranges.some((f) => f.from < h && f.to > d) && n.ranges.push({ from: d, to: h });
            }
        }
        a = !1;
      } else if (i && (o = _pe(i.ranges, r.from, r.to)))
        a = o != 2;
      else if (!r.type.isAnonymous && (s = this.nest(r, this.input)) && (r.from < r.to || !s.overlay)) {
        r.tree || vpe(r);
        let c = e.findMounts(r.from, s.parser);
        if (typeof s.overlay == "function")
          n = new Ope(s.parser, s.overlay, c, this.inner.length, r.from, r.tree, n);
        else {
          let u = NE(this.ranges, s.overlay || (r.from < r.to ? [new Ii(r.from, r.to)] : []));
          u.length && PE(u), (u.length || !s.overlay) && this.inner.push(new ME(s.parser, u.length ? s.parser.startParse(this.input, DE(c, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((d) => new Ii(d.from - r.from, d.to - r.from)) : null, r.tree, u.length ? u[0].from : r.from)), s.overlay ? u.length && (i = { ranges: u, depth: 0, prev: i }) : a = !1;
        }
      } else n && (l = n.predicate(r)) && (l === !0 && (l = new Ii(r.from, r.to)), l.from < l.to && n.ranges.push(l));
      if (a && r.firstChild())
        n && n.depth++, i && i.depth++;
      else
        for (; !r.nextSibling(); ) {
          if (!r.parent())
            break e;
          if (n && !--n.depth) {
            let c = NE(this.ranges, n.ranges);
            c.length && (PE(c), this.inner.splice(n.index, 0, new ME(n.parser, n.parser.startParse(this.input, DE(n.mounts, c), c), n.ranges.map((u) => new Ii(u.from - n.start, u.to - n.start)), n.target, c[0].from))), n = n.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}
function _pe(t, e, n) {
  for (let i of t) {
    if (i.from >= n)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= n ? 2 : 1;
  }
  return 0;
}
function RE(t, e, n, i, r, s) {
  if (e < n) {
    let o = t.buffer[e + 1];
    i.push(t.slice(e, n, o)), r.push(o - s);
  }
}
function vpe(t) {
  let { node: e } = t, n = [], i = e.context.buffer;
  do
    n.push(t.index), t.parent();
  while (!t.tree);
  let r = t.tree, s = r.children.indexOf(i), o = r.children[s], a = o.buffer, l = [s];
  function c(u, d, h, f, p, m) {
    let g = n[m], b = [], _ = [];
    RE(o, u, g, b, _, f);
    let y = a[g + 1], O = a[g + 2];
    l.push(b.length);
    let x = m ? c(g + 4, a[g + 3], o.set.types[a[g]], y, O - y, m - 1) : e.toTree();
    return b.push(x), _.push(y - f), RE(o, a[g + 3], d, b, _, f), new ot(h, b, _, p);
  }
  r.children[s] = c(0, a.length, Mn.none, 0, o.length, n.length - 1);
  for (let u of l) {
    let d = t.tree.children[u], h = t.tree.positions[u];
    t.yield(new Cn(d, h + t.from, u, t._tree));
  }
}
class $E {
  constructor(e, n) {
    this.offset = n, this.done = !1, this.cursor = e.cursor(vt.IncludeAnonymous | vt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: n } = this, i = e - this.offset;
    for (; !this.done && n.from < i; )
      n.to >= e && n.enter(i, 1, vt.IgnoreOverlays | vt.ExcludeBuffers) || n.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let n = this.cursor.tree; ; ) {
        if (n == e.tree)
          return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof ot)
          n = n.children[0];
        else
          break;
      }
    return !1;
  }
}
let xpe = class {
  constructor(e) {
    var n;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (n = i.tree.prop(UO)) !== null && n !== void 0 ? n : i.to, this.inner = new $E(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let n = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = n.tree.prop(UO)) !== null && e !== void 0 ? e : n.to, this.inner = new $E(n.tree, -n.offset);
    }
  }
  findMounts(e, n) {
    var i;
    let r = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (i = s.tree) === null || i === void 0 ? void 0 : i.prop(De.mounted);
        if (o && o.parser == n)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= s.to)
              break;
            l.tree == this.curFrag.tree && r.push({
              frag: l,
              pos: s.from - l.offset,
              mount: o
            });
          }
      }
    }
    return r;
  }
};
function NE(t, e) {
  let n = null, i = e;
  for (let r = 1, s = 0; r < t.length; r++) {
    let o = t[r - 1].to, a = t[r].from;
    for (; s < i.length; s++) {
      let l = i[s];
      if (l.from >= a)
        break;
      l.to <= o || (n || (i = n = e.slice()), l.from < o ? (n[s] = new Ii(l.from, o), l.to > a && n.splice(s + 1, 0, new Ii(a, l.to))) : l.to > a ? n[s--] = new Ii(a, l.to) : n.splice(s--, 1));
    }
  }
  return i;
}
function wpe(t, e, n, i) {
  let r = 0, s = 0, o = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let u = r == t.length ? 1e9 : o ? t[r].to : t[r].from, d = s == e.length ? 1e9 : a ? e[s].to : e[s].from;
    if (o != a) {
      let h = Math.max(l, n), f = Math.min(u, d, i);
      h < f && c.push(new Ii(h, f));
    }
    if (l = Math.min(u, d), l == 1e9)
      break;
    u == l && (o ? (o = !1, r++) : o = !0), d == l && (a ? (a = !1, s++) : a = !0);
  }
  return c;
}
function DE(t, e) {
  let n = [];
  for (let { pos: i, mount: r, frag: s } of t) {
    let o = i + (r.overlay ? r.overlay[0].from : 0), a = o + r.tree.length, l = Math.max(s.from, o), c = Math.min(s.to, a);
    if (r.overlay) {
      let u = r.overlay.map((h) => new Ii(h.from + i, h.to + i)), d = wpe(e, u, l, c);
      for (let h = 0, f = l; ; h++) {
        let p = h == d.length, m = p ? c : d[h].from;
        if (m > f && n.push(new Es(f, m, r.tree, -o, s.from >= f || s.openStart, s.to <= m || s.openEnd)), p)
          break;
        f = d[h].to;
      }
    } else
      n.push(new Es(l, c, r.tree, -o, s.from >= o || s.openStart, s.to <= a || s.openEnd));
  }
  return n;
}
var IE = { ALLUSERSPROFILE: "C:\\ProgramData", APPCODE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\appcode.vmoptions", APPDATA: "C:\\Users\\51923\\AppData\\Roaming", "asl.log": "Destination=file", CATALINA_HOME: "D:\\Program Files (x86)\\apache-tomcat-9.0.84-windows-x64\\apache-tomcat-9.0.84", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133657579525662721", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_3964_AJVANIKVVIFJLRUS", CLASSPATH: ".;D:\\Program Files\\Java\\jdk-17\\lib\\dt.jar;D:\\Program Files\\Java\\jdk-17\\lib\\tools.jar", CLION_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\clion.vmoptions", COLOR: "1", COLORTERM: "truecolor", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "INSPIRON5593", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DATAGRIP_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\datagrip.vmoptions", DATASPELL_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\dataspell.vmoptions", DEVECOSTUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\devecostudio.vmoptions", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GATEWAY_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\gateway.vmoptions", GIT_ASKPASS: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", GOLAND_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\goland.vmoptions", HOME: "C:\\Users\\51923", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\51923", IDEA_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\idea.vmoptions", INIT_CWD: "D:\\editor", "IntelliJ IDEA": "E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;", JAVA_HOME: "D:\\Program Files\\Java\\jdk-17", JETBRAINSCLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrainsclient.vmoptions", JETBRAINS_CLIENT_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\jetbrains_client.vmoptions", LANG: "zh_CN.UTF-8", LOCALAPPDATA: "C:\\Users\\51923\\AppData\\Local", LOGONSERVER: "\\\\INSPIRON5593", Maven_Home: "D:\\apache-maven-3.9.5", MAVEN_OPTS: "-Xms128m -Xmx512m", NODE: "E:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_PATH: "D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\bin\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules\\vite\\node_modules;D:\\editor\\node_modules\\.pnpm\\vite@5.3.5_sass@1.77.8\\node_modules;D:\\editor\\node_modules\\.pnpm\\node_modules", npm_command: "run-script", npm_config_cache: "C:\\Users\\51923\\AppData\\Local\\npm-cache", npm_config_chromedriver_cdnurl: "https://npm.taobao.org/mirrors/chromedriver/", npm_config_electron_builder_binaries_mirror: "https://npm.taobao.org/mirrors/electron-builder-binaries/", npm_config_electron_mirror: "https://npm.taobao.org/mirrors/electron/", npm_config_fetch_retry_maxtimeout: "120000", npm_config_fetch_retry_mintimeout: "20000", npm_config_globalconfig: "E:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "E:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\51923\\.npm-init.js", npm_config_local_prefix: "D:\\editor", npm_config_node_gyp: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.8.2", npm_config_prefix: "E:\\Program Files\\nodejs", npm_config_registry: "https://registry.npmmirror.com", npm_config_userconfig: "C:\\Users\\51923\\.npmrc", npm_config_user_agent: "npm/10.8.2 node/v18.19.0 win32 x64 workspaces/false", npm_execpath: "E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build --config ./vite.lib.config.ts", npm_node_execpath: "E:\\Program Files\\nodejs\\node.exe", npm_package_json: "D:\\editor\\package.json", npm_package_name: "hf-richtext", npm_package_version: "1.1.0", NUMBER_OF_PROCESSORS: "8", NVM_HOME: "E:\\Program Files (x86)\\nvm", NVM_SYMLINK: "E:\\Program Files\\nodejs", OneDrive: "C:\\Users\\51923\\OneDrive", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", Path: "D:\\editor\\node_modules\\.bin;D:\\node_modules\\.bin;E:\\Program Files (x86)\\nvm\\v18.19.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Common Files\\Oracle\\Java\\javapath;D:\\Program Files\\Java\\jdk-17\\bin;D:\\Program Files\\Java\\jdk-17\\jre\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;E:\\tomcat\\apache-tomcat-8.5.11\\bin;E:\\mysql-5.6\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;D:\\apache-maven-3.9.5\\bin\\;E:\\Program Files\\Git\\cmd;E:\\Program Files\\TortoiseGit\\bin;E:\\Program Files (x86)\\Tencent\\web\\dll;E:\\Program Files\\Redis\\;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;C:\\Program Files\\dotnet\\;C:\\Users\\51923\\AppData\\Local\\Yarn\\bin;D:\\apache-maven-3.9.5\\bin;C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin;%CATALIN A_HOM E%\\bin;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\Scripts\\;C:\\Users\\51923\\AppData\\Local\\Programs\\Python\\Python39\\;E:\\Programs\\Python\\Python38-32\\Scripts\\;E:\\Programs\\Python\\Python38-32\\;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin\\;C:\\Users\\51923\\AppData\\Local\\Microsoft\\WindowsApps;E:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1\\bin;E:\\Programs\\Microsoft VS Code\\bin;C:\\Users\\51923\\AppData\\Roaming\\npm;E:\\Program Files (x86)\\nvm;E:\\Program Files\\nodejs;E:\\Program Files\\JetBrains\\PyCharm 2023.2.1\\bin;E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;C:\\Users\\51923\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\OpenSSL-Win64\\bin;", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.CPL", PHPSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\phpstorm.vmoptions", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 126 Stepping 5, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "7e05", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "D:\\360MoveData\\Users\\51923\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", PyCharm: "E:\\Program Files\\JetBrains\\PyCharm 2022.1.4\\bin;", PYCHARM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\pycharm.vmoptions", RIDER_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rider.vmoptions", RUBYMINE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\rubymine.vmoptions", SESSIONNAME: "Console", STUDIO_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\studio.vmoptions", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\51923\\AppData\\Local\\Temp", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.91.1", TMP: "C:\\Users\\51923\\AppData\\Local\\Temp", USERDOMAIN: "INSPIRON5593", USERDOMAIN_ROAMINGPROFILE: "INSPIRON5593", USERNAME: "51923", USERPROFILE: "C:\\Users\\51923", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "", VSCODE_GIT_ASKPASS_MAIN: "e:\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "E:\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-c773be81e1-sock", VSCODE_INJECTION: "1", WEBIDE_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webide.vmoptions", WEBSTORM_VM_OPTIONS: "E:\\Program Files\\JetBrains\\ja-netfilter-all\\jetbra\\vmoptions\\webstorm.vmoptions", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
class Cm {
  /**
  @internal
  */
  constructor(e, n, i, r, s, o, a, l, c, u = 0, d) {
    this.p = e, this.stack = n, this.state = i, this.reducePos = r, this.pos = s, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = u, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, n, i = 0) {
    let r = e.parser.context;
    return new Cm(e, [], n, i, i, 0, [], 0, r ? new LE(r, r.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var n;
    let i = e >> 19, r = e & 65535, { parser: s } = this.p, o = this.reducePos < this.pos - 25;
    o && this.setLookAhead(this.pos);
    let a = s.dynamicPrecedence(r);
    if (a && (this.score += a), i == 0) {
      this.pushState(s.getGoto(this.state, r, !0), this.reducePos), r < s.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, o ? 8 : 4, !0), this.reduceContext(r, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), c = l ? this.stack[l - 2] : this.p.ranges[0].from, u = this.reducePos - c;
    u >= 2e3 && !(!((n = this.p.parser.nodeSet.types[r]) === null || n === void 0) && n.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = u));
    let d = l ? this.stack[l - 1] : 0, h = this.bufferBase + this.buffer.length - d;
    if (r < s.minRepeatTerm || e & 131072) {
      let f = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(r, c, f, h + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let f = this.stack[l - 3];
      this.state = s.getGoto(f, r, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(r, c);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, n, i, r = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, a = this.buffer.length;
      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {
        if (n == i)
          return;
        if (o.buffer[a - 2] >= n) {
          o.buffer[a - 2] = i;
          return;
        }
      }
    }
    if (!s || this.pos == i)
      this.buffer.push(e, n, i, r);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0) {
        let a = !1;
        for (let l = o; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; o > 0 && this.buffer[o - 2] > i; )
            this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, r > 4 && (r -= 4);
      }
      this.buffer[o] = e, this.buffer[o + 1] = n, this.buffer[o + 2] = i, this.buffer[o + 3] = r;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, n, i, r) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = r, this.shiftContext(n, i), n <= this.p.parser.maxNode && this.buffer.push(n, i, r, 4);
    else {
      let s = e, { parser: o } = this.p;
      (r > this.pos || n <= o.maxNode) && (this.pos = r, o.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(s, i), this.shiftContext(n, i), n <= o.maxNode && this.buffer.push(n, i, r, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, n, i, r) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, i, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, n) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let r = this.pos;
    this.reducePos = this.pos = r + e.length, this.pushState(n, r), this.buffer.push(
      i,
      r,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )
      n -= 4;
    let i = e.buffer.slice(n), r = e.bufferBase + n;
    for (; e && r == e.bufferBase; )
      e = e.parent;
    return new Cm(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, n) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, i ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let n = new Spe(this); ; ) {
      let i = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      n.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let r = [];
      for (let s = 0, o; s < n.length; s += 2)
        (o = n[s + 1]) != this.state && this.p.parser.hasAction(o, e) && r.push(n[s], o);
      if (this.stack.length < 120)
        for (let s = 0; r.length < 8 && s < n.length; s += 2) {
          let o = n[s + 1];
          r.some((a, l) => l & 1 && a == o) || r.push(n[s], o);
        }
      n = r;
    }
    let i = [];
    for (let r = 0; r < n.length && i.length < 4; r += 2) {
      let s = n[r + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(n[r], this.pos), o.reducePos = this.pos, o.score -= 200, i.push(o);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, n = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(n & 65536))
      return !1;
    if (!e.validAction(this.state, n)) {
      let i = n >> 19, r = n & 65535, s = this.stack.length - i * 3;
      if (s < 0 || e.getGoto(this.stack[s], r, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        n = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, n = [], i = (r, s) => {
      if (!n.includes(r))
        return n.push(r), e.allActions(r, (o) => {
          if (!(o & 393216)) if (o & 65536) {
            let a = (o >> 19) - s;
            if (a > 1) {
              let l = o & 65535, c = this.stack.length - a * 3;
              if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                return a << 19 | 65536 | l;
            }
          } else {
            let a = i(o, s + 1);
            if (a != null)
              return a;
          }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != e.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new LE(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class LE {
  constructor(e, n) {
    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;
  }
}
class Spe {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let n = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let r = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = r;
  }
}
class Am {
  constructor(e, n, i) {
    this.stack = e, this.pos = n, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new Am(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Am(this.stack, this.pos, this.index);
  }
}
function Kc(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let n = null;
  for (let i = 0, r = 0; i < t.length; ) {
    let s = 0;
    for (; ; ) {
      let o = t.charCodeAt(i++), a = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, a = !0), s += l, a)
        break;
      s *= 46;
    }
    n ? n[r++] = s : n = new e(s);
  }
  return n;
}
class tp {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const BE = new tp();
class kpe {
  /**
  @internal
  */
  constructor(e, n) {
    this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = BE, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, n) {
    let i = this.range, r = this.rangeIndex, s = this.pos + e;
    for (; s < i.from; ) {
      if (!r)
        return null;
      let o = this.ranges[--r];
      s -= i.from - o.to, i = o;
    }
    for (; n < 0 ? s > i.to : s >= i.to; ) {
      if (r == this.ranges.length - 1)
        return null;
      let o = this.ranges[++r];
      s += o.from - i.to, i = o;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let n of this.ranges)
      if (n.to > e)
        return Math.max(e, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let n = this.chunkOff + e, i, r;
    if (n >= 0 && n < this.chunk.length)
      i = this.pos + e, r = this.chunk.charCodeAt(n);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (i = s, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        r = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, a = this.range;
        for (; a.to <= i; )
          a = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - i)), r = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, n = 0) {
    let i = n ? this.resolveOffset(n, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, n) {
    this.token.value = e, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), n = this.pos + e.length;
      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, n) {
    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = BE, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to)
      return this.input.read(e, n);
    let i = "";
    for (let r of this.ranges) {
      if (r.from >= n)
        break;
      r.to > e && (i += this.input.read(Math.max(r.from, e), Math.min(r.to, n)));
    }
    return i;
  }
}
class Al {
  constructor(e, n) {
    this.data = e, this.id = n;
  }
  token(e, n) {
    let { parser: i } = n.p;
    y4(this.data, e, n, this.id, i.data, i.tokenPrecTable);
  }
}
Al.prototype.contextual = Al.prototype.fallback = Al.prototype.extend = !1;
class Tm {
  constructor(e, n, i) {
    this.precTable = n, this.elseToken = i, this.data = typeof e == "string" ? Kc(e) : e;
  }
  token(e, n) {
    let i = e.pos, r = 0;
    for (; ; ) {
      let s = e.next < 0, o = e.resolveOffset(1, 1);
      if (y4(this.data, e, n, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || r++, o == null)
        break;
      e.reset(o, e.token);
    }
    r && (e.reset(i, e.token), e.acceptToken(this.elseToken, r));
  }
}
Tm.prototype.contextual = Al.prototype.fallback = Al.prototype.extend = !1;
class br {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, n = {}) {
    this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function y4(t, e, n, i, r, s) {
  let o = 0, a = 1 << i, { dialect: l } = n.p.parser;
  e: for (; a & t[o]; ) {
    let c = t[o + 1];
    for (let f = o + 3; f < c; f += 2)
      if ((t[f + 1] & a) > 0) {
        let p = t[f];
        if (l.allows(p) && (e.token.value == -1 || e.token.value == p || Epe(p, e.token.value, r, s))) {
          e.acceptToken(p);
          break;
        }
      }
    let u = e.next, d = 0, h = t[o + 2];
    if (e.next < 0 && h > d && t[c + h * 3 - 3] == 65535) {
      o = t[c + h * 3 - 1];
      continue e;
    }
    for (; d < h; ) {
      let f = d + h >> 1, p = c + f + (f << 1), m = t[p], g = t[p + 1] || 65536;
      if (u < m)
        h = f;
      else if (u >= g)
        d = f + 1;
      else {
        o = t[p + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function QE(t, e, n) {
  for (let i = e, r; (r = t[i]) != 65535; i++)
    if (r == n)
      return i - e;
  return -1;
}
function Epe(t, e, n, i) {
  let r = QE(n, i, e);
  return r < 0 || QE(n, i, t) < r;
}
const di = typeof process < "u" && IE && /\bparse\b/.test(IE.LOG);
let R1 = null;
function FE(t, e, n) {
  let i = t.cursor(vt.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(n < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((n < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            i.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (n < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return n < 0 ? 0 : t.length;
      }
}
class Cpe {
  constructor(e, n) {
    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? FE(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? FE(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let i = this.trees[n], r = this.index[n];
      if (r == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = i.children[r], o = this.start[n] + i.positions[r];
      if (o > e)
        return this.nextStart = o, null;
      if (s instanceof ot) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let a = o + s.length;
          if (a <= this.safeTo) {
            let l = s.prop(De.lookAhead);
            if (!l || a + l < this.fragment.to)
              return s;
          }
        }
        this.index[n]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = o + s.length;
    }
  }
}
class Ape {
  constructor(e, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new tp());
  }
  getActions(e) {
    let n = 0, i = null, { parser: r } = e.p, { tokenizers: s } = r, o = r.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < s.length; c++) {
      if (!(1 << c & o))
        continue;
      let u = s[c], d = this.tokens[c];
      if (!(i && !u.fallback) && ((u.contextual || d.start != e.pos || d.mask != o || d.context != a) && (this.updateCachedToken(d, u, e), d.mask = o, d.context = a), d.lookAhead > d.end + 25 && (l = Math.max(d.lookAhead, l)), d.value != 0)) {
        let h = n;
        if (d.extended > -1 && (n = this.addActions(e, d.extended, d.end, n)), n = this.addActions(e, d.value, d.end, n), !u.extend && (i = d, n > h))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return l && e.setLookAhead(l), !i && e.pos == this.stream.end && (i = new tp(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, n = this.addActions(e, i.value, i.end, n)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let n = new tp(), { pos: i, p: r } = e;
    return n.start = i, n.end = Math.min(i + 1, r.stream.end), n.value = i == r.stream.end ? r.parser.eofTerm : 0, n;
  }
  updateCachedToken(e, n, i) {
    let r = this.stream.clipPos(i.pos);
    if (n.token(this.stream.reset(r, e), i), e.value > -1) {
      let { parser: s } = i.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let a = s.specializers[o](this.stream.read(e.start, e.end), i);
          if (a >= 0 && i.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(r + 1);
  }
  putAction(e, n, i, r) {
    for (let s = 0; s < r; s += 3)
      if (this.actions[s] == e)
        return r;
    return this.actions[r++] = e, this.actions[r++] = n, this.actions[r++] = i, r;
  }
  addActions(e, n, i, r) {
    let { state: s } = e, { parser: o } = e.p, { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(
        s,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = Os(a, c + 2);
          else {
            r == 0 && a[c + 1] == 2 && (r = this.putAction(Os(a, c + 2), n, i, r));
            break;
          }
        a[c] == n && (r = this.putAction(Os(a, c + 1), n, i, r));
      }
    return r;
  }
}
let Tpe = class {
  constructor(e, n, i, r) {
    this.parser = e, this.input = n, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new kpe(n, r), this.tokens = new Ape(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = r[0];
    this.stacks = [Cm.start(this, e.top[0], s)], this.fragments = i.length && this.stream.end - s > e.bufferLength * 4 ? new Cpe(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, n = this.minStackPos, i = this.stacks = [], r, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > n)
          i.push(a);
        else {
          if (this.advanceStack(a, i, e))
            continue;
          {
            r || (r = [], s = []), r.push(a);
            let l = this.tokens.getMainToken(a);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = r && Ppe(r);
      if (o)
        return di && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw di && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && r) {
      let o = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, s, i);
      if (o)
        return di && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((a, l) => l.score - a.score); i.length > o; )
          i.pop();
      i.some((a) => a.reducePos > n) && this.recovering--;
    } else if (i.length > 1) {
      e: for (let o = 0; o < i.length - 1; o++) {
        let a = i[o];
        for (let l = o + 1; l < i.length; l++) {
          let c = i[l];
          if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
            if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
              i.splice(l--, 1);
            else {
              i.splice(o--, 1);
              continue e;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, n, i) {
    let r = e.pos, { parser: s } = this, o = di ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && r > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, u = c ? e.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(r); d; ) {
        let h = this.parser.nodeSet.types[d.type.id] == d.type ? s.getGoto(e.state, d.type.id) : -1;
        if (h > -1 && d.length && (!c || (d.prop(De.contextHash) || 0) == u))
          return e.useNode(d, h), di && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(d.type.id)})`), !0;
        if (!(d instanceof ot) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let f = d.children[0];
        if (f instanceof ot && d.positions[0] == 0)
          d = f;
        else
          break;
      }
    }
    let a = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), di && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let u = l[c++], d = l[c++], h = l[c++], f = c == l.length || !i, p = f ? e : e.split(), m = this.tokens.mainToken;
      if (p.apply(u, d, m ? m.start : p.pos, h), di && console.log(o + this.stackID(p) + ` (via ${u & 65536 ? `reduce of ${s.getName(
        u & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(d)} @ ${r}${p == e ? "" : ", split"})`), f)
        return !0;
      p.pos > r ? n.push(p) : i.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, n) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return zE(e, n), !0;
    }
  }
  runRecovery(e, n, i) {
    let r = null, s = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = n[o << 1], c = n[(o << 1) + 1], u = di ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (s || (s = !0, a.restart(), di && console.log(u + this.stackID(a) + " (restarted)"), this.advanceFully(a, i))))
        continue;
      let d = a.split(), h = u;
      for (let f = 0; d.forceReduce() && f < 10 && (di && console.log(h + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, i)); f++)
        di && (h = this.stackID(d) + " -> ");
      for (let f of a.recoverByInsert(l))
        di && console.log(u + this.stackID(f) + " (via recover-insert)"), this.advanceFully(f, i);
      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), di && console.log(u + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), zE(a, i)) : (!r || r.score < a.score) && (r = a);
    }
    return r;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), ot.build({
      buffer: Am.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let n = (R1 || (R1 = /* @__PURE__ */ new WeakMap())).get(e);
    return n || R1.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;
  }
};
function zE(t, e) {
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (i.pos == t.pos && i.sameState(t)) {
      e[n].score < t.score && (e[n] = t);
      return;
    }
  }
  e.push(t);
}
class Mpe {
  constructor(e, n, i) {
    this.source = e, this.flags = n, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const $1 = (t) => t;
class _4 {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || $1, this.reduce = e.reduce || $1, this.reuse = e.reuse || $1, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class $a extends y_ {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      n.push("");
    let i = Object.keys(e.topRules).map((a) => e.topRules[a][1]), r = [];
    for (let a = 0; a < n.length; a++)
      r.push([]);
    function s(a, l, c) {
      r[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = De[l]);
        for (let c = 1; c < a.length; ) {
          let u = a[c++];
          if (u >= 0)
            s(u, l, a[c++]);
          else {
            let d = a[c + -u];
            for (let h = -u; h > 0; h--)
              s(a[c++], l, d);
            c++;
          }
        }
      }
    this.nodeSet = new X0(n.map((a, l) => Mn.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: r[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = p4;
    let o = Kc(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(UE), this.states = Kc(e.states, Uint32Array), this.data = Kc(e.stateData), this.goto = Kc(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new Al(o, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, n, i) {
    let r = new Tpe(this, e, n, i);
    for (let s of this.wrappers)
      r = s(r, e, n, i);
    return r;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, n, i = !1) {
    let r = this.goto;
    if (n >= r[0])
      return -1;
    for (let s = r[n + 1]; ; ) {
      let o = r[s++], a = o & 1, l = r[s++];
      if (a && i)
        return l;
      for (let c = s + (o >> 1); s < c; s++)
        if (r[s] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, n) {
    let i = this.data;
    for (let r = 0; r < 2; r++)
      for (let s = this.stateSlot(
        e,
        r ? 2 : 1
        /* ParseState.Actions */
      ), o; ; s += 3) {
        if ((o = i[s]) == 65535)
          if (i[s + 1] == 1)
            o = i[s = Os(i, s + 2)];
          else {
            if (i[s + 1] == 2)
              return Os(i, s + 2);
            break;
          }
        if (o == n || o == 0)
          return Os(i, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(e, n) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(e, n) {
    return !!this.allActions(e, (i) => i == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, n) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), r = i ? n(i) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); r == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = Os(this.data, s + 2);
        else
          break;
      r = n(Os(this.data, s + 1));
    }
    return r;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let n = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Os(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let r = this.data[i + 1];
        n.some((s, o) => o & 1 && s == r) || n.push(this.data[i], r);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let n = Object.assign(Object.create($a.prototype), this);
    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = i;
    }
    return e.tokenizers && (n.tokenizers = this.tokenizers.map((i) => {
      let r = e.tokenizers.find((s) => s.from == i);
      return r ? r.to : i;
    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((i, r) => {
      let s = e.specializers.find((a) => a.from == i.external);
      if (!s)
        return i;
      let o = Object.assign(Object.assign({}, i), { external: s.to });
      return n.specializers[r] = UE(o), o;
    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let n = Object.keys(this.dialects), i = n.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = n.indexOf(s);
        o >= 0 && (i[o] = !0);
      }
    let r = null;
    for (let s = 0; s < n.length; s++)
      if (!i[s])
        for (let o = this.dialects[n[s]], a; (a = this.data[o++]) != 65535; )
          (r || (r = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new Mpe(e, i, r);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new $a(e);
  }
}
function Os(t, e) {
  return t[e] | t[e + 1] << 16;
}
function Ppe(t) {
  let e = null;
  for (let n of t) {
    let i = n.p.stoppedAt;
    (n.pos == n.p.stream.end || i != null && n.pos > i) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function UE(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (n, i) => t.external(n, i) << 1 | e;
  }
  return t.get;
}
let Rpe = 0;
class Tr {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.set = e, this.base = n, this.modified = i, this.id = Rpe++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let n = new Tr([], null, []);
    if (n.set.push(n), e)
      for (let i of e.set)
        n.set.push(i);
    return n;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Mm();
    return (n) => n.modified.indexOf(e) > -1 ? n : Mm.get(n.base || n, n.modified.concat(e).sort((i, r) => i.id - r.id));
  }
}
let $pe = 0;
class Mm {
  constructor() {
    this.instances = [], this.id = $pe++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let i = n[0].instances.find((a) => a.base == e && Npe(n, a.modified));
    if (i)
      return i;
    let r = [], s = new Tr(r, e, n);
    for (let a of n)
      a.instances.push(s);
    let o = Dpe(n);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          r.push(Mm.get(a, l));
    return s;
  }
}
function Npe(t, e) {
  return t.length == e.length && t.every((n, i) => n == e[i]);
}
function Dpe(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++)
    for (let i = 0, r = e.length; i < r; i++)
      e.push(e[i].concat(t[n]));
  return e.sort((n, i) => i.length - n.length);
}
function uh(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let i = t[n];
    Array.isArray(i) || (i = [i]);
    for (let r of n.split(" "))
      if (r) {
        let s = [], o = 2, a = r;
        for (let d = 0; ; ) {
          if (a == "..." && d > 0 && d + 3 == r.length) {
            o = 1;
            break;
          }
          let h = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!h)
            throw new RangeError("Invalid path: " + r);
          if (s.push(h[0] == "*" ? "" : h[0][0] == '"' ? JSON.parse(h[0]) : h[0]), d += h[0].length, d == r.length)
            break;
          let f = r[d++];
          if (d == r.length && f == "!") {
            o = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + r);
          a = r.slice(d);
        }
        let l = s.length - 1, c = s[l];
        if (!c)
          throw new RangeError("Invalid path: " + r);
        let u = new Pm(i, o, l > 0 ? s.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return v4.add(e);
}
const v4 = new De();
class Pm {
  constructor(e, n, i, r) {
    this.tags = e, this.mode = n, this.context = i, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Pm.empty = new Pm([], 2, null);
function x4(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      n[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        n[o.id] = s.class;
  let { scope: i, all: r = null } = e || {};
  return {
    style: (s) => {
      let o = r;
      for (let a of s)
        for (let l of a.set) {
          let c = n[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function Ipe(t, e) {
  let n = null;
  for (let i of t) {
    let r = i.style(e);
    r && (n = n ? n + " " + r : r);
  }
  return n;
}
function Lpe(t, e, n, i = 0, r = t.length) {
  let s = new Bpe(i, Array.isArray(e) ? e : [e], n);
  s.highlightRange(t.cursor(), i, r, "", s.highlighters), s.flush(r);
}
class Bpe {
  constructor(e, n, i) {
    this.at = e, this.highlighters = n, this.span = i, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, i, r, s) {
    let { type: o, from: a, to: l } = e;
    if (a >= i || l <= n)
      return;
    o.isTop && (s = this.highlighters.filter((f) => !f.scope || f.scope(o)));
    let c = r, u = Qpe(e) || Pm.empty, d = Ipe(s, u.tags);
    if (d && (c && (c += " "), c += d, u.mode == 1 && (r += (r ? " " : "") + d)), this.startSpan(Math.max(n, a), c), u.opaque)
      return;
    let h = e.tree && e.tree.prop(De.mounted);
    if (h && h.overlay) {
      let f = e.node.enter(h.overlay[0].from + a, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(h.tree.type)), m = e.firstChild();
      for (let g = 0, b = a; ; g++) {
        let _ = g < h.overlay.length ? h.overlay[g] : null, y = _ ? _.from + a : l, O = Math.max(n, b), x = Math.min(i, y);
        if (O < x && m)
          for (; e.from < x && (this.highlightRange(e, O, x, r, s), this.startSpan(Math.min(x, e.to), c), !(e.to >= y || !e.nextSibling())); )
            ;
        if (!_ || y > i)
          break;
        b = _.to + a, b > n && (this.highlightRange(f.cursor(), Math.max(n, _.from + a), Math.min(i, b), "", p), this.startSpan(Math.min(i, b), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      h && (r = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, n, i, r, s), this.startSpan(Math.min(i, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function Qpe(t) {
  let e = t.type.prop(v4);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const se = Tr.define, Of = se(), qs = se(), WE = se(qs), VE = se(qs), Xs = se(), yf = se(Xs), N1 = se(Xs), wr = se(), qo = se(wr), _r = se(), vr = se(), WO = se(), Dc = se(WO), _f = se(), D = {
  /**
  A comment.
  */
  comment: Of,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: se(Of),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: se(Of),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: se(Of),
  /**
  Any kind of identifier.
  */
  name: qs,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: se(qs),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: WE,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: se(WE),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: VE,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: se(VE),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: se(qs),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: se(qs),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: se(qs),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: se(qs),
  /**
  A literal value.
  */
  literal: Xs,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: yf,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: se(yf),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: se(yf),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: se(yf),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: N1,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: se(N1),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: se(N1),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: se(Xs),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: se(Xs),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: se(Xs),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: se(Xs),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: se(Xs),
  /**
  A language keyword.
  */
  keyword: _r,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: se(_r),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: se(_r),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: se(_r),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: se(_r),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: se(_r),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: se(_r),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: se(_r),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: se(_r),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: se(_r),
  /**
  An operator.
  */
  operator: vr,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: se(vr),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: se(vr),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: se(vr),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: se(vr),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: se(vr),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: se(vr),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: se(vr),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: se(vr),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: se(vr),
  /**
  Program or markup punctuation.
  */
  punctuation: WO,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: se(WO),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Dc,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: se(Dc),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: se(Dc),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: se(Dc),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: se(Dc),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: wr,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: qo,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: se(qo),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: se(qo),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: se(qo),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: se(qo),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: se(qo),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: se(qo),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: se(wr),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: se(wr),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: se(wr),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: se(wr),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: se(wr),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: se(wr),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: se(wr),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: se(wr),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: se(),
  /**
  Deleted text.
  */
  deleted: se(),
  /**
  Changed text.
  */
  changed: se(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: se(),
  /**
  Metadata or meta-instruction.
  */
  meta: _f,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: se(_f),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: se(_f),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: se(_f),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tr.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tr.defineModifier()
};
x4([
  { tag: D.link, class: "tok-link" },
  { tag: D.heading, class: "tok-heading" },
  { tag: D.emphasis, class: "tok-emphasis" },
  { tag: D.strong, class: "tok-strong" },
  { tag: D.keyword, class: "tok-keyword" },
  { tag: D.atom, class: "tok-atom" },
  { tag: D.bool, class: "tok-bool" },
  { tag: D.url, class: "tok-url" },
  { tag: D.labelName, class: "tok-labelName" },
  { tag: D.inserted, class: "tok-inserted" },
  { tag: D.deleted, class: "tok-deleted" },
  { tag: D.literal, class: "tok-literal" },
  { tag: D.string, class: "tok-string" },
  { tag: D.number, class: "tok-number" },
  { tag: [D.regexp, D.escape, D.special(D.string)], class: "tok-string2" },
  { tag: D.variableName, class: "tok-variableName" },
  { tag: D.local(D.variableName), class: "tok-variableName tok-local" },
  { tag: D.definition(D.variableName), class: "tok-variableName tok-definition" },
  { tag: D.special(D.variableName), class: "tok-variableName2" },
  { tag: D.definition(D.propertyName), class: "tok-propertyName tok-definition" },
  { tag: D.typeName, class: "tok-typeName" },
  { tag: D.namespace, class: "tok-namespace" },
  { tag: D.className, class: "tok-className" },
  { tag: D.macroName, class: "tok-macroName" },
  { tag: D.propertyName, class: "tok-propertyName" },
  { tag: D.operator, class: "tok-operator" },
  { tag: D.comment, class: "tok-comment" },
  { tag: D.meta, class: "tok-meta" },
  { tag: D.invalid, class: "tok-invalid" },
  { tag: D.punctuation, class: "tok-punctuation" }
]);
const Fpe = 99, ZE = 1, zpe = 100, Upe = 101, HE = 2, w4 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Wpe = 58, Vpe = 40, S4 = 95, Zpe = 91, np = 45, Hpe = 46, qpe = 35, Xpe = 37, jpe = 38, Ype = 92, Gpe = 10;
function _d(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function k4(t) {
  return t >= 48 && t <= 57;
}
const Kpe = new br((t, e) => {
  for (let n = !1, i = 0, r = 0; ; r++) {
    let { next: s } = t;
    if (_d(s) || s == np || s == S4 || n && k4(s))
      !n && (s != np || r > 0) && (n = !0), i === r && s == np && i++, t.advance();
    else if (s == Ype && t.peek(1) != Gpe)
      t.advance(), t.next > -1 && t.advance(), n = !0;
    else {
      n && t.acceptToken(s == Vpe ? zpe : i == 2 && e.canShift(HE) ? HE : Upe);
      break;
    }
  }
}), Jpe = new br((t) => {
  if (w4.includes(t.peek(-1))) {
    let { next: e } = t;
    (_d(e) || e == S4 || e == qpe || e == Hpe || e == Zpe || e == Wpe && _d(t.peek(1)) || e == np || e == jpe) && t.acceptToken(Fpe);
  }
}), eme = new br((t) => {
  if (!w4.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == Xpe && (t.advance(), t.acceptToken(ZE)), _d(e)) {
      do
        t.advance();
      while (_d(t.next) || k4(t.next));
      t.acceptToken(ZE);
    }
  }
}), tme = uh({
  "AtKeyword import charset namespace keyframes media supports": D.definitionKeyword,
  "from to selector": D.keyword,
  NamespaceName: D.namespace,
  KeyframeName: D.labelName,
  KeyframeRangeName: D.operatorKeyword,
  TagName: D.tagName,
  ClassName: D.className,
  PseudoClassName: D.constant(D.className),
  IdName: D.labelName,
  "FeatureName PropertyName": D.propertyName,
  AttributeName: D.attributeName,
  NumberLiteral: D.number,
  KeywordQuery: D.keyword,
  UnaryQueryOp: D.operatorKeyword,
  "CallTag ValueName": D.atom,
  VariableName: D.variableName,
  Callee: D.operatorKeyword,
  Unit: D.unit,
  "UniversalSelector NestingSelector": D.definitionOperator,
  MatchOp: D.compareOperator,
  "ChildOp SiblingOp, LogicOp": D.logicOperator,
  BinOp: D.arithmeticOperator,
  Important: D.modifier,
  Comment: D.blockComment,
  ColorLiteral: D.color,
  "ParenthesizedContent StringLiteral": D.string,
  ":": D.punctuation,
  "PseudoOp #": D.derefOperator,
  "; ,": D.separator,
  "( )": D.paren,
  "[ ]": D.squareBracket,
  "{ }": D.brace
}), nme = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 }, ime = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 }, rme = { __proto__: null, not: 132, only: 132 }, sme = $a.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [tme],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [Jpe, eme, Kpe, 1, 2, 3, 4, new Tm("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (t) => nme[t] || -1 }, { term: 58, get: (t) => ime[t] || -1 }, { term: 101, get: (t) => rme[t] || -1 }],
  tokenPrec: 1200
});
class Ge {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, n, i) {
    [e, n] = nc(this, e, n);
    let r = [];
    return this.decompose(
      0,
      e,
      r,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      r,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      r,
      1
      /* Open.From */
    ), Rr.from(r, this.length - (n - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, n = this.length) {
    [e, n] = nc(this, e, n);
    let i = [];
    return this.decompose(e, n, i, 0), Rr.from(i, n - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let n = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), r = new ku(this), s = new ku(e);
    for (let o = n, a = n; ; ) {
      if (r.next(o), s.next(o), o = 0, r.lineBreak != s.lineBreak || r.done != s.done || r.value != s.value)
        return !1;
      if (a += r.value.length, r.done || a >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new ku(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, n = this.length) {
    return new E4(this, e, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, n) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let r = this.line(e).from;
      i = this.iterRange(r, Math.max(r, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new C4(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Ge.empty : e.length <= 32 ? new Bt(e) : Rr.from(Bt.split(e, []));
  }
}
class Bt extends Ge {
  constructor(e, n = ome(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, i, r) {
    for (let s = 0; ; s++) {
      let o = this.text[s], a = r + o.length;
      if ((n ? i : a) >= e)
        return new ame(r, a, i, o);
      r = a + 1, i++;
    }
  }
  decompose(e, n, i, r) {
    let s = e <= 0 && n >= this.length ? this : new Bt(qE(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (r & 1) {
      let o = i.pop(), a = ip(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32)
        i.push(new Bt(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        i.push(new Bt(a.slice(0, l)), new Bt(a.slice(l)));
      }
    } else
      i.push(s);
  }
  replace(e, n, i) {
    if (!(i instanceof Bt))
      return super.replace(e, n, i);
    [e, n] = nc(this, e, n);
    let r = ip(this.text, ip(i.text, qE(this.text, 0, e)), n), s = this.length + i.length - (n - e);
    return r.length <= 32 ? new Bt(r, s) : Rr.from(Bt.split(r, []), s);
  }
  sliceString(e, n = this.length, i = `
`) {
    [e, n] = nc(this, e, n);
    let r = "";
    for (let s = 0, o = 0; s <= n && o < this.text.length; o++) {
      let a = this.text[o], l = s + a.length;
      s > e && o && (r += i), e < l && n > s && (r += a.slice(Math.max(0, e - s), n - s)), s = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let i = [], r = -1;
    for (let s of e)
      i.push(s), r += s.length + 1, i.length == 32 && (n.push(new Bt(i, r)), i = [], r = -1);
    return r > -1 && n.push(new Bt(i, r)), n;
  }
}
class Rr extends Ge {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, n, i, r) {
    for (let s = 0; ; s++) {
      let o = this.children[s], a = r + o.length, l = i + o.lines - 1;
      if ((n ? l : a) >= e)
        return o.lineInner(e, n, i, r);
      r = a + 1, i = l + 1;
    }
  }
  decompose(e, n, i, r) {
    for (let s = 0, o = 0; o <= n && s < this.children.length; s++) {
      let a = this.children[s], l = o + a.length;
      if (e <= l && n >= o) {
        let c = r & ((o <= e ? 1 : 0) | (l >= n ? 2 : 0));
        o >= e && l <= n && !c ? i.push(a) : a.decompose(e - o, n - o, i, c);
      }
      o = l + 1;
    }
  }
  replace(e, n, i) {
    if ([e, n] = nc(this, e, n), i.lines < this.lines)
      for (let r = 0, s = 0; r < this.children.length; r++) {
        let o = this.children[r], a = s + o.length;
        if (e >= s && n <= a) {
          let l = o.replace(e - s, n - s, i), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[r] = l, new Rr(u, this.length - (n - e) + i.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, n, i);
  }
  sliceString(e, n = this.length, i = `
`) {
    [e, n] = nc(this, e, n);
    let r = "";
    for (let s = 0, o = 0; s < this.children.length && o <= n; s++) {
      let a = this.children[s], l = o + a.length;
      o > e && s && (r += i), e < l && n > o && (r += a.sliceString(e - o, n - o, i)), o = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof Rr))
      return 0;
    let i = 0, [r, s, o, a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; r += n, s += n) {
      if (r == o || s == a)
        return i;
      let l = this.children[r], c = e.children[s];
      if (l != c)
        return i + l.scanIdentical(c, n);
      i += l.length + 1;
    }
  }
  static from(e, n = e.reduce((i, r) => i + r.length + 1, -1)) {
    let i = 0;
    for (let f of e)
      i += f.lines;
    if (i < 32) {
      let f = [];
      for (let p of e)
        p.flatten(f);
      return new Bt(f, n);
    }
    let r = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), s = r << 1, o = r >> 1, a = [], l = 0, c = -1, u = [];
    function d(f) {
      let p;
      if (f.lines > s && f instanceof Rr)
        for (let m of f.children)
          d(m);
      else f.lines > o && (l > o || !l) ? (h(), a.push(f)) : f instanceof Bt && l && (p = u[u.length - 1]) instanceof Bt && f.lines + p.lines <= 32 ? (l += f.lines, c += f.length + 1, u[u.length - 1] = new Bt(p.text.concat(f.text), p.length + 1 + f.length)) : (l + f.lines > r && h(), l += f.lines, c += f.length + 1, u.push(f));
    }
    function h() {
      l != 0 && (a.push(u.length == 1 ? u[0] : Rr.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let f of e)
      d(f);
    return h(), a.length == 1 ? a[0] : new Rr(a, n);
  }
}
Ge.empty = /* @__PURE__ */ new Bt([""], 0);
function ome(t) {
  let e = -1;
  for (let n of t)
    e += n.length + 1;
  return e;
}
function ip(t, e, n = 0, i = 1e9) {
  for (let r = 0, s = 0, o = !0; s < t.length && r <= i; s++) {
    let a = t[s], l = r + a.length;
    l >= n && (l > i && (a = a.slice(0, i - r)), r < n && (a = a.slice(n - r)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), r = l + 1;
  }
  return e;
}
function qE(t, e, n) {
  return ip(t, [""], e, n);
}
class ku {
  constructor(e, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof Bt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, r = this.nodes[i], s = this.offsets[i], o = s >> 1, a = r instanceof Bt ? r.text.length : r.children.length;
      if (o == (n > 0 ? a : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[i] += n, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (r instanceof Bt) {
        let l = r.text[o + (n < 0 ? -1 : 0)];
        if (this.offsets[i] += n, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = r.children[o + (n < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[i] += n) : (n < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof Bt ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class E4 {
  constructor(e, n, i) {
    this.value = "", this.done = !1, this.cursor = new ku(e, n > i ? -1 : 1), this.pos = n > i ? e.length : 0, this.from = Math.min(n, i), this.to = Math.max(n, i);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let i = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: r } = this.cursor.next(e);
    return this.pos += (r.length + e) * n, this.value = r.length <= i ? r : n < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class C4 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: n, lineBreak: i, value: r } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Ge.prototype[Symbol.iterator] = function() {
  return this.iter();
}, ku.prototype[Symbol.iterator] = E4.prototype[Symbol.iterator] = C4.prototype[Symbol.iterator] = function() {
  return this;
});
class ame {
  /**
  @internal
  */
  constructor(e, n, i, r) {
    this.from = e, this.to = n, this.number = i, this.text = r;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function nc(t, e, n) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))];
}
let Tl = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < Tl.length; t++)
  Tl[t] += Tl[t - 1];
function lme(t) {
  for (let e = 1; e < Tl.length; e += 2)
    if (Tl[e] > t)
      return Tl[e - 1] <= t;
  return !1;
}
function XE(t) {
  return t >= 127462 && t <= 127487;
}
const jE = 8205;
function bn(t, e, n = !0, i = !0) {
  return (n ? A4 : cme)(t, e, i);
}
function A4(t, e, n) {
  if (e == t.length)
    return e;
  e && T4(t.charCodeAt(e)) && M4(t.charCodeAt(e - 1)) && e--;
  let i = pn(t, e);
  for (e += $i(i); e < t.length; ) {
    let r = pn(t, e);
    if (i == jE || r == jE || n && lme(r))
      e += $i(r), i = r;
    else if (XE(r)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && XE(pn(t, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function cme(t, e, n) {
  for (; e > 0; ) {
    let i = A4(t, e - 2, n);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function T4(t) {
  return t >= 56320 && t < 57344;
}
function M4(t) {
  return t >= 55296 && t < 56320;
}
function pn(t, e) {
  let n = t.charCodeAt(e);
  if (!M4(n) || e + 1 == t.length)
    return n;
  let i = t.charCodeAt(e + 1);
  return T4(i) ? (n - 55296 << 10) + (i - 56320) + 65536 : n;
}
function __(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function $i(t) {
  return t < 65536 ? 1 : 2;
}
const VO = /\r\n?|\n/;
var mn = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(mn || (mn = {}));
class Xr {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let i = this.sections[n + 1];
      e += i < 0 ? this.sections[n] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let n = 0, i = 0, r = 0; n < this.sections.length; ) {
      let s = this.sections[n++], o = this.sections[n++];
      o < 0 ? (e(i, r, s), r += s) : r += o, i += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, n = !1) {
    ZO(this, e, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let i = this.sections[n++], r = this.sections[n++];
      r < 0 ? e.push(i, r) : e.push(r, i);
    }
    return new Xr(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : P4(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, n = !1) {
    return e.empty ? this : HO(this, e, n);
  }
  mapPos(e, n = -1, i = mn.Simple) {
    let r = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = r + a;
      if (l < 0) {
        if (c > e)
          return s + (e - r);
        s += a;
      } else {
        if (i != mn.Simple && c >= e && (i == mn.TrackDel && r < e && c > e || i == mn.TrackBefore && r < e || i == mn.TrackAfter && c > e))
          return null;
        if (c > e || c == e && n < 0 && !a)
          return e == r || n < 0 ? s : s + l;
        s += l;
      }
      r = c;
    }
    if (e > r)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, n = e) {
    for (let i = 0, r = 0; i < this.sections.length && r <= n; ) {
      let s = this.sections[i++], o = this.sections[i++], a = r + s;
      if (o >= 0 && r <= n && a >= e)
        return r < e && a > n ? "cover" : !0;
      r = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let i = this.sections[n++], r = this.sections[n++];
      e += (e ? " " : "") + i + (r >= 0 ? ":" + r : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Xr(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Xr(e);
  }
}
class Xt extends Xr {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return ZO(this, (n, i, r, s, o) => e = e.replace(r, r + (i - n), o), !1), e;
  }
  mapDesc(e, n = !1) {
    return HO(this, e, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let n = this.sections.slice(), i = [];
    for (let r = 0, s = 0; r < n.length; r += 2) {
      let o = n[r], a = n[r + 1];
      if (a >= 0) {
        n[r] = a, n[r + 1] = o;
        let l = r >> 1;
        for (; i.length < l; )
          i.push(Ge.empty);
        i.push(o ? e.slice(s, s + o) : Ge.empty);
      }
      s += o;
    }
    return new Xt(n, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : P4(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, n = !1) {
    return e.empty ? this : HO(this, e, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, n = !1) {
    ZO(this, e, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Xr.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let n = [], i = [], r = [], s = new vd(this);
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++];
      for (; a < l || a == l && s.len == 0; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, l - a);
        xn(r, u, -1);
        let d = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        xn(n, u, d), d > 0 && co(i, n, s.text), s.forward(u), a += u;
      }
      let c = e[o++];
      for (; a < c; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, c - a);
        xn(n, u, -1), xn(r, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), a += u;
      }
    }
    return {
      changes: new Xt(n, i),
      filtered: Xr.create(r)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let i = this.sections[n], r = this.sections[n + 1];
      r < 0 ? e.push(i) : r == 0 ? e.push([i]) : e.push([i].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, n, i) {
    let r = [], s = [], o = 0, a = null;
    function l(u = !1) {
      if (!u && !r.length)
        return;
      o < n && xn(r, n - o, -1);
      let d = new Xt(r, s);
      a = a ? a.compose(d.map(a)) : d, r = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let d of u)
          c(d);
      else if (u instanceof Xt) {
        if (u.length != n)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: d, to: h = d, insert: f } = u;
        if (d > h || d < 0 || h > n)
          throw new RangeError(`Invalid change range ${d} to ${h} (in doc of length ${n})`);
        let p = f ? typeof f == "string" ? Ge.of(f.split(i || VO)) : f : Ge.empty, m = p.length;
        if (d == h && m == 0)
          return;
        d < o && l(), d > o && xn(r, d - o, -1), xn(r, h - d, m), co(s, r, p), o = h;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Xt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], i = [];
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      if (typeof s == "number")
        n.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          n.push(s[0], 0);
        else {
          for (; i.length < r; )
            i.push(Ge.empty);
          i[r] = Ge.of(s.slice(1)), n.push(s[0], i[r].length);
        }
      }
    }
    return new Xt(n, i);
  }
  /**
  @internal
  */
  static createSet(e, n) {
    return new Xt(e, n);
  }
}
function xn(t, e, n, i = !1) {
  if (e == 0 && n <= 0)
    return;
  let r = t.length - 2;
  r >= 0 && n <= 0 && n == t[r + 1] ? t[r] += e : e == 0 && t[r] == 0 ? t[r + 1] += n : i ? (t[r] += e, t[r + 1] += n) : t.push(e, n);
}
function co(t, e, n) {
  if (n.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < t.length)
    t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < i; )
      t.push(Ge.empty);
    t.push(n);
  }
}
function ZO(t, e, n) {
  let i = t.inserted;
  for (let r = 0, s = 0, o = 0; o < t.sections.length; ) {
    let a = t.sections[o++], l = t.sections[o++];
    if (l < 0)
      r += a, s += a;
    else {
      let c = r, u = s, d = Ge.empty;
      for (; c += a, u += l, l && i && (d = d.append(i[o - 2 >> 1])), !(n || o == t.sections.length || t.sections[o + 1] < 0); )
        a = t.sections[o++], l = t.sections[o++];
      e(r, c, s, u, d), r = c, s = u;
    }
  }
}
function HO(t, e, n, i = !1) {
  let r = [], s = i ? [] : null, o = new vd(t), a = new vd(e);
  for (let l = -1; ; )
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      xn(r, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !n))) {
      let c = a.len;
      for (xn(r, a.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= u && (xn(r, 0, o.ins), s && co(s, r, o.text), l = o.i), o.forward(u), c -= u;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let d = Math.min(u, a.len);
          c += d, u -= d, a.forward(d);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      xn(r, c, l < o.i ? o.ins : 0), s && l < o.i && co(s, r, o.text), l = o.i, o.forward(o.len - u);
    } else {
      if (o.done && a.done)
        return s ? Xt.createSet(r, s) : Xr.create(r);
      throw new Error("Mismatched change set lengths");
    }
}
function P4(t, e, n = !1) {
  let i = [], r = n ? [] : null, s = new vd(t), o = new vd(e);
  for (let a = !1; ; ) {
    if (s.done && o.done)
      return r ? Xt.createSet(i, r) : Xr.create(i);
    if (s.ins == 0)
      xn(i, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done)
      xn(i, 0, o.ins, a), r && co(r, i, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len), c = i.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          xn(i, l, u, a), r && u && co(r, i, o.text);
        } else o.ins == -1 ? (xn(i, s.off ? 0 : s.len, l, a), r && co(r, i, s.textBit(l))) : (xn(i, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), r && !o.off && co(r, i, o.text));
        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || i.length > c), s.forward2(l), o.forward(l);
      }
    }
  }
}
class vd {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? Ge.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, i = this.i - 2 >> 1;
    return i >= n.length && !e ? Ge.empty : n[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ua {
  constructor(e, n, i) {
    this.from = e, this.to = n, this.flags = i;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, n = -1) {
    let i, r;
    return this.empty ? i = r = e.mapPos(this.from, n) : (i = e.mapPos(this.from, 1), r = e.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new ua(i, r, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return j.range(e, n);
    let i = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return j.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return j.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new ua(e, n, i);
  }
}
class j {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, n = -1) {
    return e.empty ? this : j.create(this.ranges.map((i) => i.map(e, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new j([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, n = !0) {
    return j.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, n = this.mainIndex) {
    let i = this.ranges.slice();
    return i[n] = e, j.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new j(e.ranges.map((n) => ua.fromJSON(n)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, n = e) {
    return new j([j.range(e, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, r = 0; r < e.length; r++) {
      let s = e[r];
      if (s.empty ? s.from <= i : s.from < i)
        return j.normalized(e.slice(), n);
      i = s.to;
    }
    return new j(e, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, n = 0, i, r) {
    return ua.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (r ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, n, i, r) {
    let s = (i ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r));
    return n < e ? ua.create(n, e, 48 | s) : ua.create(e, n, (n > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, n = 0) {
    let i = e[n];
    e.sort((r, s) => r.from - s.from), n = e.indexOf(i);
    for (let r = 1; r < e.length; r++) {
      let s = e[r], o = e[r - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from, l = Math.max(s.to, o.to);
        r <= n && n--, e.splice(--r, 2, s.anchor > s.head ? j.range(l, a) : j.range(a, l));
      }
    }
    return new j(e, n);
  }
}
function R4(t, e) {
  for (let n of t.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
let v_ = 0;
class de {
  constructor(e, n, i, r, s) {
    this.combine = e, this.compareInput = n, this.compare = i, this.isStatic = r, this.id = v_++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new de(e.combine || ((n) => n), e.compareInput || ((n, i) => n === i), e.compare || (e.combine ? (n, i) => n === i : x_), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new rp([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new rp(e, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new rp(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (i) => i), this.compute([e], (i) => n(i.field(e)));
  }
}
function x_(t, e) {
  return t == e || t.length == e.length && t.every((n, i) => n === e[i]);
}
class rp {
  constructor(e, n, i, r) {
    this.dependencies = e, this.facet = n, this.type = i, this.value = r, this.id = v_++;
  }
  dynamicSlot(e) {
    var n;
    let i = this.value, r = this.facet.compareInput, s = this.id, o = e[s] >> 1, a = this.type == 2, l = !1, c = !1, u = [];
    for (let d of this.dependencies)
      d == "doc" ? l = !0 : d == "selection" ? c = !0 : ((n = e[d.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[d.id]);
    return {
      create(d) {
        return d.values[o] = i(d), 1;
      },
      update(d, h) {
        if (l && h.docChanged || c && (h.docChanged || h.selection) || qO(d, u)) {
          let f = i(d);
          if (a ? !YE(f, d.values[o], r) : !r(f, d.values[o]))
            return d.values[o] = f, 1;
        }
        return 0;
      },
      reconfigure: (d, h) => {
        let f, p = h.config.address[s];
        if (p != null) {
          let m = $m(h, p);
          if (this.dependencies.every((g) => g instanceof de ? h.facet(g) === d.facet(g) : g instanceof ln ? h.field(g, !1) == d.field(g, !1) : !0) || (a ? YE(f = i(d), m, r) : r(f = i(d), m)))
            return d.values[o] = m, 0;
        } else
          f = i(d);
        return d.values[o] = f, 1;
      }
    };
  }
}
function YE(t, e, n) {
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (!n(t[i], e[i]))
      return !1;
  return !0;
}
function qO(t, e) {
  let n = !1;
  for (let i of e)
    Eu(t, i) & 1 && (n = !0);
  return n;
}
function ume(t, e, n) {
  let i = n.map((l) => t[l.id]), r = n.map((l) => l.type), s = i.filter((l) => !(l & 1)), o = t[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < i.length; u++) {
      let d = $m(l, i[u]);
      if (r[u] == 2)
        for (let h of d)
          c.push(h);
      else
        c.push(d);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of i)
        Eu(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!qO(l, s))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);
    },
    reconfigure(l, c) {
      let u = qO(l, i), d = c.config.facets[e.id], h = c.facet(e);
      if (d && !u && x_(n, d))
        return l.values[o] = h, 0;
      let f = a(l);
      return e.compare(f, h) ? (l.values[o] = h, 0) : (l.values[o] = f, 1);
    }
  };
}
const GE = /* @__PURE__ */ de.define({ static: !0 });
class ln {
  constructor(e, n, i, r, s) {
    this.id = e, this.createF = n, this.updateF = i, this.compareF = r, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let n = new ln(v_++, e.create, e.update, e.compare || ((i, r) => i === r), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(GE).find((i) => i.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (i) => (i.values[n] = this.create(i), 1),
      update: (i, r) => {
        let s = i.values[n], o = this.updateF(s, r);
        return this.compareF(s, o) ? 0 : (i.values[n] = o, 1);
      },
      reconfigure: (i, r) => r.config.address[this.id] != null ? (i.values[n] = r.field(this), 0) : (i.values[n] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, GE.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Jo = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Ic(t) {
  return (e) => new $4(e, t);
}
const Fo = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Ic(Jo.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Ic(Jo.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Ic(Jo.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Ic(Jo.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Ic(Jo.lowest)
};
class $4 {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
}
class j0 {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new XO(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return j0.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class XO {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
}
class Rm {
  constructor(e, n, i, r, s, o) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = i, this.address = r, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, i) {
    let r = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let h of dme(e, n, o))
      h instanceof ln ? r.push(h) : (s[h.facet.id] || (s[h.facet.id] = [])).push(h);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let h of r)
      a[h.id] = c.length << 1, c.push((f) => h.slot(f));
    let u = i == null ? void 0 : i.config.facets;
    for (let h in s) {
      let f = s[h], p = f[0].facet, m = u && u[h] || [];
      if (f.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, x_(m, f))
          l.push(i.facet(p));
        else {
          let g = p.combine(f.map((b) => b.value));
          l.push(i && p.compare(g, i.facet(p)) ? i.facet(p) : g);
        }
      else {
        for (let g of f)
          g.type == 0 ? (a[g.id] = l.length << 1 | 1, l.push(g.value)) : (a[g.id] = c.length << 1, c.push((b) => g.dynamicSlot(b)));
        a[p.id] = c.length << 1, c.push((g) => ume(g, p, f));
      }
    }
    let d = c.map((h) => h(a));
    return new Rm(e, o, d, a, l, s);
  }
}
function dme(t, e, n) {
  let i = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function s(o, a) {
    let l = r.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = i[l].indexOf(o);
      c > -1 && i[l].splice(c, 1), o instanceof XO && n.delete(o.compartment);
    }
    if (r.set(o, a), Array.isArray(o))
      for (let c of o)
        s(c, a);
    else if (o instanceof XO) {
      if (n.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      n.set(o.compartment, c), s(c, a);
    } else if (o instanceof $4)
      s(o.inner, o.prec);
    else if (o instanceof ln)
      i[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof rp)
      i[a].push(o), o.facet.extensions && s(o.facet.extensions, Jo.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, a);
    }
  }
  return s(t, Jo.default), i.reduce((o, a) => o.concat(a));
}
function Eu(t, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, i = t.status[n];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  t.status[n] = 4;
  let r = t.computeSlot(t, t.config.dynamicSlots[n]);
  return t.status[n] = 2 | r;
}
function $m(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const N4 = /* @__PURE__ */ de.define(), jO = /* @__PURE__ */ de.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), D4 = /* @__PURE__ */ de.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), I4 = /* @__PURE__ */ de.define(), L4 = /* @__PURE__ */ de.define(), B4 = /* @__PURE__ */ de.define(), Q4 = /* @__PURE__ */ de.define({
  combine: (t) => t.length ? t[0] : !1
});
class $s {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new hme();
  }
}
class hme {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new $s(this, e);
  }
}
class fme {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Me(this, e);
  }
}
class Me {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new Me(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new fme(e.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let i = [];
    for (let r of e) {
      let s = r.map(n);
      s && i.push(s);
    }
    return i;
  }
}
Me.reconfigure = /* @__PURE__ */ Me.define();
Me.appendConfig = /* @__PURE__ */ Me.define();
class Vt {
  constructor(e, n, i, r, s, o) {
    this.startState = e, this.changes = n, this.selection = i, this.effects = r, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, i && R4(i, n.newLength), s.some((a) => a.type == Vt.time) || (this.annotations = s.concat(Vt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, n, i, r, s, o) {
    return new Vt(e, n, i, r, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let n = this.annotation(Vt.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
}
Vt.time = /* @__PURE__ */ $s.define();
Vt.userEvent = /* @__PURE__ */ $s.define();
Vt.addToHistory = /* @__PURE__ */ $s.define();
Vt.remote = /* @__PURE__ */ $s.define();
function pme(t, e) {
  let n = [];
  for (let i = 0, r = 0; ; ) {
    let s, o;
    if (i < t.length && (r == e.length || e[r] >= t[i]))
      s = t[i++], o = t[i++];
    else if (r < e.length)
      s = e[r++], o = e[r++];
    else
      return n;
    !n.length || n[n.length - 1] < s ? n.push(s, o) : n[n.length - 1] < o && (n[n.length - 1] = o);
  }
}
function F4(t, e, n) {
  var i;
  let r, s, o;
  return n ? (r = e.changes, s = Xt.empty(e.changes.length), o = t.changes.compose(e.changes)) : (r = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(r)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (i = t.selection) === null || i === void 0 ? void 0 : i.map(r),
    effects: Me.mapEffects(t.effects, r).concat(Me.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function YO(t, e, n) {
  let i = e.selection, r = Ml(e.annotations);
  return e.userEvent && (r = r.concat(Vt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Xt ? e.changes : Xt.of(e.changes || [], n, t.facet(D4)),
    selection: i && (i instanceof j ? i : j.single(i.anchor, i.head)),
    effects: Ml(e.effects),
    annotations: r,
    scrollIntoView: !!e.scrollIntoView
  };
}
function z4(t, e, n) {
  let i = YO(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (n = !1);
    let o = !!e[s].sequential;
    i = F4(i, YO(t, e[s], o ? i.changes.newLength : t.doc.length), o);
  }
  let r = Vt.create(t, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return gme(n ? mme(r) : r);
}
function mme(t) {
  let e = t.startState, n = !0;
  for (let r of e.facet(I4)) {
    let s = r(t);
    if (s === !1) {
      n = !1;
      break;
    }
    Array.isArray(s) && (n = n === !0 ? s : pme(n, s));
  }
  if (n !== !0) {
    let r, s;
    if (n === !1)
      s = t.changes.invertedDesc, r = Xt.empty(e.doc.length);
    else {
      let o = t.changes.filter(n);
      r = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    t = Vt.create(e, r, t.selection && t.selection.map(s), Me.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let i = e.facet(L4);
  for (let r = i.length - 1; r >= 0; r--) {
    let s = i[r](t);
    s instanceof Vt ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Vt ? t = s[0] : t = z4(e, Ml(s), !1);
  }
  return t;
}
function gme(t) {
  let e = t.startState, n = e.facet(B4), i = t;
  for (let r = n.length - 1; r >= 0; r--) {
    let s = n[r](t);
    s && Object.keys(s).length && (i = F4(i, YO(e, s, t.changes.newLength), !0));
  }
  return i == t ? t : Vt.create(e, t.changes, t.selection, i.effects, i.annotations, i.scrollIntoView);
}
const bme = [];
function Ml(t) {
  return t == null ? bme : Array.isArray(t) ? t : [t];
}
var Mt = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(Mt || (Mt = {}));
const Ome = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let GO;
try {
  GO = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function yme(t) {
  if (GO)
    return GO.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || Ome.test(n)))
      return !0;
  }
  return !1;
}
function _me(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Mt.Space;
    if (yme(e))
      return Mt.Word;
    for (let n = 0; n < t.length; n++)
      if (e.indexOf(t[n]) > -1)
        return Mt.Word;
    return Mt.Other;
  };
}
class je {
  constructor(e, n, i, r, s, o) {
    this.config = e, this.doc = n, this.selection = i, this.values = r, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Eu(this, a << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Eu(this, i), $m(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return z4(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let n = this.config, { base: i, compartments: r } = n;
    for (let a of e.effects)
      a.is(j0.reconfigure) ? (n && (r = /* @__PURE__ */ new Map(), n.compartments.forEach((l, c) => r.set(c, l)), n = null), r.set(a.value.compartment, a.value.extension)) : a.is(Me.reconfigure) ? (n = null, i = a.value) : a.is(Me.appendConfig) && (n = null, i = Ml(i).concat(a.value));
    let s;
    n ? s = e.startState.values.slice() : (n = Rm.resolve(i, r, this), s = new je(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(jO) ? e.newSelection : e.newSelection.asSingle();
    new je(n, e.newDoc, o, s, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: j.cursor(n.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let n = this.selection, i = e(n.ranges[0]), r = this.changes(i.changes), s = [i.range], o = Ml(i.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let l = e(n.ranges[a]), c = this.changes(l.changes), u = c.map(r);
      for (let h = 0; h < a; h++)
        s[h] = s[h].map(u);
      let d = r.mapDesc(c, !0);
      s.push(l.range.map(d)), r = r.compose(u), o = Me.mapEffects(o, u).concat(Me.mapEffects(Ml(l.effects), d));
    }
    return {
      changes: r,
      selection: j.create(s, n.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Xt ? e : Xt.of(e, this.doc.length, this.facet(je.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Ge.of(e.split(this.facet(je.lineSeparator) || VO));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (Eu(this, n), $m(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let r = e[i];
        r instanceof ln && this.config.address[r.id] != null && (n[i] = r.spec.toJSON(this.field(e[i]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, n = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (i) {
      for (let s in i)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = i[s], a = e[s];
          r.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return je.create({
      doc: e.doc,
      selection: j.fromJSON(e.selection),
      extensions: n.extensions ? r.concat([n.extensions]) : r
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let n = Rm.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof Ge ? e.doc : Ge.of((e.doc || "").split(n.staticFacet(je.lineSeparator) || VO)), r = e.selection ? e.selection instanceof j ? e.selection : j.single(e.selection.anchor, e.selection.head) : j.single(0);
    return R4(r, i.length), n.staticFacet(jO) || (r = r.asSingle()), new je(n, i, r, n.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(je.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(je.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Q4);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...n) {
    for (let i of this.facet(je.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (i, r) => {
      if (r == "$")
        return "$";
      let s = +(r || 1);
      return !s || s > n.length ? i : n[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, n, i = -1) {
    let r = [];
    for (let s of this.facet(N4))
      for (let o of s(this, n, i))
        Object.prototype.hasOwnProperty.call(o, e) && r.push(o[e]);
    return r;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return _me(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: n, from: i, length: r } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - i, a = e - i;
    for (; o > 0; ) {
      let l = bn(n, o, !1);
      if (s(n.slice(l, o)) != Mt.Word)
        break;
      o = l;
    }
    for (; a < r; ) {
      let l = bn(n, a);
      if (s(n.slice(a, l)) != Mt.Word)
        break;
      a = l;
    }
    return o == a ? null : j.range(o + i, a + i);
  }
}
je.allowMultipleSelections = jO;
je.tabSize = /* @__PURE__ */ de.define({
  combine: (t) => t.length ? t[0] : 4
});
je.lineSeparator = D4;
je.readOnly = Q4;
je.phrases = /* @__PURE__ */ de.define({
  compare(t, e) {
    let n = Object.keys(t), i = Object.keys(e);
    return n.length == i.length && n.every((r) => t[r] == e[r]);
  }
});
je.languageData = N4;
je.changeFilter = I4;
je.transactionFilter = L4;
je.transactionExtender = B4;
j0.reconfigure = /* @__PURE__ */ Me.define();
function is(t, e, n = {}) {
  let i = {};
  for (let r of t)
    for (let s of Object.keys(r)) {
      let o = r[s], a = i[s];
      if (a === void 0)
        i[s] = o;
      else if (!(a === o || o === void 0)) if (Object.hasOwnProperty.call(n, s))
        i[s] = n[s](a, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let r in e)
    i[r] === void 0 && (i[r] = e[r]);
  return i;
}
class Na {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, n = e) {
    return xd.create(e, n, this);
  }
}
Na.prototype.startSide = Na.prototype.endSide = 0;
Na.prototype.point = !1;
Na.prototype.mapMode = mn.TrackDel;
class xd {
  constructor(e, n, i) {
    this.from = e, this.to = n, this.value = i;
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new xd(e, n, i);
  }
}
function KO(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class w_ {
  constructor(e, n, i, r) {
    this.from = e, this.to = n, this.value = i, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, n, i, r = 0) {
    let s = i ? this.to : this.from;
    for (let o = r, a = s.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = s[l] - e || (i ? this.value[l].endSide : this.value[l].startSide) - n;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, n, i, r) {
    for (let s = this.findIndex(n, -1e9, !0), o = this.findIndex(i, 1e9, !1, s); s < o; s++)
      if (r(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, n) {
    let i = [], r = [], s = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, d = this.to[l] + e, h, f;
      if (u == d) {
        let p = n.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (h = f = p, c.startSide != c.endSide && (f = n.mapPos(u, c.endSide), f < h)))
          continue;
      } else if (h = n.mapPos(u, c.startSide), f = n.mapPos(d, c.endSide), h > f || h == f && c.startSide > 0 && c.endSide <= 0)
        continue;
      (f - h || c.endSide - c.startSide) < 0 || (o < 0 && (o = h), c.point && (a = Math.max(a, f - h)), i.push(c), r.push(h - o), s.push(f - o));
    }
    return { mapped: i.length ? new w_(r, s, i, a) : null, pos: o };
  }
}
class Ye {
  constructor(e, n, i, r) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = i, this.maxPoint = r;
  }
  /**
  @internal
  */
  static create(e, n, i, r) {
    return new Ye(e, n, i, r);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: n = [], sort: i = !1, filterFrom: r = 0, filterTo: s = this.length } = e, o = e.filter;
    if (n.length == 0 && !o)
      return this;
    if (i && (n = n.slice().sort(KO)), this.isEmpty)
      return n.length ? Ye.of(n) : this;
    let a = new U4(this, null, -1).goto(0), l = 0, c = [], u = new Ao();
    for (; a.value || l < n.length; )
      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
        let d = n[l++];
        u.addInner(d.from, d.to, d.value) || c.push(d);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!o || r > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || r > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(xd.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? Ye.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: r, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], i = [], r = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        r = Math.max(r, l.maxPoint), n.push(l), i.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: d } = l.map(a, e);
        u && (r = Math.max(r, u.maxPoint), n.push(u), i.push(d));
      }
    }
    let s = this.nextLayer.map(e);
    return n.length == 0 ? s : new Ye(i, n, s || Ye.empty, r);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, n, i) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let s = this.chunkPos[r], o = this.chunk[r];
        if (n >= s && e <= s + o.length && o.between(s, e - s, n - s, i) === !1)
          return;
      }
      this.nextLayer.between(e, n, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return wd.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, n = 0) {
    return wd.from(e).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, n, i, r, s = -1) {
    let o = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), a = n.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), l = KE(o, a, i), c = new Lc(o, l, s), u = new Lc(a, l, s);
    i.iterGaps((d, h, f) => JE(c, d, u, h, f, r)), i.empty && i.length == 0 && JE(c, 0, u, 0, 0, r);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, n, i = 0, r) {
    r == null && (r = 999999999);
    let s = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0), o = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let a = KE(s, o), l = new Lc(s, a, 0).goto(i), c = new Lc(o, a, 0).goto(i);
    for (; ; ) {
      if (l.to != c.to || !JO(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > r)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, n, i, r, s = -1) {
    let o = new Lc(e, null, s).goto(n), a = n, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, i);
      if (o.point) {
        let u = o.activeForPoint(o.to), d = o.pointFrom < n ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);
        r.point(a, c, o.point, u, d, o.pointRank), l = Math.min(o.openEnd(c), u.length);
      } else c > a && (r.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > i)
        return l + (o.point && o.to > i ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, n = !1) {
    let i = new Ao();
    for (let r of e instanceof xd ? [e] : n ? vme(e) : e)
      i.add(r.from, r.to, r.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Ye.empty;
    let n = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let r = e[i]; r != Ye.empty; r = r.nextLayer)
        n = new Ye(r.chunkPos, r.chunk, n, Math.max(r.maxPoint, n.maxPoint));
    return n;
  }
}
Ye.empty = /* @__PURE__ */ new Ye([], [], null, -1);
function vme(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let i = t[n];
      if (KO(e, i) > 0)
        return t.slice().sort(KO);
      e = i;
    }
  return t;
}
Ye.empty.nextLayer = Ye.empty;
class Ao {
  finishChunk(e) {
    this.chunks.push(new w_(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, n, i) {
    this.addInner(e, n, i) || (this.nextLayer || (this.nextLayer = new Ao())).add(e, n, i);
  }
  /**
  @internal
  */
  addInner(e, n, i) {
    let r = e - this.lastTo || i.startSide - this.last.endSide;
    if (r <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = n, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let i = n.value.length - 1;
    return this.last = n.value[i], this.lastFrom = n.from[i] + e, this.lastTo = n.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Ye.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let n = Ye.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
}
function KE(t, e, n) {
  let i = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && i.set(s.chunk[o], s.chunkPos[o]);
  let r = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = i.get(s.chunk[o]);
      a != null && (n ? n.mapPos(a) : a) == s.chunkPos[o] && !(n != null && n.touchesRange(a, a + s.chunk[o].length)) && r.add(s.chunk[o]);
    }
  return r;
}
class U4 {
  constructor(e, n, i, r = 0) {
    this.layer = e, this.skip = n, this.minPoint = i, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < e || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!i || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], i = e + n.from[this.rangeIndex];
        if (this.from = i, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class wd {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, i = -1) {
    let r = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && r.push(new U4(o, n, i, s));
    return r.length == 1 ? r[0] : new wd(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let i of this.heap)
      i.goto(e, n);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      D1(this.heap, i);
    return this.next(), this;
  }
  forward(e, n) {
    for (let i of this.heap)
      i.forward(e, n);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      D1(this.heap, i);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), D1(this.heap, 0);
    }
  }
}
function D1(t, e) {
  for (let n = t[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= t.length)
      break;
    let r = t[i];
    if (i + 1 < t.length && r.compare(t[i + 1]) >= 0 && (r = t[i + 1], i++), n.compare(r) < 0)
      break;
    t[i] = n, t[e] = r, e = i;
  }
}
class Lc {
  constructor(e, n, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = wd.from(e, n, i);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    vf(this.active, e), vf(this.activeTo, e), vf(this.activeRank, e), this.minActive = eC(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: i, to: r, rank: s } = this.cursor;
    for (; n < this.activeRank.length && (s - this.activeRank[n] || r - this.activeTo[n]) > 0; )
      n++;
    xf(this.active, n, i), xf(this.activeTo, n, r), xf(this.activeRank, n, s), e && xf(e, n, this.cursor.from), this.minActive = eC(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > e) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && vf(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(i), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let r = i.length - 1; r >= 0 && i[r] < e; r--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && n.push(this.active[i]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      n++;
    return n;
  }
}
function JE(t, e, n, i, r, s) {
  t.goto(e), n.goto(i);
  let o = i + r, a = i, l = i - e;
  for (; ; ) {
    let c = t.to + l - n.to || t.endSide - n.endSide, u = c < 0 ? t.to + l : n.to, d = Math.min(u, o);
    if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && JO(t.activeForPoint(t.to), n.activeForPoint(n.to)) || s.comparePoint(a, d, t.point, n.point) : d > a && !JO(t.active, n.active) && s.compareRange(a, d, t.active, n.active), u > o)
      break;
    a = u, c <= 0 && t.next(), c >= 0 && n.next();
  }
}
function JO(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] != e[n] && !t[n].eq(e[n]))
      return !1;
  return !0;
}
function vf(t, e) {
  for (let n = e, i = t.length - 1; n < i; n++)
    t[n] = t[n + 1];
  t.pop();
}
function xf(t, e, n) {
  for (let i = t.length - 1; i >= e; i--)
    t[i + 1] = t[i];
  t[e] = n;
}
function eC(t, e) {
  let n = -1, i = 1e9;
  for (let r = 0; r < e.length; r++)
    (e[r] - i || t[r].endSide - t[n].endSide) < 0 && (n = r, i = e[r]);
  return n;
}
function Ec(t, e, n = t.length) {
  let i = 0;
  for (let r = 0; r < n; )
    t.charCodeAt(r) == 9 ? (i += e - i % e, r++) : (i++, r = bn(t, r));
  return i;
}
function ey(t, e, n, i) {
  for (let r = 0, s = 0; ; ) {
    if (s >= e)
      return r;
    if (r == t.length)
      break;
    s += t.charCodeAt(r) == 9 ? n - s % n : 1, r = bn(t, r);
  }
  return i === !0 ? -1 : t.length;
}
const ty = "", tC = typeof Symbol > "u" ? "__" + ty : Symbol.for(ty), ny = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), nC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class To {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, n) {
    this.rules = [];
    let { finish: i } = n || {};
    function r(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, c) {
      let u = [], d = /^@(\w+)\b/.exec(o[0]), h = d && d[1] == "keyframes";
      if (d && a == null) return l.push(o[0] + ";");
      for (let f in a) {
        let p = a[f];
        if (/&/.test(f))
          s(
            f.split(/,\s*/).map((m) => o.map((g) => m.replace(/&/, g))).reduce((m, g) => m.concat(g)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!d) throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          s(r(f), p, u, h);
        } else p != null && u.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || h) && l.push((i && !d && !c ? o.map(i) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) s(r(o), e[o], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = nC[tC] || 1;
    return nC[tC] = e + 1, ty + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, n, i) {
    let r = e[ny], s = i && i.nonce;
    r ? s && r.setNonce(s) : r = new xme(e, s), r.mount(Array.isArray(n) ? n : [n], e);
  }
}
let iC = /* @__PURE__ */ new Map();
class xme {
  constructor(e, n) {
    let i = e.ownerDocument || e, r = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
      let s = iC.get(i);
      if (s) return e[ny] = s;
      this.sheet = new r.CSSStyleSheet(), iC.set(i, this);
    } else
      this.styleTag = i.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], e[ny] = this;
  }
  mount(e, n) {
    let i = this.sheet, r = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = this.modules.indexOf(a);
      if (l < s && l > -1 && (this.modules.splice(l, 1), s--, l = -1), l == -1) {
        if (this.modules.splice(s++, 0, a), i) for (let c = 0; c < a.rules.length; c++)
          i.insertRule(a.rules[c], r++);
      } else {
        for (; s < l; ) r += this.modules[s++].rules.length;
        r += a.rules.length, s++;
      }
    }
    if (i)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let o = "";
      for (let l = 0; l < this.modules.length; l++)
        o += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = o;
      let a = n.head || n;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
function Sd(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function iy(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function wme(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function sp(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return iy(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function kd(t) {
  return t.nodeType == 3 ? Ia(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Cu(t, e, n, i) {
  return n ? rC(t, e, n, i, -1) || rC(t, e, n, i, 1) : !1;
}
function Da(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function Nm(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function rC(t, e, n, i, r) {
  for (; ; ) {
    if (t == n && e == i)
      return !0;
    if (e == (r < 0 ? 0 : Ms(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Da(t) + (r < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = r < 0 ? Ms(t) : 0;
    } else
      return !1;
  }
}
function Ms(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function S_(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function Sme(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function W4(t, e) {
  let n = e.width / t.offsetWidth, i = e.height / t.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - t.offsetHeight) < 1) && (i = 1), { scaleX: n, scaleY: i };
}
function kme(t, e, n, i, r, s, o, a) {
  let l = t.ownerDocument, c = l.defaultView || window;
  for (let u = t, d = !1; u && !d; )
    if (u.nodeType == 1) {
      let h, f = u == l.body, p = 1, m = 1;
      if (f)
        h = Sme(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (d = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let _ = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = W4(u, _)), h = {
          left: _.left,
          right: _.left + u.clientWidth * p,
          top: _.top,
          bottom: _.top + u.clientHeight * m
        };
      }
      let g = 0, b = 0;
      if (r == "nearest")
        e.top < h.top ? (b = -(h.top - e.top + o), n > 0 && e.bottom > h.bottom + b && (b = e.bottom - h.bottom + b + o)) : e.bottom > h.bottom && (b = e.bottom - h.bottom + o, n < 0 && e.top - b < h.top && (b = -(h.top + b - e.top + o)));
      else {
        let _ = e.bottom - e.top, y = h.bottom - h.top;
        b = (r == "center" && _ <= y ? e.top + _ / 2 - y / 2 : r == "start" || r == "center" && n < 0 ? e.top - o : e.bottom - y + o) - h.top;
      }
      if (i == "nearest" ? e.left < h.left ? (g = -(h.left - e.left + s), n > 0 && e.right > h.right + g && (g = e.right - h.right + g + s)) : e.right > h.right && (g = e.right - h.right + s, n < 0 && e.left < h.left + g && (g = -(h.left + g - e.left + s))) : g = (i == "center" ? e.left + (e.right - e.left) / 2 - (h.right - h.left) / 2 : i == "start" == a ? e.left - s : e.right - (h.right - h.left) + s) - h.left, g || b)
        if (f)
          c.scrollBy(g, b);
        else {
          let _ = 0, y = 0;
          if (b) {
            let O = u.scrollTop;
            u.scrollTop += b / m, y = (u.scrollTop - O) * m;
          }
          if (g) {
            let O = u.scrollLeft;
            u.scrollLeft += g / p, _ = (u.scrollLeft - O) * p;
          }
          e = {
            left: e.left - _,
            top: e.top - y,
            right: e.right - _,
            bottom: e.bottom - y
          }, _ && Math.abs(_ - g) < 1 && (i = "nearest"), y && Math.abs(y - b) < 1 && (r = "nearest");
        }
      if (f)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function Eme(t) {
  let e = t.ownerDocument, n, i;
  for (let r = t.parentNode; r && !(r == e.body || n && i); )
    if (r.nodeType == 1)
      !i && r.scrollHeight > r.clientHeight && (i = r), !n && r.scrollWidth > r.clientWidth && (n = r), r = r.assignedSlot || r.parentNode;
    else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return { x: n, y: i };
}
class Cme {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: i } = e;
    this.set(n, Math.min(e.anchorOffset, n ? Ms(n) : 0), i, Math.min(e.focusOffset, i ? Ms(i) : 0));
  }
  set(e, n, i, r) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = i, this.focusOffset = r;
  }
}
let al = null;
function V4(t) {
  if (t.setActive)
    return t.setActive();
  if (al)
    return t.focus(al);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (t.focus(al == null ? {
    get preventScroll() {
      return al = { preventScroll: !0 }, !0;
    }
  } : void 0), !al) {
    al = !1;
    for (let n = 0; n < e.length; ) {
      let i = e[n++], r = e[n++], s = e[n++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
let sC;
function Ia(t, e, n = e) {
  let i = sC || (sC = document.createRange());
  return i.setEnd(t, n), i.setStart(t, e), i;
}
function Pl(t, e, n, i) {
  let r = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  i && ({ altKey: r.altKey, ctrlKey: r.ctrlKey, shiftKey: r.shiftKey, metaKey: r.metaKey } = i);
  let s = new KeyboardEvent("keydown", r);
  s.synthetic = !0, t.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", r);
  return o.synthetic = !0, t.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function Ame(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function Z4(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function Tme(t, e) {
  let n = e.focusNode, i = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, Ms(n)); ; )
    if (i) {
      if (n.nodeType != 1)
        return !1;
      let r = n.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (n = r, i = Ms(n));
    } else {
      if (n == t)
        return !0;
      i = Da(n), n = n.parentNode;
    }
}
function H4(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function q4(t, e) {
  for (let n = t, i = e; ; ) {
    if (n.nodeType == 3 && i > 0)
      return { node: n, offset: i };
    if (n.nodeType == 1 && i > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[i - 1], i = Ms(n);
    } else if (n.parentNode && !Nm(n))
      i = Da(n), n = n.parentNode;
    else
      return null;
  }
}
function X4(t, e) {
  for (let n = t, i = e; ; ) {
    if (n.nodeType == 3 && i < n.nodeValue.length)
      return { node: n, offset: i };
    if (n.nodeType == 1 && i < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[i], i = 0;
    } else if (n.parentNode && !Nm(n))
      i = Da(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class Sn {
  constructor(e, n, i = !0) {
    this.node = e, this.offset = n, this.precise = i;
  }
  static before(e, n) {
    return new Sn(e.parentNode, Da(e), n);
  }
  static after(e, n) {
    return new Sn(e.parentNode, Da(e) + 1, n);
  }
}
const k_ = [];
class _t {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return n;
      n += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let i = this.dom, r = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = r ? r.nextSibling : i.firstChild)) {
            let a = _t.get(s);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, n), o.flags &= -8;
        }
        if (s = r ? r.nextSibling : i.firstChild, n && !n.written && n.node == i && s != o.dom && (n.written = !0), o.dom.parentNode == i)
          for (; s && s != o.dom; )
            s = oC(s);
        else
          i.insertBefore(o.dom, s);
        r = o.dom;
      }
      for (s = r ? r.nextSibling : i.firstChild, s && n && n.node == i && (n.written = !0); s; )
        s = oC(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, n), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[n];
    else {
      let r = Ms(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        r == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? r = -1 : r = 1), e = s;
      }
      r < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !_t.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let r = 0, s = 0; ; r++) {
      let o = this.children[r];
      if (o.dom == i)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, n, i = 0) {
    let r = -1, s = -1, o = -1, a = -1;
    for (let l = 0, c = i, u = i; l < this.children.length; l++) {
      let d = this.children[l], h = c + d.length;
      if (c < e && h > n)
        return d.domBoundsAround(e, n, c);
      if (h >= e && r == -1 && (r = l, s = c), c > n && d.dom.parentNode == this.dom) {
        o = l, a = u;
        break;
      }
      u = h, c = h + d.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? i + this.length : a,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, i = k_) {
    this.markDirty();
    for (let r = e; r < n; r++) {
      let s = this.children[r];
      s.parent == this && i.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, n - e, ...i);
    for (let r = 0; r < i.length; r++)
      i[r].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new j4(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, i, r, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
_t.prototype.breakAfter = 0;
function oC(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class j4 {
  constructor(e, n, i) {
    this.children = e, this.pos = n, this.i = i, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function Y4(t, e, n, i, r, s, o, a, l) {
  let { children: c } = t, u = c.length ? c[e] : null, d = s.length ? s[s.length - 1] : null, h = d ? d.breakAfter : o;
  if (!(e == i && u && !o && !h && s.length < 2 && u.merge(n, r, s.length ? d : null, n == 0, a, l))) {
    if (i < c.length) {
      let f = c[i];
      f && (r < f.length || f.breakAfter && (d != null && d.breakAfter)) ? (e == i && (f = f.split(r), r = 0), !h && d && f.merge(0, r, d, !0, 0, l) ? s[s.length - 1] = f : ((r || f.children.length && !f.children[0].length) && f.merge(0, r, null, !1, 0, l), s.push(f))) : f != null && f.breakAfter && (d ? d.breakAfter = 1 : o = 1), i++;
    }
    for (u && (u.breakAfter = o, n > 0 && (!o && s.length && u.merge(n, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, !1, a, 0), e++)); e < i && s.length; )
      if (c[i - 1].become(s[s.length - 1]))
        i--, s.pop(), l = s.length ? 0 : a;
      else if (c[e].become(s[0]))
        e++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < i || s.length) && t.replaceChildren(e, i, s);
  }
}
function G4(t, e, n, i, r, s) {
  let o = t.childCursor(), { i: a, off: l } = o.findPos(n, 1), { i: c, off: u } = o.findPos(e, -1), d = e - n;
  for (let h of i)
    d += h.length;
  t.length += d, Y4(t, c, u, a, l, i, 0, r, s);
}
let Yn = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, ry = typeof document < "u" ? document : { documentElement: { style: {} } };
const sy = /* @__PURE__ */ /Edge\/(\d+)/.exec(Yn.userAgent), K4 = /* @__PURE__ */ /MSIE \d/.test(Yn.userAgent), oy = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Yn.userAgent), Y0 = !!(K4 || oy || sy), aC = !Y0 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Yn.userAgent), I1 = !Y0 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Yn.userAgent), lC = "webkitFontSmoothing" in ry.documentElement.style, J4 = !Y0 && /* @__PURE__ */ /Apple Computer/.test(Yn.vendor), cC = J4 && (/* @__PURE__ */ /Mobile\/\w+/.test(Yn.userAgent) || Yn.maxTouchPoints > 2);
var ue = {
  mac: cC || /* @__PURE__ */ /Mac/.test(Yn.platform),
  windows: /* @__PURE__ */ /Win/.test(Yn.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Yn.platform),
  ie: Y0,
  ie_version: K4 ? ry.documentMode || 6 : oy ? +oy[1] : sy ? +sy[1] : 0,
  gecko: aC,
  gecko_version: aC ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Yn.userAgent) || [0, 0])[1] : 0,
  chrome: !!I1,
  chrome_version: I1 ? +I1[1] : 0,
  ios: cC,
  android: /* @__PURE__ */ /Android\b/.test(Yn.userAgent),
  webkit: lC,
  safari: J4,
  webkit_version: lC ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Yn.userAgent) || [0, 0])[1] : 0,
  tabSize: ry.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const Mme = 256;
class hr extends _t {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, i) {
    return this.flags & 8 || i && (!(i instanceof hr) || this.length - (n - e) + i.length > Mme || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(e) {
    let n = new hr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Sn(this.dom, e);
  }
  domBoundsAround(e, n, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return Pme(this.dom, e, n);
  }
}
class Ps extends _t {
  constructor(e, n = [], i = 0) {
    super(), this.mark = e, this.children = n, this.length = i;
    for (let r of n)
      r.setParent(this);
  }
  setAttrs(e) {
    if (Z4(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, i, r, s, o) {
    return i && (!(i instanceof Ps && i.mark.eq(this.mark)) || e && s <= 0 || n < this.length && o <= 0) ? !1 : (G4(this, e, n, i ? i.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [], i = 0, r = -1, s = 0;
    for (let a of this.children) {
      let l = i + a.length;
      l > e && n.push(i < e ? a.split(e - i) : a), r < 0 && i >= e && (r = s), i = l, s++;
    }
    let o = this.length - e;
    return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new Ps(this.mark, n, o);
  }
  domAtPos(e) {
    return e$(this, e);
  }
  coordsAt(e, n) {
    return n$(this, e, n);
  }
}
function Pme(t, e, n) {
  let i = t.nodeValue.length;
  e > i && (e = i);
  let r = e, s = e, o = 0;
  e == 0 && n < 0 || e == i && n >= 0 ? ue.chrome || ue.gecko || (e ? (r--, o = 1) : s < i && (s++, o = -1)) : n < 0 ? r-- : s < i && s++;
  let a = Ia(t, r, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : n >= 0) ? 0 : a.length - 1];
  return ue.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? S_(l, o < 0) : l || null;
}
class uo extends _t {
  static create(e, n, i) {
    return new uo(e, n, i);
  }
  constructor(e, n, i) {
    super(), this.widget = e, this.length = n, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let n = uo.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, i, r, s, o) {
    return i && (!(i instanceof uo) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - n), !0);
  }
  become(e) {
    return e instanceof uo && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Ge.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, i = n && n.state.doc, r = this.posAtStart;
    return i ? i.slice(r, r + this.length) : Ge.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Sn.before(this.dom) : Sn.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let i = this.widget.coordsAt(this.dom, e, n);
    if (i)
      return i;
    let r = this.dom.getClientRects(), s = null;
    if (!r.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? r.length - 1 : 0; s = r[a], !(e > 0 ? a == 0 : a == r.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
      ;
    return S_(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class ic extends _t {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof ic && e.side == this.side;
  }
  split() {
    return new ic(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Sn.before(this.dom) : Sn.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Ge.empty;
  }
  get isHidden() {
    return !0;
  }
}
hr.prototype.children = uo.prototype.children = ic.prototype.children = k_;
function e$(t, e) {
  let n = t.dom, { children: i } = t, r = 0;
  for (let s = 0; r < i.length; r++) {
    let o = i[r], a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == n)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = a;
    }
  }
  for (let s = r; s > 0; s--) {
    let o = i[s - 1];
    if (o.dom.parentNode == n)
      return o.domAtPos(o.length);
  }
  for (let s = r; s < i.length; s++) {
    let o = i[s];
    if (o.dom.parentNode == n)
      return o.domAtPos(0);
  }
  return new Sn(n, 0);
}
function t$(t, e, n) {
  let i, { children: r } = t;
  n > 0 && e instanceof Ps && r.length && (i = r[r.length - 1]) instanceof Ps && i.mark.eq(e.mark) ? t$(i, e.children[0], n - 1) : (r.push(e), e.setParent(t)), t.length += e.length;
}
function n$(t, e, n) {
  let i = null, r = -1, s = null, o = -1;
  function a(c, u) {
    for (let d = 0, h = 0; d < c.children.length && h <= u; d++) {
      let f = c.children[d], p = h + f.length;
      p >= u && (f.children.length ? a(f, u - h) : (!s || s.isHidden && n > 0) && (p > u || h == p && f.getSide() > 0) ? (s = f, o = u - h) : (h < u || h == p && f.getSide() < 0 && !f.isHidden) && (i = f, r = u - h)), h = p;
    }
  }
  a(t, e);
  let l = (n < 0 ? i : s) || i || s;
  return l ? l.coordsAt(Math.max(0, l == i ? r : o), n) : Rme(t);
}
function Rme(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let n = kd(e);
  return n[n.length - 1] || null;
}
function ay(t, e) {
  for (let n in t)
    n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
  return e;
}
const uC = /* @__PURE__ */ Object.create(null);
function Dm(t, e, n) {
  if (t == e)
    return !0;
  t || (t = uC), e || (e = uC);
  let i = Object.keys(t), r = Object.keys(e);
  if (i.length - (n && i.indexOf(n) > -1 ? 1 : 0) != r.length - (n && r.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != n && (r.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function ly(t, e, n) {
  let i = !1;
  if (e)
    for (let r in e)
      n && r in n || (i = !0, r == "style" ? t.style.cssText = "" : t.removeAttribute(r));
  if (n)
    for (let r in n)
      e && e[r] == n[r] || (i = !0, r == "style" ? t.style.cssText = n[r] : t.setAttribute(r, n[r]));
  return i;
}
function $me(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let i = t.attributes[n];
    e[i.name] = i.value;
  }
  return e;
}
class Ut extends _t {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, n, i, r, s, o) {
    if (i) {
      if (!(i instanceof Ut))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return r && this.setDeco(i ? i.attrs : null), G4(this, e, n, i ? i.children.slice() : [], s, o), !0;
  }
  split(e) {
    let n = new Ut();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i, off: r } = this.childPos(e);
    r && (n.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      n.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Dm(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    t$(this, e, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let n = e.spec.attributes, i = e.spec.class;
    n && (this.attrs = ay(n, this.attrs || {})), i && (this.attrs = ay({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return e$(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var i;
    this.dom ? this.flags & 4 && (Z4(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (ly(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let r = this.dom.lastChild;
    for (; r && _t.get(r) instanceof Ps; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((i = _t.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!ue.ios || !this.children.some((s) => s instanceof hr))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let i of this.children) {
      if (!(i instanceof hr) || /[^ -~]/.test(i.text))
        return null;
      let r = kd(i.dom);
      if (r.length != 1)
        return null;
      e += r[0].width, n = r[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let i = n$(this, e, n);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - r.lineHeight) < 2 && r.textHeight < s) {
        let o = (s - r.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return e instanceof Ut && this.children.length == 0 && e.children.length == 0 && Dm(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let i = 0, r = 0; i < e.children.length; i++) {
      let s = e.children[i], o = r + s.length;
      if (o >= n) {
        if (s instanceof Ut)
          return s;
        if (o > n)
          break;
      }
      r = o + s.breakAfter;
    }
    return null;
  }
}
class Cs extends _t {
  constructor(e, n, i) {
    super(), this.widget = e, this.length = n, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, i, r, s, o) {
    return i && (!(i instanceof Cs) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - n), !0);
  }
  domAtPos(e) {
    return e == 0 ? Sn.before(this.dom) : Sn.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let i = new Cs(this.widget, n, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return k_;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Ge.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Cs && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    return this.widget.coordsAt(this.dom, e, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: i } = this.deco;
    return n == i ? !1 : e < 0 ? n < 0 : i > 0;
  }
}
class Ns {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, n, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Bn = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Bn || (Bn = {}));
class ve extends Na {
  constructor(e, n, i, r) {
    super(), this.startSide = e, this.endSide = n, this.widget = i, this.spec = r;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new dh(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return n += i && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Mo(e, n, n, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let n = !!e.block, i, r;
    if (e.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: s, end: o } = i$(e, n);
      i = (s ? n ? -3e8 : -1 : 5e8) - 1, r = (o ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new Mo(e, i, r, n, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new hh(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, n = !1) {
    return Ye.of(e, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ve.none = Ye.empty;
class dh extends ve {
  constructor(e) {
    let { start: n, end: i } = i$(e);
    super(n ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, i;
    return this == e || e instanceof dh && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && Dm(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
dh.prototype.point = !1;
class hh extends ve {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof hh && this.spec.class == e.spec.class && Dm(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
hh.prototype.mapMode = mn.TrackBefore;
hh.prototype.point = !0;
class Mo extends ve {
  constructor(e, n, i, r, s, o) {
    super(n, i, s, e), this.block = r, this.isReplace = o, this.mapMode = r ? n <= 0 ? mn.TrackBefore : mn.TrackAfter : mn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Bn.WidgetRange : this.startSide <= 0 ? Bn.WidgetBefore : Bn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Mo && Nme(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
Mo.prototype.point = !0;
function i$(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: i } = t;
  return n == null && (n = t.inclusive), i == null && (i = t.inclusive), { start: n ?? e, end: i ?? e };
}
function Nme(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function cy(t, e, n, i = 0) {
  let r = n.length - 1;
  r >= 0 && n[r] + i >= t ? n[r] = Math.max(n[r], e) : n.push(t, e);
}
class Au {
  constructor(e, n, i, r) {
    this.doc = e, this.pos = n, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Cs && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Ut()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(wf(new ic(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Cs) && this.getLine();
  }
  buildText(e, n, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let r = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - i)), this.getLine().append(wf(new hr(this.text.slice(this.textOff, this.textOff + r)), n), i), this.atCursorPos = !0, this.textOff += r, e -= r, i = 0;
    }
  }
  span(e, n, i, r) {
    this.buildText(n - e, i, r), this.pos = n, this.openStart < 0 && (this.openStart = r);
  }
  point(e, n, i, r, s, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof Mo) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - e;
    if (i instanceof Mo)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Cs(i.widget || rc.block, a, i));
      else {
        let l = uo.create(i.widget || rc.inline, a, a ? 0 : i.startSide), c = this.atCursorPos && !l.isEditable && s <= r.length && (e < n || i.startSide > 0), u = !l.isEditable && (e < n || s > r.length || i.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), c && (d.append(wf(new ic(1), r), s), s = r.length + Math.max(0, s - r.length)), d.append(wf(l, r), s), this.atCursorPos = u, this.pendingBuffer = u ? e < n || s > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, n, i, r, s) {
    let o = new Au(e, n, i, s);
    return o.openEnd = Ye.spans(r, n, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function wf(t, e) {
  for (let n of e)
    t = new Ps(n, [t], t.length);
  return t;
}
class rc extends Ns {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
rc.inline = /* @__PURE__ */ new rc("span");
rc.block = /* @__PURE__ */ new rc("div");
var At = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(At || (At = {}));
const La = At.LTR, E_ = At.RTL;
function r$(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    e.push(1 << +t[n]);
  return e;
}
const Dme = /* @__PURE__ */ r$("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Ime = /* @__PURE__ */ r$("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), uy = /* @__PURE__ */ Object.create(null), xr = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), n = /* @__PURE__ */ t.charCodeAt(1);
  uy[e] = n, uy[n] = -e;
}
function s$(t) {
  return t <= 247 ? Dme[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? Ime[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const Lme = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class ho {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? E_ : La;
  }
  /**
  @internal
  */
  constructor(e, n, i) {
    this.from = e, this.to = n, this.level = i;
  }
  /**
  @internal
  */
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, n) {
    return e == (this.dir == n);
  }
  /**
  @internal
  */
  static find(e, n, i, r) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= n && a.to >= n) {
        if (a.level == i)
          return o;
        (s < 0 || (r != 0 ? r < 0 ? a.from < n : a.to > n : e[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function o$(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++) {
    let i = t[n], r = e[n];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !o$(i.inner, r.inner))
      return !1;
  }
  return !0;
}
const bt = [];
function Bme(t, e, n, i, r) {
  for (let s = 0; s <= i.length; s++) {
    let o = s ? i[s - 1].to : e, a = s < i.length ? i[s].from : n, l = s ? 256 : r;
    for (let c = o, u = l, d = l; c < a; c++) {
      let h = s$(t.charCodeAt(c));
      h == 512 ? h = u : h == 8 && d == 4 && (h = 16), bt[c] = h == 4 ? 2 : h, h & 7 && (d = h), u = h;
    }
    for (let c = o, u = l, d = l; c < a; c++) {
      let h = bt[c];
      if (h == 128)
        c < a - 1 && u == bt[c + 1] && u & 24 ? h = bt[c] = u : bt[c] = 256;
      else if (h == 64) {
        let f = c + 1;
        for (; f < a && bt[f] == 64; )
          f++;
        let p = c && u == 8 || f < n && bt[f] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let m = c; m < f; m++)
          bt[m] = p;
        c = f - 1;
      } else h == 8 && d == 1 && (bt[c] = 1);
      u = h, h & 7 && (d = h);
    }
  }
}
function Qme(t, e, n, i, r) {
  let s = r == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= i.length; o++) {
    let c = o ? i[o - 1].to : e, u = o < i.length ? i[o].from : n;
    for (let d = c, h, f, p; d < u; d++)
      if (f = uy[h = t.charCodeAt(d)])
        if (f < 0) {
          for (let m = a - 3; m >= 0; m -= 3)
            if (xr[m + 1] == -f) {
              let g = xr[m + 2], b = g & 2 ? r : g & 4 ? g & 1 ? s : r : 0;
              b && (bt[d] = bt[xr[m]] = b), a = m;
              break;
            }
        } else {
          if (xr.length == 189)
            break;
          xr[a++] = d, xr[a++] = h, xr[a++] = l;
        }
      else if ((p = bt[d]) == 2 || p == 1) {
        let m = p == r;
        l = m ? 0 : 1;
        for (let g = a - 3; g >= 0; g -= 3) {
          let b = xr[g + 2];
          if (b & 2)
            break;
          if (m)
            xr[g + 2] |= 2;
          else {
            if (b & 4)
              break;
            xr[g + 2] |= 4;
          }
        }
      }
  }
}
function Fme(t, e, n, i) {
  for (let r = 0, s = i; r <= n.length; r++) {
    let o = r ? n[r - 1].to : t, a = r < n.length ? n[r].from : e;
    for (let l = o; l < a; ) {
      let c = bt[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (r == n.length)
              break;
            u = n[r++].to, a = r < n.length ? n[r].from : e;
          } else if (bt[u] == 256)
            u++;
          else
            break;
        let d = s == 1, h = (u < e ? bt[u] : i) == 1, f = d == h ? d ? 1 : 2 : i;
        for (let p = u, m = r, g = m ? n[m - 1].to : t; p > l; )
          p == g && (p = n[--m].from, g = m ? n[m - 1].to : t), bt[--p] = f;
        l = u;
      } else
        s = c, l++;
    }
  }
}
function dy(t, e, n, i, r, s, o) {
  let a = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let l = e, c = 0; l < n; ) {
      let u = !0, d = !1;
      if (c == s.length || l < s[c].from) {
        let m = bt[l];
        m != a && (u = !1, d = m == 16);
      }
      let h = !u && a == 1 ? [] : null, f = u ? i : i + 1, p = l;
      e: for (; ; )
        if (c < s.length && p == s[c].from) {
          if (d)
            break e;
          let m = s[c];
          if (!u)
            for (let g = m.to, b = c + 1; ; ) {
              if (g == n)
                break e;
              if (b < s.length && s[b].from == g)
                g = s[b++].to;
              else {
                if (bt[g] == a)
                  break e;
                break;
              }
            }
          if (c++, h)
            h.push(m);
          else {
            m.from > l && o.push(new ho(l, m.from, f));
            let g = m.direction == La != !(f % 2);
            hy(t, g ? i + 1 : i, r, m.inner, m.from, m.to, o), l = m.to;
          }
          p = m.to;
        } else {
          if (p == n || (u ? bt[p] != a : bt[p] == a))
            break;
          p++;
        }
      h ? dy(t, l, p, i + 1, r, h, o) : l < p && o.push(new ho(l, p, f)), l = p;
    }
  else
    for (let l = n, c = s.length; l > e; ) {
      let u = !0, d = !1;
      if (!c || l > s[c - 1].to) {
        let m = bt[l - 1];
        m != a && (u = !1, d = m == 16);
      }
      let h = !u && a == 1 ? [] : null, f = u ? i : i + 1, p = l;
      e: for (; ; )
        if (c && p == s[c - 1].to) {
          if (d)
            break e;
          let m = s[--c];
          if (!u)
            for (let g = m.from, b = c; ; ) {
              if (g == e)
                break e;
              if (b && s[b - 1].to == g)
                g = s[--b].from;
              else {
                if (bt[g - 1] == a)
                  break e;
                break;
              }
            }
          if (h)
            h.push(m);
          else {
            m.to < l && o.push(new ho(m.to, l, f));
            let g = m.direction == La != !(f % 2);
            hy(t, g ? i + 1 : i, r, m.inner, m.from, m.to, o), l = m.from;
          }
          p = m.from;
        } else {
          if (p == e || (u ? bt[p - 1] != a : bt[p - 1] == a))
            break;
          p--;
        }
      h ? dy(t, p, l, i + 1, r, h, o) : p < l && o.push(new ho(p, l, f)), l = p;
    }
}
function hy(t, e, n, i, r, s, o) {
  let a = e % 2 ? 2 : 1;
  Bme(t, r, s, i, a), Qme(t, r, s, i, a), Fme(r, s, i, a), dy(t, r, s, e, n, i, o);
}
function zme(t, e, n) {
  if (!t)
    return [new ho(0, 0, e == E_ ? 1 : 0)];
  if (e == La && !n.length && !Lme.test(t))
    return a$(t.length);
  if (n.length)
    for (; t.length > bt.length; )
      bt[bt.length] = 256;
  let i = [], r = e == La ? 0 : 1;
  return hy(t, r, r, n, 0, t.length, i), i;
}
function a$(t) {
  return [new ho(0, t, 0)];
}
let l$ = "";
function Ume(t, e, n, i, r) {
  var s;
  let o = i.head - t.from, a = ho.find(e, o, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc), l = e[a], c = l.side(r, n);
  if (o == c) {
    let h = a += r ? 1 : -1;
    if (h < 0 || h >= e.length)
      return null;
    l = e[a = h], o = l.side(!r, n), c = l.side(r, n);
  }
  let u = bn(t.text, o, l.forward(r, n));
  (u < l.from || u > l.to) && (u = c), l$ = t.text.slice(Math.min(o, u), Math.max(o, u));
  let d = a == (r ? e.length - 1 : 0) ? null : e[a + (r ? 1 : -1)];
  return d && u == c && d.level + (r ? 0 : 1) < l.level ? j.cursor(d.side(!r, n) + t.from, d.forward(r, n) ? 1 : -1, d.level) : j.cursor(u + t.from, l.forward(r, n) ? -1 : 1, l.level);
}
function Wme(t, e, n) {
  for (let i = e; i < n; i++) {
    let r = s$(t.charCodeAt(i));
    if (r == 1)
      return La;
    if (r == 2 || r == 4)
      return E_;
  }
  return La;
}
const c$ = /* @__PURE__ */ de.define(), u$ = /* @__PURE__ */ de.define(), d$ = /* @__PURE__ */ de.define(), h$ = /* @__PURE__ */ de.define(), fy = /* @__PURE__ */ de.define(), f$ = /* @__PURE__ */ de.define(), p$ = /* @__PURE__ */ de.define(), m$ = /* @__PURE__ */ de.define({
  combine: (t) => t.some((e) => e)
}), g$ = /* @__PURE__ */ de.define({
  combine: (t) => t.some((e) => e)
}), b$ = /* @__PURE__ */ de.define();
class Rl {
  constructor(e, n = "nearest", i = "nearest", r = 5, s = 5, o = !1) {
    this.range = e, this.y = n, this.x = i, this.yMargin = r, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new Rl(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Rl(j.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Sf = /* @__PURE__ */ Me.define({ map: (t, e) => t.map(e) }), O$ = /* @__PURE__ */ Me.define();
function ni(t, e, n) {
  let i = t.facet(h$);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
const eo = /* @__PURE__ */ de.define({ combine: (t) => t.length ? t[0] : !0 });
let Vme = 0;
const Jc = /* @__PURE__ */ de.define();
class Ht {
  constructor(e, n, i, r, s) {
    this.id = e, this.create = n, this.domEventHandlers = i, this.domEventObservers = r, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, n) {
    const { eventHandlers: i, eventObservers: r, provide: s, decorations: o } = n || {};
    return new Ht(Vme++, e, i, r, (a) => {
      let l = [Jc.of(a)];
      return o && l.push(Ed.of((c) => {
        let u = c.plugin(a);
        return u ? o(u) : ve.none;
      })), s && l.push(s(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, n) {
    return Ht.define((i) => new e(i), n);
  }
}
class L1 {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (i) {
            if (ni(n.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        ni(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        ni(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const y$ = /* @__PURE__ */ de.define(), C_ = /* @__PURE__ */ de.define(), Ed = /* @__PURE__ */ de.define(), _$ = /* @__PURE__ */ de.define(), A_ = /* @__PURE__ */ de.define(), v$ = /* @__PURE__ */ de.define();
function dC(t, e) {
  let n = t.state.facet(v$);
  if (!n.length)
    return n;
  let i = n.map((s) => s instanceof Function ? s(t) : s), r = [];
  return Ye.spans(i, e.from, e.to, {
    point() {
    },
    span(s, o, a, l) {
      let c = s - e.from, u = o - e.from, d = r;
      for (let h = a.length - 1; h >= 0; h--, l--) {
        let f = a[h].spec.bidiIsolate, p;
        if (f == null && (f = Wme(e.text, c, u)), l > 0 && d.length && (p = d[d.length - 1]).to == c && p.direction == f)
          p.to = u, d = p.inner;
        else {
          let m = { from: c, to: u, direction: f, inner: [] };
          d.push(m), d = m.inner;
        }
      }
    }
  }), r;
}
const x$ = /* @__PURE__ */ de.define();
function w$(t) {
  let e = 0, n = 0, i = 0, r = 0;
  for (let s of t.state.facet(x$)) {
    let o = s(t);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (n = Math.max(n, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (r = Math.max(r, o.bottom)));
  }
  return { left: e, right: n, top: i, bottom: r };
}
const eu = /* @__PURE__ */ de.define();
class Ui {
  constructor(e, n, i, r) {
    this.fromA = e, this.toA = n, this.fromB = i, this.toB = r;
  }
  join(e) {
    return new Ui(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, i = this;
    for (; n > 0; n--) {
      let r = e[n - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, i), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let i = [];
    for (let r = 0, s = 0, o = 0, a = 0; ; r++) {
      let l = r == e.length ? null : e[r], c = o - a, u = l ? l.fromB : 1e9;
      for (; s < n.length && n[s] < u; ) {
        let d = n[s], h = n[s + 1], f = Math.max(a, d), p = Math.min(u, h);
        if (f <= p && new Ui(f + c, p + c, f, p).addToSet(i), h > u)
          break;
        s += 2;
      }
      if (!l)
        return i;
      new Ui(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), o = l.toA, a = l.toB;
    }
  }
}
class Im {
  constructor(e, n, i) {
    this.view = e, this.state = n, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = Xt.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let r = [];
    this.changes.iterChangedRanges((s, o, a, l) => r.push(new Ui(s, o, a, l))), this.changedRanges = r;
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new Im(e, n, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class hC extends _t {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = ve.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Ut()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Ui(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var n;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let r = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? r = this.domChanged.newSel.head : !Gme(e.changes, this.hasComposition) && !e.selectionSet && (r = e.state.selection.main.head));
    let s = r > -1 ? Hme(this.view, e.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      i = new Ui(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(i.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (ue.ie || ue.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = jme(o, a, e.changes);
    return i = Ui.extendWithRanges(i, l), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, n, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, i);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = ue.chrome || ue.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || r.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Cs && o.widget instanceof fC && s.push(o.dom);
    r.updateGaps(s);
  }
  updateChildren(e, n, i) {
    let r = i ? i.range.addToSet(e.slice()) : e, s = this.childCursor(n);
    for (let o = r.length - 1; ; o--) {
      let a = o >= 0 ? r[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: d } = a, h, f, p, m;
      if (i && i.range.fromB < d && i.range.toB > u) {
        let O = Au.build(this.view.state.doc, u, i.range.fromB, this.decorations, this.dynamicDecorationMap), x = Au.build(this.view.state.doc, i.range.toB, d, this.decorations, this.dynamicDecorationMap);
        f = O.breakAtStart, p = O.openStart, m = x.openEnd;
        let v = this.compositionView(i);
        x.breakAtStart ? v.breakAfter = 1 : x.content.length && v.merge(v.length, v.length, x.content[0], !1, x.openStart, 0) && (v.breakAfter = x.content[0].breakAfter, x.content.shift()), O.content.length && v.merge(0, 0, O.content[O.content.length - 1], !0, 0, O.openEnd) && O.content.pop(), h = O.content.concat(v).concat(x.content);
      } else
        ({ content: h, breakAtStart: f, openStart: p, openEnd: m } = Au.build(this.view.state.doc, u, d, this.decorations, this.dynamicDecorationMap));
      let { i: g, off: b } = s.findPos(c, 1), { i: _, off: y } = s.findPos(l, -1);
      Y4(this, _, y, g, b, h, f, p, m);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions)
      for (let i of n.effects)
        i.is(O$) && (this.editContextFormatting = i.value);
  }
  compositionView(e) {
    let n = new hr(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: r } of e.marks)
      n = new Ps(r, [n], n.length);
    let i = new Ut();
    return i.append(n, 0), i;
  }
  fixCompositionDOM(e) {
    let n = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = _t.get(s);
      a && a != o && (a.dom = null), o.setDOM(s);
    }, i = this.childPos(e.range.fromB, 1), r = this.children[i.i];
    n(e.line, r);
    for (let s = e.marks.length - 1; s >= -1; s--)
      i = r.childPos(i.off, 1), r = r.children[i.i], n(s >= 0 ? e.marks[s].node : e.text, r);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, r = i == this.dom, s = !r && sp(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(r || n || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (ue.gecko && a.empty && !this.hasComposition && Zme(l)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(d, l.node.childNodes[l.offset] || null)), l = c = new Sn(d, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!Cu(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Cu(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      ue.android && ue.chrome && this.dom.contains(u.focusNode) && Yme(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = Sd(this.view.root);
      if (d) if (a.empty) {
        if (ue.gecko) {
          let h = qme(l.node, l.offset);
          if (h && h != 3) {
            let f = (h == 1 ? q4 : X4)(l.node, l.offset);
            f && (l = new Sn(f.node, f.offset));
          }
        }
        d.collapse(l.node, l.offset), a.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = a.bidiLevel);
      } else if (d.extend) {
        d.collapse(l.node, l.offset);
        try {
          d.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let h = document.createRange();
        a.anchor > a.head && ([l, c] = [c, l]), h.setEnd(c.node, c.offset), h.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(h);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new Sn(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Sn(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, n) {
    return this.hasComposition && n.empty && Cu(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, i = Sd(e.root), { anchorNode: r, anchorOffset: s } = e.observer.selectionRange;
    if (!i || !n.empty || !n.assoc || !i.modify)
      return;
    let o = Ut.find(this, n.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (n.head == a || n.head == a + o.length)
      return;
    let l = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(n.head + n.assoc);
    i.collapse(u.node, u.offset), i.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != n.from && i.collapse(r, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let n = this.dom, i;
    if (e.node != n)
      return e;
    for (let r = e.offset; !i && r < n.childNodes.length; r++) {
      let s = _t.get(n.childNodes[r]);
      s instanceof Ut && (i = s.domAtPos(0));
    }
    for (let r = e.offset - 1; !i && r >= 0; r--) {
      let s = _t.get(n.childNodes[r]);
      s instanceof Ut && (i = s.domAtPos(s.length));
    }
    return i ? new Sn(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let i = _t.get(n);
      if (i && i.rootView == this)
        return i;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, n) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: i } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let r = this.children[n];
      if (i < r.length || r instanceof Ut)
        break;
      n++, i = 0;
    }
    return this.children[n].domAtPos(i);
  }
  coordsAt(e, n) {
    let i = null, r = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = s - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!i || a instanceof Ut && !(i instanceof Ut && n >= 0)))
        i = a, r = c;
      else if (i && c == e && l == e && a instanceof Cs && Math.abs(n) < 2) {
        if (a.deco.startSide < 0)
          break;
        o && (i = null);
      }
      s = c;
    }
    return i ? i.coordsAt(e - r, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: i } = this.childPos(e, 1), r = this.children[n];
    if (!(r instanceof Ut))
      return null;
    for (; r.children.length; ) {
      let { i: a, off: l } = r.childPos(i, 1);
      for (; ; a++) {
        if (a == r.children.length)
          return null;
        if ((r = r.children[a]).length)
          break;
      }
      i = l;
    }
    if (!(r instanceof hr))
      return null;
    let s = bn(r.text, i);
    if (s == i)
      return null;
    let o = Ia(r.dom, i, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: i, to: r } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == At.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let d = this.children[u], h = c + d.length;
      if (h > r)
        break;
      if (c >= i) {
        let f = d.dom.getBoundingClientRect();
        if (n.push(f.height), o) {
          let p = d.dom.lastChild, m = p ? kd(p) : [];
          if (m.length) {
            let g = m[m.length - 1], b = l ? g.right - f.left : f.right - g.left;
            b > a && (a = b, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = h);
          }
        }
      }
      c = h + d.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? At.RTL : At.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Ut) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), n, i, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = kd(e.firstChild)[0];
      n = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, r = s ? s.height : n, e.remove();
    }), { lineHeight: n, charWidth: i, textHeight: r };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new j4(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let s = r == n.viewports.length ? null : n.viewports[r], o = s ? s.from - 1 : this.length;
      if (o > i) {
        let a = (n.lineBlockAt(o).bottom - n.lineBlockAt(i).top) / this.view.scaleY;
        e.push(ve.replace({
          widget: new fC(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return ve.set(e);
  }
  updateDeco() {
    let e = 1, n = this.view.state.facet(Ed).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), i = !1, r = this.view.state.facet(_$).map((s, o) => {
      let a = typeof s == "function";
      return a && (i = !0), a ? s(this.view) : s;
    });
    for (r.length && (this.dynamicDecorationMap[e++] = i, n.push(Ye.join(r))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(b$))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (u) {
        ni(this.view.state, u, "scroll handler");
      }
    let { range: n } = e, i = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), r;
    if (!i)
      return;
    !n.empty && (r = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let s = w$(this.view), o = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    kme(this.view.scrollDOM, o, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == At.LTR);
  }
}
function Zme(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class fC extends Ns {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function S$(t, e) {
  let n = t.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let i = q4(n.focusNode, n.focusOffset), r = X4(n.focusNode, n.focusOffset), s = i || r;
  if (r && i && r.node != i.node) {
    let a = _t.get(r.node);
    if (!a || a instanceof hr && a.text != r.node.nodeValue)
      s = r;
    else if (t.docView.lastCompositionAfterCursor) {
      let l = _t.get(i.node);
      !l || l instanceof hr && l.text != i.node.nodeValue || (s = r);
    }
  }
  if (t.docView.lastCompositionAfterCursor = s != i, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function Hme(t, e, n) {
  let i = S$(t, n);
  if (!i)
    return null;
  let { node: r, from: s, to: o } = i, a = r.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(i.from, i.to) != a)
    return null;
  let l = e.invertedDesc, c = new Ui(l.mapPos(s), l.mapPos(o), s, o), u = [];
  for (let d = r.parentNode; ; d = d.parentNode) {
    let h = _t.get(d);
    if (h instanceof Ps)
      u.push({ node: d, deco: h.mark });
    else {
      if (h instanceof Ut || d.nodeName == "DIV" && d.parentNode == t.contentDOM)
        return { range: c, text: r, marks: u, line: d };
      if (d != t.contentDOM)
        u.push({ node: d, deco: new dh({
          inclusive: !0,
          attributes: $me(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function qme(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let Xme = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    cy(e, n, this.changes);
  }
  comparePoint(e, n) {
    cy(e, n, this.changes);
  }
};
function jme(t, e, n) {
  let i = new Xme();
  return Ye.compare(t, e, n, i), i.changes;
}
function Yme(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function Gme(t, e) {
  let n = !1;
  return e && t.iterChangedRanges((i, r) => {
    i < e.to && r > e.from && (n = !0);
  }), n;
}
function Kme(t, e, n = 1) {
  let i = t.charCategorizer(e), r = t.doc.lineAt(e), s = e - r.from;
  if (r.length == 0)
    return j.cursor(e);
  s == 0 ? n = 1 : s == r.length && (n = -1);
  let o = s, a = s;
  n < 0 ? o = bn(r.text, s, !1) : a = bn(r.text, s);
  let l = i(r.text.slice(o, a));
  for (; o > 0; ) {
    let c = bn(r.text, o, !1);
    if (i(r.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < r.length; ) {
    let c = bn(r.text, a);
    if (i(r.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return j.range(o + r.from, a + r.from);
}
function Jme(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function e0e(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function B1(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function pC(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function mC(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function py(t, e, n) {
  let i, r, s, o, a = !1, l, c, u, d;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let m = kd(p);
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      r && B1(r, b) && (b = pC(mC(b, r.bottom), r.top));
      let _ = Jme(e, b), y = e0e(n, b);
      if (_ == 0 && y == 0)
        return p.nodeType == 3 ? gC(p, e, n) : py(p, e, n);
      if (!i || o > y || o == y && s > _) {
        i = p, r = b, s = _, o = y;
        let O = y ? n < b.top ? -1 : 1 : _ ? e < b.left ? -1 : 1 : 0;
        a = !O || (O > 0 ? g < m.length - 1 : g > 0);
      }
      _ == 0 ? n > b.bottom && (!u || u.bottom < b.bottom) ? (l = p, u = b) : n < b.top && (!d || d.top > b.top) && (c = p, d = b) : u && B1(u, b) ? u = mC(u, b.bottom) : d && B1(d, b) && (d = pC(d, b.top));
    }
  }
  if (u && u.bottom >= n ? (i = l, r = u) : d && d.top <= n && (i = c, r = d), !i)
    return { node: t, offset: 0 };
  let h = Math.max(r.left, Math.min(r.right, e));
  if (i.nodeType == 3)
    return gC(i, h, n);
  if (a && i.contentEditable != "false")
    return py(i, h, n);
  let f = Array.prototype.indexOf.call(t.childNodes, i) + (e >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: t, offset: f };
}
function gC(t, e, n) {
  let i = t.nodeValue.length, r = -1, s = 1e9, o = 0;
  for (let a = 0; a < i; a++) {
    let l = Ia(t, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let d = (u.top > n ? u.top - n : n - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && d < s) {
        let h = e >= (u.left + u.right) / 2, f = h;
        if ((ue.chrome || ue.gecko) && Ia(t, a).getBoundingClientRect().left == u.right && (f = !h), d <= 0)
          return { node: t, offset: a + (f ? 1 : 0) };
        r = a + (f ? 1 : 0), s = d;
      }
    }
  }
  return { node: t, offset: r > -1 ? r : o > 0 ? t.nodeValue.length : 0 };
}
function k$(t, e, n, i = -1) {
  var r, s;
  let o = t.contentDOM.getBoundingClientRect(), a = o.top + t.viewState.paddingTop, l, { docHeight: c } = t.viewState, { x: u, y: d } = e, h = d - a;
  if (h < 0)
    return 0;
  if (h > c)
    return t.state.doc.length;
  for (let O = t.viewState.heightOracle.textHeight / 2, x = !1; l = t.elementAtHeight(h), l.type != Bn.Text; )
    for (; h = i > 0 ? l.bottom + O : l.top - O, !(h >= 0 && h <= c); ) {
      if (x)
        return n ? null : 0;
      x = !0, i = -i;
    }
  d = a + h;
  let f = l.from;
  if (f < t.viewport.from)
    return t.viewport.from == 0 ? 0 : n ? null : bC(t, o, l, u, d);
  if (f > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : bC(t, o, l, u, d);
  let p = t.dom.ownerDocument, m = t.root.elementFromPoint ? t.root : p, g = m.elementFromPoint(u, d);
  g && !t.contentDOM.contains(g) && (g = null), g || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), g = m.elementFromPoint(u, d), g && !t.contentDOM.contains(g) && (g = null));
  let b, _ = -1;
  if (g && ((r = t.docView.nearest(g)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let O = p.caretPositionFromPoint(u, d);
      O && ({ offsetNode: b, offset: _ } = O);
    } else if (p.caretRangeFromPoint) {
      let O = p.caretRangeFromPoint(u, d);
      O && ({ startContainer: b, startOffset: _ } = O, (!t.contentDOM.contains(b) || ue.safari && t0e(b, _, u) || ue.chrome && n0e(b, _, u)) && (b = void 0));
    }
  }
  if (!b || !t.docView.dom.contains(b)) {
    let O = Ut.find(t.docView, f);
    if (!O)
      return h > l.top + l.height / 2 ? l.to : l.from;
    ({ node: b, offset: _ } = py(O.dom, u, d));
  }
  let y = t.docView.nearest(b);
  if (!y)
    return null;
  if (y.isWidget && ((s = y.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let O = y.dom.getBoundingClientRect();
    return e.y < O.top || e.y <= O.bottom && e.x <= (O.left + O.right) / 2 ? y.posAtStart : y.posAtEnd;
  } else
    return y.localPosFromDOM(b, _) + y.posAtStart;
}
function bC(t, e, n, i, r) {
  let s = Math.round((i - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, l = Math.floor((r - n.top - (t.defaultLineHeight - a) * 0.5) / a);
    s += l * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(n.from, n.to);
  return n.from + ey(o, s, t.state.tabSize);
}
function t0e(t, e, n) {
  let i;
  if (t.nodeType != 3 || e != (i = t.nodeValue.length))
    return !1;
  for (let r = t.nextSibling; r; r = r.nextSibling)
    if (r.nodeType != 1 || r.nodeName != "BR")
      return !1;
  return Ia(t, i - 1, i).getBoundingClientRect().left > n;
}
function n0e(t, e, n) {
  if (e != 0)
    return !1;
  for (let r = t; ; ) {
    let s = r.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != r)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    r = s;
  }
  let i = t.nodeType == 1 ? t.getBoundingClientRect() : Ia(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - i.left > 5;
}
function my(t, e) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let i of n.type)
      if (i.to > e || i.to == e && (i.to == n.to || i.type == Bn.Text))
        return i;
  }
  return n;
}
function i0e(t, e, n, i) {
  let r = my(t, e.head), s = !i || r.type != Bn.Text || !(t.lineWrapping || r.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(), a = t.textDirectionAt(r.from), l = t.posAtCoords({
      x: n == (a == At.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return j.cursor(l, n ? -1 : 1);
  }
  return j.cursor(n ? r.to : r.from, n ? -1 : 1);
}
function OC(t, e, n, i) {
  let r = t.state.doc.lineAt(e.head), s = t.bidiSpans(r), o = t.textDirectionAt(r.from);
  for (let a = e, l = null; ; ) {
    let c = Ume(r, s, o, a, n), u = l$;
    if (!c) {
      if (r.number == (n ? t.state.doc.lines : 1))
        return a;
      u = `
`, r = t.state.doc.line(r.number + (n ? 1 : -1)), s = t.bidiSpans(r), c = t.visualLineSide(r, !n);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!i)
        return c;
      l = i(u);
    }
    a = c;
  }
}
function r0e(t, e, n) {
  let i = t.state.charCategorizer(e), r = i(n);
  return (s) => {
    let o = i(s);
    return r == Mt.Space && (r = o), r == o;
  };
}
function s0e(t, e, n, i) {
  let r = e.head, s = n ? 1 : -1;
  if (r == (n ? t.state.doc.length : 0))
    return j.cursor(r, e.assoc);
  let o = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(r, e.assoc || -1), u = t.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = s < 0 ? c.top : c.bottom;
  else {
    let f = t.viewState.lineBlockAt(r);
    o == null && (o = Math.min(l.right - l.left, t.defaultCharacterWidth * (r - f.from))), a = (s < 0 ? f.top : f.bottom) + u;
  }
  let d = l.left + o, h = i ?? t.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let p = a + (h + f) * s, m = k$(t, { x: d, y: p }, !1, s);
    if (p < l.top || p > l.bottom || (s < 0 ? m < r : m > r)) {
      let g = t.docView.coordsForChar(m), b = !g || p < g.top ? -1 : 1;
      return j.cursor(m, b, void 0, o);
    }
  }
}
function op(t, e, n) {
  for (; ; ) {
    let i = 0;
    for (let r of t)
      r.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = i || n || (e - s < o - e ? -1 : 1);
          e = l < 0 ? s : o, i = l;
        }
      });
    if (!i)
      return e;
  }
}
function Q1(t, e, n) {
  let i = op(t.state.facet(A_).map((r) => r(t)), n.from, e.head > n.from ? -1 : 1);
  return i == n.from ? n : j.cursor(i, i < n.from ? 1 : -1);
}
class o0e {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, ue.safari && e.contentDOM.addEventListener("input", () => null), ue.gecko && x0e(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !p0e(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let i = this.handlers[e];
    if (i) {
      for (let r of i.observers)
        r(this.view, n);
      for (let r of i.handlers) {
        if (n.defaultPrevented)
          break;
        if (r(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = a0e(e), i = this.handlers, r = this.view.contentDOM;
    for (let s in n)
      if (s != "scroll") {
        let o = !n[s].handlers.length, a = i[s];
        a && o != !a.handlers.length && (r.removeEventListener(s, this.handleEvent), a = null), a || r.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in i)
      s != "scroll" && !n[s] && r.removeEventListener(s, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && C$.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), ue.android && ue.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return ue.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = E$.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || l0e.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Pl(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : ue.safari && !ue.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function yC(t, e) {
  return (n, i) => {
    try {
      return e.call(t, i, n);
    } catch (r) {
      ni(n.state, r);
    }
  };
}
function a0e(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of t) {
    let r = i.spec;
    if (r && r.domEventHandlers)
      for (let s in r.domEventHandlers) {
        let o = r.domEventHandlers[s];
        o && n(s).handlers.push(yC(i.value, o));
      }
    if (r && r.domEventObservers)
      for (let s in r.domEventObservers) {
        let o = r.domEventObservers[s];
        o && n(s).observers.push(yC(i.value, o));
      }
  }
  for (let i in fr)
    n(i).handlers.push(fr[i]);
  for (let i in Yi)
    n(i).observers.push(Yi[i]);
  return e;
}
const E$ = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], l0e = "dthko", C$ = [16, 17, 18, 20, 91, 92, 224, 225], kf = 6;
function Ef(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function c0e(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class u0e {
  constructor(e, n, i, r) {
    this.view = e, this.startEvent = n, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = Eme(e.contentDOM), this.atoms = e.state.facet(A_).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(je.allowMultipleSelections) && d0e(e, n), this.dragging = f0e(e, n) && M$(n) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && c0e(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, i = 0, r = 0, s = 0, o = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: r, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = w$(this.view);
    e.clientX - l.left <= r + kf ? n = -Ef(r - e.clientX) : e.clientX + l.right >= o - kf && (n = Ef(e.clientX - o)), e.clientY - l.top <= s + kf ? i = -Ef(s - e.clientY) : e.clientY + l.bottom >= a - kf && (i = Ef(e.clientY - a)), this.setScrollSpeed(n, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: n } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let r = e.ranges[i], s = null;
      if (r.empty) {
        let o = op(this.atoms, r.from, 0);
        o != r.from && (s = j.cursor(o, -1));
      } else {
        let o = op(this.atoms, r.from, -1), a = op(this.atoms, r.to, 1);
        (o != r.from || a != r.to) && (s = j.range(r.from == r.anchor ? o : a, r.from == r.head ? o : a));
      }
      s && (n || (n = e.ranges.slice()), n[i] = s);
    }
    return n ? j.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function d0e(t, e) {
  let n = t.state.facet(c$);
  return n.length ? n[0](e) : ue.mac ? e.metaKey : e.ctrlKey;
}
function h0e(t, e) {
  let n = t.state.facet(u$);
  return n.length ? n[0](e) : ue.mac ? !e.altKey : !e.ctrlKey;
}
function f0e(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty)
    return !1;
  let i = Sd(t.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function p0e(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target, i; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (i = _t.get(n)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const fr = /* @__PURE__ */ Object.create(null), Yi = /* @__PURE__ */ Object.create(null), A$ = ue.ie && ue.ie_version < 15 || ue.ios && ue.webkit_version < 604;
function m0e(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    t.focus(), n.remove(), T$(t, n.value);
  }, 50);
}
function T$(t, e) {
  let { state: n } = t, i, r = 1, s = n.toText(e), o = s.lines == n.selection.ranges.length;
  if (gy != null && n.selection.ranges.every((l) => l.empty) && gy == s.toString()) {
    let l = -1;
    i = n.changeByRange((c) => {
      let u = n.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let d = n.toText((o ? s.line(r++).text : e) + n.lineBreak);
      return {
        changes: { from: u.from, insert: d },
        range: j.cursor(c.from + d.length)
      };
    });
  } else o ? i = n.changeByRange((l) => {
    let c = s.line(r++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: j.cursor(l.from + c.length)
    };
  }) : i = n.replaceSelection(s);
  t.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Yi.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
fr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
Yi.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
Yi.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
fr.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let i of t.state.facet(d$))
    if (n = i(t, e), n)
      break;
  if (!n && e.button == 0 && (n = O0e(t, e)), n) {
    let i = !t.hasFocus;
    t.inputState.startMouseSelection(new u0e(t, e, n, i)), i && t.observer.ignore(() => {
      V4(t.contentDOM);
      let s = t.root.activeElement;
      s && !s.contains(t.contentDOM) && s.blur();
    });
    let r = t.inputState.mouseSelection;
    if (r)
      return r.start(e), r.dragging === !1;
  }
  return !1;
};
function _C(t, e, n, i) {
  if (i == 1)
    return j.cursor(e, n);
  if (i == 2)
    return Kme(t.state, e, n);
  {
    let r = Ut.find(t.docView, e), s = t.state.doc.lineAt(r ? r.posAtEnd : e), o = r ? r.posAtStart : s.from, a = r ? r.posAtEnd : s.to;
    return a < t.state.doc.length && a == s.to && a++, j.range(o, a);
  }
}
let vC = (t, e, n) => e >= n.top && e <= n.bottom && t >= n.left && t <= n.right;
function g0e(t, e, n, i) {
  let r = Ut.find(t.docView, e);
  if (!r)
    return 1;
  let s = e - r.posAtStart;
  if (s == 0)
    return 1;
  if (s == r.length)
    return -1;
  let o = r.coordsAt(s, -1);
  if (o && vC(n, i, o))
    return -1;
  let a = r.coordsAt(s, 1);
  return a && vC(n, i, a) ? 1 : o && o.bottom >= i ? -1 : 1;
}
function xC(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: g0e(t, n, e.clientX, e.clientY) };
}
const b0e = ue.ie && ue.ie_version <= 11;
let wC = null, SC = 0, kC = 0;
function M$(t) {
  if (!b0e)
    return t.detail;
  let e = wC, n = kC;
  return wC = t, kC = Date.now(), SC = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (SC + 1) % 3 : 1;
}
function O0e(t, e) {
  let n = xC(t, e), i = M$(e), r = t.state.selection;
  return {
    update(s) {
      s.docChanged && (n.pos = s.changes.mapPos(n.pos), r = r.map(s.changes));
    },
    get(s, o, a) {
      let l = xC(t, s), c, u = _C(t, l.pos, l.bias, i);
      if (n.pos != l.pos && !o) {
        let d = _C(t, n.pos, n.bias, i), h = Math.min(d.from, u.from), f = Math.max(d.to, u.to);
        u = h < u.from ? j.range(h, f) : j.range(f, h);
      }
      return o ? r.replaceRange(r.main.extend(u.from, u.to)) : a && i == 1 && r.ranges.length > 1 && (c = y0e(r, l.pos)) ? c : a ? r.addRange(u) : j.create([u]);
    }
  };
}
function y0e(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: i, to: r } = t.ranges[n];
    if (i <= e && r >= e)
      return j.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
fr.dragstart = (t, e) => {
  let { selection: { main: n } } = t.state;
  if (e.target.draggable) {
    let r = t.docView.nearest(e.target);
    if (r && r.isWidget) {
      let s = r.posAtStart, o = s + r.length;
      (s >= n.to || o <= n.from) && (n = j.range(s, o));
    }
  }
  let { inputState: i } = t;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(n.from, n.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
fr.dragend = (t) => (t.inputState.draggedContent = null, !1);
function EC(t, e, n, i) {
  if (!n)
    return;
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, o = i && s && h0e(t, e) ? { from: s.from, to: s.to } : null, a = { from: r, insert: n }, l = t.state.changes(o ? [o, a] : a);
  t.focus(), t.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(r, -1), head: l.mapPos(r, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
fr.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let i = Array(n.length), r = 0, s = () => {
      ++r == n.length && EC(t, e, i.filter((o) => o != null).join(t.state.lineBreak), !1);
    };
    for (let o = 0; o < n.length; o++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (i[o] = a.result), s();
      }, a.readAsText(n[o]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return EC(t, e, i, !0), !0;
  }
  return !1;
};
fr.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let n = A$ ? null : e.clipboardData;
  return n ? (T$(t, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (m0e(t), !1);
};
function _0e(t, e) {
  let n = t.dom.parentNode;
  if (!n)
    return;
  let i = n.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), t.focus();
  }, 50);
}
function v0e(t) {
  let e = [], n = [], i = !1;
  for (let r of t.selection.ranges)
    r.empty || (e.push(t.sliceDoc(r.from, r.to)), n.push(r));
  if (!e.length) {
    let r = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > r && (e.push(o.text), n.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), r = o.number;
    }
    i = !0;
  }
  return { text: e.join(t.lineBreak), ranges: n, linewise: i };
}
let gy = null;
fr.copy = fr.cut = (t, e) => {
  let { text: n, ranges: i, linewise: r } = v0e(t.state);
  if (!n && !r)
    return !1;
  gy = r ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = A$ ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", n), !0) : (_0e(t, n), !1);
};
const P$ = /* @__PURE__ */ $s.define();
function R$(t, e) {
  let n = [];
  for (let i of t.facet(p$)) {
    let r = i(t, e);
    r && n.push(r);
  }
  return n ? t.update({ effects: n, annotations: P$.of(!0) }) : null;
}
function $$(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = R$(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
Yi.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), $$(t);
};
Yi.blur = (t) => {
  t.observer.clearSelectionRange(), $$(t);
};
Yi.compositionstart = Yi.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
Yi.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, ue.chrome && ue.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
Yi.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
fr.beforeinput = (t, e) => {
  var n;
  let i;
  if (ue.chrome && ue.android && (i = E$.find((r) => r.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let r = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > r + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return ue.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), ue.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => Yi.compositionend(t, e), 20), !1;
};
const CC = /* @__PURE__ */ new Set();
function x0e(t) {
  CC.has(t) || (CC.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const AC = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let sc = !1;
function TC() {
  sc = !1;
}
class w0e {
  constructor(e) {
    this.lineWrapping = e, this.doc = Ge.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, n) {
    let i = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((n - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return AC.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (n = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return n;
  }
  refresh(e, n, i, r, s, o) {
    let a = AC.indexOf(e) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = i, this.textHeight = r, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class S0e {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class $r {
  /**
  @internal
  */
  constructor(e, n, i, r, s) {
    this.from = e, this.length = n, this.top = i, this.height = r, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Bn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Mo ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new $r(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var Ct = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(Ct || (Ct = {}));
const ap = 1e-3;
class Qn {
  constructor(e, n, i = 2) {
    this.length = e, this.height = n, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > ap && (sc = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, n, i) {
    return Qn.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, i, r) {
    let s = this, o = i.doc;
    for (let a = r.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: d } = r[a], h = s.lineAt(l, Ct.ByPosNoHeight, i.setDoc(n), 0, 0), f = h.to >= c ? h : s.lineAt(c, Ct.ByPosNoHeight, i, 0, 0);
      for (d += f.to - c, c = f.to; a > 0 && h.from <= r[a - 1].toA; )
        l = r[a - 1].fromA, u = r[a - 1].fromB, a--, l < h.from && (h = s.lineAt(l, Ct.ByPosNoHeight, i, 0, 0));
      u += h.from - l, l = h.from;
      let p = T_.build(i.setDoc(o), e, u, d);
      s = Lm(s, s.replace(l, c, p));
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new gi(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, i = e.length, r = 0, s = 0;
    for (; ; )
      if (n == i)
        if (r > s * 2) {
          let a = e[n - 1];
          a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), i += 1 + a.break, r -= a.size;
        } else if (s > r * 2) {
          let a = e[i];
          a.break ? e.splice(i, 1, a.left, null, a.right) : e.splice(i, 1, a.left, a.right), i += 2 + a.break, s -= a.size;
        } else
          break;
      else if (r < s) {
        let a = e[n++];
        a && (r += a.size);
      } else {
        let a = e[--i];
        a && (s += a.size);
      }
    let o = 0;
    return e[n - 1] == null ? (o = 1, n--) : e[n] == null && (o = 1, i++), new k0e(Qn.of(e.slice(0, n)), o, Qn.of(e.slice(i)));
  }
}
function Lm(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (sc = !0), e);
}
Qn.prototype.size = 1;
class N$ extends Qn {
  constructor(e, n, i) {
    super(e, n), this.deco = i;
  }
  blockAt(e, n, i, r) {
    return new $r(r, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, n, i, r, s) {
    return this.blockAt(0, i, r, s);
  }
  forEachLine(e, n, i, r, s, o) {
    e <= s + this.length && n >= s && o(this.blockAt(0, i, r, s));
  }
  updateHeight(e, n = 0, i = !1, r) {
    return r && r.from <= n && r.more && this.setHeight(r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class gi extends N$ {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, i, r) {
    return new $r(r, this.length, i, this.height, this.breaks);
  }
  replace(e, n, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof gi || r instanceof dn && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof dn ? r = new gi(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : Qn.of(i);
  }
  updateHeight(e, n = 0, i = !1, r) {
    return r && r.from <= n && r.more ? this.setHeight(r.heights[r.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class dn extends Qn {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let i = e.doc.lineAt(n).number, r = e.doc.lineAt(n + this.length).number, s = r - i + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: i, lastLine: r, perLine: o, perChar: a };
  }
  blockAt(e, n, i, r) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(n, r);
    if (n.lineWrapping) {
      let c = r + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length)), u = n.doc.lineAt(c), d = a + u.length * l, h = Math.max(i, e - d / 2);
      return new $r(u.from, u.length, h, d, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - i) / a))), { from: u, length: d } = n.doc.line(s + c);
      return new $r(u, d, i + a * c, a, 0);
    }
  }
  lineAt(e, n, i, r, s) {
    if (n == Ct.ByHeight)
      return this.blockAt(e, i, r, s);
    if (n == Ct.ByPosNoHeight) {
      let { from: f, to: p } = i.doc.lineAt(e);
      return new $r(f, p - f, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(i, s), c = i.doc.lineAt(e), u = a + c.length * l, d = c.number - o, h = r + a * d + l * (c.from - s - d);
    return new $r(c.from, c.length, Math.max(r, Math.min(h, r + this.height - u)), u, 0);
  }
  forEachLine(e, n, i, r, s, o) {
    e = Math.max(e, s), n = Math.min(n, s + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(i, s);
    for (let u = e, d = r; u <= n; ) {
      let h = i.doc.lineAt(u);
      if (u == e) {
        let p = h.number - a;
        d += l * p + c * (e - s - p);
      }
      let f = l + c * h.length;
      o(new $r(h.from, h.length, d, f, 0)), d += f, u = h.to + 1;
    }
  }
  replace(e, n, i) {
    let r = this.length - n;
    if (r > 0) {
      let s = i[i.length - 1];
      s instanceof dn ? i[i.length - 1] = new dn(s.length + r) : i.push(null, new dn(r - 1));
    }
    if (e > 0) {
      let s = i[0];
      s instanceof dn ? i[0] = new dn(e + s.length) : i.unshift(new dn(e - 1), null);
    }
    return Qn.of(i);
  }
  decomposeLeft(e, n) {
    n.push(new dn(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new dn(this.length - e - 1));
  }
  updateHeight(e, n = 0, i = !1, r) {
    let s = n + this.length;
    if (r && r.from <= n + this.length && r.more) {
      let o = [], a = Math.max(n, r.from), l = -1;
      for (r.from > n && o.push(new dn(r.from - n - 1).updateHeight(e, n)); a <= s && r.more; ) {
        let u = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let d = r.heights[r.index++];
        l == -1 ? l = d : Math.abs(d - l) >= ap && (l = -2);
        let h = new gi(u, d);
        h.outdated = !1, o.push(h), a += u + 1;
      }
      a <= s && o.push(null, new dn(s - a).updateHeight(e, a));
      let c = Qn.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= ap || Math.abs(l - this.heightMetrics(e, n).perLine) >= ap) && (sc = !0), Lm(this, c);
    } else (i || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class k0e extends Qn {
  constructor(e, n, i) {
    super(e.length + n + i.length, e.height + i.height, n | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, i, r) {
    let s = i + this.left.height;
    return e < s ? this.left.blockAt(e, n, i, r) : this.right.blockAt(e, n, s, r + this.left.length + this.break);
  }
  lineAt(e, n, i, r, s) {
    let o = r + this.left.height, a = s + this.left.length + this.break, l = n == Ct.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, n, i, r, s) : this.right.lineAt(e, n, i, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = n == Ct.ByPosNoHeight ? Ct.ByPosNoHeight : Ct.ByPos;
    return l ? c.join(this.right.lineAt(a, u, i, o, a)) : this.left.lineAt(a, u, i, r, s).join(c);
  }
  forEachLine(e, n, i, r, s, o) {
    let a = r + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, n, i, r, s, o), n >= l && this.right.forEachLine(e, n, i, a, l, o);
    else {
      let c = this.lineAt(l, Ct.ByPos, i, r, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, i, r, s, o), c.to >= e && c.from <= n && o(c), n > c.to && this.right.forEachLine(c.to + 1, n, i, a, l, o);
    }
  }
  replace(e, n, i) {
    let r = this.left.length + this.break;
    if (n < r)
      return this.balanced(this.left.replace(e, n, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - r, n - r, i));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let a of i)
      s.push(a);
    if (e > 0 && MC(s, o - 1), n < this.length) {
      let a = s.length;
      this.decomposeRight(n, s), MC(s, a);
    }
    return Qn.of(s);
  }
  decomposeLeft(e, n) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (i++, e >= i && n.push(null)), e > i && this.right.decomposeLeft(e - i, n);
  }
  decomposeRight(e, n) {
    let i = this.left.length, r = i + this.break;
    if (e >= r)
      return this.right.decomposeRight(e - r, n);
    e < i && this.left.decomposeRight(e, n), this.break && e < r && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? Qn.of(this.break ? [e, null, n] : [e, n]) : (this.left = Lm(this.left, e), this.right = Lm(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, i = !1, r) {
    let { left: s, right: o } = this, a = n + s.length + this.break, l = null;
    return r && r.from <= n + s.length && r.more ? l = s = s.updateHeight(e, n, i, r) : s.updateHeight(e, n, i), r && r.from <= a + o.length && r.more ? l = o = o.updateHeight(e, a, i, r) : o.updateHeight(e, a, i), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function MC(t, e) {
  let n, i;
  t[e] == null && (n = t[e - 1]) instanceof dn && (i = t[e + 1]) instanceof dn && t.splice(e - 1, 3, new dn(n.length + 1 + i.length));
}
const E0e = 5;
class T_ {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let i = Math.min(n, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof gi ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new gi(i - this.pos, -1)), this.writtenTo = i, n > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, i) {
    if (e < n || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let o = n - e;
      i.block ? this.addBlock(new N$(o, r, i)) : (o || s || r >= E0e) && this.addLineDeco(r, s, o);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new gi(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let i = new dn(n - e);
    return this.oracle.doc.lineAt(e).to == n && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof gi)
      return e;
    let n = new gi(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += n, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof gi) && !this.isCovered ? this.nodes.push(new gi(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let r of this.nodes)
      r instanceof gi && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, n, i, r) {
    let s = new T_(i, e);
    return Ye.spans(n, i, r, s, 0), s.finish(i);
  }
}
function C0e(t, e, n) {
  let i = new A0e();
  return Ye.compare(t, e, n, i, 0), i.changes;
}
class A0e {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, i, r) {
    (e < n || i && i.heightRelevant || r && r.heightRelevant) && cy(e, n, this.changes, 5);
  }
}
function T0e(t, e) {
  let n = t.getBoundingClientRect(), i = t.ownerDocument, r = i.defaultView || window, s = Math.max(0, n.left), o = Math.min(r.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(r.innerHeight, n.bottom);
  for (let c = t.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let u = c, d = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && d.overflow != "visible") {
        let h = u.getBoundingClientRect();
        s = Math.max(s, h.left), o = Math.min(o, h.right), a = Math.max(a, h.top), l = c == t.parentNode ? h.bottom : Math.min(l, h.bottom);
      }
      c = d.position == "absolute" || d.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - n.left,
    right: Math.max(s, o) - n.left,
    top: a - (n.top + e),
    bottom: Math.max(a, l) - (n.top + e)
  };
}
function M0e(t, e) {
  let n = t.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
class F1 {
  constructor(e, n, i) {
    this.from = e, this.to = n, this.size = i;
  }
  static same(e, n) {
    if (e.length != n.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i], s = n[i];
      if (r.from != s.from || r.to != s.to || r.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, n) {
    return ve.replace({
      widget: new P0e(this.size * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
}
class P0e extends Ns {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class PC {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = RC, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = At.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = e.facet(C_).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new w0e(n), this.stateDeco = e.facet(Ed).filter((i) => typeof i != "function"), this.heightMap = Qn.empty().applyChanges(this.stateDeco, Ge.empty, this.heightOracle.setDoc(e.doc), [new Ui(0, 0, 0, e.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ve.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? n.head : n.anchor;
      if (!e.some(({ from: s, to: o }) => r >= s && r <= o)) {
        let { from: s, to: o } = this.lineBlockAt(r);
        e.push(new Cf(s, o));
      }
    }
    return this.viewports = e.sort((i, r) => i.from - r.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? RC : new M_(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(tu(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(Ed).filter((u) => typeof u != "function");
    let r = e.changedRanges, s = Ui.extendWithRanges(r, C0e(i, this.stateDeco, e ? e.changes : Xt.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    TC(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || sc) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(g$) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM, i = window.getComputedStyle(n), r = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? At.RTL : At.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), a = n.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: O, scaleY: x } = W4(n, a);
      (O > 5e-3 && Math.abs(this.scaleX - O) > 5e-3 || x > 5e-3 && Math.abs(this.scaleY - x) > 5e-3) && (this.scaleX = O, this.scaleY = x, c |= 8, o = l = !0);
    }
    let d = (parseInt(i.paddingTop) || 0) * this.scaleY, h = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != h) && (this.paddingTop = d, this.paddingBottom = h, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let f = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f && (this.scrollAnchorHeight = -1, this.scrollTop = f), this.scrolledToBottom = H4(e.scrollDOM);
    let p = (this.printing ? M0e : T0e)(n, this.paddingTop), m = p.top - this.pixelViewport.top, g = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let _ = a.width;
    if ((this.contentDOMWidth != _ || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), l) {
      let O = e.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(O) && (o = !0), o || r.lineWrapping && Math.abs(_ - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: x, charWidth: v, textHeight: w } = e.docView.measureTextSize();
        o = x > 0 && r.refresh(s, x, v, w, _ / v, O), o && (e.docView.minWidth = 0, c |= 8);
      }
      m > 0 && g > 0 ? u = Math.max(m, g) : m < 0 && g < 0 && (u = Math.min(m, g)), TC();
      for (let x of this.viewports) {
        let v = x.from == this.viewport.from ? O : e.docView.measureVisibleLineHeights(x);
        this.heightMap = (o ? Qn.empty().applyChanges(this.stateDeco, Ge.empty, this.heightOracle, [new Ui(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, o, new S0e(x.from, v));
      }
      sc && (c |= 2);
    }
    let y = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return y && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || y) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), r = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new Cf(r.lineAt(o - i * 1e3, Ct.ByHeight, s, 0, 0).from, r.lineAt(a + (1 - i) * 1e3, Ct.ByHeight, s, 0, 0).to);
    if (n) {
      let { head: c } = n.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = r.lineAt(c, Ct.ByPos, s, 0, 0), h;
        n.y == "center" ? h = (d.top + d.bottom) / 2 - u / 2 : n.y == "start" || n.y == "nearest" && c < l.from ? h = d.top : h = d.bottom - u, l = new Cf(r.lineAt(h - 1e3 / 2, Ct.ByHeight, s, 0, 0).from, r.lineAt(h + u + 1e3 / 2, Ct.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, n) {
    let i = n.mapPos(e.from, -1), r = n.mapPos(e.to, 1);
    return new Cf(this.heightMap.lineAt(i, Ct.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, Ct.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: n }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(e, Ct.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(n, Ct.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || r <= o - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || s >= a + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && r > o - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let i = [];
    for (let r of e)
      n.touchesRange(r.from, r.to) || i.push(new F1(n.mapPos(r.from), n.mapPos(r.to), r.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, n) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, s = r >> 1, o = r << 1;
    if (this.defaultTextDirection != At.LTR && !i)
      return [];
    let a = [], l = (u, d, h, f) => {
      if (d - u < s)
        return;
      let p = this.state.selection.main, m = [p.from];
      p.empty || m.push(p.to);
      for (let b of m)
        if (b > u && b < d) {
          l(u, b - 10, h, f), l(b + 10, d, h, f);
          return;
        }
      let g = $0e(e, (b) => b.from >= h.from && b.to <= h.to && Math.abs(b.from - u) < s && Math.abs(b.to - d) < s && !m.some((_) => b.from < _ && b.to > _));
      if (!g) {
        if (d < h.to && n && i && n.visibleRanges.some((b) => b.from <= d && b.to >= d)) {
          let b = n.moveToLineBoundary(j.cursor(d), !1, !0).head;
          b > u && (d = b);
        }
        g = new F1(u, d, this.gapSize(h, u, d, f));
      }
      a.push(g);
    }, c = (u) => {
      if (u.length < o || u.type != Bn.Text)
        return;
      let d = R0e(u.from, u.to, this.stateDeco);
      if (d.total < o)
        return;
      let h = this.scrollTarget ? this.scrollTarget.range.head : null, f, p;
      if (i) {
        let m = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, b;
        if (h != null) {
          let _ = Tf(d, h), y = ((this.visibleBottom - this.visibleTop) / 2 + m) / u.height;
          g = _ - y, b = _ + y;
        } else
          g = (this.visibleTop - u.top - m) / u.height, b = (this.visibleBottom - u.top + m) / u.height;
        f = Af(d, g), p = Af(d, b);
      } else {
        let m = d.total * this.heightOracle.charWidth, g = r * this.heightOracle.charWidth, b, _;
        if (h != null) {
          let y = Tf(d, h), O = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / m;
          b = y - O, _ = y + O;
        } else
          b = (this.pixelViewport.left - g) / m, _ = (this.pixelViewport.right + g) / m;
        f = Af(d, b), p = Af(d, _);
      }
      f > u.from && l(u.from, f, u, d), p < u.to && l(p, u.to, u, d);
    };
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return a;
  }
  gapSize(e, n, i, r) {
    let s = Tf(r, i) - Tf(r, n);
    return this.heightOracle.lineWrapping ? e.height * s : r.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    F1.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = ve.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let n = [];
    Ye.spans(e, this.viewport.from, this.viewport.to, {
      span(r, s) {
        n.push({ from: r, to: s });
      },
      point() {
      }
    }, 20);
    let i = n.length != this.visibleRanges.length || this.visibleRanges.some((r, s) => r.from != n[s].from || r.to != n[s].to);
    return this.visibleRanges = n, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || tu(this.heightMap.lineAt(e, Ct.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || tu(this.heightMap.lineAt(this.scaler.fromDOM(e), Ct.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return tu(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Cf {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
function R0e(t, e, n) {
  let i = [], r = t, s = 0;
  return Ye.spans(n, t, e, {
    span() {
    },
    point(o, a) {
      o > r && (i.push({ from: r, to: o }), s += o - r), r = a;
    }
  }, 20), r < e && (i.push({ from: r, to: e }), s += e - r), { total: s, ranges: i };
}
function Af({ total: t, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(t * n);
  for (let r = 0; ; r++) {
    let { from: s, to: o } = e[r], a = o - s;
    if (i <= a)
      return s + i;
    i -= a;
  }
}
function Tf(t, e) {
  let n = 0;
  for (let { from: i, to: r } of t.ranges) {
    if (e <= r) {
      n += e - i;
      break;
    }
    n += r - i;
  }
  return n / t.total;
}
function $0e(t, e) {
  for (let n of t)
    if (e(n))
      return n;
}
const RC = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class M_ {
  constructor(e, n, i) {
    let r = 0, s = 0, o = 0;
    this.viewports = i.map(({ from: a, to: l }) => {
      let c = n.lineAt(a, Ct.ByPos, e, 0, 0).top, u = n.lineAt(l, Ct.ByPos, e, 0, 0).bottom;
      return r += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (n.height - r);
    for (let a of this.viewports)
      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(e) {
    for (let n = 0, i = 0, r = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.top)
        return r + (e - i) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      i = s.bottom, r = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, i = 0, r = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.domTop)
        return i + (e - r) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      i = s.bottom, r = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof M_ ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, i) => n.from == e.viewports[i].from && n.to == e.viewports[i].to) : !1;
  }
}
function tu(t, e) {
  if (e.scale == 1)
    return t;
  let n = e.toDOM(t.top), i = e.toDOM(t.bottom);
  return new $r(t.from, t.length, n, i - n, Array.isArray(t._content) ? t._content.map((r) => tu(r, e)) : t._content);
}
const Mf = /* @__PURE__ */ de.define({ combine: (t) => t.join(" ") }), by = /* @__PURE__ */ de.define({ combine: (t) => t.indexOf(!0) > -1 }), Oy = /* @__PURE__ */ To.newName(), D$ = /* @__PURE__ */ To.newName(), I$ = /* @__PURE__ */ To.newName(), L$ = { "&light": "." + D$, "&dark": "." + I$ };
function yy(t, e, n) {
  return new To(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return t;
        if (!n || !n[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return n[r];
      }) : t + " " + i;
    }
  });
}
const N0e = /* @__PURE__ */ yy("." + Oy, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, L$), nu = "";
class D0e {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(je.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += nu;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let r = e; ; ) {
      this.findPointBefore(i, r);
      let s = this.text.length;
      this.readNode(r);
      let o = r.nextSibling;
      if (o == n)
        break;
      let a = _t.get(r), l = _t.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Nm(r)) || Nm(o) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > s) && this.lineBreak(), r = o;
    }
    return this.findPointBefore(i, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, n.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, a;
      if (this.lineSeparator ? (s = n.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (a = r.exec(n)) && (s = a.index, o = a[0].length), this.append(n.slice(i, s < 0 ? n.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      i = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = _t.get(e), i = n && n.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == n && (i.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (I0e(e, i.node, i.offset) ? n : 0));
  }
}
function I0e(t, e, n) {
  for (; ; ) {
    if (!e || n < Ms(e))
      return !1;
    if (e == t)
      return !0;
    n = Da(e) + 1, e = e.parentNode;
  }
}
class $C {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
}
class L0e {
  constructor(e, n, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, i, 0))) {
      let a = s || o ? [] : F0e(e), l = new D0e(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = z0e(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !iy(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !iy(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((ue.ios || ue.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let d = Math.min(l, c), h = Math.max(l, c), f = u.from - d, p = u.to - h;
        (f == 0 || f == 1 || d == 0) && (p == 0 || p == -1 || h == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = j.single(c, l);
    }
  }
}
function B$(t, e) {
  let n, { newSel: i } = e, r = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = r.from, c = null;
    (s === 8 || ue.android && e.text.length < a - o) && (l = r.to, c = "end");
    let u = Q0e(t.state.doc.sliceString(o, a, nu), e.text, l - o, c);
    u && (ue.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == nu + nu && u.toB--, n = {
      from: o + u.from,
      to: o + u.toA,
      insert: Ge.of(e.text.slice(u.from, u.toB).split(nu))
    });
  } else i && (!t.hasFocus && t.state.facet(eo) || i.main.eq(r)) && (i = null);
  if (!n && !i)
    return !1;
  if (!n && e.typeOver && !r.empty && i && i.main.empty ? n = { from: r.from, to: r.to, insert: t.state.doc.slice(r.from, r.to) } : n && n.from >= r.from && n.to <= r.to && (n.from != r.from || n.to != r.to) && r.to - r.from - (n.to - n.from) <= 4 ? n = {
    from: r.from,
    to: r.to,
    insert: t.state.doc.slice(r.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, r.to))
  } : (ue.mac || ue.android) && n && n.from == n.to && n.from == r.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (i && n.insert.length == 2 && (i = j.single(i.main.anchor - 1, i.main.head - 1)), n = { from: r.from, to: r.to, insert: Ge.of([" "]) }) : ue.chrome && n && n.from == n.to && n.from == r.head && n.insert.toString() == `
 ` && t.lineWrapping && (i && (i = j.single(i.main.anchor - 1, i.main.head - 1)), n = { from: r.from, to: r.to, insert: Ge.of([" "]) }), n)
    return Q$(t, n, i, s);
  if (i && !i.main.eq(r)) {
    let o = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: i, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function Q$(t, e, n, i = -1) {
  if (ue.ios && t.inputState.flushIOSKey(e))
    return !0;
  let r = t.state.selection.main;
  if (ue.android && (e.to == r.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == r.from || e.from == r.from - 1 && t.state.sliceDoc(e.from, r.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Pl(t.contentDOM, "Enter", 13) || (e.from == r.from - 1 && e.to == r.to && e.insert.length == 0 || i == 8 && e.insert.length < e.to - e.from && e.to > r.head) && Pl(t.contentDOM, "Backspace", 8) || e.from == r.from && e.to == r.to + 1 && e.insert.length == 0 && Pl(t.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let o, a = () => o || (o = B0e(t, e, n));
  return t.state.facet(f$).some((l) => l(t, e.from, e.to, s, a)) || t.dispatch(a()), !0;
}
function B0e(t, e, n) {
  let i, r = t.state, s = r.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = s.from < e.from ? r.sliceDoc(s.from, e.from) : "", l = s.to > e.to ? r.sliceDoc(e.to, s.to) : "";
    i = r.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));
  } else {
    let a = r.changes(e), l = n && n.main.to <= a.newLength ? n.main : void 0;
    if (r.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), u, d = n && S$(t, n.main.head);
      if (d) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: d.from, to: d.to - p };
      } else
        u = t.state.doc.lineAt(s.head);
      let h = s.to - e.to, f = s.to - s.from;
      i = r.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: a, range: l || p.map(a) };
        let m = p.to - h, g = m - c.length;
        if (p.to - p.from != f || t.state.sliceDoc(g, m) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let b = r.changes({ from: g, to: m, insert: e.insert }), _ = p.to - s.to;
        return {
          changes: b,
          range: l ? j.range(Math.max(0, l.anchor + _), Math.max(0, l.head + _)) : p.map(b)
        };
      });
    } else
      i = {
        changes: a,
        selection: l && r.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, o += ".compose", t.inputState.compositionFirstChange && (o += ".start", t.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: o, scrollIntoView: !0 });
}
function Q0e(t, e, n, i) {
  let r = Math.min(t.length, e.length), s = 0;
  for (; s < r && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == r && t.length == e.length)
    return null;
  let o = t.length, a = e.length;
  for (; o > 0 && a > 0 && t.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (i == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    n -= o + l - s;
  }
  if (o < s && t.length < e.length) {
    let l = n <= s && n >= o ? s - n : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = n <= s && n >= a ? s - n : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { from: s, toA: o, toB: a };
}
function F0e(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: s } = t.observer.selectionRange;
  return n && (e.push(new $C(n, i)), (r != n || s != i) && e.push(new $C(r, s))), e;
}
function z0e(t, e) {
  if (t.length == 0)
    return null;
  let n = t[0].pos, i = t.length == 2 ? t[1].pos : n;
  return n > -1 && i > -1 ? j.single(n + e, i + e) : null;
}
const U0e = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, z1 = ue.ie && ue.ie_version <= 11;
class W0e {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new Cme(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let i of n)
        this.queue.push(i);
      (ue.ie && ue.ie_version <= 11 || ue.ios && e.composing) && n.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(ue.chrome && ue.chrome_version < 126) && (this.editContext = new Z0e(e), e.state.facet(eo) && (e.contentDOM.editContext = this.editContext.editContext)), z1 && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, i) => n != e[i]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(eo) ? i.root.activeElement != this.dom : !sp(i.dom, r))
      return;
    let s = r.anchorNode && i.docView.nearest(r.anchorNode);
    if (s && s.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (ue.ie && ue.ie_version <= 11 || ue.android && ue.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    r.focusNode && Cu(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, n = Sd(e.root);
    if (!n)
      return !1;
    let i = ue.safari && e.root.nodeType == 11 && wme(this.dom.ownerDocument) == this.dom && V0e(this.view, n) || n;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let r = sp(this.dom, i);
    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && Tme(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = n)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, U0e), z1 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), z1 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, n) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Pl(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, i = -1, r = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (r = !0), n == -1 ? { from: n, to: i } = o : (n = Math.min(o.from, n), i = Math.max(o.to, i)));
    }
    return { from: n, to: i, typeOver: r };
  }
  readChange() {
    let { from: e, to: n, typeOver: i } = this.processRecords(), r = this.selectionChanged && sp(this.dom, this.selectionRange);
    if (e < 0 && !r)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new L0e(this.view, e, n, i);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, r = B$(this.view, n);
    return this.view.state == i && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), r;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let i = NC(n, e.previousSibling || e.target.previousSibling, -1), r = NC(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? n.posAfter(i) : n.posAtStart,
        to: r ? n.posBefore(r) : n.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(eo) != e.state.facet(eo) && (e.view.contentDOM.editContext = e.state.facet(eo) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function NC(t, e, n) {
  for (; e; ) {
    let i = _t.get(e);
    if (i && i.parent == t)
      return i;
    let r = e.parentNode;
    e = r != t.dom ? r : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function DC(t, e) {
  let n = e.startContainer, i = e.startOffset, r = e.endContainer, s = e.endOffset, o = t.docView.domAtPos(t.state.selection.main.anchor);
  return Cu(o.node, o.offset, r, s) && ([n, i, r, s] = [r, s, n, i]), { anchorNode: n, anchorOffset: i, focusNode: r, focusOffset: s };
}
function V0e(t, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(t.root)[0];
    if (r)
      return DC(t, r);
  }
  let n = null;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), n = r.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", i, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, !0), n ? DC(t, n) : null;
}
class Z0e {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.resetRange(e.state);
    let n = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let { anchor: r } = e.state.selection.main, s = {
        from: this.toEditorPos(i.updateRangeStart),
        to: this.toEditorPos(i.updateRangeEnd),
        insert: Ge.of(i.text.split(`
`))
      };
      s.from == this.from && r < this.from ? s.from = r : s.to == this.to && r > this.to && (s.to = r), !(s.from == s.to && !s.insert.length) && (this.pendingContextChange = s, e.state.readOnly || Q$(e, s, j.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd))), this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)));
    }, this.handlers.characterboundsupdate = (i) => {
      let r = [], s = null;
      for (let o = this.toEditorPos(i.rangeStart), a = this.toEditorPos(i.rangeEnd); o < a; o++) {
        let l = e.coordsForChar(o);
        s = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || s || new DOMRect(), r.push(s);
      }
      n.updateCharacterBounds(i.rangeStart, r);
    }, this.handlers.textformatupdate = (i) => {
      let r = [];
      for (let s of i.getTextFormats()) {
        let o = s.underlineStyle, a = s.underlineThickness;
        if (o != "None" && a != "None") {
          let l = `text-decoration: underline ${o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
          r.push(ve.mark({ attributes: { style: l } }).range(this.toEditorPos(s.rangeStart), this.toEditorPos(s.rangeEnd)));
        }
      }
      e.dispatch({ effects: O$.of(ve.set(r)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      e.inputState.composing = -1, e.inputState.compositionFirstChange = null;
    };
    for (let i in this.handlers)
      n.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: (i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let r = Sd(i.root);
      r && r.rangeCount && this.editContext.updateSelectionBounds(r.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let n = 0, i = !1, r = this.pendingContextChange;
    return e.changes.iterChanges((s, o, a, l, c) => {
      if (i)
        return;
      let u = c.length - (o - s);
      if (r && o >= r.to)
        if (r.from == s && r.to == o && r.insert.eq(c)) {
          r = this.pendingContextChange = null, n += u, this.to += u;
          return;
        } else
          r = null, this.revertPending(e.state);
      if (s += n, o += n, o <= this.from)
        this.from += u, this.to += u;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), this.to += u;
      }
      n += u;
    }), r && !i && this.revertPending(e.state), !i;
  }
  update(e) {
    let n = this.pendingContextChange;
    !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.resetRange(e.state), this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)), this.setSelection(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), r = this.toContextPos(n.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != r) && this.editContext.updateSelection(i, r);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e) {
    return e + this.from;
  }
  toContextPos(e) {
    return e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class ae {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    this.dispatchTransactions = e.dispatchTransactions || n && ((i) => i.forEach((r) => n(r, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || Ame(e.parent) || document, this.viewState = new PC(e.state || je.create(e)), e.scrollTo && e.scrollTo.is(Sf) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Jc).map((i) => new L1(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new W0e(this), this.inputState = new o0e(this), this.inputState.ensureHandlers(this.plugins), this.docView = new hC(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof Vt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, i = !1, r, s = this.state;
    for (let h of e) {
      if (h.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = h.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((h) => h.annotation(P$)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = R$(s, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(je.phrases) != this.state.facet(je.phrases))
      return this.setState(s);
    r = Im.create(this, s, e), r.flags |= a;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let h of e) {
        if (d && (d = d.map(h.changes)), h.scrollIntoView) {
          let { main: f } = h.state.selection;
          d = new Rl(f.empty ? f : j.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of h.effects)
          f.is(Sf) && (d = f.value.clip(this.state));
      }
      this.viewState.update(r, d), this.bidiCache = Bm.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), n = this.docView.update(r), this.state.facet(eu) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((h) => h.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(Mf) != r.state.facet(Mf) && (this.viewState.mustMeasureContent = !0), (n || i || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !r.empty)
      for (let h of this.state.facet(fy))
        try {
          h(r);
        } catch (f) {
          ni(this.state, f, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !B$(this, u) && c.force && Pl(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new PC(e), this.plugins = e.facet(Jc).map((i) => new L1(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new hC(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(Jc), i = e.state.facet(Jc);
    if (n != i) {
      let r = [];
      for (let s of i) {
        let o = n.indexOf(s);
        if (o < 0)
          r.push(new L1(s));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, r.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = e;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    n != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (i) {
          ni(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (H4(i))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let f = this.viewState.scrollAnchorAt(r);
            s = f.from, o = f.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((f) => {
          try {
            return f.read(this);
          } catch (p) {
            return ni(this.state, p), IC;
          }
        }), d = Im.create(this, this.state, []), h = !1;
        d.flags |= l, n ? n.flags |= l : n = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), h = this.docView.update(d), h && this.docViewUpdate());
        for (let f = 0; f < c.length; f++)
          if (u[f] != IC)
            try {
              let p = c[f];
              p.write && p.write(u[f], this);
            } catch (p) {
              ni(this.state, p);
            }
        if (h && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                r = r + p, i.scrollTop = r / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let a of this.state.facet(fy))
        a(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Oy + " " + (this.state.facet(by) ? I$ : D$) + " " + this.state.facet(Mf);
  }
  updateAttrs() {
    let e = LC(this, y$, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(eo) ? "true" : "false",
      class: "cm-content",
      style: `${ue.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), LC(this, C_, n);
    let i = this.observer.ignore(() => {
      let r = ly(this.contentDOM, this.contentAttrs, n), s = ly(this.dom, this.editorAttrs, e);
      return r || s;
    });
    return this.editorAttrs = e, this.contentAttrs = n, i;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let i of e)
      for (let r of i.effects)
        if (r.is(ae.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(eu);
    let e = this.state.facet(ae.cspNonce);
    To.mount(this.root, this.styleModules.concat(N0e).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((i) => i.spec == e) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, n, i) {
    return Q1(this, e, OC(this, e, n, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, n) {
    return Q1(this, e, OC(this, e, n, (i) => r0e(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, n) {
    let i = this.bidiSpans(e), r = this.textDirectionAt(e.from), s = i[n ? i.length - 1 : 0];
    return j.cursor(s.side(n, r) + e.from, s.forward(!n, r) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, n, i = !0) {
    return i0e(this, e, n, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, n, i) {
    return Q1(this, e, s0e(this, e, n, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), k$(this, e, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, n);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(e), s = this.bidiSpans(r), o = s[ho.find(s, e - r.from, -1, n)];
    return S_(i, o.dir == At.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(m$) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > H0e)
      return a$(e.length);
    let n = this.textDirectionAt(e.from), i;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == n && (s.fresh || o$(s.isolates, i = dC(this, e))))
        return s.order;
    i || (i = dC(this, e));
    let r = zme(e.text, n, i);
    return this.bidiCache.push(new Bm(e.from, e.to, n, i, !0, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || ue.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      V4(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, n = {}) {
    return Sf.of(new Rl(typeof e == "number" ? j.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return Sf.of(new Rl(j.cursor(i.from), "start", "start", i.top - e, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Ht.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Ht.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, n) {
    let i = To.newName(), r = [Mf.of(i), eu.of(yy(`.${i}`, e))];
    return n && n.dark && r.push(by.of(!0)), r;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Fo.lowest(eu.of(yy("." + Oy, e, L$)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var n;
    let i = e.querySelector(".cm-content"), r = i && _t.get(i) || _t.get(e);
    return ((n = r == null ? void 0 : r.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
ae.styleModule = eu;
ae.inputHandler = f$;
ae.scrollHandler = b$;
ae.focusChangeEffect = p$;
ae.perLineTextDirection = m$;
ae.exceptionSink = h$;
ae.updateListener = fy;
ae.editable = eo;
ae.mouseSelectionStyle = d$;
ae.dragMovesSelection = u$;
ae.clickAddsSelectionRange = c$;
ae.decorations = Ed;
ae.outerDecorations = _$;
ae.atomicRanges = A_;
ae.bidiIsolatedRanges = v$;
ae.scrollMargins = x$;
ae.darkTheme = by;
ae.cspNonce = /* @__PURE__ */ de.define({ combine: (t) => t.length ? t[0] : "" });
ae.contentAttributes = C_;
ae.editorAttributes = y$;
ae.lineWrapping = /* @__PURE__ */ ae.contentAttributes.of({ class: "cm-lineWrapping" });
ae.announce = /* @__PURE__ */ Me.define();
const H0e = 4096, IC = {};
class Bm {
  constructor(e, n, i, r, s, o) {
    this.from = e, this.to = n, this.dir = i, this.isolates = r, this.fresh = s, this.order = o;
  }
  static update(e, n) {
    if (n.empty && !e.some((s) => s.fresh))
      return e;
    let i = [], r = e.length ? e[e.length - 1].dir : At.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == r && !n.touchesRange(o.from, o.to) && i.push(new Bm(n.mapPos(o.from, 1), n.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return i;
  }
}
function LC(t, e, n) {
  for (let i = t.state.facet(e), r = i.length - 1; r >= 0; r--) {
    let s = i[r], o = typeof s == "function" ? s(t) : s;
    o && ay(o, n);
  }
  return n;
}
const q0e = ue.mac ? "mac" : ue.windows ? "win" : ue.linux ? "linux" : "key";
function X0e(t, e) {
  const n = t.split(/-(?!$)/);
  let i = n[n.length - 1];
  i == "Space" && (i = " ");
  let r, s, o, a;
  for (let l = 0; l < n.length - 1; ++l) {
    const c = n[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (i = "Alt-" + i), s && (i = "Ctrl-" + i), a && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function Pf(t, e, n) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const j0e = /* @__PURE__ */ Fo.default(/* @__PURE__ */ ae.domEventHandlers({
  keydown(t, e) {
    return z$(F$(e.state), t, e, "editor");
  }
})), G0 = /* @__PURE__ */ de.define({ enables: j0e }), BC = /* @__PURE__ */ new WeakMap();
function F$(t) {
  let e = t.facet(G0), n = BC.get(e);
  return n || BC.set(e, n = K0e(e.reduce((i, r) => i.concat(r), []))), n;
}
function Y0e(t, e, n) {
  return z$(F$(t.state), e, t, n);
}
let to = null;
const G0e = 4e3;
function K0e(t, e = q0e) {
  let n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), r = (o, a) => {
    let l = i[o];
    if (l == null)
      i[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, a, l, c, u) => {
    var d, h;
    let f = n[o] || (n[o] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((b) => X0e(b, e));
    for (let b = 1; b < p.length; b++) {
      let _ = p.slice(0, b).join(" ");
      r(_, !0), f[_] || (f[_] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(y) => {
          let O = to = { view: y, prefix: _, scope: o };
          return setTimeout(() => {
            to == O && (to = null);
          }, G0e), !0;
        }]
      });
    }
    let m = p.join(" ");
    r(m, !1);
    let g = f[m] || (f[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((h = (d = f._any) === null || d === void 0 ? void 0 : d.run) === null || h === void 0 ? void 0 : h.slice()) || []
    });
    l && g.run.push(l), c && (g.preventDefault = !0), u && (g.stopPropagation = !0);
  };
  for (let o of t) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: d } = o;
        for (let h in u)
          u[h].run.push((f) => d(f, _y));
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return n;
}
let _y = null;
function z$(t, e, n, i) {
  _y = e;
  let r = IT(e), s = pn(r, 0), o = $i(s) == r.length && r != " ", a = "", l = !1, c = !1, u = !1;
  to && to.view == n && to.scope == i && (a = to.prefix + " ", C$.indexOf(e.keyCode) < 0 && (c = !0, to = null));
  let d = /* @__PURE__ */ new Set(), h = (g) => {
    if (g) {
      for (let b of g.run)
        if (!d.has(b) && (d.add(b), b(n)))
          return g.stopPropagation && (u = !0), !0;
      g.preventDefault && (g.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, f = t[i], p, m;
  return f && (h(f[a + Pf(r, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ue.windows && e.ctrlKey && e.altKey) && (p = As[e.keyCode]) && p != r ? (h(f[a + Pf(p, e, !0)]) || e.shiftKey && (m = zu[e.keyCode]) != r && m != p && h(f[a + Pf(m, e, !1)])) && (l = !0) : o && e.shiftKey && h(f[a + Pf(r, e, !0)]) && (l = !0), !l && h(f._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), _y = null, l;
}
class fh {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, n, i, r, s) {
    this.className = e, this.left = n, this.top = i, this.width = r, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, n, i) {
    if (i.empty) {
      let r = e.coordsAtPos(i.head, i.assoc || 1);
      if (!r)
        return [];
      let s = U$(e);
      return [new fh(n, r.left - s.left, r.top - s.top, null, r.bottom - r.top)];
    } else
      return J0e(e, n, i);
  }
}
function U$(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == At.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function QC(t, e, n, i) {
  let r = t.coordsAtPos(e, n * 2);
  if (!r)
    return i;
  let s = t.dom.getBoundingClientRect(), o = (r.top + r.bottom) / 2, a = t.posAtCoords({ x: s.left + 1, y: o }), l = t.posAtCoords({ x: s.right - 1, y: o });
  return a == null || l == null ? i : { from: Math.max(i.from, Math.min(a, l)), to: Math.min(i.to, Math.max(a, l)) };
}
function J0e(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to)
    return [];
  let i = Math.max(n.from, t.viewport.from), r = Math.min(n.to, t.viewport.to), s = t.textDirection == At.LTR, o = t.contentDOM, a = o.getBoundingClientRect(), l = U$(t), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), d = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), h = a.right - (u ? parseInt(u.paddingRight) : 0), f = my(t, i), p = my(t, r), m = f.type == Bn.Text ? f : null, g = p.type == Bn.Text ? p : null;
  if (m && (t.lineWrapping || f.widgetLineBreaks) && (m = QC(t, i, 1, m)), g && (t.lineWrapping || p.widgetLineBreaks) && (g = QC(t, r, -1, g)), m && g && m.from == g.from && m.to == g.to)
    return _(y(n.from, n.to, m));
  {
    let x = m ? y(n.from, null, m) : O(f, !1), v = g ? y(null, n.to, g) : O(p, !0), w = [];
    return (m || f).to < (g || p).from - (m && g ? 1 : 0) || f.widgetLineBreaks > 1 && x.bottom + t.defaultLineHeight / 2 < v.top ? w.push(b(d, x.bottom, h, v.top)) : x.bottom < v.top && t.elementAtHeight((x.bottom + v.top) / 2).type == Bn.Text && (x.bottom = v.top = (x.bottom + v.top) / 2), _(x).concat(w).concat(_(v));
  }
  function b(x, v, w, T) {
    return new fh(
      e,
      x - l.left,
      v - l.top - 0.01,
      w - x,
      T - v + 0.01
      /* C.Epsilon */
    );
  }
  function _({ top: x, bottom: v, horizontal: w }) {
    let T = [];
    for (let S = 0; S < w.length; S += 2)
      T.push(b(w[S], x, w[S + 1], v));
    return T;
  }
  function y(x, v, w) {
    let T = 1e9, S = -1e9, $ = [];
    function I(q, K, ie, k, N) {
      let W = t.coordsAtPos(q, q == w.to ? -2 : 2), X = t.coordsAtPos(ie, ie == w.from ? 2 : -2);
      !W || !X || (T = Math.min(W.top, X.top, T), S = Math.max(W.bottom, X.bottom, S), N == At.LTR ? $.push(s && K ? d : W.left, s && k ? h : X.right) : $.push(!s && k ? d : X.left, !s && K ? h : W.right));
    }
    let F = x ?? w.from, V = v ?? w.to;
    for (let q of t.visibleRanges)
      if (q.to > F && q.from < V)
        for (let K = Math.max(q.from, F), ie = Math.min(q.to, V); ; ) {
          let k = t.state.doc.lineAt(K);
          for (let N of t.bidiSpans(k)) {
            let W = N.from + k.from, X = N.to + k.from;
            if (W >= ie)
              break;
            X > K && I(Math.max(W, K), x == null && W <= F, Math.min(X, ie), v == null && X >= V, N.dir);
          }
          if (K = k.to + 1, K >= ie)
            break;
        }
    return $.length == 0 && I(F, x == null, V, v == null, t.textDirection), { top: T, bottom: S, horizontal: $ };
  }
  function O(x, v) {
    let w = a.top + (v ? x.top : x.bottom);
    return { top: w, bottom: w, horizontal: [] };
  }
}
function ege(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class tge {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(lp) != e.state.facet(lp) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0, i = e.facet(lp);
    for (; n < i.length && i[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, i) => !ege(n, this.drawn[i]))) {
      let n = this.dom.firstChild, i = 0;
      for (let r of e)
        r.update && n && r.constructor && this.drawn[i].constructor && r.update(n, this.drawn[i]) ? (n = n.nextSibling, i++) : this.dom.insertBefore(r.draw(), n);
      for (; n; ) {
        let r = n.nextSibling;
        n.remove(), n = r;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const lp = /* @__PURE__ */ de.define();
function W$(t) {
  return [
    Ht.define((e) => new tge(e, t)),
    lp.of(t)
  ];
}
const V$ = !ue.ios, Cd = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function nge(t = {}) {
  return [
    Cd.of(t),
    ige,
    rge,
    sge,
    g$.of(!0)
  ];
}
function Z$(t) {
  return t.startState.facet(Cd) != t.state.facet(Cd);
}
const ige = /* @__PURE__ */ W$({
  above: !0,
  markers(t) {
    let { state: e } = t, n = e.facet(Cd), i = [];
    for (let r of e.selection.ranges) {
      let s = r == e.selection.main;
      if (r.empty ? !s || V$ : n.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = r.empty ? r : j.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let l of fh.forRange(t, o, a))
          i.push(l);
      }
    }
    return i;
  },
  update(t, e) {
    t.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = Z$(t);
    return n && FC(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    FC(e.state, t);
  },
  class: "cm-cursorLayer"
});
function FC(t, e) {
  e.style.animationDuration = t.facet(Cd).cursorBlinkRate + "ms";
}
const rge = /* @__PURE__ */ W$({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : fh.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || Z$(t);
  },
  class: "cm-selectionLayer"
}), vy = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
V$ && (vy[".cm-line"].caretColor = vy[".cm-content"].caretColor = "transparent !important");
const sge = /* @__PURE__ */ Fo.highest(/* @__PURE__ */ ae.theme(vy)), H$ = /* @__PURE__ */ Me.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), iu = /* @__PURE__ */ ln.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, i) => i.is(H$) ? i.value : n, t);
  }
}), oge = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let n = t.state.field(iu);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(iu) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(iu), n = e != null && t.coordsAtPos(e);
    if (!n)
      return null;
    let i = t.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - i.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: n.top - i.top + t.scrollDOM.scrollTop * t.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(iu) != t && this.view.dispatch({ effects: H$.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function age() {
  return [iu, oge];
}
function zC(t, e, n, i, r) {
  e.lastIndex = 0;
  for (let s = t.iterRange(n, i), o = n, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; a = e.exec(s.value); )
        r(o + a.index, a);
}
function lge(t, e) {
  let n = t.visibleRanges;
  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
    return n;
  let i = [];
  for (let { from: r, to: s } of n)
    r = Math.max(t.state.doc.lineAt(r).from, r - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = s : i.push({ from: r, to: s });
  return i;
}
class cge {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: n, decoration: i, decorate: r, boundary: s, maxLength: o = 1e3 } = e;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, r)
      this.addMatch = (a, l, c, u) => r(u, c, c + a[0].length, a, l);
    else if (typeof i == "function")
      this.addMatch = (a, l, c, u) => {
        let d = i(a, l, c);
        d && u(c, c + a[0].length, d);
      };
    else if (i)
      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let n = new Ao(), i = n.add.bind(n);
    for (let { from: r, to: s } of lge(e, this.maxLength))
      zC(e.state.doc, this.regexp, r, s, (o, a) => this.addMatch(a, e, o, i));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, n) {
    let i = 1e9, r = -1;
    return e.docChanged && e.changes.iterChanges((s, o, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (i = Math.min(a, i), r = Math.max(l, r));
    }), e.viewportChanged || r - i > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, n.map(e.changes), i, r) : n;
  }
  updateRange(e, n, i, r) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, i), a = Math.min(s.to, r);
      if (a > o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(s.from, l.from), d = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              d = a;
              break;
            }
        }
        let h = [], f, p = (m, g, b) => h.push(b.range(m, g));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (f = this.regexp.exec(l.text)) && f.index < d - l.from; )
            this.addMatch(f, e, f.index + l.from, p);
        else
          zC(e.state.doc, this.regexp, u, d, (m, g) => this.addMatch(g, e, m, p));
        n = n.update({ filterFrom: u, filterTo: d, filter: (m, g) => m < u || g > d, add: h });
      }
    }
    return n;
  }
}
const xy = /x/.unicode != null ? "gu" : "g", uge = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, xy), dge = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let U1 = null;
function hge() {
  var t;
  if (U1 == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    U1 = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return U1 || !1;
}
const cp = /* @__PURE__ */ de.define({
  combine(t) {
    let e = is(t, {
      render: null,
      specialChars: uge,
      addSpecialChars: null
    });
    return (e.replaceTabs = !hge()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, xy)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, xy)), e;
  }
});
function fge(t = {}) {
  return [cp.of(t), pge()];
}
let UC = null;
function pge() {
  return UC || (UC = Ht.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = ve.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(cp)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new cge({
        regexp: t.specialChars,
        decoration: (e, n, i) => {
          let { doc: r } = n.state, s = pn(e[0], 0);
          if (s == 9) {
            let o = r.lineAt(i), a = n.state.tabSize, l = Ec(o.text, a, i - o.from);
            return ve.replace({
              widget: new Oge((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = ve.replace({ widget: new bge(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(cp);
      t.startState.facet(cp) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const mge = "";
function gge(t) {
  return t >= 32 ? mge : t == 10 ? "" : String.fromCharCode(9216 + t);
}
class bge extends Ns {
  constructor(e, n) {
    super(), this.options = e, this.code = n;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = gge(this.code), i = e.state.phrase("Control character") + " " + (dge[this.code] || "0x" + this.code.toString(16)), r = this.options.render && this.options.render(this.code, i, n);
    if (r)
      return r;
    let s = document.createElement("span");
    return s.textContent = n, s.title = i, s.setAttribute("aria-label", i), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class Oge extends Ns {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function yge() {
  return vge;
}
const _ge = /* @__PURE__ */ ve.line({ class: "cm-activeLine" }), vge = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, n = [];
    for (let i of t.state.selection.ranges) {
      let r = t.lineBlockAt(i.head);
      r.from > e && (n.push(_ge.range(r.from)), e = r.from);
    }
    return ve.set(n);
  }
}, {
  decorations: (t) => t.decorations
}), wy = 2e3;
function xge(t, e, n) {
  let i = Math.min(e.line, n.line), r = Math.max(e.line, n.line), s = [];
  if (e.off > wy || n.off > wy || e.col < 0 || n.col < 0) {
    let o = Math.min(e.off, n.off), a = Math.max(e.off, n.off);
    for (let l = i; l <= r; l++) {
      let c = t.doc.line(l);
      c.length <= a && s.push(j.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, n.col), a = Math.max(e.col, n.col);
    for (let l = i; l <= r; l++) {
      let c = t.doc.line(l), u = ey(c.text, o, t.tabSize, !0);
      if (u < 0)
        s.push(j.cursor(c.to));
      else {
        let d = ey(c.text, a, t.tabSize);
        s.push(j.range(c.from + u, c.from + d));
      }
    }
  }
  return s;
}
function wge(t, e) {
  let n = t.coordsAtPos(t.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
}
function WC(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = t.state.doc.lineAt(n), r = n - i.from, s = r > wy ? -1 : r == i.length ? wge(t, e.clientX) : Ec(i.text, t.state.tabSize, n - i.from);
  return { line: i.number, col: s, off: r };
}
function Sge(t, e) {
  let n = WC(t, e), i = t.state.selection;
  return n ? {
    update(r) {
      if (r.docChanged) {
        let s = r.changes.mapPos(r.startState.doc.line(n.line).from), o = r.state.doc.lineAt(s);
        n = { line: o.number, col: n.col, off: Math.min(n.off, o.length) }, i = i.map(r.changes);
      }
    },
    get(r, s, o) {
      let a = WC(t, r);
      if (!a)
        return i;
      let l = xge(t.state, n, a);
      return l.length ? o ? j.create(l.concat(i.ranges)) : j.create(l) : i;
    }
  } : null;
}
function kge(t) {
  let e = (n) => n.altKey && n.button == 0;
  return ae.mouseSelectionStyle.of((n, i) => e(i) ? Sge(n, i) : null);
}
const Ege = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, Cge = { style: "cursor: crosshair" };
function Age(t = {}) {
  let [e, n] = Ege[t.key || "Alt"], i = Ht.fromClass(class {
    constructor(r) {
      this.view = r, this.isDown = !1;
    }
    set(r) {
      this.isDown != r && (this.isDown = r, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(r) {
        this.set(r.keyCode == e || n(r));
      },
      keyup(r) {
        (r.keyCode == e || !n(r)) && this.set(!1);
      },
      mousemove(r) {
        this.set(n(r));
      }
    }
  });
  return [
    i,
    ae.contentAttributes.of((r) => {
      var s;
      return !((s = r.plugin(i)) === null || s === void 0) && s.isDown ? Cge : null;
    })
  ];
}
const Bc = "-10000px";
class q$ {
  constructor(e, n, i, r) {
    this.facet = n, this.createTooltipView = i, this.removeTooltipView = r, this.input = e.state.facet(n), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = i(o, s));
  }
  update(e, n) {
    var i;
    let r = e.state.facet(this.facet), s = r.filter((l) => l);
    if (r === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = n ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let c = s[l], u = -1;
      if (c) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let h = this.tooltips[d];
          h && h.create == c.create && (u = d);
        }
        if (u < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let d = o[l] = this.tooltipViews[u];
          a && (a[l] = n[u]), d.update && d.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return n && (a.forEach((l, c) => n[c] = l), n.length = a.length), this.input = r, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function Tge(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const W1 = /* @__PURE__ */ de.define({
  combine: (t) => {
    var e, n, i;
    return {
      position: ue.ios ? "absolute" : ((e = t.find((r) => r.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = t.find((r) => r.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((i = t.find((r) => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || Tge
    };
  }
}), VC = /* @__PURE__ */ new WeakMap(), P_ = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(W1);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new q$(t, R_, (n, i) => this.createTooltip(n, i), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let n = e || t.geometryChanged, i = t.state.facet(W1);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      n = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      n = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let n = t.create(this.view), i = e ? e.dom : null;
    if (n.dom.classList.add("cm-tooltip"), t.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let r = document.createElement("div");
      r.className = "cm-tooltip-arrow", n.dom.appendChild(r);
    }
    return n.dom.style.position = this.position, n.dom.style.top = Bc, n.dom.style.left = "0px", this.container.insertBefore(n.dom, i), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var t, e, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (t = i.destroy) === null || t === void 0 || t.call(i);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, n = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: r } = this.manager.tooltipViews[0];
      if (ue.gecko)
        i = r.offsetParent != this.container.ownerDocument.body;
      else if (r.style.top == Bc && r.style.left == "0px") {
        let s = r.getBoundingClientRect();
        i = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let r = this.parent.getBoundingClientRect();
        r.width && r.height && (e = r.width / this.parent.offsetWidth, n = r.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: n } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((r, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(r.pos) : this.view.coordsAtPos(r.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()),
      space: this.view.state.facet(W1).tooltipSpace(this.view),
      scaleX: e,
      scaleY: n,
      makeAbsolute: i
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: n, space: i, scaleX: r, scaleY: s } = t, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, d = t.pos[a], h = t.size[a];
      if (!d || d.bottom <= Math.max(n.top, i.top) || d.top >= Math.min(n.bottom, i.bottom) || d.right < Math.max(n.left, i.left) - 0.1 || d.left > Math.min(n.right, i.right) + 0.1) {
        u.style.top = Bc;
        continue;
      }
      let f = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = f ? 7 : 0, m = h.right - h.left, g = (e = VC.get(c)) !== null && e !== void 0 ? e : h.bottom - h.top, b = c.offset || Pge, _ = this.view.textDirection == At.LTR, y = h.width > i.right - i.left ? _ ? i.left : i.right - h.width : _ ? Math.max(i.left, Math.min(d.left - (f ? 14 : 0) + b.x, i.right - m)) : Math.min(Math.max(i.left, d.left - m + (f ? 14 : 0) - b.x), i.right - m), O = this.above[a];
      !l.strictSide && (O ? d.top - (h.bottom - h.top) - b.y < i.top : d.bottom + (h.bottom - h.top) + b.y > i.bottom) && O == i.bottom - d.bottom > d.top - i.top && (O = this.above[a] = !O);
      let x = (O ? d.top - i.top : i.bottom - d.bottom) - p;
      if (x < g && c.resize !== !1) {
        if (x < this.view.defaultLineHeight) {
          u.style.top = Bc;
          continue;
        }
        VC.set(c, g), u.style.height = (g = x) / s + "px";
      } else u.style.height && (u.style.height = "");
      let v = O ? d.top - g - p - b.y : d.bottom + p + b.y, w = y + m;
      if (c.overlap !== !0)
        for (let T of o)
          T.left < w && T.right > y && T.top < v + g && T.bottom > v && (v = O ? T.top - g - 2 - p : T.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (v - t.parent.top) / s + "px", u.style.left = (y - t.parent.left) / r + "px") : (u.style.top = v / s + "px", u.style.left = y / r + "px"), f) {
        let T = d.left + (_ ? b.x : -b.x) - (y + 14 - 7);
        f.style.left = T / r + "px";
      }
      c.overlap !== !0 && o.push({ left: y, top: v, right: w, bottom: v + g }), u.classList.toggle("cm-tooltip-above", O), u.classList.toggle("cm-tooltip-below", !O), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = Bc;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), Mge = /* @__PURE__ */ ae.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Pge = { x: 0, y: 0 }, R_ = /* @__PURE__ */ de.define({
  enables: [P_, Mge]
}), Qm = /* @__PURE__ */ de.define({
  combine: (t) => t.reduce((e, n) => e.concat(n), [])
});
class K0 {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new K0(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new q$(e, Qm, (n, i) => this.createHostedView(n, i), (n) => n.dom.remove());
  }
  createHostedView(e, n) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews)
      (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let i of this.manager.tooltipViews) {
      let r = i[e];
      if (r !== void 0) {
        if (n === void 0)
          n = r;
        else if (n !== r)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const Rge = /* @__PURE__ */ R_.compute([Qm], (t) => {
  let e = t.facet(Qm);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((n) => n.pos)),
    end: Math.max(...e.map((n) => {
      var i;
      return (i = n.end) !== null && i !== void 0 ? i : n.pos;
    })),
    create: K0.create,
    above: e[0].above,
    arrow: e.some((n) => n.arrow)
  };
});
class $ge {
  constructor(e, n, i, r, s) {
    this.view = e, this.source = n, this.field = i, this.setHover = r, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this, i = e.docView.nearest(n.target);
    if (!i)
      return;
    let r, s = 1;
    if (i instanceof uo)
      r = i.posAtStart;
    else {
      if (r = e.posAtCoords(n), r == null)
        return;
      let a = e.coordsAtPos(r);
      if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - e.defaultCharacterWidth || n.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(r)).find((u) => u.from <= r && u.to >= r), c = l && l.dir == At.RTL ? -1 : 1;
      s = n.x < a.left ? -c : c;
    }
    let o = this.source(e, r, s);
    if (o != null && o.then) {
      let a = this.pending = { pos: r };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => ni(e.state, l, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(P_), n = e ? e.manager.tooltips.findIndex((i) => i.create == K0.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: r, tooltip: s } = this;
    if (r.length && s && !Nge(s.dom, e) || this.pending) {
      let { pos: o } = r[0] || this.pending, a = (i = (n = r[0]) === null || n === void 0 ? void 0 : n.end) !== null && i !== void 0 ? i : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !Dge(this.view, o, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (i) => {
      e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Rf = 4;
function Nge(t, e) {
  let n = t.getBoundingClientRect();
  return e.clientX >= n.left - Rf && e.clientX <= n.right + Rf && e.clientY >= n.top - Rf && e.clientY <= n.bottom + Rf;
}
function Dge(t, e, n, i, r, s) {
  let o = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (o.left > i || o.right < i || o.top > r || Math.min(o.bottom, a) < r)
    return !1;
  let l = t.posAtCoords({ x: i, y: r }, !1);
  return l >= e && l <= n;
}
function Ige(t, e = {}) {
  let n = Me.define(), i = ln.define({
    create() {
      return [];
    },
    update(r, s) {
      if (r.length && (e.hideOnChange && (s.docChanged || s.selection) ? r = [] : e.hideOn && (r = r.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let a of r) {
          let l = s.changes.mapPos(a.pos, -1, mn.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = l, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        r = o;
      }
      for (let o of s.effects)
        o.is(n) && (r = o.value), o.is(Lge) && (r = []);
      return r;
    },
    provide: (r) => Qm.from(r)
  });
  return [
    i,
    Ht.define((r) => new $ge(
      r,
      t,
      i,
      n,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    Rge
  ];
}
function X$(t, e) {
  let n = t.plugin(P_);
  if (!n)
    return null;
  let i = n.manager.tooltips.indexOf(e);
  return i < 0 ? null : n.manager.tooltipViews[i];
}
const Lge = /* @__PURE__ */ Me.define(), ZC = /* @__PURE__ */ de.define({
  combine(t) {
    let e, n;
    for (let i of t)
      e = e || i.topContainer, n = n || i.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function Ad(t, e) {
  let n = t.plugin(j$), i = n ? n.specs.indexOf(e) : -1;
  return i > -1 ? n.panels[i] : null;
}
const j$ = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(Td), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
    let e = t.state.facet(ZC);
    this.top = new $f(t, !0, e.topContainer), this.bottom = new $f(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(t) {
    let e = t.state.facet(ZC);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new $f(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new $f(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = t.state.facet(Td);
    if (n != this.input) {
      let i = n.filter((l) => l), r = [], s = [], o = [], a = [];
      for (let l of i) {
        let c = this.specs.indexOf(l), u;
        c < 0 ? (u = l(t.view), a.push(u)) : (u = this.panels[c], u.update && u.update(t)), r.push(u), (u.top ? s : o).push(u);
      }
      this.specs = i, this.panels = r, this.top.sync(s), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => ae.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class $f {
  constructor(e, n, i) {
    this.view = e, this.top = n, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = HC(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = HC(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function HC(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const Td = /* @__PURE__ */ de.define({
  enables: j$
});
class Rs extends Na {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Rs.prototype.elementClass = "";
Rs.prototype.toDOM = void 0;
Rs.prototype.mapMode = mn.TrackBefore;
Rs.prototype.startSide = Rs.prototype.endSide = -1;
Rs.prototype.point = !0;
const up = /* @__PURE__ */ de.define(), Bge = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Ye.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Tu = /* @__PURE__ */ de.define();
function Qge(t) {
  return [Y$(), Tu.of(Object.assign(Object.assign({}, Bge), t))];
}
const qC = /* @__PURE__ */ de.define({
  combine: (t) => t.some((e) => e)
});
function Y$(t) {
  return [
    Fge
  ];
}
const Fge = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Tu).map((e) => new jC(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(qC), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, n = t.view.viewport, i = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(i < (n.to - n.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(qC) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let n = Ye.iter(this.view.state.facet(up), this.view.viewport.from), i = [], r = this.gutters.map((s) => new zge(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(s.type)) {
        let o = !0;
        for (let a of s.type)
          if (a.type == Bn.Text && o) {
            Sy(n, i, a.from);
            for (let l of r)
              l.line(this.view, a, i);
            o = !1;
          } else if (a.widget)
            for (let l of r)
              l.widget(this.view, a);
      } else if (s.type == Bn.Text) {
        Sy(n, i, s.from);
        for (let o of r)
          o.line(this.view, s, i);
      } else if (s.widget)
        for (let o of r)
          o.widget(this.view, s);
    for (let s of r)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(Tu), n = t.state.facet(Tu), i = t.docChanged || t.heightChanged || t.viewportChanged || !Ye.eq(t.startState.facet(up), t.state.facet(up), t.view.viewport.from, t.view.viewport.to);
    if (e == n)
      for (let r of this.gutters)
        r.update(t) && (i = !0);
    else {
      i = !0;
      let r = [];
      for (let s of n) {
        let o = e.indexOf(s);
        o < 0 ? r.push(new jC(this.view, s)) : (this.gutters[o].update(t), r.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), r.indexOf(s) < 0 && s.destroy();
      for (let s of r)
        this.dom.appendChild(s.dom);
      this.gutters = r;
    }
    return i;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => ae.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == At.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };
  })
});
function XC(t) {
  return Array.isArray(t) ? t : [t];
}
function Sy(t, e, n) {
  for (; t.value && t.from <= n; )
    t.from == n && e.push(t.value), t.next();
}
class zge {
  constructor(e, n, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = Ye.iter(e.markers, n.from);
  }
  addElement(e, n, i) {
    let { gutter: r } = this, s = (n.top - this.height) / e.scaleY, o = n.height / e.scaleY;
    if (this.i == r.elements.length) {
      let a = new G$(e, o, s, i);
      r.elements.push(a), r.dom.appendChild(a.dom);
    } else
      r.elements[this.i].update(e, o, s, i);
    this.height = n.bottom, this.i++;
  }
  line(e, n, i) {
    let r = [];
    Sy(this.cursor, r, n.from), i.length && (r = r.concat(i));
    let s = this.gutter.config.lineMarker(e, n, r);
    s && r.unshift(s);
    let o = this.gutter;
    r.length == 0 && !o.config.renderEmptyElements || this.addElement(e, n, r);
  }
  widget(e, n) {
    let i = this.gutter.config.widgetMarker(e, n.widget, n);
    i && this.addElement(e, n, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class jC {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in n.domEventHandlers)
      this.dom.addEventListener(i, (r) => {
        let s = r.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = r.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        n.domEventHandlers[i](e, a, r) && r.preventDefault();
      });
    this.markers = XC(n.markers(e)), n.initialSpacer && (this.spacer = new G$(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = XC(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let r = this.config.updateSpacer(this.spacer.markers[0], e);
      r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]);
    }
    let i = e.view.viewport;
    return !Ye.eq(this.markers, n, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class G$ {
  constructor(e, n, i, r) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, i, r);
  }
  update(e, n, i, r) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), Uge(this.markers, r) || this.setMarkers(e, r);
  }
  setMarkers(e, n) {
    let i = "cm-gutterElement", r = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o, l = s < n.length ? n[s++] : null, c = !1;
      if (l) {
        let u = l.elementClass;
        u && (i += " " + u);
        for (let d = o; d < this.markers.length; d++)
          if (this.markers[d].compare(l)) {
            a = d, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(r);
          let d = r.nextSibling;
          r.remove(), r = d;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? r = r.nextSibling : this.dom.insertBefore(l.toDOM(e), r)), c && o++;
    }
    this.dom.className = i, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Uge(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].compare(e[n]))
      return !1;
  return !0;
}
const Wge = /* @__PURE__ */ de.define(), _l = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let i = Object.assign({}, e);
        for (let r in n) {
          let s = i[r], o = n[r];
          i[r] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;
        }
        return i;
      }
    });
  }
});
class V1 extends Rs {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Z1(t, e) {
  return t.state.facet(_l).formatNumber(e, t.state);
}
const Vge = /* @__PURE__ */ Tu.compute([_l], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Wge);
  },
  lineMarker(e, n, i) {
    return i.some((r) => r.toDOM) ? null : new V1(Z1(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(_l) != e.state.facet(_l),
  initialSpacer(e) {
    return new V1(Z1(e, YC(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let i = Z1(n.view, YC(n.view.state.doc.lines));
    return i == e.number ? e : new V1(i);
  },
  domEventHandlers: t.facet(_l).domEventHandlers
}));
function Zge(t = {}) {
  return [
    _l.of(t),
    Y$(),
    Vge
  ];
}
function YC(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const Hge = /* @__PURE__ */ new class extends Rs {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), qge = /* @__PURE__ */ up.compute(["selection"], (t) => {
  let e = [], n = -1;
  for (let i of t.selection.ranges) {
    let r = t.doc.lineAt(i.head).from;
    r > n && (n = r, e.push(Hge.range(r)));
  }
  return Ye.of(e);
});
function Xge() {
  return qge;
}
var H1;
const da = /* @__PURE__ */ new De();
function $_(t) {
  return de.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const N_ = /* @__PURE__ */ new De();
class Li {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, n, i = [], r = "") {
    this.data = e, this.name = r, je.prototype.hasOwnProperty("tree") || Object.defineProperty(je.prototype, "tree", { get() {
      return Nt(this);
    } }), this.parser = n, this.extension = [
      Po.of(this),
      je.languageData.of((s, o, a) => {
        let l = GC(s, o, a), c = l.type.prop(da);
        if (!c)
          return [];
        let u = s.facet(c), d = l.type.prop(N_);
        if (d) {
          let h = l.resolve(o - l.from, a);
          for (let f of d)
            if (f.test(h, s)) {
              let p = s.facet(f.facet);
              return f.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, n, i = -1) {
    return GC(e, n, i).type.prop(da) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let n = e.facet(Po);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let i = [], r = (s, o) => {
      if (s.prop(da) == this.data) {
        i.push({ from: o, to: o + s.length });
        return;
      }
      let a = s.prop(De.mounted);
      if (a) {
        if (a.tree.prop(da) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              i.push({ from: l.from + o, to: l.to + o });
          else
            i.push({ from: o, to: o + s.length });
          return;
        } else if (a.overlay) {
          let l = i.length;
          if (r(a.tree, a.overlay[0].from + o), i.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let c = s.children[l];
        c instanceof ot && r(c, s.positions[l] + o);
      }
    };
    return r(Nt(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Li.setState = /* @__PURE__ */ Me.define();
function GC(t, e, n) {
  let i = t.facet(Po), r = Nt(t).topNode;
  if (!i || i.allowsNesting)
    for (let s = r; s; s = s.enter(e, n, vt.ExcludeBuffers))
      s.type.isTop && (r = s);
  return r;
}
class Ba extends Li {
  constructor(e, n, i) {
    super(e, n, [], i), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let n = $_(e.languageData);
    return new Ba(n, e.parser.configure({
      props: [da.add((i) => i.isTop ? n : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, n) {
    return new Ba(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Nt(t) {
  let e = t.field(Li.state, !1);
  return e ? e.tree : ot.empty;
}
class jge {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let i = this.cursorPos - this.string.length;
    return e < i || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - i, n - i);
  }
}
let Qc = null;
class oc {
  constructor(e, n, i = [], r, s, o, a, l) {
    this.parser = e, this.state = n, this.fragments = i, this.tree = r, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new oc(e, n, [], ot.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new jge(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != ot.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let r = Date.now() + e;
        e = () => Date.now() > r;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(Es.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(Es.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let n = Qc;
    Qc = this;
    try {
      return e();
    } finally {
      Qc = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = KC(e, n.from, n.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, n) {
    let { fragments: i, tree: r, treeLen: s, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, d, h) => l.push({ fromA: c, toA: u, fromB: d, toB: h })), i = Es.applyChanges(i, l), r = ot.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), d = e.mapPos(c.to, -1);
          u < d && a.push({ from: u, to: d });
        }
      }
    }
    return new oc(this.parser, n, i, r, s, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: r, to: s } = this.skipped[i];
      r < e.to && s > e.from && (this.fragments = KC(this.fragments, r, s), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends y_ {
      createParse(n, i, r) {
        let s = r[0].from, o = r[r.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = Qc;
            if (l) {
              for (let c of r)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new ot(Mn.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Qc;
  }
}
function KC(t, e, n) {
  return Es.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class ac {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, i) || n.takeTree(), new ac(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), i = oc.create(e.facet(Po).parser, e, { from: 0, to: n });
    return i.work(20, n) || i.takeTree(), new ac(i);
  }
}
Li.state = /* @__PURE__ */ ln.define({
  create: ac.init,
  update(t, e) {
    for (let n of e.effects)
      if (n.is(Li.setState))
        return n.value;
    return e.startState.facet(Po) != e.state.facet(Po) ? ac.init(e.state) : t.apply(e);
  }
});
let K$ = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (K$ = (t) => {
  let e = -1, n = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
const q1 = typeof navigator < "u" && (!((H1 = navigator.scheduling) === null || H1 === void 0) && H1.isInputPending) ? () => navigator.scheduling.isInputPending() : null, Yge = /* @__PURE__ */ Ht.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(Li.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(Li.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = K$(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: r } } = this.view, s = i.field(Li.state);
    if (s.tree == s.context.tree && s.context.isDone(
      r + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !q1 ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < r && i.doc.length > r + 1e3, l = s.context.work(() => q1 && q1() || Date.now() > o, r + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: Li.setState.of(new ac(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => ni(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Po = /* @__PURE__ */ de.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    Li.state,
    Yge,
    ae.contentAttributes.compute([t], (e) => {
      let n = e.facet(t);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class J0 {
  /**
  Create a language support object.
  */
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
}
const J$ = /* @__PURE__ */ de.define(), eg = /* @__PURE__ */ de.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function Qa(t) {
  let e = t.facet(eg);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function Md(t, e) {
  let n = "", i = t.tabSize, r = t.facet(eg)[0];
  if (r == "	") {
    for (; e >= i; )
      n += "	", e -= i;
    r = " ";
  }
  for (let s = 0; s < e; s++)
    n += r;
  return n;
}
function D_(t, e) {
  t instanceof je && (t = new tg(t));
  for (let i of t.state.facet(J$)) {
    let r = i(t, e);
    if (r !== void 0)
      return r;
  }
  let n = Nt(t.state);
  return n.length >= e ? Gge(t, n, e) : null;
}
class tg {
  /**
  Create an indent context.
  */
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = Qa(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, n = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: r, simulateDoubleBreak: s } = this.options;
    return r != null && r >= i.from && r <= i.to ? s && r == e ? { text: "", from: e } : (n < 0 ? r < e : r <= e) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: r } = this.lineAt(e, n);
    return i.slice(e - r, Math.min(i.length, e + 100 - r));
  }
  /**
  Find the column for the given position.
  */
  column(e, n = 1) {
    let { text: i, from: r } = this.lineAt(e, n), s = this.countColumn(i, e - r), o = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return o > -1 && (s += o - this.countColumn(i, i.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, n = e.length) {
    return Ec(e, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, n = 1) {
    let { text: i, from: r } = this.lineAt(e, n), s = this.options.overrideIndentation;
    if (s) {
      let o = s(r);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const ph = /* @__PURE__ */ new De();
function Gge(t, e, n) {
  let i = e.resolveStack(n), r = i.node.enterUnfinishedNodesBefore(n);
  if (r != i.node) {
    let s = [];
    for (let o = r; o != i.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      i = { node: s[o], next: i };
  }
  return eN(i, t, n);
}
function eN(t, e, n) {
  for (let i = t; i; i = i.next) {
    let r = Jge(i.node);
    if (r)
      return r(I_.create(e, n, i));
  }
  return 0;
}
function Kge(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function Jge(t) {
  let e = t.type.prop(ph);
  if (e)
    return e;
  let n = t.firstChild, i;
  if (n && (i = n.type.prop(De.closedBy))) {
    let r = t.lastChild, s = r && i.indexOf(r.name) > -1;
    return (o) => tN(o, !0, 1, void 0, s && !Kge(o) ? r.from : void 0);
  }
  return t.parent == null ? e1e : null;
}
function e1e() {
  return 0;
}
class I_ extends tg {
  constructor(e, n, i) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, n, i) {
    return new I_(e, n, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(n.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (t1e(i, e))
        break;
      n = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return eN(this.context.next, this.base, this.pos);
  }
}
function t1e(t, e) {
  for (let n = e; n; n = n.parent)
    if (t == n)
      return !0;
  return !1;
}
function n1e(t) {
  let e = t.node, n = e.childAfter(e.from), i = e.lastChild;
  if (!n)
    return null;
  let r = t.options.simulateBreak, s = t.state.doc.lineAt(n.from), o = r == null || r <= s.from ? s.to : Math.min(s.to, r);
  for (let a = n.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped)
      return l.from < o ? n : null;
    a = l.to;
  }
}
function i1e({ closing: t, align: e = !0, units: n = 1 }) {
  return (i) => tN(i, e, n, t);
}
function tN(t, e, n, i, r) {
  let s = t.textAfter, o = s.match(/^\s*/)[0].length, a = i && s.slice(o, o + i.length) == i || r == t.pos + o, l = e ? n1e(t) : null;
  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n);
}
const r1e = (t) => t.baseIndent;
function $l({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let i = t && t.test(n.textAfter);
    return n.baseIndent + (i ? 0 : e * n.unit);
  };
}
const s1e = 200;
function o1e() {
  return je.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let n = t.newDoc, { head: i } = t.newSelection.main, r = n.lineAt(i);
    if (i > r.from + s1e)
      return t;
    let s = n.sliceString(r.from, i);
    if (!e.some((c) => c.test(s)))
      return t;
    let { state: o } = t, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let d = D_(o, u.from);
      if (d == null)
        continue;
      let h = /^\s*/.exec(u.text)[0], f = Md(o, d);
      h != f && l.push({ from: u.from, to: u.from + h.length, insert: f });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const a1e = /* @__PURE__ */ de.define(), mh = /* @__PURE__ */ new De();
function L_(t) {
  let e = t.firstChild, n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
function l1e(t, e, n) {
  let i = Nt(t);
  if (i.length < n)
    return null;
  let r = i.resolveStack(n, 1), s = null;
  for (let o = r; o; o = o.next) {
    let a = o.node;
    if (a.to <= n || a.from > n)
      continue;
    if (s && a.from < e)
      break;
    let l = a.type.prop(mh);
    if (l && (a.to < i.length - 50 || i.length == t.doc.length || !c1e(a))) {
      let c = l(a, t);
      c && c.from <= n && c.from >= e && c.to > n && (s = c);
    }
  }
  return s;
}
function c1e(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function Fm(t, e, n) {
  for (let i of t.facet(a1e)) {
    let r = i(t, e, n);
    if (r)
      return r;
  }
  return l1e(t, e, n);
}
function nN(t, e) {
  let n = e.mapPos(t.from, 1), i = e.mapPos(t.to, -1);
  return n >= i ? void 0 : { from: n, to: i };
}
const ng = /* @__PURE__ */ Me.define({ map: nN }), gh = /* @__PURE__ */ Me.define({ map: nN });
function iN(t) {
  let e = [];
  for (let { head: n } of t.state.selection.ranges)
    e.some((i) => i.from <= n && i.to >= n) || e.push(t.lineBlockAt(n));
  return e;
}
const Fa = /* @__PURE__ */ ln.define({
  create() {
    return ve.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      if (n.is(ng) && !u1e(t, n.value.from, n.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(oN), r = i ? ve.replace({ widget: new b1e(i(e.state, n.value)) }) : JC;
        t = t.update({ add: [r.range(n.value.from, n.value.to)] });
      } else n.is(gh) && (t = t.update({
        filter: (i, r) => n.value.from != i || n.value.to != r,
        filterFrom: n.value.from,
        filterTo: n.value.to
      }));
    if (e.selection) {
      let n = !1, { head: i } = e.selection.main;
      t.between(i, i, (r, s) => {
        r < i && s > i && (n = !0);
      }), n && (t = t.update({
        filterFrom: i,
        filterTo: i,
        filter: (r, s) => s <= i || r >= i
      }));
    }
    return t;
  },
  provide: (t) => ae.decorations.from(t),
  toJSON(t, e) {
    let n = [];
    return t.between(0, e.doc.length, (i, r) => {
      n.push(i, r);
    }), n;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t.length; ) {
      let i = t[n++], r = t[n++];
      if (typeof i != "number" || typeof r != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(JC.range(i, r));
    }
    return ve.set(e, !0);
  }
});
function zm(t, e, n) {
  var i;
  let r = null;
  return (i = t.field(Fa, !1)) === null || i === void 0 || i.between(e, n, (s, o) => {
    (!r || r.from > s) && (r = { from: s, to: o });
  }), r;
}
function u1e(t, e, n) {
  let i = !1;
  return t.between(e, e, (r, s) => {
    r == e && s == n && (i = !0);
  }), i;
}
function rN(t, e) {
  return t.field(Fa, !1) ? e : e.concat(Me.appendConfig.of(aN()));
}
const d1e = (t) => {
  for (let e of iN(t)) {
    let n = Fm(t.state, e.from, e.to);
    if (n)
      return t.dispatch({ effects: rN(t.state, [ng.of(n), sN(t, n)]) }), !0;
  }
  return !1;
}, h1e = (t) => {
  if (!t.state.field(Fa, !1))
    return !1;
  let e = [];
  for (let n of iN(t)) {
    let i = zm(t.state, n.from, n.to);
    i && e.push(gh.of(i), sN(t, i, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function sN(t, e, n = !0) {
  let i = t.state.doc.lineAt(e.from).number, r = t.state.doc.lineAt(e.to).number;
  return ae.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${i} ${t.state.phrase("to")} ${r}.`);
}
const f1e = (t) => {
  let { state: e } = t, n = [];
  for (let i = 0; i < e.doc.length; ) {
    let r = t.lineBlockAt(i), s = Fm(e, r.from, r.to);
    s && n.push(ng.of(s)), i = (s ? t.lineBlockAt(s.to) : r).to + 1;
  }
  return n.length && t.dispatch({ effects: rN(t.state, n) }), !!n.length;
}, p1e = (t) => {
  let e = t.state.field(Fa, !1);
  if (!e || !e.size)
    return !1;
  let n = [];
  return e.between(0, t.state.doc.length, (i, r) => {
    n.push(gh.of({ from: i, to: r }));
  }), t.dispatch({ effects: n }), !0;
}, m1e = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: d1e },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: h1e },
  { key: "Ctrl-Alt-[", run: f1e },
  { key: "Ctrl-Alt-]", run: p1e }
], g1e = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, oN = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, g1e);
  }
});
function aN(t) {
  return [Fa, _1e];
}
function lN(t, e) {
  let { state: n } = t, i = n.facet(oN), r = (o) => {
    let a = t.lineBlockAt(t.posAtDOM(o.target)), l = zm(t.state, a.from, a.to);
    l && t.dispatch({ effects: gh.of(l) }), o.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(t, r, e);
  let s = document.createElement("span");
  return s.textContent = i.placeholderText, s.setAttribute("aria-label", n.phrase("folded code")), s.title = n.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = r, s;
}
const JC = /* @__PURE__ */ ve.replace({ widget: /* @__PURE__ */ new class extends Ns {
  toDOM(t) {
    return lN(t, null);
  }
}() });
class b1e extends Ns {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return lN(e, this.value);
  }
}
const O1e = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class X1 extends Rs {
  constructor(e, n) {
    super(), this.config = e, this.open = n;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function y1e(t = {}) {
  let e = Object.assign(Object.assign({}, O1e), t), n = new X1(e, !0), i = new X1(e, !1), r = Ht.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Po) != o.state.facet(Po) || o.startState.field(Fa, !1) != o.state.field(Fa, !1) || Nt(o.startState) != Nt(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new Ao();
      for (let l of o.viewportLineBlocks) {
        let c = zm(o.state, l.from, l.to) ? i : Fm(o.state, l.from, l.to) ? n : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    r,
    Qge({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(r)) === null || a === void 0 ? void 0 : a.markers) || Ye.empty;
      },
      initialSpacer() {
        return new X1(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, a, l) => {
        if (s.click && s.click(o, a, l))
          return !0;
        let c = zm(o.state, a.from, a.to);
        if (c)
          return o.dispatch({ effects: gh.of(c) }), !0;
        let u = Fm(o.state, a.from, a.to);
        return u ? (o.dispatch({ effects: ng.of(u) }), !0) : !1;
      } })
    }),
    aN()
  ];
}
const _1e = /* @__PURE__ */ ae.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class ig {
  constructor(e, n) {
    this.specs = e;
    let i;
    function r(a) {
      let l = To.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof n.all == "string" ? n.all : n.all ? r(n.all) : void 0, o = n.scope;
    this.scope = o instanceof Li ? (a) => a.prop(da) == o.data : o ? (a) => a == o : void 0, this.style = x4(e.map((a) => ({
      tag: a.tag,
      class: a.class || r(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = i ? new To(i) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, n) {
    return new ig(e, n || {});
  }
}
const ky = /* @__PURE__ */ de.define(), cN = /* @__PURE__ */ de.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function j1(t) {
  let e = t.facet(ky);
  return e.length ? e : t.facet(cN);
}
function v1e(t, e) {
  let n = [w1e], i;
  return t instanceof ig && (t.module && n.push(ae.styleModule.of(t.module)), i = t.themeType), e != null && e.fallback ? n.push(cN.of(t)) : i ? n.push(ky.computeN([ae.darkTheme], (r) => r.facet(ae.darkTheme) == (i == "dark") ? [t] : [])) : n.push(ky.of(t)), n;
}
class x1e {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Nt(e.state), this.decorations = this.buildDeco(e, j1(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let n = Nt(e.state), i = j1(e.state), r = i != j1(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    n.length < s.to && !r && n.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (n != this.tree || e.viewportChanged || r) && (this.tree = n, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = s.to);
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return ve.none;
    let i = new Ao();
    for (let { from: r, to: s } of e.visibleRanges)
      Lpe(this.tree, n, (o, a, l) => {
        i.add(o, a, this.markCache[l] || (this.markCache[l] = ve.mark({ class: l })));
      }, r, s);
    return i.finish();
  }
}
const w1e = /* @__PURE__ */ Fo.high(/* @__PURE__ */ Ht.fromClass(x1e, {
  decorations: (t) => t.decorations
})), S1e = /* @__PURE__ */ ig.define([
  {
    tag: D.meta,
    color: "#404740"
  },
  {
    tag: D.link,
    textDecoration: "underline"
  },
  {
    tag: D.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: D.emphasis,
    fontStyle: "italic"
  },
  {
    tag: D.strong,
    fontWeight: "bold"
  },
  {
    tag: D.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: D.keyword,
    color: "#708"
  },
  {
    tag: [D.atom, D.bool, D.url, D.contentSeparator, D.labelName],
    color: "#219"
  },
  {
    tag: [D.literal, D.inserted],
    color: "#164"
  },
  {
    tag: [D.string, D.deleted],
    color: "#a11"
  },
  {
    tag: [D.regexp, D.escape, /* @__PURE__ */ D.special(D.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ D.definition(D.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ D.local(D.variableName),
    color: "#30a"
  },
  {
    tag: [D.typeName, D.namespace],
    color: "#085"
  },
  {
    tag: D.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ D.special(D.variableName), D.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ D.definition(D.propertyName),
    color: "#00c"
  },
  {
    tag: D.comment,
    color: "#940"
  },
  {
    tag: D.invalid,
    color: "#f00"
  }
]), k1e = /* @__PURE__ */ ae.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), uN = 1e4, dN = "()[]{}", hN = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, {
      afterCursor: !0,
      brackets: dN,
      maxScanDistance: uN,
      renderMatch: A1e
    });
  }
}), E1e = /* @__PURE__ */ ve.mark({ class: "cm-matchingBracket" }), C1e = /* @__PURE__ */ ve.mark({ class: "cm-nonmatchingBracket" });
function A1e(t) {
  let e = [], n = t.matched ? E1e : C1e;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const T1e = /* @__PURE__ */ ln.define({
  create() {
    return ve.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let n = [], i = e.state.facet(hN);
    for (let r of e.state.selection.ranges) {
      if (!r.empty)
        continue;
      let s = Br(e.state, r.head, -1, i) || r.head > 0 && Br(e.state, r.head - 1, 1, i) || i.afterCursor && (Br(e.state, r.head, 1, i) || r.head < e.state.doc.length && Br(e.state, r.head + 1, -1, i));
      s && (n = n.concat(i.renderMatch(s, e.state)));
    }
    return ve.set(n, !0);
  },
  provide: (t) => ae.decorations.from(t)
}), M1e = [
  T1e,
  k1e
];
function P1e(t = {}) {
  return [hN.of(t), M1e];
}
const fN = /* @__PURE__ */ new De();
function Ey(t, e, n) {
  let i = t.prop(e < 0 ? De.openedBy : De.closedBy);
  if (i)
    return i;
  if (t.name.length == 1) {
    let r = n.indexOf(t.name);
    if (r > -1 && r % 2 == (e < 0 ? 1 : 0))
      return [n[r + e]];
  }
  return null;
}
function Cy(t) {
  let e = t.type.prop(fN);
  return e ? e(t.node) : t;
}
function Br(t, e, n, i = {}) {
  let r = i.maxScanDistance || uN, s = i.brackets || dN, o = Nt(t), a = o.resolveInner(e, n);
  for (let l = a; l; l = l.parent) {
    let c = Ey(l.type, n, s);
    if (c && l.from < l.to) {
      let u = Cy(l);
      if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return R1e(t, e, n, l, u, c, s);
    }
  }
  return $1e(t, e, n, o, a.type, r, s);
}
function R1e(t, e, n, i, r, s, o) {
  let a = i.parent, l = { from: r.from, to: r.to }, c = 0, u = a == null ? void 0 : a.cursor();
  if (u && (n < 0 ? u.childBefore(i.from) : u.childAfter(i.to)))
    do
      if (n < 0 ? u.to <= i.from : u.from >= i.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let d = Cy(u);
          return { start: l, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (Ey(u.type, n, o))
          c++;
        else if (Ey(u.type, -n, o)) {
          if (c == 0) {
            let d = Cy(u);
            return {
              start: l,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (n < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function $1e(t, e, n, i, r, s, o) {
  let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != n > 0)
    return null;
  let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), d = 0;
  for (let h = 0; !u.next().done && h <= s; ) {
    let f = u.value;
    n < 0 && (h += f.length);
    let p = e + h * n;
    for (let m = n > 0 ? 0 : f.length - 1, g = n > 0 ? f.length : -1; m != g; m += n) {
      let b = o.indexOf(f[m]);
      if (!(b < 0 || i.resolveInner(p + m, 1).type != r))
        if (b % 2 == 0 == n > 0)
          d++;
        else {
          if (d == 1)
            return { start: c, end: { from: p + m, to: p + m + 1 }, matched: b >> 1 == l >> 1 };
          d--;
        }
    }
    n > 0 && (h += f.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function eA(t, e, n, i = 0, r = 0) {
  e == null && (e = t.search(/[^\s\u00a0]/), e == -1 && (e = t.length));
  let s = r;
  for (let o = i; o < e; o++)
    t.charCodeAt(o) == 9 ? s += n - s % n : s++;
  return s;
}
class pN {
  /**
  Create a stream.
  */
  constructor(e, n, i, r) {
    this.string = e, this.tabSize = n, this.indentUnit = i, this.overrideIndent = r, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let n = this.string.charAt(this.pos), i;
    if (typeof e == "string" ? i = n == e : i = n && (e instanceof RegExp ? e.test(n) : e(n)), i)
      return ++this.pos, n;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let n = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > n;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let n = this.string.indexOf(e, this.pos);
    if (n > -1)
      return this.pos = n, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = eA(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : eA(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, n, i) {
    if (typeof e == "string") {
      let r = (o) => i ? o.toLowerCase() : o, s = this.string.substr(this.pos, e.length);
      return r(s) == r(e) ? (n !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let r = this.string.slice(this.pos).match(e);
      return r && r.index > 0 ? null : (r && n !== !1 && (this.pos += r[0].length), r);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function N1e(t) {
  return {
    name: t.name || "",
    token: t.token,
    blankLine: t.blankLine || (() => {
    }),
    startState: t.startState || (() => !0),
    copyState: t.copyState || D1e,
    indent: t.indent || (() => null),
    languageData: t.languageData || {},
    tokenTable: t.tokenTable || F_
  };
}
function D1e(t) {
  if (typeof t != "object")
    return t;
  let e = {};
  for (let n in t) {
    let i = t[n];
    e[n] = i instanceof Array ? i.slice() : i;
  }
  return e;
}
const tA = /* @__PURE__ */ new WeakMap();
class B_ extends Li {
  constructor(e) {
    let n = $_(e.languageData), i = N1e(e), r, s = new class extends y_ {
      createParse(o, a, l) {
        return new L1e(r, o, a, l);
      }
    }();
    super(n, s, [J$.of((o, a) => this.getIndent(o, a))], e.name), this.topNode = F1e(n), r = this, this.streamParser = i, this.stateAfter = new De({ perNode: !0 }), this.tokenTable = e.tokenTable ? new ON(i.tokenTable) : Q1e;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new B_(e);
  }
  getIndent(e, n) {
    let i = Nt(e.state), r = i.resolve(n);
    for (; r && r.type != this.topNode; )
      r = r.parent;
    if (!r)
      return null;
    let s, { overrideIndentation: o } = e.options;
    o && (s = tA.get(e.state), s != null && s < n - 1e4 && (s = void 0));
    let a = Q_(this, i, 0, r.from, s ?? n), l, c;
    if (a ? (c = a.state, l = a.pos + 1) : (c = this.streamParser.startState(e.unit), l = 0), n - l > 1e4)
      return null;
    for (; l < n; ) {
      let d = e.state.doc.lineAt(l), h = Math.min(n, d.to);
      if (d.length) {
        let f = o ? o(d.from) : -1, p = new pN(d.text, e.state.tabSize, e.unit, f < 0 ? void 0 : f);
        for (; p.pos < h - d.from; )
          gN(this.streamParser.token, p, c);
      } else
        this.streamParser.blankLine(c, e.unit);
      if (h == n)
        break;
      l = d.to + 1;
    }
    let u = e.lineAt(n);
    return o && s == null && tA.set(e.state, u.from), this.streamParser.indent(c, /^\s*(.*)/.exec(u.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function Q_(t, e, n, i, r) {
  let s = n >= i && n + e.length <= r && e.prop(t.stateAfter);
  if (s)
    return { state: t.streamParser.copyState(s), pos: n + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let a = e.children[o], l = n + e.positions[o], c = a instanceof ot && l < r && Q_(t, a, l, i, r);
    if (c)
      return c;
  }
  return null;
}
function mN(t, e, n, i, r) {
  if (r && n <= 0 && i >= e.length)
    return e;
  !r && e.type == t.topNode && (r = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s], a = e.children[s], l;
    if (o < i && a instanceof ot) {
      if (!(l = mN(t, a, n - o, i - o, r)))
        break;
      return r ? new ot(e.type, e.children.slice(0, s).concat(l), e.positions.slice(0, s + 1), o + l.length) : l;
    }
  }
  return null;
}
function I1e(t, e, n, i) {
  for (let r of e) {
    let s = r.from + (r.openStart ? 25 : 0), o = r.to - (r.openEnd ? 25 : 0), a = s <= n && o > n && Q_(t, r.tree, 0 - r.offset, n, o), l;
    if (a && (l = mN(t, r.tree, n + r.offset, a.pos + r.offset, !1)))
      return { state: a.state, tree: l };
  }
  return { state: t.streamParser.startState(i ? Qa(i) : 4), tree: ot.empty };
}
class L1e {
  constructor(e, n, i, r) {
    this.lang = e, this.input = n, this.fragments = i, this.ranges = r, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = r[r.length - 1].to;
    let s = oc.get(), o = r[0].from, { state: a, tree: l } = I1e(e, i, o, s == null ? void 0 : s.state);
    this.state = a, this.parsedPos = this.chunkStart = o + l.length;
    for (let c = 0; c < l.children.length; c++)
      this.chunks.push(l.children[c]), this.chunkPos.push(l.positions[c]);
    s && this.parsedPos < s.viewport.from - 1e5 && (this.state = this.lang.streamParser.startState(Qa(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = oc.get(), n = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      n,
      this.chunkStart + 2048
      /* C.ChunkSize */
    );
    for (e && (i = Math.min(i, e.viewport.to)); this.parsedPos < i; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= n ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, n), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let n = this.input.chunk(e);
    if (this.input.lineChunks)
      n == `
` && (n = "");
    else {
      let i = n.indexOf(`
`);
      i > -1 && (n = n.slice(0, i));
    }
    return e + n.length <= this.to ? n : n.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, n = this.lineAfter(e), i = e + n.length;
    for (let r = this.rangeIndex; ; ) {
      let s = this.ranges[r].to;
      if (s >= i || (n = n.slice(0, s - (i - n.length)), r++, r == this.ranges.length))
        break;
      let o = this.ranges[r].from, a = this.lineAfter(o);
      n += a, i = o + a.length;
    }
    return { line: n, end: i };
  }
  skipGapsTo(e, n, i) {
    for (; ; ) {
      let r = this.ranges[this.rangeIndex].to, s = e + n;
      if (i > 0 ? r > s : r >= s)
        break;
      let o = this.ranges[++this.rangeIndex].from;
      n += o - r;
    }
    return n;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, n, i, r, s) {
    if (this.ranges.length > 1) {
      s = this.skipGapsTo(n, s, 1), n += s;
      let o = this.chunk.length;
      s = this.skipGapsTo(i, s, -1), i += s, r += this.chunk.length - o;
    }
    return this.chunk.push(e, n, i, r), s;
  }
  parseLine(e) {
    let { line: n, end: i } = this.nextLine(), r = 0, { streamParser: s } = this.lang, o = new pN(n, e ? e.state.tabSize : 4, e ? Qa(e.state) : 2);
    if (o.eol())
      s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let a = gN(s.token, o, this.state);
        if (a && (r = this.emitToken(this.lang.tokenTable.resolve(a), this.parsedPos + o.start, this.parsedPos + o.pos, 4, r)), o.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = ot.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: B1e,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    e = new ot(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new ot(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function gN(t, e, n) {
  e.start = e.pos;
  for (let i = 0; i < 10; i++) {
    let r = t(e, n);
    if (e.pos > e.start)
      return r;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const F_ = /* @__PURE__ */ Object.create(null), Pd = [Mn.none], B1e = /* @__PURE__ */ new X0(Pd), nA = [], iA = /* @__PURE__ */ Object.create(null), bN = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  bN[t] = /* @__PURE__ */ yN(F_, e);
class ON {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), bN);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = yN(this.extra, e)) : 0;
  }
}
const Q1e = /* @__PURE__ */ new ON(F_);
function Y1(t, e) {
  nA.indexOf(t) > -1 || (nA.push(t), console.warn(e));
}
function yN(t, e) {
  let n = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = t[c] || D[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : Y1(c, `Modifier ${c} used at start of tag`) : l.length ? Y1(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : Y1(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      n.push(c);
  }
  if (!n.length)
    return 0;
  let i = e.replace(/ /g, "_"), r = i + " " + n.map((a) => a.id), s = iA[r];
  if (s)
    return s.id;
  let o = iA[r] = Mn.define({
    id: Pd.length,
    name: i,
    props: [uh({ [i]: n })]
  });
  return Pd.push(o), o.id;
}
function F1e(t) {
  let e = Mn.define({ id: Pd.length, name: "Document", props: [da.add(() => t)], top: !0 });
  return Pd.push(e), e;
}
At.RTL, At.LTR;
let G1 = null;
function K1() {
  if (!G1 && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], n = /* @__PURE__ */ new Set();
    for (let i in t)
      i != "cssText" && i != "cssFloat" && typeof t[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (r) => "-" + r.toLowerCase())), n.has(i) || (e.push(i), n.add(i)));
    G1 = e.sort().map((i) => ({ type: "property", label: i }));
  }
  return G1 || [];
}
const rA = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), sA = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), z1e = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), Ls = /^(\w[\w-]*|-\w[\w-]*|)$/, U1e = /^-(-[\w-]*)?$/;
function W1e(t, e) {
  var n;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let i = (n = t.parent) === null || n === void 0 ? void 0 : n.firstChild;
  return (i == null ? void 0 : i.name) != "Callee" ? !1 : e.sliceString(i.from, i.to) == "var";
}
const oA = /* @__PURE__ */ new O4(), V1e = ["Declaration"];
function Z1e(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function _N(t, e, n) {
  if (e.to - e.from > 4096) {
    let i = oA.get(e);
    if (i)
      return i;
    let r = [], s = /* @__PURE__ */ new Set(), o = e.cursor(vt.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let a of _N(t, o.node, n))
          s.has(a.label) || (s.add(a.label), r.push(a));
      while (o.nextSibling());
    return oA.set(e, r), r;
  } else {
    let i = [], r = /* @__PURE__ */ new Set();
    return e.cursor().iterate((s) => {
      var o;
      if (n(s) && s.matchContext(V1e) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let a = t.sliceString(s.from, s.to);
        r.has(a) || (r.add(a), i.push({ label: a, type: "variable" }));
      }
    }), i;
  }
}
const H1e = (t) => (e) => {
  let { state: n, pos: i } = e, r = Nt(n).resolveInner(i, -1), s = r.type.isError && r.from == r.to - 1 && n.doc.sliceString(r.from, r.to) == "-";
  if (r.name == "PropertyName" || (s || r.name == "TagName") && /^(Block|Styles)$/.test(r.resolve(r.to).name))
    return { from: r.from, options: K1(), validFor: Ls };
  if (r.name == "ValueName")
    return { from: r.from, options: sA, validFor: Ls };
  if (r.name == "PseudoClassName")
    return { from: r.from, options: rA, validFor: Ls };
  if (t(r) || (e.explicit || s) && W1e(r, n.doc))
    return {
      from: t(r) || s ? r.from : i,
      options: _N(n.doc, Z1e(r), t),
      validFor: U1e
    };
  if (r.name == "TagName") {
    for (let { parent: l } = r; l; l = l.parent)
      if (l.name == "Block")
        return { from: r.from, options: K1(), validFor: Ls };
    return { from: r.from, options: z1e, validFor: Ls };
  }
  if (!e.explicit)
    return null;
  let o = r.resolve(i), a = o.childBefore(i);
  return a && a.name == ":" && o.name == "PseudoClassSelector" ? { from: i, options: rA, validFor: Ls } : a && a.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: i, options: sA, validFor: Ls } : o.name == "Block" || o.name == "Styles" ? { from: i, options: K1(), validFor: Ls } : null;
}, q1e = /* @__PURE__ */ H1e((t) => t.name == "VariableName"), Um = /* @__PURE__ */ Ba.define({
  name: "css",
  parser: /* @__PURE__ */ sme.configure({
    props: [
      /* @__PURE__ */ ph.add({
        Declaration: /* @__PURE__ */ $l()
      }),
      /* @__PURE__ */ mh.add({
        "Block KeyframeList": L_
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function vN() {
  return new J0(Um, Um.data.of({ autocomplete: q1e }));
}
const X1e = 54, j1e = 1, Y1e = 55, G1e = 2, K1e = 56, J1e = 3, aA = 4, ebe = 5, Wm = 6, xN = 7, wN = 8, SN = 9, kN = 10, tbe = 11, nbe = 12, ibe = 13, J1 = 57, rbe = 14, lA = 58, EN = 20, sbe = 22, CN = 23, obe = 24, Ay = 26, AN = 27, abe = 28, lbe = 31, cbe = 34, ube = 36, dbe = 37, hbe = 0, fbe = 1, pbe = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, mbe = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, cA = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function gbe(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function TN(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let uA = null, dA = null, hA = 0;
function Ty(t, e) {
  let n = t.pos + e;
  if (hA == n && dA == t) return uA;
  let i = t.peek(e);
  for (; TN(i); ) i = t.peek(++e);
  let r = "";
  for (; gbe(i); )
    r += String.fromCharCode(i), i = t.peek(++e);
  return dA = t, hA = n, uA = r ? r.toLowerCase() : i == bbe || i == Obe ? void 0 : null;
}
const MN = 60, Vm = 62, z_ = 47, bbe = 63, Obe = 33, ybe = 45;
function fA(t, e) {
  this.name = t, this.parent = e;
}
const _be = [Wm, kN, xN, wN, SN], vbe = new _4({
  start: null,
  shift(t, e, n, i) {
    return _be.indexOf(e) > -1 ? new fA(Ty(i, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == EN && t ? t.parent : t;
  },
  reuse(t, e, n, i) {
    let r = e.type.id;
    return r == Wm || r == ube ? new fA(Ty(i, 1) || "", t) : t;
  },
  strict: !1
}), xbe = new br((t, e) => {
  if (t.next != MN) {
    t.next < 0 && e.context && t.acceptToken(J1);
    return;
  }
  t.advance();
  let n = t.next == z_;
  n && t.advance();
  let i = Ty(t, 0);
  if (i === void 0) return;
  if (!i) return t.acceptToken(n ? rbe : Wm);
  let r = e.context ? e.context.name : null;
  if (n) {
    if (i == r) return t.acceptToken(tbe);
    if (r && mbe[r]) return t.acceptToken(J1, -2);
    if (e.dialectEnabled(hbe)) return t.acceptToken(nbe);
    for (let s = e.context; s; s = s.parent) if (s.name == i) return;
    t.acceptToken(ibe);
  } else {
    if (i == "script") return t.acceptToken(xN);
    if (i == "style") return t.acceptToken(wN);
    if (i == "textarea") return t.acceptToken(SN);
    if (pbe.hasOwnProperty(i)) return t.acceptToken(kN);
    r && cA[r] && cA[r][i] ? t.acceptToken(J1, -1) : t.acceptToken(Wm);
  }
}, { contextual: !0 }), wbe = new br((t) => {
  for (let e = 0, n = 0; ; n++) {
    if (t.next < 0) {
      n && t.acceptToken(lA);
      break;
    }
    if (t.next == ybe)
      e++;
    else if (t.next == Vm && e >= 2) {
      n >= 3 && t.acceptToken(lA, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function Sbe(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math") return !0;
  return !1;
}
const kbe = new br((t, e) => {
  if (t.next == z_ && t.peek(1) == Vm) {
    let n = e.dialectEnabled(fbe) || Sbe(e.context);
    t.acceptToken(n ? ebe : aA, 2);
  } else t.next == Vm && t.acceptToken(aA, 1);
});
function U_(t, e, n) {
  let i = 2 + t.length;
  return new br((r) => {
    for (let s = 0, o = 0, a = 0; ; a++) {
      if (r.next < 0) {
        a && r.acceptToken(e);
        break;
      }
      if (s == 0 && r.next == MN || s == 1 && r.next == z_ || s >= 2 && s < i && r.next == t.charCodeAt(s - 2))
        s++, o++;
      else if ((s == 2 || s == i) && TN(r.next))
        o++;
      else if (s == i && r.next == Vm) {
        a > o ? r.acceptToken(e, -o) : r.acceptToken(n, -(o - 2));
        break;
      } else if ((r.next == 10 || r.next == 13) && a) {
        r.acceptToken(e, 1);
        break;
      } else
        s = o = 0;
      r.advance();
    }
  });
}
const Ebe = U_("script", X1e, j1e), Cbe = U_("style", Y1e, G1e), Abe = U_("textarea", K1e, J1e), Tbe = uh({
  "Text RawText": D.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": D.angleBracket,
  TagName: D.tagName,
  "MismatchedCloseTag/TagName": [D.tagName, D.invalid],
  AttributeName: D.attributeName,
  "AttributeValue UnquotedAttributeValue": D.attributeValue,
  Is: D.definitionOperator,
  "EntityReference CharacterReference": D.character,
  Comment: D.blockComment,
  ProcessingInst: D.processingInstruction,
  DoctypeDecl: D.documentMeta
}), Mbe = $a.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: vbe,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [Tbe],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [Ebe, Cbe, Abe, kbe, xbe, wbe, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function PN(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i of t.getChildren(CN)) {
    let r = i.getChild(obe), s = i.getChild(Ay) || i.getChild(AN);
    r && (n[e.read(r.from, r.to)] = s ? s.type.id == Ay ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return n;
}
function pA(t, e) {
  let n = t.getChild(sbe);
  return n ? e.read(n.from, n.to) : " ";
}
function eb(t, e, n) {
  let i;
  for (let r of n)
    if (!r.attrs || r.attrs(i || (i = PN(t.node.parent.firstChild, e))))
      return { parser: r.parser };
  return null;
}
function RN(t = [], e = []) {
  let n = [], i = [], r = [], s = [];
  for (let a of t)
    (a.tag == "script" ? n : a.tag == "style" ? i : a.tag == "textarea" ? r : s).push(a);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e) (o[a.name] || (o[a.name] = [])).push(a);
  return bpe((a, l) => {
    let c = a.type.id;
    if (c == abe) return eb(a, l, n);
    if (c == lbe) return eb(a, l, i);
    if (c == cbe) return eb(a, l, r);
    if (c == EN && s.length) {
      let u = a.node, d = u.firstChild, h = d && pA(d, l), f;
      if (h) {
        for (let p of s)
          if (p.tag == h && (!p.attrs || p.attrs(f || (f = PN(d, l))))) {
            let m = u.lastChild, g = m.type.id == dbe ? m.from : u.to;
            if (g > d.to)
              return { parser: p.parser, overlay: [{ from: d.to, to: g }] };
          }
      }
    }
    if (o && c == CN) {
      let u = a.node, d;
      if (d = u.firstChild) {
        let h = o[l.read(d.from, d.to)];
        if (h) for (let f of h) {
          if (f.tagName && f.tagName != pA(u.parent, l)) continue;
          let p = u.lastChild;
          if (p.type.id == Ay) {
            let m = p.from + 1, g = p.lastChild, b = p.to - (g && g.isError ? 0 : 1);
            if (b > m) return { parser: f.parser, overlay: [{ from: m, to: b }] };
          } else if (p.type.id == AN)
            return { parser: f.parser, overlay: [{ from: p.from, to: p.to }] };
        }
      }
    }
    return null;
  });
}
const Pbe = 312, mA = 1, Rbe = 2, $be = 3, Nbe = 4, Dbe = 313, Ibe = 315, Lbe = 316, Bbe = 5, Qbe = 6, Fbe = 0, My = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], $N = 125, zbe = 59, Py = 47, Ube = 42, Wbe = 43, Vbe = 45, Zbe = 60, Hbe = 44, qbe = 63, Xbe = 46, jbe = new _4({
  start: !1,
  shift(t, e) {
    return e == Bbe || e == Qbe || e == Ibe ? t : e == Lbe;
  },
  strict: !1
}), Ybe = new br((t, e) => {
  let { next: n } = t;
  (n == $N || n == -1 || e.context) && t.acceptToken(Dbe);
}, { contextual: !0, fallback: !0 }), Gbe = new br((t, e) => {
  let { next: n } = t, i;
  My.indexOf(n) > -1 || n == Py && ((i = t.peek(1)) == Py || i == Ube) || n != $N && n != zbe && n != -1 && !e.context && t.acceptToken(Pbe);
}, { contextual: !0 }), Kbe = new br((t, e) => {
  let { next: n } = t;
  if (n == Wbe || n == Vbe) {
    if (t.advance(), n == t.next) {
      t.advance();
      let i = !e.context && e.canShift(mA);
      t.acceptToken(i ? mA : Rbe);
    }
  } else n == qbe && t.peek(1) == Xbe && (t.advance(), t.advance(), (t.next < 48 || t.next > 57) && t.acceptToken($be));
}, { contextual: !0 });
function tb(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const Jbe = new br((t, e) => {
  if (t.next != Zbe || !e.dialectEnabled(Fbe) || (t.advance(), t.next == Py)) return;
  let n = 0;
  for (; My.indexOf(t.next) > -1; )
    t.advance(), n++;
  if (tb(t.next, !0)) {
    for (t.advance(), n++; tb(t.next, !1); )
      t.advance(), n++;
    for (; My.indexOf(t.next) > -1; )
      t.advance(), n++;
    if (t.next == Hbe) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!tb(t.next, !0)) return;
        break;
      }
      if (t.next != "extends".charCodeAt(i)) break;
      t.advance(), n++;
    }
  }
  t.acceptToken(Nbe, -n);
}), eOe = uh({
  "get set async static": D.modifier,
  "for while do if else switch try catch finally return throw break continue default case": D.controlKeyword,
  "in of await yield void typeof delete instanceof": D.operatorKeyword,
  "let var const using function class extends": D.definitionKeyword,
  "import export from": D.moduleKeyword,
  "with debugger as new": D.keyword,
  TemplateString: D.special(D.string),
  super: D.atom,
  BooleanLiteral: D.bool,
  this: D.self,
  null: D.null,
  Star: D.modifier,
  VariableName: D.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": D.function(D.variableName),
  VariableDefinition: D.definition(D.variableName),
  Label: D.labelName,
  PropertyName: D.propertyName,
  PrivatePropertyName: D.special(D.propertyName),
  "CallExpression/MemberExpression/PropertyName": D.function(D.propertyName),
  "FunctionDeclaration/VariableDefinition": D.function(D.definition(D.variableName)),
  "ClassDeclaration/VariableDefinition": D.definition(D.className),
  PropertyDefinition: D.definition(D.propertyName),
  PrivatePropertyDefinition: D.definition(D.special(D.propertyName)),
  UpdateOp: D.updateOperator,
  "LineComment Hashbang": D.lineComment,
  BlockComment: D.blockComment,
  Number: D.number,
  String: D.string,
  Escape: D.escape,
  ArithOp: D.arithmeticOperator,
  LogicOp: D.logicOperator,
  BitOp: D.bitwiseOperator,
  CompareOp: D.compareOperator,
  RegExp: D.regexp,
  Equals: D.definitionOperator,
  Arrow: D.function(D.punctuation),
  ": Spread": D.punctuation,
  "( )": D.paren,
  "[ ]": D.squareBracket,
  "{ }": D.brace,
  "InterpolationStart InterpolationEnd": D.special(D.brace),
  ".": D.derefOperator,
  ", ;": D.separator,
  "@": D.meta,
  TypeName: D.typeName,
  TypeDefinition: D.definition(D.typeName),
  "type enum interface implements namespace module declare": D.definitionKeyword,
  "abstract global Privacy readonly override": D.modifier,
  "is keyof unique infer": D.operatorKeyword,
  JSXAttributeValue: D.attributeValue,
  JSXText: D.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": D.angleBracket,
  "JSXIdentifier JSXNameSpacedName": D.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": D.attributeName,
  "JSXBuiltin/JSXIdentifier": D.standard(D.tagName)
}), tOe = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, extends: 54, this: 58, true: 66, false: 66, null: 78, void: 82, typeof: 86, super: 102, new: 136, delete: 148, yield: 157, await: 161, class: 166, public: 229, private: 229, protected: 229, readonly: 231, instanceof: 250, satisfies: 253, in: 254, const: 256, import: 290, keyof: 345, unique: 349, infer: 355, is: 391, abstract: 411, implements: 413, type: 415, let: 418, var: 420, using: 423, interface: 429, enum: 433, namespace: 439, module: 441, declare: 445, global: 449, for: 468, of: 477, while: 480, with: 484, do: 488, if: 492, else: 494, switch: 498, case: 504, try: 510, catch: 514, finally: 518, return: 522, throw: 526, break: 530, continue: 534, debugger: 538 }, nOe = { __proto__: null, async: 123, get: 125, set: 127, declare: 189, public: 191, private: 191, protected: 191, static: 193, abstract: 195, override: 197, readonly: 203, accessor: 205, new: 395 }, iOe = { __proto__: null, "<": 187 }, rOe = $a.deserialize({
  version: 14,
  states: "$@QO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#CiO+RO!bO'#CjO+aO#tO'#CjO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DwO0fQ^O'#EPOOQ?Mr'#EX'#EXO1PQWO'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQWO'#GpO1dQWO'#ElO1iQWO'#ElO3hQ?NdO'#JmO6[Q?NdO'#JnO6uQWO'#F[O6zQ&jO'#FsOOQ?Mr'#Fe'#FeO7VO,YO'#FeO7eQ7[O'#FzO9RQWO'#FyOOQ?Mr'#Jn'#JnOOQ?Mp'#Jm'#JmO9WQWO'#GtOOQU'#KZ'#KZO9cQWO'#IUO9hQ?MxO'#IVOOQU'#JZ'#JZOOQU'#IZ'#IZQ`Q^OOO`Q^OOO9pQMnO'#DsO9wQ^O'#D{O:OQ^O'#D}O9^QWO'#GpO:VQ7[O'#CoO:eQWO'#EkO:pQWO'#EvO:uQ7[O'#FdO;dQWO'#GpOOQO'#K['#K[O;iQWO'#K[O;wQWO'#GxO;wQWO'#GyO;wQWO'#G{O9^QWO'#HOO<nQWO'#HRO>VQWO'#CeO>gQWO'#H_O>oQWO'#HeO>oQWO'#HgO`Q^O'#HiO>oQWO'#HkO>oQWO'#HnO>tQWO'#HtO>yQ?MyO'#HzO%[Q^O'#H|O?UQ?MyO'#IOO?aQ?MyO'#IQO9hQ?MxO'#ISO?lQ?NdO'#CiO@nQ`O'#DiQOQWOOO%[Q^O'#D}OAUQWO'#EQO:VQ7[O'#EkOAaQWO'#EkOAlQpO'#FdOOQU'#Cg'#CgOOQ?Mp'#Dn'#DnOOQ?Mp'#Jq'#JqO%[Q^O'#JqOOQO'#Jt'#JtOOQO'#Id'#IdOBlQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Jx'#JxOChQ?NQO'#EdOCrQ`O'#ETOOQO'#Js'#JsODWQ`O'#JtOEeQ`O'#ETOCrQ`O'#EdPErO#@ItO'#CbPOOO)CDx)CDxOOOO'#I['#I[OE}O!bO,59UOOQ?Mr,59U,59UOOOO'#I]'#I]OF]O#tO,59UO%[Q^O'#D`OOOO'#I_'#I_OFkO!0LbO,59xOOQ?Mr,59x,59xOFyQ^O'#I`OG^QWO'#JoOI]QrO'#JoO+}Q^O'#JoOIdQWO,5:OOIzQWO'#EmOJXQWO'#KOOJdQWO'#J}OJdQWO'#J}OJlQWO,5;ZOJqQWO'#J|OOQ?Mv,5:Z,5:ZOJxQ^O,5:ZOLvQ?NdO,5:cOMgQWO,5:kONQQ?MxO'#J{ONXQWO'#JzO9WQWO'#JzONmQWO'#JzONuQWO,5;YONzQWO'#JzO!#PQrO'#JnOOQ?Mr'#Ci'#CiO%[Q^O'#EPO!#oQrO,5:pOOQQ'#Ju'#JuOOQO-E<f-E<fO9^QWO,5=[O!$VQWO,5=[O!$[Q^O,5;WO!&_Q7[O'#EhO!'xQWO,5;WO!'}Q^O'#DvO!(XQ`O,5;aO!(aQ`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!(oQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yOOQ?Mr,5;{,5;{O%[Q^O'#IlO!*rQ?MxO,5<gO%[Q^O,5;bO!&_Q7[O,5;bO!+aQ7[O,5;bO!-RQ7[O'#EZO%[Q^O,5;vOOQ?Mr,5;z,5;zO!-YQ&jO'#FiO!.VQ&jO'#KSO!-qQ&jO'#KSO!.^Q&jO'#KSOOQO'#KS'#KSO!.rQ&jO,5<ROOOS,5<_,5<_O!/TQ^O'#FuOOOS'#Ik'#IkO7VO,YO,5<PO!/[Q&jO'#FwOOQ?Mr,5<P,5<PO!/{Q!LQO'#CvOOQ?Mr'#Cz'#CzO!0`O!0LbO'#DOO!0|Q7[O,5<dO!1TQWO,5<fO!2pQ$ISO'#GVO!2}QWO'#GWO!3SQWO'#GWO!4rQ$ISO'#G[O!5nQ`O'#G`OOQO'#Gk'#GkO!+hQ7[O'#GjOOQO'#Gm'#GmO!+hQ7[O'#GlO!6aQ!LQO'#JgOOQ?Mr'#Jg'#JgO!6kQWO'#JfO!6yQWO'#JeO!7RQWO'#CuOOQ?Mr'#Cx'#CxO!7ZQWO'#CzOOQ?Mr'#DS'#DSOOQ?Mr'#DU'#DUO1SQWO'#DWO!+hQ7[O'#F}O!+hQ7[O'#GPO!7`QWO'#GRO!7eQWO'#GSO!3SQWO'#GYO!+hQ7[O'#G_O!7jQWO'#EnO!8XQWO,5<eOOQ?Mp'#Cr'#CrO!8aQWO'#EoO!9ZQ`O'#EpOOQ?Mp'#J|'#J|O!9bQ?MxO'#K]O9hQ?MxO,5=`O`Q^O,5>pOOQU'#Jc'#JcOOQU,5>q,5>qOOQU-E<X-E<XO!;aQ?NdO,5:_O!9UQ`O,5:]O!=zQ?NdO,5:gO%[Q^O,5:gO!@bQ?NdO,5:iOOQO,5@v,5@vO!ARQ7[O,5=[O!AaQ?MxO'#JdO9RQWO'#JdO!ArQ?MxO,59ZO!A}Q`O,59ZO!BVQ7[O,59ZO:VQ7[O,59ZO!BbQWO,5;WO!BjQWO'#H^O!COQWO'#K`O%[Q^O,5;|O!9UQ`O,5<OO!CWQWO,5=wO!C]QWO,5=wO!CbQWO,5=wO9hQ?MxO,5=wO;wQWO,5=gOOQO'#Cv'#CvO!CpQ`O,5=dO!CxQ7[O,5=eO!DTQWO,5=gO!DYQpO,5=jO!DbQWO'#K[O>tQWO'#HTO9^QWO'#HVO!DgQWO'#HVO:VQ7[O'#HXO!DlQWO'#HXOOQU,5=m,5=mO!DqQWO'#HYO!ESQWO'#CoO!EXQWO,59PO!EcQWO,59PO!GhQ^O,59POOQU,59P,59PO!GxQ?MxO,59PO%[Q^O,59PO!JTQ^O'#HaOOQU'#Hb'#HbOOQU'#Hc'#HcO`Q^O,5=yO!JkQWO,5=yO`Q^O,5>PO`Q^O,5>RO!JpQWO,5>TO`Q^O,5>VO!JuQWO,5>YO!JzQ^O,5>`OOQU,5>f,5>fO%[Q^O,5>fO9hQ?MxO,5>hOOQU,5>j,5>jO# UQWO,5>jOOQU,5>l,5>lO# UQWO,5>lOOQU,5>n,5>nO# rQ`O'#D[O%[Q^O'#JqO# |Q`O'#JqO#!kQ`O'#DjO#!|Q`O'#DjO#%_Q^O'#DjO#%fQWO'#JpO#%nQWO,5:TO#%sQWO'#EqO#&RQWO'#KPO#&ZQWO,5;[O#&`Q`O'#DjO#&mQ`O'#ESOOQ?Mr,5:l,5:lO%[Q^O,5:lO#&tQWO,5:lO>tQWO,5;VO!A}Q`O,5;VO!BVQ7[O,5;VO:VQ7[O,5;VO#&|QWO,5@]O#'RQ(CYO,5:pOOQO-E<b-E<bO#(XQ?NQO,5;OOCrQ`O,5:oO#(cQ`O,5:oOCrQ`O,5;OO!ArQ?MxO,5:oOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#(pQ?MxO,5;OO#({Q?MxO,5;OO!A}Q`O,5:oOOQO,5;U,5;UO#)ZQ?MxO,5;OPOOO'#IY'#IYP#)oO#@ItO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ?Mr1G.p1G.pOOOO-E<Z-E<ZO#)zQpO,59zOOOO-E<]-E<]OOQ?Mr1G/d1G/dO#*PQrO,5>zO+}Q^O,5>zOOQO,5?Q,5?QO#*ZQ^O'#I`OOQO-E<^-E<^O#*hQWO,5@ZO#*pQrO,5@ZO#*wQWO,5@iOOQ?Mr1G/j1G/jO%[Q^O,5@jO#+PQWO'#IfOOQO-E<d-E<dO#*wQWO,5@iOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0V1G0VO%[Q^O,5@gO#+eQ?MxO,5@gO#+vQ?MxO,5@gO#+}QWO,5@fO9WQWO,5@fO#,VQWO,5@fO#,eQWO'#IiO#+}QWO,5@fOOQ?Mp1G0t1G0tO!(XQ`O,5:rO!(dQ`O,5:rOOQQ,5:t,5:tO#-VQYO,5:tO#-_Q7[O1G2vO9^QWO1G2vOOQ?Mr1G0r1G0rO#-mQ?NdO1G0rO#.rQ?NbO,5;SOOQ?Mr'#GU'#GUO#/`Q?NdO'#JgO!$[Q^O1G0rO#1hQrO'#JrO%[Q^O'#JrO#1rQWO,5:bOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#1wQWO1G0{O#4]Q?NdO1G0|O#4dQ?NdO1G0|O#6zQ?NdO1G0|O#7RQ?NdO1G0|O#9iQ?NdO1G0|O#<PQ?NdO1G0|O#<WQ?NdO1G0|O#<_Q?NdO1G0|O#>uQ?NdO1G0|O#>|Q?NdO1G0|O#AZQ07bO'#CiO#CUQ07bO1G1_O#C]Q07bO'#JnO#CpQ?NdO,5?WOOQ?Mp-E<j-E<jO#E}Q?NdO1G0|O#FzQ?NdO1G0|OOQ?Mr1G0|1G0|O#GzQ7[O'#JwO#HUQWO,5:uO#HZQ?NdO1G1bO#H}Q&jO,5<VO#IVQ&jO,5<WO#I_Q&jO'#FnO#IvQWO'#FmOOQO'#KT'#KTOOQO'#Ij'#IjO#I{Q&jO1G1mOOQ?Mr1G1m1G1mOOOS1G1x1G1xO#J^Q07bO'#JmO#JhQWO,5<aO!(oQ^O,5<aOOOS-E<i-E<iOOQ?Mr1G1k1G1kO#JmQ`O'#KSOOQ?Mr,5<c,5<cO#JuQ`O,5<cO!&_Q7[O'#DQOOOO'#I^'#I^O#JzO!0LbO,59jOOQ?Mr,59j,59jO%[Q^O1G2OO!7eQWO'#InO#KVQ7[O,5<xOOQ?Mr,5<u,5<uO!+hQ7[O'#IqO#KuQ7[O,5=UO!+hQ7[O'#IsO#LhQ7[O,5=WO!&_Q7[O,5=YOOQO1G2Q1G2QO#LrQpO'#CrO#MVQ$ISO'#EoO#NUQ`O'#G`O#NrQpO,5<qO#NyQWO'#KWO9WQWO'#KWO$ XQWO,5<sO!+hQ7[O,5<rO$ ^QWO'#GXO$ oQWO,5<rO$ tQpO'#GUO$!RQpO'#KXO$!]QWO'#KXO!&_Q7[O'#KXO$!bQWO,5<vO$!gQ`O'#GaO!5iQ`O'#GaO$!xQWO'#GcO$!}QWO'#GeO!3SQWO'#GhO$#SQ?MxO'#IpO$#_Q`O,5<zOOQ?Mv,5<z,5<zO$#fQ`O'#GaO$#tQ`O'#GbO$#|Q`O'#GbO$$RQ7[O,5=UO$$cQ7[O,5=WOOQ?Mr,5=Z,5=ZO!+hQ7[O,5@QO!+hQ7[O,5@QO$$sQWO'#IuO$%OQWO,5@PO$%WQWO,59aOOQ?Mr,59f,59fO$%zQ!LSO,59rOOQ?Mr'#Jk'#JkO$&mQ7[O,5<iO$'`Q7[O,5<kO@fQWO,5<mOOQ?Mr,5<n,5<nO$'jQWO,5<tO$'oQ7[O,5<yO$(PQWO'#JzO!$[Q^O1G2PO$(UQWO1G2PO9WQWO'#J}O9WQWO'#EqO%[Q^O'#EqO9WQWO'#IwO$(ZQ?MxO,5@wOOQU1G2z1G2zOOQU1G4[1G4[OOQ?Mr1G/y1G/yOOQ?Mr1G/w1G/wO$*]Q?NdO1G0ROOQU1G2v1G2vO!&_Q7[O1G2vO%[Q^O1G2vO#-bQWO1G2vO$,aQ7[O'#EhOOQ?Mp,5@O,5@OO$,kQ?MxO,5@OOOQU1G.u1G.uO!ArQ?MxO1G.uO!A}Q`O1G.uO!BVQ7[O1G.uO$,|QWO1G0rO$-RQWO'#CiO$-^QWO'#KaO$-fQWO,5=xO$-kQWO'#KaO$-pQWO'#KaO$.OQWO'#I}O$.^QWO,5@zO$.fQrO1G1hOOQ?Mr1G1j1G1jO9^QWO1G3cO@fQWO1G3cO$.mQWO1G3cO$.rQWO1G3cOOQU1G3c1G3cO!DTQWO1G3RO!&_Q7[O1G3OO$.wQWO1G3OOOQU1G3P1G3PO!&_Q7[O1G3PO$.|QWO1G3PO$/UQ`O'#G}OOQU1G3R1G3RO!5iQ`O'#IyO!DYQpO1G3UOOQU1G3U1G3UOOQU,5=o,5=oO$/^Q7[O,5=qO9^QWO,5=qO$!}QWO,5=sO9RQWO,5=sO!A}Q`O,5=sO!BVQ7[O,5=sO:VQ7[O,5=sO$/lQWO'#K_O$/wQWO,5=tOOQU1G.k1G.kO$/|Q?MxO1G.kO@fQWO1G.kO$0XQWO1G.kO9hQ?MxO1G.kO$2aQrO,5@|O$2nQWO,5@|O9WQWO,5@|O$2yQ^O,5={O$3QQWO,5={OOQU1G3e1G3eO`Q^O1G3eOOQU1G3k1G3kOOQU1G3m1G3mO>oQWO1G3oO$3VQ^O1G3qO$7ZQ^O'#HpOOQU1G3t1G3tO$7hQWO'#HvO>tQWO'#HxOOQU1G3z1G3zO$7pQ^O1G3zO9hQ?MxO1G4QOOQU1G4S1G4SOOQ?Mp'#G]'#G]O9hQ?MxO1G4UO9hQ?MxO1G4WO$;wQWO,5@]O!(oQ^O,5;]O9WQWO,5;]O>tQWO,5:UO!(oQ^O,5:UO!A}Q`O,5:UO$;|Q07bO,5:UOOQO,5;],5;]O$<WQ`O'#IaO$<nQWO,5@[OOQ?Mr1G/o1G/oO$<vQ`O'#IgO$=QQWO,5@kOOQ?Mp1G0v1G0vO#!|Q`O,5:UOOQO'#Ic'#IcO$=YQ`O,5:nOOQ?Mv,5:n,5:nO#&wQWO1G0WOOQ?Mr1G0W1G0WO%[Q^O1G0WOOQ?Mr1G0q1G0qO>tQWO1G0qO!A}Q`O1G0qO!BVQ7[O1G0qOOQ?Mp1G5w1G5wO!ArQ?MxO1G0ZOOQO1G0j1G0jO%[Q^O1G0jO$=aQ?MxO1G0jO$=lQ?MxO1G0jO!A}Q`O1G0ZOCrQ`O1G0ZO$=zQ?MxO1G0jOOQO1G0Z1G0ZO$>`Q?NdO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$>jQpO,5<gO$>rQrO1G4fOOQO1G4l1G4lO%[Q^O,5>zO$>|QWO1G5uO$?UQWO1G6TO$?^QrO1G6UO9WQWO,5?QO$?hQ?NdO1G6RO%[Q^O1G6RO$?xQ?MxO1G6RO$@ZQWO1G6QO$@ZQWO1G6QO9WQWO1G6QO$@cQWO,5?TO9WQWO,5?TOOQO,5?T,5?TO$@wQWO,5?TO$(PQWO,5?TOOQO-E<g-E<gOOQQ1G0^1G0^OOQQ1G0`1G0`O#-YQWO1G0`OOQU7+(b7+(bO!&_Q7[O7+(bO%[Q^O7+(bO$AVQWO7+(bO$AbQ7[O7+(bO$ApQ?NdO,5=UO$CxQ?NdO,5=WO$FQQ?NdO,5=UO$H`Q?NdO,5=WO$JnQ?NdO,59rO$LsQ?NdO,5<iO$N{Q?NdO,5<kO%#TQ?NdO,5<yOOQ?Mr7+&^7+&^O%%cQ?NdO7+&^O%&VQ^O'#IbO%&dQWO,5@^O%&lQrO,5@^OOQ?Mr1G/|1G/|O%&vQWO7+&gOOQ?Mr7+&g7+&gO%&{Q07bO,5:cO%[Q^O7+&yO%'VQ07bO,5:_O%'dQ07bO,5:gO%'nQ07bO,5:iO%'xQ7[O'#IeO%(SQWO,5@cOOQ?Mr1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%([QtO,5<YO!(oQ^O,5<XOOQO-E<h-E<hOOQ?Mr7+'X7+'XOOOS7+'d7+'dOOOS1G1{1G1{O%(gQWO1G1{OOQ?Mr1G1}1G1}O%(lQpO,59lOOOO-E<[-E<[OOQ?Mr1G/U1G/UO%(sQ?NdO7+'jOOQ?Mr,5?Y,5?YO%)gQpO,5?YOOQ?Mr1G2d1G2dP!&_Q7[O'#InPOQ?Mr-E<l-E<lO%*VQ7[O,5?]OOQ?Mr-E<o-E<oO%*xQ7[O,5?_OOQ?Mr-E<q-E<qO%+SQpO1G2tO%+ZQpO'#CrO%+qQ7[O'#J}O%+xQ^O'#EqOOQ?Mr1G2]1G2]O%,SQWO'#ImO%,hQWO,5@rO%,hQWO,5@rO%,pQWO,5@rO%,{QWO,5@rOOQO1G2_1G2_O%-ZQ7[O1G2^O!+hQ7[O1G2^O%-kQ$ISO'#IoO%-xQWO,5@sO!&_Q7[O,5@sO%.QQpO,5@sOOQ?Mr1G2b1G2bOOQ?Mp,5<{,5<{OOQ?Mp,5<|,5<|O$(PQWO,5<|OCcQWO,5<|O!A}Q`O,5<{OOQO'#Gd'#GdO%.[QWO,5<}OOQ?Mp,5=P,5=PO$(PQWO,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ?Mv1G2f1G2fO!5iQ`O,5<{O%.dQWO,5<|O$!xQWO,5<}O%.oQ`O,5<|O!+hQ7[O'#IqO%/`Q7[O1G2pO!+hQ7[O'#IsO%0RQ7[O1G2rO%0]Q7[O1G5lO%0gQ7[O1G5lOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9UQ`O,59tO%[Q^O,59tOOQ?Mr,5<h,5<hO%0tQWO1G2XO!+hQ7[O1G2`O%0yQ?NdO7+'kOOQ?Mr7+'k7+'kO!$[Q^O7+'kO%1mQWO,5;]OOQ?Mp,5?c,5?cOOQ?Mp-E<u-E<uO%1rQpO'#KYO#&wQWO7+(bO4UQrO7+(bO$AYQWO7+(bO%1|Q?NbO'#CiO%2aQ?NbO,5=QO%3RQWO,5=QOOQ?Mp1G5j1G5jOOQU7+$a7+$aO!ArQ?MxO7+$aO!A}Q`O7+$aO!$[Q^O7+&^O%3WQWO'#I|O%3oQWO,5@{OOQO1G3d1G3dO9^QWO,5@{O%3oQWO,5@{O%3wQWO,5@{OOQO,5?i,5?iOOQO-E<{-E<{OOQ?Mr7+'S7+'SO%3|QWO7+(}O9hQ?MxO7+(}O9^QWO7+(}O@fQWO7+(}OOQU7+(m7+(mO%4RQ?NbO7+(jO!&_Q7[O7+(jO%4]QpO7+(kOOQU7+(k7+(kO!&_Q7[O7+(kO%4dQWO'#K^O%4oQWO,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQU7+(p7+(pO%6RQ`O'#HWOOQU1G3]1G3]O!&_Q7[O1G3]O%[Q^O1G3]O%6YQWO1G3]O%6eQ7[O1G3]O9hQ?MxO1G3_O$!}QWO1G3_O9RQWO1G3_O!A}Q`O1G3_O!BVQ7[O1G3_O%6sQWO'#I{O%7XQWO,5@yO%7aQ`O,5@yOOQ?Mp1G3`1G3`OOQU7+$V7+$VO@fQWO7+$VO9hQ?MxO7+$VO%7lQWO7+$VO%[Q^O1G6hO%[Q^O1G6iO%7qQ?MxO1G6hO%7{Q^O1G3gO%8SQWO1G3gO%8XQ^O1G3gOOQU7+)P7+)PO9hQ?MxO7+)ZO`Q^O7+)]OOQU'#Kd'#KdOOQU'#JO'#JOO%8`Q^O,5>[OOQU,5>[,5>[O%[Q^O'#HqO%8mQWO'#HsOOQU,5>b,5>bO9WQWO,5>bOOQU,5>d,5>dOOQU7+)f7+)fOOQU7+)l7+)lOOQU7+)p7+)pOOQU7+)r7+)rO%8rQ`O1G5wO%9WQ07bO1G0wO%9bQWO1G0wOOQO1G/p1G/pO%9mQ07bO1G/pO>tQWO1G/pO!(oQ^O'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!A}Q`O1G/pOOQO-E<a-E<aOOQ?Mv1G0Y1G0YOOQ?Mr7+%r7+%rO#&wQWO7+%rOOQ?Mr7+&]7+&]O>tQWO7+&]O!A}Q`O7+&]OOQO7+%u7+%uO$>`Q?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%9wQ?MxO7+&UO!ArQ?MxO7+%uO!A}Q`O7+%uO%:SQ?MxO7+&UO%:bQ?NdO7++mO%[Q^O7++mO%:rQWO7++lO%:rQWO7++lOOQO1G4o1G4oO9WQWO1G4oO%:zQWO1G4oOOQQ7+%z7+%zO#&wQWO<<K|O4UQrO<<K|O%;YQWO<<K|OOQU<<K|<<K|O!&_Q7[O<<K|O%[Q^O<<K|O%;bQWO<<K|O%;mQ?NdO,5?]O%=uQ?NdO,5?_O%?}Q?NdO1G2^O%B]Q?NdO1G2pO%DeQ?NdO1G2rO%FmQrO,5>|O%[Q^O,5>|OOQO-E<`-E<`O%FwQWO1G5xOOQ?Mr<<JR<<JRO%GPQ07bO1G0rO%IWQ07bO1G0|O%I_Q07bO1G0|O%K`Q07bO1G0|O%KgQ07bO1G0|O%MhQ07bO1G0|O& iQ07bO1G0|O& pQ07bO1G0|O& wQ07bO1G0|O&#xQ07bO1G0|O&$PQ07bO1G0|O&$WQ?NdO<<JeO&&OQ07bO1G0|O&&{Q07bO1G0|O&'{Q07bO'#JgO&*OQ07bO1G1bO&*]Q07bO1G0RO&*gQ7[O,5?POOQO-E<c-E<cO!(oQ^O'#FpOOQO'#KU'#KUOOQO1G1t1G1tO&*qQWO1G1sO&*vQ07bO,5?WOOOS7+'g7+'gOOOO1G/W1G/WOOQ?Mr1G4t1G4tO!+hQ7[O7+(`O&-WQrO'#CiO&-bQWO,5?XO9WQWO,5?XOOQO-E<k-E<kO&-pQWO1G6^O&-pQWO1G6^O&-xQWO1G6^O&.TQ7[O7+'xO&.eQpO,5?ZO&.oQWO,5?ZO!&_Q7[O,5?ZOOQO-E<m-E<mO&.tQpO1G6_O&/OQWO1G6_OOQ?Mp1G2h1G2hO$(PQWO1G2hOOQ?Mp1G2g1G2gO&/WQWO1G2iO!&_Q7[O1G2iOOQ?Mp1G2n1G2nO!A}Q`O1G2gOCcQWO1G2hO&/]QWO1G2iO&/eQWO1G2hO$!xQWO1G2iO&0XQ7[O,5?]OOQ?Mr-E<p-E<pO&0zQ7[O,5?_OOQ?Mr-E<r-E<rO!+hQ7[O7++WOOQ?Mr1G/`1G/`O&1UQWO1G/`OOQ?Mr7+'s7+'sO&1ZQ7[O7+'zO&1kQ?NdO<<KVOOQ?Mr<<KV<<KVO&2_QWO1G0wO!&_Q7[O'#IvO&2dQWO,5@tO&4fQrO<<K|O!&_Q7[O1G2lOOQU<<G{<<G{O!ArQ?MxO<<G{O&4mQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?h,5?hO&5aQWO,5?hO&5fQWO,5?hOOQO-E<z-E<zO&5tQWO1G6gO&5tQWO1G6gO9^QWO1G6gO@fQWO<<LiOOQU<<Li<<LiO&5|QWO<<LiO9hQ?MxO<<LiOOQU<<LU<<LUO%4RQ?NbO<<LUOOQU<<LV<<LVO%4]QpO<<LVO&6RQ`O'#IxO&6^QWO,5@xO!(oQ^O,5@xOOQU1G3T1G3TO%+xQ^O'#JqOOQO'#Iz'#IzO9hQ?MxO'#IzO&6fQ`O,5=rOOQU,5=r,5=rO&6mQ`O'#EdO&7RQ`O'#GcO&7WQWO7+(wO&7]QWO7+(wOOQU7+(w7+(wO!&_Q7[O7+(wO%[Q^O7+(wO&7eQWO7+(wOOQU7+(y7+(yO9hQ?MxO7+(yO$!}QWO7+(yO9RQWO7+(yO!A}Q`O7+(yO&7pQWO,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&7{QWO1G6eO9hQ?MxO<<GqOOQU<<Gq<<GqO@fQWO<<GqO&8TQWO7+,SO&8YQWO7+,TO%[Q^O7+,SO%[Q^O7+,TOOQU7+)R7+)RO&8_QWO7+)RO&8dQ^O7+)RO&8kQWO7+)ROOQU<<Lu<<LuOOQU<<Lw<<LwOOQU-E<|-E<|OOQU1G3v1G3vO&8pQWO,5>]OOQU,5>_,5>_O&8uQWO1G3|O9WQWO7+&cO!(oQ^O7+&cOOQO7+%[7+%[O&8zQ07bO1G6UO>tQWO7+%[OOQ?Mr<<I^<<I^OOQ?Mr<<Iw<<IwO>tQWO<<IwOOQO<<Ip<<IpO$>`Q?NdO<<IpO%[Q^O<<IpOOQO<<Ia<<IaO!ArQ?MxO<<IaO&9UQ?MxO<<IpO&9aQ?NdO<= XO&9qQWO<= WOOQO7+*Z7+*ZO9WQWO7+*ZOOQUANAhANAhO&9yQrOANAhO!&_Q7[OANAhO#&wQWOANAhO4UQrOANAhO&:QQWOANAhO%[Q^OANAhO&:YQ?NdO7+'xO&<hQ?NdO,5?]O&>pQ?NdO,5?_O&@xQ?NdO7+'zO&CWQrO1G4hO&CbQ07bO7+&^O&EcQ07bO,5=UO&GgQ07bO,5=WO&GwQ07bO,5=UO&HXQ07bO,5=WO&HiQ07bO,59rO&JlQ07bO,5<iO&LlQ07bO,5<kO&N}Q07bO,5<yO'!pQ07bO7+'jO'!}Q07bO7+'kO'#[QWO,5<[OOQO7+'_7+'_O'#aQ7[O<<KzOOQO1G4s1G4sO'#hQWO1G4sO'#sQWO1G4sO'$RQWO7++xO'$RQWO7++xO!&_Q7[O1G4uO'$ZQpO1G4uO'$eQWO7++yOOQ?Mp7+(S7+(SO'$mQWO7+(TO'$xQpO7+(TOOQ?Mp7+(R7+(RO$(PQWO7+(SO'%PQWO7+(TO!&_Q7[O7+(TOCcQWO7+(SO'%UQWO7+(TO'%^Q7[O<<NrOOQ?Mr7+$z7+$zO'%hQpO,5?bOOQO-E<t-E<tO'%rQ?NbO7+(WOOQUAN=gAN=gO9^QWO1G5SOOQO1G5S1G5SO'&SQWO1G5SO'&XQWO7+,RO'&XQWO7+,RO9hQ?MxOANBTO@fQWOANBTOOQUANBTANBTOOQUANApANApOOQUANAqANAqO'&aQWO,5?dOOQO-E<v-E<vO'&lQ07bO1G6dOOQO,5?f,5?fOOQO-E<x-E<xOOQU1G3^1G3^O%+xQ^O,5<}O'&vQWO,5<}OOQU<<Lc<<LcO!&_Q7[O<<LcO&7WQWO<<LcO'&{QWO<<LcO%[Q^O<<LcOOQU<<Le<<LeO9hQ?MxO<<LeO$!}QWO<<LeO9RQWO<<LeO''TQ`O1G5RO''`QWO7+,POOQUAN=]AN=]O9hQ?MxOAN=]OOQU<= n<= nOOQU<= o<= oO''hQWO<= nO''mQWO<= oOOQU<<Lm<<LmO''rQWO<<LmO''wQ^O<<LmOOQU1G3w1G3wO>tQWO7+)hO'(OQWO<<I}O'(ZQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$>`Q?NdOAN?[OOQOAN>{AN>{O%[Q^OAN?[OOQO<<Mu<<MuOOQUG27SG27SO!&_Q7[OG27SO#&wQWOG27SO'(eQrOG27SO4UQrOG27SO'(lQWOG27SO'(tQ07bO<<JeO')RQ07bO1G2^O'*tQ07bO,5?]O',tQ07bO,5?_O'.tQ07bO1G2pO'0tQ07bO1G2rO'2tQ07bO<<KVO'3RQ07bO<<IxOOQO1G1v1G1vO!+hQ7[OANAfOOQO7+*_7+*_O'3`QWO7+*_O'3kQWO<= dO'3sQpO7+*aOOQ?Mp<<Ko<<KoO$(PQWO<<KoOCcQWO<<KoO'3}QWO<<KoOOQ?Mp<<Kn<<KnO'4YQpO<<KoO$(PQWO<<KnO'4aQWO<<KoO!&_Q7[O<<KoOOQO7+*n7+*nO9^QWO7+*nO'4fQWO<= mOOQUG27oG27oO9hQ?MxOG27oO!(oQ^O1G5OO'4nQWO7+,OO&7WQWOANA}OOQUANA}ANA}O!&_Q7[OANA}O'4vQWOANA}OOQUANBPANBPO9hQ?MxOANBPO$!}QWOANBPOOQO'#H['#H[OOQO7+*m7+*mOOQUG22wG22wOOQUANEYANEYOOQUANEZANEZOOQUANBXANBXO'5OQWOANBXOOQU<<MS<<MSO!(oQ^OAN?iOOQOG24vG24vO$>`Q?NdOG24vO#&wQWOLD,nOOQULD,nLD,nO!&_Q7[OLD,nO'5TQrOLD,nO'5[Q07bO7+'xO'6}Q07bO,5?]O'8}Q07bO,5?_O':}Q07bO7+'zO'<pQ7[OG27QOOQO<<My<<MyOOQ?MpANAZANAZO$(PQWOANAZOCcQWOANAZO'=QQWOANAZOOQ?MpANAYANAYO'=]QpOANAZOOQO<<NY<<NYOOQULD-ZLD-ZO'=dQ07bO7+*jOOQUG27iG27iO&7WQWOG27iO!&_Q7[OG27iOOQUG27kG27kO9hQ?MxOG27kOOQUG27sG27sO'=nQ07bOG25TOOQOLD*bLD*bOOQU!$(!Y!$(!YO#&wQWO!$(!YO!&_Q7[O!$(!YO'=xQ?NdOG27QOOQ?MpG26uG26uO$(PQWOG26uOCcQWOG26uO'@WQWOG26uOOQULD-TLD-TO&7WQWOLD-TOOQULD-VLD-VOOQU!)9Et!)9EtO#&wQWO!)9EtOOQ?MpLD,aLD,aO$(PQWOLD,aOCcQWOLD,aOOQU!$(!o!$(!oOOQU!.K;`!.K;`O'@cQ07bOG27QOOQ?Mp!$( {!$( {O$(PQWO!$( {OOQ?Mp!)9Eg!)9EgO!(oQ^O'#DwO1PQWO'#EUO'BUQrO'#JmO'B]QMnO'#DsO'BdQ^O'#D{O'BkQrO'#CiO'ERQrO'#CiO!(oQ^O'#D}O'EcQ^O,5;WO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O'#IlO'GfQWO,5<gO!(oQ^O,5;bO'GnQ7[O,5;bO'IXQ7[O,5;bO!(oQ^O,5;vO!&_Q7[O'#GjO'GnQ7[O'#GjO!&_Q7[O'#GlO'GnQ7[O'#GlO1SQWO'#DWO1SQWO'#DWO!&_Q7[O'#F}O'GnQ7[O'#F}O!&_Q7[O'#GPO'GnQ7[O'#GPO!&_Q7[O'#G_O'GnQ7[O'#G_O!(oQ^O,5:gO'I`Q`O'#D[O!(oQ^O,5@jO'EcQ^O1G0rO'IjQ07bO'#CiO!(oQ^O1G2OO!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO'ItQpO'#CrO!&_Q7[O,5<rO'GnQ7[O,5<rO'EcQ^O1G2PO!(oQ^O7+&yO!&_Q7[O1G2^O'GnQ7[O1G2^O!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO!&_Q7[O1G2`O'GnQ7[O1G2`O'EcQ^O7+'kO'EcQ^O7+&^O!&_Q7[OANAfO'GnQ7[OANAfO'JXQWO'#ElO'J^QWO'#ElO'JfQWO'#F[O'JkQWO'#EvO'JpQWO'#KOO'J{QWO'#J|O'KWQWO,5;WO'K]Q7[O,5<dO'KdQWO'#GWO'KiQWO'#GWO'KnQWO,5<eO'KvQWO,5;WO'LOQ07bO1G1_O'LVQWO,5<rO'L[QWO,5<rO'LaQWO,5<tO'LfQWO,5<tO'LkQWO1G2PO'LpQWO1G0rO'LuQ7[O<<KzO'L|Q7[O<<KzO7eQ7[O'#FzO9RQWO'#FyOAaQWO'#EkO!(oQ^O,5;sO!3SQWO'#GWO!3SQWO'#GWO!3SQWO'#GYO!3SQWO'#GYO!+hQ7[O7+(`O!+hQ7[O7+(`O%+SQpO1G2tO%+SQpO1G2tO!&_Q7[O,5=YO!&_Q7[O,5=Y",
  stateData: "'NQ~O'wOS'xOSTOS'yRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(OSO(QTO(TUO([VO(j[O(yiO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O'y!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'u]X([]X(m]X(t]X(u]X~O!d%PX~P(qO_!}O(Q#PO(R!}O(S#PO~O_#QO(S#PO(T#PO(U#QO~Ou#SO!R#TO(]#TO(^#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O;UO(QTO(TUO([VO(j[O(yiO~O!X#ZO!Y#WO!V(cP!V(qP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(QTO(TUO([VO(j[O(yiO~Om#mO!X#iO!y]O#f#lO#g#iO(O;VO!h(nP~P.iO!i#oO(O#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa(aX'u(aX's(aX!h(aX!V(aX![(aX%f(aX!d(aX~P1qO#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX![(bX%f(bX~Oa(bX'u(bX's(bX!V(bX!h(bXs(bX!d(bX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O$sO(QTO(TUO([$uO(t$}O(u%POg(XP~O!i%cO~O!P%fO![%gO(O%eO~O!d%kO~Oa%lO'u%lO~O}%pO~P%[O(P!lO~P%[O%k%tO~P%[Oh%VO!i%cO(O%eO(P!lO~Oe%{O!i%cO(O%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(O%eO(P!lO(QTO(TUO`)SP~O!u#sO~O%p&VO!P)OX![)OX(O)OX~O(O&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(P!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'u%lO~Oa%lO't&{O'u%lO~Oa%lO't&}O'u%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(P!lO(QTO(TUO~Op'RO!P'QO!X'UO(`'PO!Z(dP!Z(sP~P@YOk'_O![']O(O%eO~Oe'dO!i%cO(O%eO~O}&QO!i&PO~Op!nO!P!oO!y;QO#Q!pO#R!pO#T!pO#U!pO(P!lO(QTO(TUO(`!mO(j!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'u%lO(m'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(QTO(TUO(`!mO(j!sO~O![XOp(hX!P(hX!_(hX!`(hX!a(hX!y(hX#Q(hX#R(hX#S(hX#T(hX#U(hX#X(hX#Y(hX(P(hX(Q(hX(T(hX(`(hX(j(hX~O!`'iO!a'iO(P!lO~PCrO'z'uO'{'uO'|'wO~O_!}O(Q'yO(R!}O(S'yO~O_#QO(S'yO(T'yO(U#QO~Ou#SO!R#TO(]#TO(^'}O~O!X(PO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(RO!V(cX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(RO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~O!V(cX~PGfO!V(WO~O!V(pX!Y(pX!d(pX!h(pX(m(pX~O#](pX#h#aX!Z(pX~PIiO#](XO!V(rX!Y(rX~O!Y(YO!V(qX~O!V(]O~O#]$eO~PIiO!Z(^O~P`OR#zO}#yO!P#{O!i#xO([VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(m!ka(t!ka(u!ka~Oa!ka'u!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKPO!h(_O~O!d#vO#](`O(m'mO!Y(oXa(oX'u(oX~O!h(oX~PMlO!P%fO![%gO!y]O#f(eO#g(dO(O%eO~O!Y(fO!h(nX~O!h(hO~O!P%fO![%gO#g(dO(O%eO~OP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O!d#vO!h(bX~P! YOR(jO}(iO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(O!xa~P!#ZO!u(nO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#h(tO~O!X(vO!h(fP~P%[O(`(xO(j[O~O!P(zO!i#xO(`(xO(j[O~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y$_Oa$oa'u$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)`O~P!&_Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~Og(kP~P!+hO})eO!d)dO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)dO![(vX$Y(vX$[(vX$^(vX$e(vX~O})eO~P!-qO})eO![(vX$Y(vX$[(vX$^(vX$e(vX~O![)gO$Y)kO$[)fO$^)fO$e)lO~O!X)oO~P!(oO$[$hO$^$gO$e)sO~Ok$xX}$xX!P$xX#P$xX(t$xX(u$xX~OgjXg$xXkjX!YjX#]jX~P!/gOu)uO(])vO(^)xO~Ok*RO})zO!P){O(t$}O(u%PO~Og)yO~P!0kOg*SO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P*UO![*VO!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~O!X*YO(O*TO!h(zP~P!1YO#h*[O~O!i*]O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O*_O(QTO(TUO([$uO(t$}O(u%PO~O!X*bO!V({P~P!3XOo*nO!P*fO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO(`!mO~O!Z*kO~P!4|O#P$dOk(ZX}(ZX!P(ZX(t(ZX(u(ZX!Y(ZX#](ZX~Og(ZX#}(ZX~P!5uOk*sO#]*rOg(YX!Y(YX~O!Y*tOg(XX~O(O&WOg(XP~Op*wO~O!i*|O~O(O(rO~Om+QO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(O%eO!h(nP~O!d#vO#h+RO~O!P%fO!X+TO!Y(YO![%gO(O%eO!V(qP~Op'XO!P+VO!X+UO(QTO(TUO(`(xO~O!Z(sP~P!8uO!Y+WOa)PX'u)PX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa!ga!Y!ga'u!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9mOR#zO}#yO!P#{O!i#xO([VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(m!oa(t!oa(u!oa~Oa!oa'u!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<TOR#zO}#yO!P#{O!i#xO([VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(m!qa(t!qa(u!qa~Oa!qa'u!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>kOh%VOk+aO![']O%f+`O~O!d+cOa(WX![(WX'u(WX!Y(WX~Oa%lO![XO'u%lO~Oh%VO!i%cO~Oh%VO!i%cO(O%eO~O!d#vO#h(tO~Ob+nO%g+oO(O+kO(QTO(TUO!Z)TP~O!Y+pO`)SX~O[+tO~O`+uO~O![%}O(O%eO(P!lO`)SP~Oh%VO#]+zO~Oh%VOk+}O![$|O~O![,PO~O},RO![XO~O%k%tO~O!u,WO~Oe,]O~Ob,^O(O#nO(QTO(TUO!Z)RP~Oe%{O~O%g!QO(O&WO~P=RO[,cO`,bO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(QTO(TUO([VO(j[O(yiO~O![!eO!r!gO$V!kO(O!dO~P!EkO`,bOa%lO'u%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa,hO!rwO#t!OO%i!OO%j!OO%k!OO~P!HTO!i&lO~O&Y,nO~O![,pO~O&k,rO&m,sOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(O&ha(Q&ha(T&ha([&ha(j&ha(y&ha!Z&ha&a&hab&ha&f&ha~O(O,xO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# ZO!d,}O#],|Oh(eX!Y#eX!Y(eX!Z#eX!Z(eX!d(eX!i(eX~Oh%VO!d-PO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(QTO(TUO(`!mO~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(QTO(TUO([VO(j[O(y<xO~O(O;zO~P##_O!Y-TO!Z(dX~O!Z-VO~O!d,}O#],|O!Y#eX!Z#eX~O!Y-WO!Z(sX~O!Z-YO~O!`-ZO!a-ZO(P!lO~P#!|O!Z-^O~P'_Ok-aO![']O~O!V-fO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(P!xa(Q!xa(T!xa(`!xa(j!xa~P!#ZO!m-kO#]-iO~PCSO!`-mO!a-mO(P!lO~PCrOa%lO#]-iO'u%lO~Oa%lO!d#vO#]-iO'u%lO~Oa%lO!d#vO!m-kO#]-iO'u%lO(m'mO~O'z'uO'{'uO'|-rO~Os-sO~O!V'Sa!Y'Sa~P!9mO!X-wO!V'SX!Y'SX~P%[O!Y(RO!V(ca~O!V(ca~PGfO!Y(YO!V(qa~O!P%fO!X-{O![%gO(O%eO!V'YX!Y'YX~O#]-}O!Y(oa!h(oaa(oa'u(oa~O!d#vO~P#+eO!Y(fO!h(na~O!P%fO![%gO#g.RO(O%eO~Om.WO!P%fO!X.TO![%gO!y]O#f.VO#g.TO(O%eO!Y']X!h']X~OR.[O!i#xO~Oh%VOk._O![']O%f.^O~Oa#`i!Y#`i'u#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9mOk=UO})zO!P){O(t$}O(u%PO~O#h#[aa#[a#]#[a'u#[a!Y#[a!h#[a![#[a!V#[a~P#.aO#h(ZXP(ZXR(ZX[(ZXa(ZXo(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX'u(ZX([(ZX(m(ZX!h(ZX!V(ZX's(ZXs(ZX![(ZX%f(ZX!d(ZX~P!5uO!Y.lO!h(fX~P!9mO!h.oO~O!V.qO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#1|O#k$OO~P#1|OP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#4kO#o$QO~P#4kOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO([VOa#ji!Y#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO([VO(u#}Oa#ji!Y#ji#y#ji#z#ji'u#ji(m#ji(t#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#9pO#w#ji~P#9pO#u$SO~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO([VO(t#|O(u#}Oa#ji!Y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<fO#y$WO~P#<fOP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X!Y]X!Z]X~O#}]X~P#?TOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O#y;bO#z;cO([VO(m$YO(t#|O(u#}O~O#}.sO~P#AbO#P$dO#];iO$P;iO#}(bX!Z(bX~P! YOa'`a!Y'`a'u'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9mO[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO(t#ji(u#ji~P#DdOk=UO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P#DdO!Y.wOg(kX~P!0kOg.yO~Oa$Oi!Y$Oi'u$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9mO$[.zO$^.zO~O$[.{O$^.{O~O!d)dO#].|O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X.}O~O![)gO$Y/PO$[)fO$^)fO$e/QO~O!Y;dO!Z(aX~P#AbO!Z/RO~O!d)dO$e(vX~O$e/TO~Ou)uO(])vO(^/WO~O!V/[O~P!&_O(t$}Ok%^a}%^a!P%^a(u%^a!Y%^a#]%^a~Og%^a#}%^a~P#K^O(u%POk%`a}%`a!P%`a(t%`a!Y%`a#]%`a~Og%`a#}%`a~P#LPO!YfX!dfX!hfX!h$xX(mfX~P!/gO!X/eO!Y(YO(O/dO!V(qP!V({P~P!1YOo*nO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO~Op'XO!P/fO!X+UO!Z*kO(QTO(TUO(`;wO!Z(sP~P#MjO!h/gO~P#.aO!Y/hO!d#vO(m'mO!h(zX~O!h/mO~O!P%fO!X*YO![%gO(O%eO!h(zP~O#h/oO~O!V$xX!Y$xX!d%PX~P!/gO!Y/pO!V({X~P#.aO!d/rO~O!V/tO~Oh%VOo/xO!d#vO!i%cO(m'mO~O(O/zO~O!d+cO~Oa%lO!Y0OO'u%lO~O!Z0QO~P!4|O!`0RO!a0RO(P!lO(`!mO~O!P0TO(`!mO~O#X0UO~Og%^a!Y%^a#]%^a#}%^a~P!0kOg%`a!Y%`a#]%`a#}%`a~P!0kO(O&WOg'iX!Y'iX~O!Y*tOg(Xa~Og0_O~OR0`O}0`O!P0aO#P$dOkza(tza(uza!Yza#]za~Ogza#}za~P$%]O})zO!P){Ok$qa(t$qa(u$qa!Y$qa#]$qa~Og$qa#}$qa~P$&UO})zO!P){Ok$sa(t$sa(u$sa!Y$sa#]$sa~Og$sa#}$sa~P$&wO#h0dO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0kO!d#vO~O#h0gO~O!Y+WOa)Pa'u)Pa~OR#zO}#yO!P#{O!i#xO([VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(m!oi(t!oi(u!oi~Oa!oi'u!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$(fOh%VOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~Om0pO(O0oO~P$*|O!d+cOa(Wa![(Wa'u(Wa!Y(Wa~O#h0vO~O[]X!YfX!ZfX~O!Y0wO!Z)TX~O!Z0yO~O[0zO~Ob0|O(O+kO(QTO(TUO~O![%}O(O%eO`'qX!Y'qX~O!Y+pO`)Sa~O!h1PO~P!9mO[1SO~O`1TO~O#]1WO~Ok1ZO![$|O~O(`(xO!Z)QP~Oh%VOk1dO![1aO%f1cO~O[1nO!Y1lO!Z)RX~O!Z1oO~O`1qOa%lO'u%lO~O(O#nO(QTO(TUO~O#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O#s1tO&W1uOa(bX~P$0dO#]$eO#s1tO&W1uO~Oa1wO~P%[Oa1yO~O&a1|OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(O&_i(Q&_i(T&_i([&_i(j&_i(y&_i!Z&_ib&_i&f&_i~Ob2SO!Z2QO&f2RO~P`O![XO!i2UO~O&m,sOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(O&hi(Q&hi(T&hi([&hi(j&hi(y&hi!Z&hi&a&hib&hi&f&hi~O!V2[O~O!Y!^a!Z!^a~P#AbOp!nO!P!oO!X2bO(`!mO!Y'TX!Z'TX~P@YO!Y-TO!Z(da~O!Y'ZX!Z'ZX~P!8uO!Y-WO!Z(sa~O!Z2iO~P'_Oa%lO#]2rO'u%lO~Oa%lO!d#vO#]2rO'u%lO~Oa%lO!d#vO!m2vO#]2rO'u%lO(m'mO~Oa%lO'u%lO~P!9mO!Y$_Os$oa~O!V'Si!Y'Si~P!9mO!Y(RO!V(ci~O!Y(YO!V(qi~O!V(ri!Y(ri~P!9mO!Y(oi!h(oia(oi'u(oi~P!9mO#]2xO!Y(oi!h(oia(oi'u(oi~O!Y(fO!h(ni~O!P%fO![%gO!y]O#f2}O#g2|O(O%eO~O!P%fO![%gO#g2|O(O%eO~Ok3UO![']O%f3TO~Oh%VOk3UO![']O%f3TO~O#h%^aP%^aR%^a[%^aa%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K^O#h%`aP%`aR%`a[%`aa%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LPO#h%^aP%^aR%^a[%^aa%^ao%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.aO#h%`aP%`aR%`a[%`aa%`ao%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.aO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'uza([za(mza!hza!Vza'szasza![za%fza!dza~P$%]O#h$qaP$qaR$qa[$qaa$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'u$qa([$qa(m$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$&UO#h$saP$saR$sa[$saa$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'u$sa([$sa(m$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$&wO#h%RaP%RaR%Ra[%Raa%Rao%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'u%Ra([%Ra(m%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.aOa#`q!Y#`q'u#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9mO!X3^O!Y'UX!h'UX~P%[O!Y.lO!h(fa~O!Y.lO!h(fa~P!9mO!V3aO~O#}!ka!Z!ka~PKPO#}!ga!Y!ga!Z!ga~P#AbO#}!oa!Z!oa~P!<TO#}!qa!Z!qa~P!>kOg'XX!Y'XX~P!+hO!Y.wOg(ka~OSfO![3uO$c3vO~O!Z3zO~Os3{O~P#.aOa$lq!Y$lq'u$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9mO!V3|O~P#.aO})zO!P){O(u%POk'ea(t'ea!Y'ea#]'ea~Og'ea#}'ea~P%)nO})zO!P){Ok'ga(t'ga(u'ga!Y'ga#]'ga~Og'ga#}'ga~P%*aO(m$YO~P#.aO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/gO(O<QO~P!1YOmkO(O4OO~P.iO!P%fO!X4QO![%gO(O%eO!Y'aX!h'aX~O!Y/hO!h(za~O!Y/hO!d#vO!h(za~O!Y/hO!d#vO(m'mO!h(za~Og$zi!Y$zi#]$zi#}$zi~P!0kO!X4YO!V'cX!Y'cX~P!3XO!Y/pO!V({a~O!Y/pO!V({a~P#.aO!d#vO#s4bO~Oo4eO!d#vO(m'mO~O!P4hO(`!mO~O(t$}Ok%^i}%^i!P%^i(u%^i!Y%^i#]%^i~Og%^i#}%^i~P%.wO(u%POk%`i}%`i!P%`i(t%`i!Y%`i#]%`i~Og%`i#}%`i~P%/jOg(Yi!Y(Yi~P!0kO#]4mOg(Yi!Y(Yi~P!0kO!h4pO~Oa$mq!Y$mq'u$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9mO!V4tO~O!Y4uO![(|X~P#.aOa$xX![$xX%Z]X'u$xX!Y$xX~P!/gO%Z4xOalXklX}lX!PlX![lX'ulX(tlX(ulX!YlX~O%Z4xO~Ob5OO%g5PO(O+kO(QTO(TUO!Y'pX!Z'pX~O!Y0wO!Z)Ta~O[5TO~O`5UO~Oa%lO'u%lO~P#.aO![$|O~P#.aO!Y5^O#]5`O!Z)QX~O!Z5aO~Oo5hOp!nO!P5bO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5gO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O!Z5fO~P%4tOk5mO![1aO%f5lO~Oh%VOk5mO![1aO%f5lO~Ob5tO(O#nO(QTO(TUO!Y'oX!Z'oX~O!Y1lO!Z)Ra~O(QTO(TUO(`5vO~O`5zO~O#s5}O&W6OO~PMlO!h6PO~P%[Oa6RO~Oa6RO~P%[Ob2SO!Z6WO&f2RO~P`O!d6YO~O!d6[Oh(ei!Y(ei!Z(ei!d(ei!i(ei~O!Y#ei!Z#ei~P#AbO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AbOa%lO#]6fO'u%lO~Oa%lO!d#vO#]6fO'u%lO~O!Y(oq!h(oqa(oq'u(oq~P!9mO!Y(fO!h(nq~O!P%fO![%gO#g6mO(O%eO~O![']O%f6pO~Ok6tO![']O%f6pO~O#h'eaP'eaR'ea['eaa'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'u'ea(['ea(m'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%)nO#h'gaP'gaR'ga['gaa'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'u'ga(['ga(m'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%*aO#h$ziP$ziR$zi[$zia$zio$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'u$zi([$zi(m$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.aO#h%^iP%^iR%^i[%^ia%^io%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'u%^i([%^i(m%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%.wO#h%`iP%`iR%`i[%`ia%`io%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'u%`i([%`i(m%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%/jO!Y'Ua!h'Ua~P!9mO!Y.lO!h(fi~O#}#`i!Y#`i!Z#`i~P#AbOP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#k#ji~P%G^O#k;YO~P%G^OP$[OR#zOo;fO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#o#ji~P%IfO#o;[O~P%IfOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O([VO#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#u#ji~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O([VO(u#}O#y#ji#z#ji#}#ji(m#ji(t#ji!Y#ji!Z#ji~O#w;`O~P%MoO#w#ji~P%MoO#u;^O~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O([VO(t#|O(u#}O#z#ji#}#ji(m#ji!Y#ji!Z#ji~O#y#ji~P&!OO#y;bO~P&!OOa#{y!Y#{y'u#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9mO[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO(t#ji(u#ji~P&$zOk=VO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P&$zO#P$dOP(ZXR(ZX[(ZXk(ZXo(ZX}(ZX!P(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX#}(ZX([(ZX(m(ZX(t(ZX(u(ZX!Y(ZX!Z(ZX~O#}$Oi!Y$Oi!Z$Oi~P#AbO#}!oi!Z!oi~P$(fOg'Xa!Y'Xa~P!0kO!Z7WO~O!Y'`a!Z'`a~P#AbOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!d%WX#s%WX~P&+QO!d#vO(m'mO!Y'aa!h'aa~O!Y/hO!h(zi~O!Y/hO!d#vO!h(zi~Og$zq!Y$zq#]$zq#}$zq~P!0kO!V'ca!Y'ca~P#.aO!d7_O~O!Y/pO!V({i~P#.aO!Y/pO!V({i~O!V7cO~O!d#vO#s7hO~Oo7iO!d#vO(m'mO~O})zO!P){O(u%POk'fa(t'fa!Y'fa#]'fa~Og'fa#}'fa~P&/pO})zO!P){Ok'ha(t'ha(u'ha!Y'ha#]'ha~Og'ha#}'ha~P&0cO!V7lO~Og$|q!Y$|q#]$|q#}$|q~P!0kOa$my!Y$my'u$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9mO!d6[O~O!Y4uO![(|a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa([$Sa(m$Sa(t$Sa(u$Sa~O%f6pO~P&2lOa#`y!Y#`y'u#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9mO[7qO~Ob7sO(O+kO(QTO(TUO~O!Y0wO!Z)Ti~O`7wO~O(`(xO!Y'lX!Z'lX~O!Y5^O!Z)Qa~O!Z8QO~P%4tOp!nO!P8RO(QTO(TUO(`!mO(j!sO~O#X8SO~O![1aO~O![1aO%f8UO~Ok8XO![1aO%f8UO~O[8^O!Y'oa!Z'oa~O!Y1lO!Z)Ri~O!h8bO~O!h8cO~O!h8fO~O!h8fO~P%[Oa8hO~O!d8iO~O!h8jO~O!Y(ri!Z(ri~P#AbOa%lO#]8rO'u%lO~O!Y(oy!h(oya(oy'u(oy~P!9mO!Y(fO!h(ny~O%f8uO~P&2lO![']O%f8uO~O#h$zqP$zqR$zq[$zqa$zqo$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'u$zq([$zq(m$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.aO#h'faP'faR'fa['faa'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'u'fa(['fa(m'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&/pO#h'haP'haR'ha['haa'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'u'ha(['ha(m'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&0cO#h$|qP$|qR$|q[$|qa$|qo$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'u$|q([$|q(m$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.aO!Y'Ui!h'Ui~P!9mO#}#`q!Y#`q!Z#`q~P#AbO(t$}OP%^aR%^a[%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a([%^a(m%^a!Y%^a!Z%^a~Ok%^a}%^a!P%^a(u%^a~P&CoO(u%POP%`aR%`a[%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a([%`a(m%`a!Y%`a!Z%`a~Ok%`a}%`a!P%`a(t%`a~P&EsOk=VO})zO!P){O(u%PO~P&CoOk=VO})zO!P){O(t$}O~P&EsOR0`O}0`O!P0aO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za([za(mza(tza(uza!Yza!Zza~O})zO!P){OP$qaR$qa[$qak$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa([$qa(m$qa(t$qa(u$qa!Y$qa!Z$qa~O})zO!P){OP$saR$sa[$sak$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa([$sa(m$sa(t$sa(u$sa!Y$sa!Z$sa~Ok=VO})zO!P){O(t$}O(u%PO~OP%RaR%Ra[%Rao%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra([%Ra(m%Ra!Y%Ra!Z%Ra~P&NlO#}$lq!Y$lq!Z$lq~P#AbO#}$mq!Y$mq!Z$mq~P#AbO!Z9SO~O#}9TO~P!0kO!d#vO!Y'ai!h'ai~O!d#vO(m'mO!Y'ai!h'ai~O!Y/hO!h(zq~O!V'ci!Y'ci~P#.aO!Y/pO!V({q~Oo9[O!d#vO(m'mO~O!V9]O~P#.aO!V9]O~O!d#vO#s9bO~Og(Yy!Y(Yy~P!0kO!Y'ja!['ja~P#.aOa%Yq![%Yq'u%Yq!Y%Yq~P#.aO[9dO~O!Y0wO!Z)Tq~O#]9hO!Y'la!Z'la~O!Y5^O!Z)Qi~P#AbO!P4hO~O![1aO%f9lO~O(QTO(TUO(`9qO~O!Y1lO!Z)Rq~O!h9tO~O!h9uO~O!h9vO~O!h9vO~P%[O#]9yO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AbO%f:OO~P&2lO![']O%f:OO~O#}#{y!Y#{y!Z#{y~P#AbOP$ziR$zi[$zio$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi([$zi(m$zi!Y$zi!Z$zi~P&NlO})zO!P){O(u%POP'eaR'ea['eak'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(['ea(m'ea(t'ea!Y'ea!Z'ea~O})zO!P){OP'gaR'ga['gak'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(['ga(m'ga(t'ga(u'ga!Y'ga!Z'ga~O(t$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i([%^i(m%^i(u%^i!Y%^i!Z%^i~O(u%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i([%`i(m%`i(t%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AbO#}#`y!Y#`y!Z#`y~P#AbO!d#vO!Y'aq!h'aq~O!Y/hO!h(zy~O!V'cq!Y'cq~P#.aOo:YO!d#vO(m'mO~O!V:ZO~P#.aO!V:ZO~O!Y0wO!Z)Ty~O!Y5^O!Z)Qq~O![1aO%f:cO~O!h:fO~O%f:kO~P&2lOP$zqR$zq[$zqo$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq([$zq(m$zq!Y$zq!Z$zq~P&NlO})zO!P){O(u%POP'faR'fa['fak'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(['fa(m'fa(t'fa!Y'fa!Z'fa~O})zO!P){OP'haR'ha['hak'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(['ha(m'ha(t'ha(u'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q([$|q(m$|q!Y$|q!Z$|q~P&NlOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0kOo:oO!d#vO(m'mO~O!V:pO~P#.aO!Y'lq!Z'lq~P#AbO!Y#e!Z!Z#e!Z~P#AbO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'u%b!Z([%b!Z(m%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.aOo:xO!d#vO(m'mO~OP%b!ZR%b!Z[%b!Zo%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z([%b!Z(m%b!Z!Y%b!Z!Z%b!Z~P&NlOs(aX~P1qO}%pO~P!(oO(P!lO~P!(oO!VfX!YfX#]fX~P&+QOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!dfX!h]X!hfX(mfX~P'BxOP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![XO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y;dO!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;oO!P${O![$|O!f=PO!i$xO#g;uO$V%_O$r;qO$t;sO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#t)`O~P'GnOo!bX(m!bX~P# ZO!Z]X!ZfX~P'BxO!VfX!V$xX!YfX!Y$xX#]fX~P!/gO#h;XO~O!d#vO#h;XO~O#];iO~O#s;]O~O#];xO!Y(rX!Z(rX~O#];iO!Y(pX!Z(pX~O#h;yO~Og;{O~P!0kO#h<RO~O#h<SO~O!d#vO#h<TO~O!d#vO#h;yO~O#}<UO~P#AbO#h<VO~O#h<WO~O#h<]O~O#h<^O~O#h<_O~O#h<`O~O#}<aO~P!0kO#}<bO~P!0kO#P#Q#R#T#U#X#f#g#r(y$r$t$w%Z%e%f%g%n%p%s%t%v%x~'yT#l!U'w(P#mp#k#no}'x$['x(O$^(`~",
  goto: "$4Q)XPPPPPP)YPP)]P)nP+O/PPPPP5xPP6`PP<V?mP@QP@QPPP@QPBRP@QP@QP@QPBVPB[PByPGrPPPGvPPPPGvJxPPPKOKzPGvPGvPPNYGvPPPGvPGvP!!aGvP!%v!&{!'UP!'x!'|!'x!+YPPPPPPP!+y!&{PP!,Z!-gP!0jGvGv!0o!3z!8b!8b!<`PPP!<hGvPPPPPPPPPPP!?vP!ATPPGv!BfPGvPGvGvGvGvGvPGv!CxP!GRP!JWP!J[!Jf!Jj!JjP!GOP!Jn!JnP!MsP!MwGvGv!M}##RBV@QP@QP@Q@QP#$_@Q@Q#&j@Q#)Z@Q#+`@Q@Q#,O#.]#.]#.b#.k#.]#.wP#.]P@Q#/a@Q#3S@Q@Q5xPPP#6{PPP#7f#7fP#7fP#7|#7fPP#8SP#7yP#7y#8g#7y#9R#9X5u)]#9[)]P#9c#9c#9cP)]P)]P)]P)]PP)]P#9i#9lP#9l)]P#9pP#9sP)]P)]P)]P)]P)]P)])]PP#9y#:P#:[#:b#:h#:n#:t#;S#;Y#;d#;j#;t#;z#<[#<b#=S#=f#=l#=r#>Q#>g#@V#@e#@l#BR#Ba#C|#D[#Db#Dh#Dn#Dx#EO#EU#E`#Er#ExPPPPPPPPPP#FOPPPPPPP#Fs#Iz#KZ#Kb#KjPPP$!sP$!|$%t$,^$,a$,d$-P$-S$-Z$-cP$-i$-lP$.Y$.^$/U$0d$0i$1PPP$1U$1[$1`P$1c$1g$1k$2a$2x$3a$3e$3h$3k$3q$3t$3x$3|R!|RoqOXst!Z#d%k&o&q&r&t,k,p1|2PY!vQ']-]1a5eQ%rvQ%zyQ&R|Q&g!VS'T!e-TQ'c!iS'i!r!yU*e$|*V*jQ+i%{Q+v&TQ,[&aQ-Z'[Q-e'dQ-m'jQ0R*lQ1k,]R;v;T%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8rS#q];Q!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U*y%[;n;oQ+n%}Q,^&dQ,e&lQ0m+aQ0q+cQ0|+oQ1s,cQ3Q._Q5O0wQ5t1lQ6r3UQ7s5PR8x6t'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{t!nQ!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5g$|$ti#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ&U|Q'R!eU'X%g*V-WQ+n%}Q,^&dQ0c*|Q0|+oQ1R+uQ1r,bQ1s,cQ5O0wQ5X1TQ5t1lQ5w1nQ5x1qQ7s5PQ7v5UQ8a5zQ9g7wR9r8^rnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR,`&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<z<{[#]WZ#W#Z'U(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+h%z%{Q+l%}Q,V&_Q,Z&aS-d'c'dQ.a(nQ0u+iQ0{+oQ0}+pQ1Q+tQ1f,WS1j,[,]Q2n-eQ4}0wQ5R0zQ5W1SQ5s1kQ7r5PQ7u5TQ9c7qR:^9d!O$zi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R!S%wy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dQ+b%uQ+{&XQ,O&YQ,Y&aQ.`(mQ1e,VU1i,Z,[,]Q3V.aQ5n1fS5r1j1kQ8]5s#^<|#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo<};g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bW%Ti%V*t<xS&X!Q&fQ&Y!RQ&Z!SR+y&V$}%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VT)v$u)wV*y%[;n;oW'X!e%g*V-WS(y#y#zQ+]%pQ+s&QS.Y(i(jQ1[,PQ4n0`R7{5^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{$i$^c#Y#e%o%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.t.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q'V!eR2c-Tv!nQ!e!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5gU*d$|*V*jS/y*e*lQ0S*mQ1^,RQ4d0RR4g0UnqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&v!^Q's!xS(o#u;XQ+f%xQ,T&[Q,U&^Q-b'aQ-o'lS.j(t;yS0f+R<TQ0s+gQ1`,SQ2T,rQ2V,sQ2_-OQ2l-cQ2o-gS4s0g<_Q4y0tS4|0v<`Q6^2aQ6b2mQ6g2tQ7p4zQ8m6`Q8n6cQ8q6hR9x8j$d$]c#Y#e%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oS(k#p'fQ({#zS+[%o.tS.Z(j(lR3O.['OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S#q];QQ&q!XQ&r!YQ&t![Q&u!]R1{,nQ'^!hQ+_%uQ-`'`S.](m+bQ2j-_W3S.`.a0l0nQ6a2kW6n3P3R3V4wU8t6o6q6sU9}8v8w8yS:i9|:PQ:t:jR:z:uU!wQ']-]T5c1a5e!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,k,p.S1|2P]!pQ!r']-]1a5eT#q];Q%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS(y#y#zS.Y(i(j!s<f$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U$fd)Z,eS(l#p'fU*q%R(s3pU0b*x.f7PQ4w0mQ6o3QQ8w6rR:P8xm!tQ!r!v!y!z']'i'j'k-]-m1a5e5gQ'q!uS(b#g1vS-k'h'tQ/k*XQ/w*dQ2v-nQ4U/lS4_/x0SQ7Z4PS7f4e4gQ9V7[Q9Z7cQ9`7iS:X9[9]S:n:Y:ZS:w:o:pR:}:xQ#wbQ'p!uS(a#g1vS(c#m+QQ+S%dQ+d%vQ+j%|U-j'h'q'tQ.O(bQ/j*XQ/v*dQ/|*gQ0r+eQ1g,XS2s-k-nQ2{.WS4T/k/lS4^/w0SQ4a/{Q4c/}Q5p1hQ6i2vQ7Y4PQ7^4US7b4_4gQ7g4fQ8Z5qS9U7Z7[Q9Y7cQ9^7fQ9a7jQ9o8[Q:V9VS:W9Z9]Q:[9`Q:e9pS:m:X:ZS:v:n:pQ:|:wQ;O:}Q<i<dQ<t<mR<u<nV!wQ']-]%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS#wz!j!r<c$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<i<z%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dS%|z!jQ+e%wQ,X&aW1h,Y,Z,[,]U5q1i1j1kS8[5r5sQ9p8]!r<d$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q<m<yR<n<z%OeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rY#bWZ#W#Z(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ,f&l!p<e$Z$n)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<h'UU'Y!e%g*VR2e-W%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8r!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q,e&lQ0m+aQ3Q._Q6r3UR8x6t!b$Tc#Y%o(O(U(p(u)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!P;_)Y)m-R.t2]2`3b3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!f$Vc#Y%o(O(U(p(u)S)T)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!T;a)Y)m-R.t2]2`3b3h3i3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!^$Zc#Y%o(O(U(p(u)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;RQ3}/cz<{)Y)m-R.t2]2`3b3q3y6_6z7T7U7}8l8z9Q9R:`:g<oQ=Q=SR=R=T'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S$oh$pR3v.|'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$kf$qQ$ifS)f$l)jR)r$qT$jf$qT)h$l)j'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$oh$pQ$rhR)q$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8r!s<y$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{#elOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_(z)o+V+a,h,k,p-a._.}/f0a1d1t1u1w1y1|2P2R3U3u5b5m5}6O6R6t8R8X8h!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=VQ*}%`Q/Y)zo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!O$yi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=RQ*^$zU*g$|*V*jQ+O%aQ/}*h#^<k#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn<l;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bQ<p<|Q<q<}Q<r=OR<s=P!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bnoOXst!Z#d%k&o&q&r&t,k,p1|2PS*a${*UQ,y&{Q,z&}R4X/p$|%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ+|&YQ1Y,OQ5[1XR7z5]V*i$|*V*jU*i$|*V*jT5d1a5eU/{*f/f5bS4f0T8RR7j4hQ+d%vQ/|*gQ0r+eQ1g,XQ5p1hQ8Z5qQ9o8[R:e9p!O%Oi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rr)}$v)a*O*p+P/n0Z0[3s4V4q7X7k:U<j<v<wS0V*o0W#^;j#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;k;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!`;|(q)_*W*`.b.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=T`;}3o6{7O7S8{:Q:T:{S<X.d3ZT<Y6}9O!O%Qi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rv*P$v)a*Q*o+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<wS0X*p0Y#^;l#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;m;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!d<O(q)_*W*`.c.d.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=Td<P3o6|6}7S8{8|:Q:R:T:{S<Z.e3[T<[7O9PrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ&c!UR,h&lrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR&c!UQ,Q&ZR1U+ysnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ1b,VS5k1e1fU8T5i5j5nS9k8V8WS:a9j9mQ:q:bR:y:rQ&j!VR,a&fR5w1nS&O|&TR0}+pQ&o!WR,k&pR,q&uT1},p2PR,u&vQ,t&vR2W,uQ'v!{R-q'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)w$uR/V)wQ#UVR'|#UQ#XWU(S#X(T-xQ(T#YR-x(UQ-U'VR2d-UQ.m(uS3_.m3`R3`.nQ-]']R2h-]Y!rQ']-]1a5eR'g!rQ.x)aR3t.xU#_W%f*UU(Z#_([-yQ([#`R-y(VQ-X'YR2f-Xt`OXst!V!Z#d%k&f&h&o&q&r&t,k,p1|2PS#hZ%cU#r`#h.SR.S(fQ(g#jQ.P(cW.X(g.P2y6kQ2y.QR6k2zQ)j$lR/O)jQ$phR)p$pQ$`cU)]$`-t;eQ-t;RR;e)mQ/i*XW4R/i4S7]9WU4S/j/k/lS7]4T4UR9W7^$Z)|$v(q)_)a*W*`*o*p*z*{+P.d.e.g.h.i/U/Z/_/a/c/n/s0Z0[0k1V1X3W3X3Y3o3s4V4W4[4i4k4q5Z5]6u6v6w6x6}7O7Q7R7S7X7`7d7k7m7o8{8|8}9X9_:Q:R:S:T:U:]:l:{<j<v<w=S=TQ/q*`U4Z/q4]7aQ4]/sR7a4[S*j$|*VR0P*jr*O$v)a*o*p+P/n0Z0[3s4V4q7X7k:U<j<v<w!`.b(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=TU/`*O.b6{a6{3o6}7O7S8{:Q:T:{Q0W*oQ3Z.dU4j0W3Z9OR9O6}v*Q$v)a*o*p+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<w!d.c(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=TU/b*Q.c6|e6|3o6}7O7S8{8|:Q:R:T:{Q0Y*pQ3[.eU4l0Y3[9PR9P7OQ*u%UR0^*uQ4v0kR7n4vQ+X%iR0j+XQ5_1[S7|5_9iR9i7}Q,S&[R1_,SQ5e1aR8P5eQ1m,^S5u1m8_R8_5wQ0x+lW5Q0x5S7t9eQ5S0{Q7t5RR9e7uQ+q&OR1O+qQ2P,pR6V2PYrOXst#dQ&s!ZQ+Z%kQ,j&oQ,l&qQ,m&rQ,o&tQ1z,kS1},p2PR6U1|Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Y%jQ+f%xQ+x&UQ,`&jQ,w&yW-h'h'p'q'tQ-o'lQ0O*iQ0s+gS1p,a,dQ2X,vQ2Y,yQ2Z,zQ2o-gW2q-j-k-n-pQ4y0tQ5V1RQ5Y1VQ5o1gQ5y1rQ6T1{U6d2p2s2vQ6g2tQ7p4zQ7x5XQ7y5ZQ8O5dQ8Y5pQ8`5xS8o6e6iQ8q6hQ9f7vQ9n8ZQ9s8aQ9z8pQ:_9gQ:d9oQ:h9{R:s:eQ%xyQ'a!iQ'l!uU+g%y%z%{Q-O'SU-c'b'c'dS-g'h'rQ/u*dS0t+h+iQ2a-QS2m-d-eQ2t-lQ4`/yQ4z0uQ6`2gQ6c2nQ6h2uR7e4dS$wi<xR*v%VU%Ui%V<xR0]*tQ$viS(q#v+cS)_$b$cQ)a$dQ*W$xS*`${*UQ*o%OQ*p%QQ*z%]Q*{%^Q+P%bQ.d;jQ.e;lQ.g;pQ.h;rQ.i;tQ/U)uS/Z){/]Q/_)}Q/a*PQ/c*RQ/n*[S/s*b/eQ0Z*rQ0[*sh0k+`.^1c3T5l6p8U8u9l:O:c:kQ1V+zQ1X+}Q3W;|Q3X<OQ3Y<RS3o;g;hQ3s.wQ4V/oQ4W/pQ4[/rQ4i0VQ4k0XQ4q0dQ5Z1WQ5]1ZQ6u<VQ6v<XQ6w<ZQ6x<]Q6};kQ7O;mQ7Q;qQ7R;sQ7S;uQ7X3}Q7`4YQ7d4bQ7k4mQ7m4uQ7o4xQ8{<SQ8|;}Q8}<PQ9X7_Q9_7hQ:Q<WQ:R<YQ:S<[Q:T<^Q:U9TQ:]9bQ:l<aQ:{<bQ<j<xQ<v=QQ<w=RQ=S=UR=T=VQ*x%[Q.f;nR7P;onpOXst!Z#d%k&o&q&r&t,k,p1|2PQ!fPS#fZ#oQ&y!`U'e!o5b8RQ'{#SQ(|#{Q)n$nS,d&h&kQ,i&lQ,v&xQ,{'QQ-_'_Q.p(zQ/S)oS0h+V/fQ0n+aQ1x,hQ2k-aQ3R._Q3x.}Q4o0aQ5j1dQ5{1tQ5|1uQ6Q1wQ6S1yQ6X2RQ6s3UQ7V3uQ8W5mQ8d5}Q8e6OQ8g6RQ8y6tQ9m8XR9w8h#YcOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_(z+V+a,h,k,p-a._/f0a1d1t1u1w1y1|2P2R3U5b5m5}6O6R6t8R8X8hQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)Y$ZQ)[$_Q)^$aQ)c$eW)m$n)o.}3uQ+^%rQ+r&PS-R'U2bQ-p'oS-u(P-wQ-z(XQ-|(`Q.k(tQ.n(vQ.r;PQ.t;SQ.u;TQ.v;WQ/X)yQ0e+RQ2],|Q2`-PQ2p-iQ2w-}Q3].lQ3b;XQ3c;YQ3d;ZQ3e;[Q3f;]Q3g;^Q3h;_Q3i;`Q3j;aQ3k;bQ3l;cQ3m.sQ3n;fQ3q;iQ3r;vQ3y;dQ4r0gQ4{0vQ6_;xQ6e2rQ6j2xQ6y3^Q6z;yQ7T;{Q7U<TQ7}5`Q8l6]Q8p6fQ8z<UQ9Q<_Q9R<`Q9{8rQ:`9hQ:g9yQ;R#SR<o<{R#[WR'W!el!tQ!r!v!y!z']'i'j'k-]-m1a5e5gS'S!e-TS-Q'T'[R2g-ZR(w#xQ!fQT-[']-]]!qQ!r']-]1a5eQ#p]R'f;QR)b$dY!uQ']-]1a5eQ'h!rS'r!v!yS't!z5gS-l'i'jQ-n'kR2u-mT#kZ%cS#jZ%cS%im,gU(c#h#i#lS.Q(d(eQ.U(fQ0i+WQ2z.RU2{.S.T.VS6l2|2}R8s6md#^W#W#Z%f(P(Y*U+T-{/er#gZm#h#i#l%c(d(e(f+W.R.S.T.V2|2}6mS*X$x*]Q/l*YQ1v,gQ2^,}Q4P/hQ6Z2UQ7[4QQ8k6[T<g'U+UV#aW%f*UU#`W%f*US(Q#W(YU(V#Z+T/eS-S'U+UT-v(P-{V'Z!e%g*VQ$lfR)t$qT)i$l)jR3w.|T*Z$x*]T*c${*UQ0l+`Q3P.^Q5i1cQ6q3TQ8V5lQ8v6pQ9j8UQ9|8uQ:b9lQ:j:OQ:r:cR:u:knqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&i!VR,`&ftmOXst!U!V!Z#d%k&f&o&q&r&t,k,p1|2PR,g&lT%jm,gR1],PR,_&dQ&S|R+w&TR+m%}T&m!W&pT&n!W&pT2O,p2P",
  nodeNames: " ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 376,
  context: jbe,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
    ["group", -26, 9, 17, 19, 65, 204, 208, 212, 213, 215, 218, 221, 231, 233, 239, 241, 243, 245, 248, 254, 260, 262, 264, 266, 268, 270, 271, "Statement", -34, 13, 14, 29, 32, 33, 39, 48, 51, 52, 54, 59, 67, 69, 73, 77, 79, 81, 82, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 167, 169, "Expression", -23, 28, 30, 34, 38, 40, 42, 171, 173, 175, 176, 178, 179, 180, 182, 183, 184, 186, 187, 188, 198, 200, 202, 203, "Type", -3, 85, 100, 106, "ClassItem"],
    ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
    ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"]
  ],
  propSources: [eOe],
  skippedNodes: [0, 5, 6, 274],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Rp(U!b'w0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(S#S$h&j'x0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Rp(U!b'x0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(Q':f$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(U!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Rp(U!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Rp(U!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(U!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(U!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(RpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(RpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Rp(U!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(j%1l(Rp(U!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Rp(U!b$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Rp(U!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Rp(U!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(u+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(T';W$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(RpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Rp(U!b(P%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Rp(U!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Rp(U!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Rp(U!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Rp(U!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(U!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(U!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(U!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(U!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(U!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(U!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Rp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Rp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Rp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Rp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(RpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(RpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Rp(U!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Rp(U!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Rp(U!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Rp(U!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Rp(U!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Rp(U!b'y0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Rp(U!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(U!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(U!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(RpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(RpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Rp(U!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Rp(U!b(y7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(m(Ct$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Rp(U!b([+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Rp(U!b(O,2j$^#t(`$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Rp(U!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(t+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z(Kd$?V_!Z(Cds`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Rp(U!b'w0/l$[#t(O,2j(`$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Rp(U!b'x0/l$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [Gbe, Kbe, Jbe, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, Ybe, new Tm("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(^~~", 141, 335), new Tm("j~RQYZXz{^~^O'{~~aP!P!Qd~iO'|~~", 25, 318)],
  topRules: { Script: [0, 7], SingleExpression: [1, 272], SingleClassItem: [2, 273] },
  dialects: { jsx: 0, ts: 14725 },
  dynamicPrecedences: { 77: 1, 79: 1, 91: 1, 167: 1, 196: 1 },
  specialized: [{ term: 322, get: (t) => tOe[t] || -1 }, { term: 338, get: (t) => nOe[t] || -1 }, { term: 92, get: (t) => iOe[t] || -1 }],
  tokenPrec: 14749
});
class NN {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, n, i, r) {
    this.state = e, this.pos = n, this.explicit = i, this.view = r, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let n = Nt(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), i = Math.max(n.from, this.pos - 250), r = n.text.slice(i - n.from, this.pos - n.from), s = r.search(IN(e, !1));
    return s < 0 ? null : { from: i + s, to: this.pos, text: r.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, n) {
    e == "abort" && this.abortListeners && this.abortListeners.push(n);
  }
}
function gA(t) {
  let e = Object.keys(t).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function sOe(t) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of t) {
    e[r[0]] = !0;
    for (let s = 1; s < r.length; s++)
      n[r[s]] = !0;
  }
  let i = gA(e) + gA(n) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function DN(t) {
  let e = t.map((r) => typeof r == "string" ? { label: r } : r), [n, i] = e.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : sOe(e);
  return (r) => {
    let s = r.matchBefore(i);
    return s || r.explicit ? { from: s ? s.from : r.pos, options: e, validFor: n } : null;
  };
}
function oOe(t, e) {
  return (n) => {
    for (let i = Nt(n.state).resolveInner(n.pos, -1); i; i = i.parent) {
      if (t.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(n);
  };
}
class bA {
  constructor(e, n, i, r) {
    this.completion = e, this.source = n, this.match = i, this.score = r;
  }
}
function xo(t) {
  return t.selection.main.from;
}
function IN(t, e) {
  var n;
  let { source: i } = t, r = e && i[0] != "^", s = i[i.length - 1] != "$";
  return !r && !s ? t : new RegExp(`${r ? "^" : ""}(?:${i})${s ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const W_ = /* @__PURE__ */ $s.define();
function aOe(t, e, n, i) {
  let { main: r } = t.selection, s = n - r.from, o = i - r.from;
  return Object.assign(Object.assign({}, t.changeByRange((a) => a != r && n != i && t.sliceDoc(a.from + s, a.from + o) != t.sliceDoc(n, i) ? { range: a } : {
    changes: { from: a.from + s, to: i == r.from ? a.to : a.from + o, insert: e },
    range: j.cursor(a.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const OA = /* @__PURE__ */ new WeakMap();
function lOe(t) {
  if (!Array.isArray(t))
    return t;
  let e = OA.get(t);
  return e || OA.set(t, e = DN(t)), e;
}
const Zm = /* @__PURE__ */ Me.define(), Rd = /* @__PURE__ */ Me.define();
class cOe {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let i = pn(e, n), r = $i(i);
      this.chars.push(i);
      let s = e.slice(n, n + r), o = s.toUpperCase();
      this.folded.push(pn(o == s ? s.toLowerCase() : o, 0)), n += r;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: n, folded: i, any: r, precise: s, byWord: o } = this;
    if (n.length == 1) {
      let _ = pn(e, 0), y = $i(_), O = y == e.length ? 0 : -100;
      if (_ != n[0]) if (_ == i[0])
        O += -200;
      else
        return null;
      return this.ret(O, [0, y]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = n.length, c = 0;
    if (a < 0) {
      for (let _ = 0, y = Math.min(e.length, 200); _ < y && c < l; ) {
        let O = pn(e, _);
        (O == n[c] || O == i[c]) && (r[c++] = _), _ += $i(O);
      }
      if (c < l)
        return null;
    }
    let u = 0, d = 0, h = !1, f = 0, p = -1, m = -1, g = /[a-z]/.test(e), b = !0;
    for (let _ = 0, y = Math.min(e.length, 200), O = 0; _ < y && d < l; ) {
      let x = pn(e, _);
      a < 0 && (u < l && x == n[u] && (s[u++] = _), f < l && (x == n[f] || x == i[f] ? (f == 0 && (p = _), m = _ + 1, f++) : f = 0));
      let v, w = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (v = __(x)) != v.toLowerCase() ? 1 : v != v.toUpperCase() ? 2 : 0;
      (!_ || w == 1 && g || O == 0 && w != 0) && (n[d] == x || i[d] == x && (h = !0) ? o[d++] = _ : o.length && (b = !1)), O = w, _ += $i(x);
    }
    return d == l && o[0] == 0 && b ? this.result(-100 + (h ? -200 : 0), o, e) : f == l && p == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : f == l ? this.ret(-900 - e.length, [p, m]) : d == l ? this.result(-100 + (h ? -200 : 0) + -700 + (b ? 0 : -1100), o, e) : n.length == 2 ? null : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e);
  }
  result(e, n, i) {
    let r = [], s = 0;
    for (let o of n) {
      let a = o + (this.astral ? $i(pn(i, o)) : 1);
      s && r[s - 1] == o ? r[s - 1] = a : (r[s++] = o, r[s++] = a);
    }
    return this.ret(e - i.length, r);
  }
}
class uOe {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let n = e.slice(0, this.pattern.length), i = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, n.length], this.score = i + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const gn = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: dOe,
      filterStrict: !1,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (i) => yA(e(i), n(i)),
      optionClass: (e, n) => (i) => yA(e(i), n(i)),
      addToOptions: (e, n) => e.concat(n),
      filterStrict: (e, n) => e || n
    });
  }
});
function yA(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function dOe(t, e, n, i, r, s) {
  let o = t.textDirection == At.RTL, a = o, l = !1, c = "top", u, d, h = e.left - r.left, f = r.right - e.right, p = i.right - i.left, m = i.bottom - i.top;
  if (a && h < Math.min(p, f) ? a = !1 : !a && f < Math.min(p, h) && (a = !0), p <= (a ? h : f))
    u = Math.max(r.top, Math.min(n.top, r.bottom - m)) - e.top, d = Math.min(400, a ? h : f);
  else {
    l = !0, d = Math.min(
      400,
      (o ? e.right : r.right - e.left) - 30
      /* Info.Margin */
    );
    let _ = r.bottom - e.bottom;
    _ >= m || _ > e.top ? u = n.bottom - e.top : (c = "bottom", u = e.bottom - n.top);
  }
  let g = (e.bottom - e.top) / s.offsetHeight, b = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / g}px; max-width: ${d / b}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function hOe(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(n) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), n.type && i.classList.add(...n.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(n, i, r, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = n.displayLabel || n.label, l = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], d = s[c++];
        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
        let h = o.appendChild(document.createElement("span"));
        h.appendChild(document.createTextNode(a.slice(u, d))), h.className = "cm-completionMatchedText", l = d;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = n.detail, i;
    },
    position: 80
  }), e.sort((n, i) => n.position - i.position).map((n) => n.render);
}
function nb(t, e, n) {
  if (t <= n)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let r = Math.floor(e / n);
    return { from: r * n, to: (r + 1) * n };
  }
  let i = Math.floor((t - e) / n);
  return { from: t - (i + 1) * n, to: t - i * n };
}
class fOe {
  constructor(e, n, i) {
    this.view = e, this.stateField = n, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = e.state.field(n), { options: s, selected: o } = r.open, a = e.state.facet(gn);
    this.optionContent = hOe(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = nb(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(n).open;
      for (let u = l.target, d; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (d = /-(\d+)$/.exec(u.id)) && +d[1] < c.length) {
          this.applyCompletion(e, c[+d[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(gn).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: Rd.of(null) });
    }), this.showOptions(s, r.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let i = e.state.field(this.stateField), r = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != r) {
      let { options: s, selected: o, disabled: a } = i.open;
      (!r.open || r.open.options != s) && (this.range = nb(s.length, o, e.state.facet(gn).maxRenderedOptions), this.showOptions(s, i.id)), this.updateSel(), a != ((n = r.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of n.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = nb(n.options.length, n.selected, this.view.state.facet(gn).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: i } = n.options[n.selected], { info: r } = i;
      if (!r)
        return;
      let s = typeof r == "string" ? document.createTextNode(r) : r(i);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, i);
      }).catch((o) => ni(this.view.state, o, "completion info")) : this.addInfoPane(s, i);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: r, destroy: s } = e;
      i.appendChild(r), this.infoDestroy = s || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)
      i.nodeName != "LI" || !i.id ? r-- : r == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), n = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return n && mOe(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return r.top > Math.min(s.bottom, n.bottom) - 10 || r.bottom < Math.max(s.top, n.top) + 10 ? null : this.view.state.facet(gn).positionInfo(this.view, n, r, i, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, i) {
    const r = document.createElement("ul");
    r.id = n, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = i.from; o < i.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let h = typeof c == "string" ? c : c.name;
        if (h != s && (o > i.from || i.from == 0))
          if (s = h, typeof c != "string" && c.header)
            r.appendChild(c.header(c));
          else {
            let f = r.appendChild(document.createElement("completion-section"));
            f.textContent = h;
          }
      }
      const u = r.appendChild(document.createElement("li"));
      u.id = n + "-" + o, u.setAttribute("role", "option");
      let d = this.optionClass(a);
      d && (u.className = d);
      for (let h of this.optionContent) {
        let f = h(a, this.view.state, this.view, l);
        f && u.appendChild(f);
      }
    }
    return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < e.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function pOe(t, e) {
  return (n) => new fOe(n, t, e);
}
function mOe(t, e) {
  let n = t.getBoundingClientRect(), i = e.getBoundingClientRect(), r = n.height / t.offsetHeight;
  i.top < n.top ? t.scrollTop -= (n.top - i.top) / r : i.bottom > n.bottom && (t.scrollTop += (i.bottom - n.bottom) / r);
}
function _A(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function gOe(t, e) {
  let n = [], i = null, r = (c) => {
    n.push(c);
    let { section: u } = c.completion;
    if (u) {
      i || (i = []);
      let d = typeof u == "string" ? u : u.name;
      i.some((h) => h.name == d) || i.push(typeof u == "string" ? { name: d } : u);
    }
  }, s = e.facet(gn);
  for (let c of t)
    if (c.hasResult()) {
      let u = c.result.getMatch;
      if (c.result.filter === !1)
        for (let d of c.result.options)
          r(new bA(d, c.source, u ? u(d) : [], 1e9 - n.length));
      else {
        let d = e.sliceDoc(c.from, c.to), h, f = s.filterStrict ? new uOe(d) : new cOe(d);
        for (let p of c.result.options)
          if (h = f.match(p.label)) {
            let m = p.displayLabel ? u ? u(p, h.matched) : [] : h.matched;
            r(new bA(p, c.source, m, h.score + (p.boost || 0)));
          }
      }
    }
  if (i) {
    let c = /* @__PURE__ */ Object.create(null), u = 0, d = (h, f) => {
      var p, m;
      return ((p = h.rank) !== null && p !== void 0 ? p : 1e9) - ((m = f.rank) !== null && m !== void 0 ? m : 1e9) || (h.name < f.name ? -1 : 1);
    };
    for (let h of i.sort(d))
      u -= 1e5, c[h.name] = u;
    for (let h of n) {
      let { section: f } = h.completion;
      f && (h.score += c[typeof f == "string" ? f : f.name]);
    }
  }
  let o = [], a = null, l = s.compareCompletions;
  for (let c of n.sort((u, d) => d.score - u.score || l(u.completion, d.completion))) {
    let u = c.completion;
    !a || a.label != u.label || a.detail != u.detail || a.type != null && u.type != null && a.type != u.type || a.apply != u.apply || a.boost != u.boost ? o.push(c) : _A(c.completion) > _A(a) && (o[o.length - 1] = c), a = c.completion;
  }
  return o;
}
class vl {
  constructor(e, n, i, r, s, o) {
    this.options = e, this.attrs = n, this.tooltip = i, this.timestamp = r, this.selected = s, this.disabled = o;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new vl(this.options, vA(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, i, r, s) {
    let o = gOe(e, n);
    if (!o.length)
      return r && e.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new vl(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0) : null;
    let a = n.facet(gn).selectOnOpen ? 0 : -1;
    if (r && r.selected != a && r.selected != -1) {
      let l = r.options[r.selected].completion;
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == l) {
          a = c;
          break;
        }
    }
    return new vl(o, vA(i, a), {
      pos: e.reduce((l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),
      create: xOe,
      above: s.aboveCursor
    }, r ? r.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new vl(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Hm {
  constructor(e, n, i) {
    this.active = e, this.id = n, this.open = i;
  }
  static start() {
    return new Hm(_Oe, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, i = n.facet(gn), s = (i.override || n.languageDataAt("autocomplete", xo(n)).map(lOe)).map((a) => (this.active.find((c) => c.source == a) || new yi(
      a,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !bOe(s, this.active) ? o = vl.build(s, n, this.id, o, i) : o && o.disabled && !s.some(
      (a) => a.state == 1
      /* State.Pending */
    ) && (o = null), !o && s.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new yi(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(QN) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new Hm(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? OOe : yOe;
  }
}
function bOe(t, e) {
  if (t == e)
    return !0;
  for (let n = 0, i = 0; ; ) {
    for (; n < t.length && !t[n].hasResult; )
      n++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let r = n == t.length, s = i == e.length;
    if (r || s)
      return r == s;
    if (t[n++].result != e[i++].result)
      return !1;
  }
}
const OOe = {
  "aria-autocomplete": "list"
}, yOe = {};
function vA(t, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const _Oe = [];
function LN(t, e) {
  if (t.isUserEvent("input.complete")) {
    let i = t.annotation(W_);
    if (i && e.activateOnCompletion(i))
      return 12;
  }
  let n = t.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class yi {
  constructor(e, n, i = -1) {
    this.source = e, this.state = n, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, n) {
    let i = LN(e, n), r = this;
    (i & 8 || i & 16 && this.touches(e)) && (r = new yi(
      r.source,
      0
      /* State.Inactive */
    )), i & 4 && r.state == 0 && (r = new yi(
      this.source,
      1
      /* State.Pending */
    )), r = r.updateFor(e, i);
    for (let s of e.effects)
      if (s.is(Zm))
        r = new yi(r.source, 1, s.value ? xo(e.state) : -1);
      else if (s.is(Rd))
        r = new yi(
          r.source,
          0
          /* State.Inactive */
        );
      else if (s.is(BN))
        for (let o of s.value)
          o.source == r.source && (r = o);
    return r;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new yi(this.source, this.state, e.mapPos(this.explicitPos));
  }
  touches(e) {
    return e.changes.touchesRange(xo(e.state));
  }
}
class Nl extends yi {
  constructor(e, n, i, r, s) {
    super(e, 2, n), this.result = i, this.from = r, this.to = s;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var i;
    if (!(n & 3))
      return this.map(e.changes);
    let r = this.result;
    r.map && !e.changes.empty && (r = r.map(r, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = xo(e.state);
    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || !r || n & 2 && xo(e.startState) == this.from)
      return new yi(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
    return vOe(r.validFor, e.state, s, o) ? new Nl(this.source, l, r, s, o) : r.update && (r = r.update(r, s, o, new NN(e.state, a, l >= 0))) ? new Nl(this.source, l, r, r.from, (i = r.to) !== null && i !== void 0 ? i : xo(e.state)) : new yi(this.source, 1, l);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Nl(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new yi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function vOe(t, e, n, i) {
  if (!t)
    return !1;
  let r = e.sliceDoc(n, i);
  return typeof t == "function" ? t(r, n, i, e) : IN(t, !0).test(r);
}
const BN = /* @__PURE__ */ Me.define({
  map(t, e) {
    return t.map((n) => n.map(e));
  }
}), QN = /* @__PURE__ */ Me.define(), Gn = /* @__PURE__ */ ln.define({
  create() {
    return Hm.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    R_.from(t, (e) => e.tooltip),
    ae.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function V_(t, e) {
  const n = e.completion.apply || e.completion.label;
  let i = t.state.field(Gn).active.find((r) => r.source == e.source);
  return i instanceof Nl ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, aOe(t.state, n, i.from, i.to)), { annotations: W_.of(e.completion) })) : n(t, e.completion, i.from, i.to), !0) : !1;
}
const xOe = /* @__PURE__ */ pOe(Gn, V_);
function Nf(t, e = "option") {
  return (n) => {
    let i = n.state.field(Gn, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < n.state.facet(gn).interactionDelay)
      return !1;
    let r = 1, s;
    e == "page" && (s = X$(n, i.open.tooltip)) && (r = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = i.open.options, a = i.open.selected > -1 ? i.open.selected + r * (t ? 1 : -1) : t ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), n.dispatch({ effects: QN.of(a) }), !0;
  };
}
const wOe = (t) => {
  let e = t.state.field(Gn, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(gn).interactionDelay ? !1 : V_(t, e.open.options[e.open.selected]);
}, SOe = (t) => t.state.field(Gn, !1) ? (t.dispatch({ effects: Zm.of(!0) }), !0) : !1, kOe = (t) => {
  let e = t.state.field(Gn, !1);
  return !e || !e.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: Rd.of(null) }), !0);
};
class EOe {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const COe = 50, AOe = 1e3, TOe = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(Gn).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(Gn), n = t.state.facet(gn);
    if (!t.selectionSet && !t.docChanged && t.startState.field(Gn) == e)
      return;
    let i = t.transactions.some((s) => {
      let o = LN(s, n);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (i || o.updates.length + t.transactions.length > COe && Date.now() - o.time > AOe) {
        for (let a of o.context.abortListeners)
          try {
            a();
          } catch (l) {
            ni(this.view.state, l);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((s) => s.effects.some((o) => o.is(Zm))) && (this.pendingStart = !0);
    let r = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.state == 1 && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)
      for (let s of t.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(Gn);
    for (let n of e.active)
      n.state == 1 && !this.running.some((i) => i.active.source == n.source) && this.startQuery(n);
  }
  startQuery(t) {
    let { state: e } = this.view, n = xo(e), i = new NN(e, n, t.explicitPos == n, this.view), r = new EOe(t, i);
    this.running.push(r), Promise.resolve(t.source(i)).then((s) => {
      r.context.aborted || (r.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: Rd.of(null) }), ni(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(gn).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(gn);
    for (let i = 0; i < this.running.length; i++) {
      let r = this.running[i];
      if (r.done === void 0)
        continue;
      if (this.running.splice(i--, 1), r.done) {
        let o = new Nl(r.active.source, r.active.explicitPos, r.done, r.done.from, (t = r.done.to) !== null && t !== void 0 ? t : xo(r.updates.length ? r.updates[0].startState : this.view.state));
        for (let a of r.updates)
          o = o.update(a, n);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(Gn).active.find((o) => o.source == r.active.source);
      if (s && s.state == 1)
        if (r.done == null) {
          let o = new yi(
            r.active.source,
            0
            /* State.Inactive */
          );
          for (let a of r.updates)
            o = o.update(a, n);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: BN.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(Gn, !1);
      if (e && e.tooltip && this.view.state.facet(gn).closeOnBlur) {
        let n = e.open && X$(this.view, e.open.tooltip);
        (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Rd.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Zm.of(!1) }), 20), this.composing = 0;
    }
  }
}), MOe = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), POe = /* @__PURE__ */ Fo.highest(/* @__PURE__ */ ae.domEventHandlers({
  keydown(t, e) {
    let n = e.state.field(Gn, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(MOe && t.altKey) || t.metaKey)
      return !1;
    let i = n.open.options[n.open.selected], r = n.active.find((o) => o.source == i.source), s = i.completion.commitCharacters || r.result.commitCharacters;
    return s && s.indexOf(t.key) > -1 && V_(e, i), !1;
  }
})), FN = /* @__PURE__ */ ae.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class ROe {
  constructor(e, n, i, r) {
    this.field = e, this.line = n, this.from = i, this.to = r;
  }
}
class Z_ {
  constructor(e, n, i) {
    this.field = e, this.from = n, this.to = i;
  }
  map(e) {
    let n = e.mapPos(this.from, -1, mn.TrackDel), i = e.mapPos(this.to, 1, mn.TrackDel);
    return n == null || i == null ? null : new Z_(this.field, n, i);
  }
}
class H_ {
  constructor(e, n) {
    this.lines = e, this.fieldPositions = n;
  }
  instantiate(e, n) {
    let i = [], r = [n], s = e.doc.lineAt(n), o = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let c = o, u = /^\t*/.exec(l)[0].length;
        for (let d = 0; d < u; d++)
          c += e.facet(eg);
        r.push(n + c.length - u), l = c + l.slice(u);
      }
      i.push(l), n += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new Z_(l.field, r[l.line] + l.from, r[l.line] + l.to));
    return { text: i, ranges: a };
  }
  static parse(e) {
    let n = [], i = [], r = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o); ) {
        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || "", c = -1, u = l.replace(/\\[{}]/g, (d) => d[1]);
        for (let d = 0; d < n.length; d++)
          (a != null ? n[d].seq == a : u && n[d].name == u) && (c = d);
        if (c < 0) {
          let d = 0;
          for (; d < n.length && (a == null || n[d].seq != null && n[d].seq < a); )
            d++;
          n.splice(d, 0, { seq: a, name: u }), c = d;
          for (let h of r)
            h.field >= c && h.field++;
        }
        r.push(new ROe(c, i.length, s.index, s.index + u.length)), o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (a, l, c) => {
        for (let u of r)
          u.line == i.length && u.from > c && (u.from--, u.to--);
        return l;
      }), i.push(o);
    }
    return new H_(i, r);
  }
}
let $Oe = /* @__PURE__ */ ve.widget({ widget: /* @__PURE__ */ new class extends Ns {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), NOe = /* @__PURE__ */ ve.mark({ class: "cm-snippetField" });
class Cc {
  constructor(e, n) {
    this.ranges = e, this.active = n, this.deco = ve.set(e.map((i) => (i.from == i.to ? $Oe : NOe).range(i.from, i.to)));
  }
  map(e) {
    let n = [];
    for (let i of this.ranges) {
      let r = i.map(e);
      if (!r)
        return null;
      n.push(r);
    }
    return new Cc(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((i) => i.field == this.active && i.from <= n.from && i.to >= n.to));
  }
}
const bh = /* @__PURE__ */ Me.define({
  map(t, e) {
    return t && t.map(e);
  }
}), DOe = /* @__PURE__ */ Me.define(), $d = /* @__PURE__ */ ln.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let n of e.effects) {
      if (n.is(bh))
        return n.value;
      if (n.is(DOe) && t)
        return new Cc(t.ranges, n.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => ae.decorations.from(t, (e) => e ? e.deco : ve.none)
});
function q_(t, e) {
  return j.create(t.filter((n) => n.field == e).map((n) => j.range(n.from, n.to)));
}
function IOe(t) {
  let e = H_.parse(t);
  return (n, i, r, s) => {
    let { text: o, ranges: a } = e.instantiate(n.state, r), l = {
      changes: { from: r, to: s, insert: Ge.of(o) },
      scrollIntoView: !0,
      annotations: i ? [W_.of(i), Vt.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (l.selection = q_(a, 0)), a.some((c) => c.field > 0)) {
      let c = new Cc(a, 0), u = l.effects = [bh.of(c)];
      n.state.field($d, !1) === void 0 && u.push(Me.appendConfig.of([$d, zOe, UOe, FN]));
    }
    n.dispatch(n.state.update(l));
  };
}
function zN(t) {
  return ({ state: e, dispatch: n }) => {
    let i = e.field($d, !1);
    if (!i || t < 0 && i.active == 0)
      return !1;
    let r = i.active + t, s = t > 0 && !i.ranges.some((o) => o.field == r + t);
    return n(e.update({
      selection: q_(i.ranges, r),
      effects: bh.of(s ? null : new Cc(i.ranges, r)),
      scrollIntoView: !0
    })), !0;
  };
}
const LOe = ({ state: t, dispatch: e }) => t.field($d, !1) ? (e(t.update({ effects: bh.of(null) })), !0) : !1, BOe = /* @__PURE__ */ zN(1), QOe = /* @__PURE__ */ zN(-1), FOe = [
  { key: "Tab", run: BOe, shift: QOe },
  { key: "Escape", run: LOe }
], xA = /* @__PURE__ */ de.define({
  combine(t) {
    return t.length ? t[0] : FOe;
  }
}), zOe = /* @__PURE__ */ Fo.highest(/* @__PURE__ */ G0.compute([xA], (t) => t.facet(xA)));
function Hn(t, e) {
  return Object.assign(Object.assign({}, e), { apply: IOe(t) });
}
const UOe = /* @__PURE__ */ ae.domEventHandlers({
  mousedown(t, e) {
    let n = e.state.field($d, !1), i;
    if (!n || (i = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let r = n.ranges.find((s) => s.from <= i && s.to >= i);
    return !r || r.field == n.active ? !1 : (e.dispatch({
      selection: q_(n.ranges, r.field),
      effects: bh.of(n.ranges.some((s) => s.field > r.field) ? new Cc(n.ranges, r.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Nd = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ha = /* @__PURE__ */ Me.define({
  map(t, e) {
    let n = e.mapPos(t, -1, mn.TrackAfter);
    return n ?? void 0;
  }
}), X_ = /* @__PURE__ */ new class extends Na {
}();
X_.startSide = 1;
X_.endSide = -1;
const UN = /* @__PURE__ */ ln.define({
  create() {
    return Ye.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (i) => i >= n.from && i <= n.to });
    }
    for (let n of e.effects)
      n.is(ha) && (t = t.update({ add: [X_.range(n.value, n.value + 1)] }));
    return t;
  }
});
function WOe() {
  return [ZOe, UN];
}
const ib = "()[]{}<>";
function WN(t) {
  for (let e = 0; e < ib.length; e += 2)
    if (ib.charCodeAt(e) == t)
      return ib.charAt(e + 1);
  return __(t < 128 ? t : t + 1);
}
function VN(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || Nd;
}
const VOe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), ZOe = /* @__PURE__ */ ae.inputHandler.of((t, e, n, i) => {
  if ((VOe ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let r = t.state.selection.main;
  if (i.length > 2 || i.length == 2 && $i(pn(i, 0)) == 1 || e != r.from || n != r.to)
    return !1;
  let s = XOe(t.state, i);
  return s ? (t.dispatch(s), !0) : !1;
}), HOe = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let i = VN(t, t.selection.main.head).brackets || Nd.brackets, r = null, s = t.changeByRange((o) => {
    if (o.empty) {
      let a = jOe(t.doc, o.head);
      for (let l of i)
        if (l == a && rg(t.doc, o.head) == WN(pn(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: j.cursor(o.head - l.length)
          };
    }
    return { range: r = o };
  });
  return r || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !r;
}, qOe = [
  { key: "Backspace", run: HOe }
];
function XOe(t, e) {
  let n = VN(t, t.selection.main.head), i = n.brackets || Nd.brackets;
  for (let r of i) {
    let s = WN(pn(r, 0));
    if (e == r)
      return s == r ? KOe(t, r, i.indexOf(r + r + r) > -1, n) : YOe(t, r, s, n.before || Nd.before);
    if (e == s && ZN(t, t.selection.main.from))
      return GOe(t, r, s);
  }
  return null;
}
function ZN(t, e) {
  let n = !1;
  return t.field(UN).between(0, t.doc.length, (i) => {
    i == e && (n = !0);
  }), n;
}
function rg(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, $i(pn(n, 0)));
}
function jOe(t, e) {
  let n = t.sliceString(e - 2, e);
  return $i(pn(n, 0)) == n.length ? n : n.slice(1);
}
function YOe(t, e, n, i) {
  let r = null, s = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: n, from: o.to }],
        effects: ha.of(o.to + e.length),
        range: j.range(o.anchor + e.length, o.head + e.length)
      };
    let a = rg(t.doc, o.head);
    return !a || /\s/.test(a) || i.indexOf(a) > -1 ? {
      changes: { insert: e + n, from: o.head },
      effects: ha.of(o.head + e.length),
      range: j.cursor(o.head + e.length)
    } : { range: r = o };
  });
  return r ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function GOe(t, e, n) {
  let i = null, r = t.changeByRange((s) => s.empty && rg(t.doc, s.head) == n ? {
    changes: { from: s.head, to: s.head + n.length, insert: n },
    range: j.cursor(s.head + n.length)
  } : i = { range: s });
  return i ? null : t.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function KOe(t, e, n, i) {
  let r = i.stringPrefixes || Nd.stringPrefixes, s = null, o = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: ha.of(a.to + e.length),
        range: j.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = rg(t.doc, l), u;
    if (c == e) {
      if (wA(t, l))
        return {
          changes: { insert: e + e, from: l },
          effects: ha.of(l + e.length),
          range: j.cursor(l + e.length)
        };
      if (ZN(t, l)) {
        let h = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + h.length, insert: h },
          range: j.cursor(l + h.length)
        };
      }
    } else {
      if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = SA(t, l - 2 * e.length, r)) > -1 && wA(t, u))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: ha.of(l + e.length),
          range: j.cursor(l + e.length)
        };
      if (t.charCategorizer(l)(c) != Mt.Word && SA(t, l, r) > -1 && !JOe(t, l, e, r))
        return {
          changes: { insert: e + e, from: l },
          effects: ha.of(l + e.length),
          range: j.cursor(l + e.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function wA(t, e) {
  let n = Nt(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function JOe(t, e, n, i) {
  let r = Nt(t).resolveInner(e, -1), s = i.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = t.sliceDoc(r.from, Math.min(r.to, r.from + n.length + s)), l = a.indexOf(n);
    if (!l || l > -1 && i.indexOf(a.slice(0, l)) > -1) {
      let u = r.firstChild;
      for (; u && u.from == r.from && u.to - u.from > n.length + l; ) {
        if (t.sliceDoc(u.to - n.length, u.to) == n)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = r.to == e && r.parent;
    if (!c)
      break;
    r = c;
  }
  return !1;
}
function SA(t, e, n) {
  let i = t.charCategorizer(e);
  if (i(t.sliceDoc(e - 1, e)) != Mt.Word)
    return e;
  for (let r of n) {
    let s = e - r.length;
    if (t.sliceDoc(s, e) == r && i(t.sliceDoc(s - 1, s)) != Mt.Word)
      return s;
  }
  return -1;
}
function eye(t = {}) {
  return [
    POe,
    Gn,
    gn.of(t),
    TOe,
    tye,
    FN
  ];
}
const HN = [
  { key: "Ctrl-Space", run: SOe },
  { key: "Escape", run: kOe },
  { key: "ArrowDown", run: /* @__PURE__ */ Nf(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Nf(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Nf(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Nf(!1, "page") },
  { key: "Enter", run: wOe }
], tye = /* @__PURE__ */ Fo.highest(/* @__PURE__ */ G0.computeN([gn], (t) => t.facet(gn).defaultKeymap ? [HN] : [])), qN = [
  /* @__PURE__ */ Hn("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], nye = /* @__PURE__ */ qN.concat([
  /* @__PURE__ */ Hn("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Hn("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), kA = /* @__PURE__ */ new O4(), XN = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Fc(t) {
  return (e, n) => {
    let i = e.node.getChild("VariableDefinition");
    return i && n(i, t), !0;
  };
}
const iye = ["FunctionDeclaration"], rye = {
  FunctionDeclaration: /* @__PURE__ */ Fc("function"),
  ClassDeclaration: /* @__PURE__ */ Fc("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Fc("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Fc("type"),
  NamespaceDeclaration: /* @__PURE__ */ Fc("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(iye) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function jN(t, e) {
  let n = kA.get(e);
  if (n)
    return n;
  let i = [], r = !0;
  function s(o, a) {
    let l = t.sliceString(o.from, o.to);
    i.push({ label: l, type: a });
  }
  return e.cursor(vt.IncludeAnonymous).iterate((o) => {
    if (r)
      r = !1;
    else if (o.name) {
      let a = rye[o.name];
      if (a && a(o, s) || XN.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let a of jN(t, o.node))
        i.push(a);
      return !1;
    }
  }), kA.set(e, i), i;
}
const EA = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, YN = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function sye(t) {
  let e = Nt(t.state).resolveInner(t.pos, -1);
  if (YN.indexOf(e.name) > -1)
    return null;
  let n = e.name == "VariableName" || e.to - e.from < 20 && EA.test(t.state.sliceDoc(e.from, e.to));
  if (!n && !t.explicit)
    return null;
  let i = [];
  for (let r = e; r; r = r.parent)
    XN.has(r.name) && (i = i.concat(jN(t.state.doc, r)));
  return {
    options: i,
    from: n ? e.from : t.pos,
    validFor: EA
  };
}
const jr = /* @__PURE__ */ Ba.define({
  name: "javascript",
  parser: /* @__PURE__ */ rOe.configure({
    props: [
      /* @__PURE__ */ ph.add({
        IfStatement: /* @__PURE__ */ $l({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ $l({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: r1e,
        SwitchBody: (t) => {
          let e = t.textAfter, n = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (n ? 0 : i ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ i1e({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ $l({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ mh.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": L_,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), GN = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ $_({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, KN = /* @__PURE__ */ jr.configure({ dialect: "ts" }, "typescript"), JN = /* @__PURE__ */ jr.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ N_.add((t) => t.isTop ? [GN] : void 0)]
}), e6 = /* @__PURE__ */ jr.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ N_.add((t) => t.isTop ? [GN] : void 0)]
}, "typescript");
let t6 = (t) => ({ label: t, type: "keyword" });
const n6 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(t6), oye = /* @__PURE__ */ n6.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(t6));
function i6(t = {}) {
  let e = t.jsx ? t.typescript ? e6 : JN : t.typescript ? KN : jr, n = t.typescript ? nye.concat(oye) : qN.concat(n6);
  return new J0(e, [
    jr.data.of({
      autocomplete: oOe(YN, DN(n))
    }),
    jr.data.of({
      autocomplete: sye
    }),
    t.jsx ? cye : []
  ]);
}
function aye(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function CA(t, e, n = t.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return t.sliceString(i.from, Math.min(i.to, n));
  return "";
}
const lye = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), cye = /* @__PURE__ */ ae.inputHandler.of((t, e, n, i, r) => {
  if ((lye ? t.composing : t.compositionStarted) || t.state.readOnly || e != n || i != ">" && i != "/" || !jr.isActiveAt(t.state, e, -1))
    return !1;
  let s = r(), { state: o } = s, a = o.changeByRange((l) => {
    var c;
    let { head: u } = l, d = Nt(o).resolveInner(u - 1, -1), h;
    if (d.name == "JSXStartTag" && (d = d.parent), !(o.doc.sliceString(u - 1, u) != i || d.name == "JSXAttributeValue" && d.to > u)) {
      if (i == ">" && d.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (i == "/" && d.name == "JSXStartCloseTag") {
        let f = d.parent, p = f.parent;
        if (p && f.from == u - 2 && ((h = CA(o.doc, p.firstChild, u)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let m = `${h}>`;
          return { range: j.cursor(u + m.length, -1), changes: { from: u, insert: m } };
        }
      } else if (i == ">") {
        let f = aye(d);
        if (f && f.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(u, u + 2)) && (h = CA(o.doc, f, u)))
          return { range: l, changes: { from: u, insert: `</${h}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    s,
    o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), zc = ["_blank", "_self", "_top", "_parent"], rb = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], sb = ["get", "post", "put", "delete"], ob = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], hi = ["true", "false"], Oe = {}, uye = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: zc,
      hreflang: null
    }
  },
  abbr: Oe,
  address: Oe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: Oe,
  aside: Oe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: Oe,
  base: { attrs: { href: null, target: zc } },
  bdi: Oe,
  bdo: Oe,
  blockquote: { attrs: { cite: null } },
  body: Oe,
  br: Oe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: ob,
      formmethod: sb,
      formnovalidate: ["novalidate"],
      formtarget: zc,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: Oe,
  center: Oe,
  cite: Oe,
  code: Oe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: Oe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: Oe,
  div: Oe,
  dl: Oe,
  dt: Oe,
  em: Oe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: Oe,
  figure: Oe,
  footer: Oe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": rb,
      autocomplete: ["on", "off"],
      enctype: ob,
      method: sb,
      novalidate: ["novalidate"],
      target: zc
    }
  },
  h1: Oe,
  h2: Oe,
  h3: Oe,
  h4: Oe,
  h5: Oe,
  h6: Oe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: Oe,
  hgroup: Oe,
  hr: Oe,
  html: {
    attrs: { manifest: null }
  },
  i: Oe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: ob,
      formmethod: sb,
      formnovalidate: ["novalidate"],
      formtarget: zc,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: Oe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: Oe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: Oe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: rb,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: Oe,
  noscript: Oe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: Oe,
  param: { attrs: { name: null, value: null } },
  pre: Oe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: Oe,
  rt: Oe,
  ruby: Oe,
  samp: Oe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: rb
    }
  },
  section: Oe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: Oe,
  source: { attrs: { src: null, type: null, media: null } },
  span: Oe,
  strong: Oe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: Oe,
  summary: Oe,
  sup: Oe,
  table: Oe,
  tbody: Oe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: Oe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: Oe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: Oe,
  time: { attrs: { datetime: null } },
  title: Oe,
  tr: Oe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: Oe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: Oe
}, r6 = {
  accesskey: null,
  class: null,
  contenteditable: hi,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: hi,
  autocorrect: hi,
  autocapitalize: hi,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": hi,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": hi,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": hi,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": hi,
  "aria-hidden": hi,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": hi,
  "aria-multiselectable": hi,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": hi,
  "aria-relevant": null,
  "aria-required": hi,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, s6 = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of s6)
  r6[t] = null;
class qm {
  constructor(e, n) {
    this.tags = Object.assign(Object.assign({}, uye), e), this.globalAttrs = Object.assign(Object.assign({}, r6), n), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
qm.default = /* @__PURE__ */ new qm();
function lc(t, e, n = t.length) {
  if (!e)
    return "";
  let i = e.firstChild, r = i && i.getChild("TagName");
  return r ? t.sliceString(r.from, Math.min(r.to, n)) : "";
}
function cc(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function o6(t, e, n) {
  let i = n.tags[lc(t, cc(e))];
  return (i == null ? void 0 : i.children) || n.allTags;
}
function j_(t, e) {
  let n = [];
  for (let i = cc(e); i && !i.type.isTop; i = cc(i.parent)) {
    let r = lc(t, i);
    if (r && i.lastChild.name == "CloseTag")
      break;
    r && n.indexOf(r) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && n.push(r);
  }
  return n;
}
const a6 = /^[:\-\.\w\u00b7-\uffff]*$/;
function AA(t, e, n, i, r) {
  let s = /\s*>/.test(t.sliceDoc(r, r + 5)) ? "" : ">", o = cc(n, !0);
  return {
    from: i,
    to: r,
    options: o6(t.doc, o, e).map((a) => ({ label: a, type: "type" })).concat(j_(t.doc, n).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + s,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function TA(t, e, n, i) {
  let r = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: n,
    to: i,
    options: j_(t.doc, e).map((s, o) => ({ label: s, apply: s + r, type: "type", boost: 99 - o })),
    validFor: a6
  };
}
function dye(t, e, n, i) {
  let r = [], s = 0;
  for (let o of o6(t.doc, n, e))
    r.push({ label: "<" + o, type: "type" });
  for (let o of j_(t.doc, n))
    r.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
  return { from: i, to: i, options: r, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function hye(t, e, n, i, r) {
  let s = cc(n), o = s ? e.tags[lc(t.doc, s)] : null, a = o && o.attrs ? Object.keys(o.attrs) : [], l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: i,
    to: r,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: a6
  };
}
function fye(t, e, n, i, r) {
  var s;
  let o = (s = n.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), a = [], l;
  if (o) {
    let c = t.sliceDoc(o.from, o.to), u = e.globalAttrs[c];
    if (!u) {
      let d = cc(n), h = d ? e.tags[lc(t.doc, d)] : null;
      u = (h == null ? void 0 : h.attrs) && h.attrs[c];
    }
    if (u) {
      let d = t.sliceDoc(i, r).toLowerCase(), h = '"', f = '"';
      /^['"]/.test(d) ? (l = d[0] == '"' ? /^[^"]*$/ : /^[^']*$/, h = "", f = t.sliceDoc(r, r + 1) == d[0] ? "" : d[0], d = d.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let p of u)
        a.push({ label: p, apply: h + p + f, type: "constant" });
    }
  }
  return { from: i, to: r, options: a, validFor: l };
}
function pye(t, e) {
  let { state: n, pos: i } = e, r = Nt(n).resolveInner(i, -1), s = r.resolve(i);
  for (let o = i, a; s == r && (a = r.childBefore(o)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    s = r = a, o = l.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? TA(n, r, r.from, i) : AA(n, t, r, r.from, i) : r.name == "StartTag" ? AA(n, t, r, i, i) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? TA(n, r, i, i) : r.name == "OpenTag" || r.name == "SelfClosingTag" || r.name == "AttributeName" ? hye(n, t, r, r.name == "AttributeName" ? r.from : i, i) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? fye(n, t, r, r.name == "Is" ? i : r.from, i) : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? dye(n, t, r, i) : null;
}
function mye(t) {
  let { extraTags: e, extraGlobalAttributes: n } = t, i = n || e ? new qm(e, n) : qm.default;
  return (r) => pye(i, r);
}
const gye = /* @__PURE__ */ jr.parser.configure({ top: "SingleExpression" }), l6 = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: KN.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: JN.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: e6.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: gye
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: jr.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: Um.parser
  }
], c6 = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ Um.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ s6.map((t) => ({ name: t, parser: jr.parser }))), u6 = /* @__PURE__ */ Ba.define({
  name: "html",
  parser: /* @__PURE__ */ Mbe.configure({
    props: [
      /* @__PURE__ */ ph.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, n;
          for (let i = t.node; ; ) {
            let r = i.lastChild;
            if (!r || r.name != "Element" || r.to != i.to)
              break;
            e = i = r;
          }
          return e && !((n = e.lastChild) && (n.name == "CloseTag" || n.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ mh.add({
        Element(t) {
          let e = t.firstChild, n = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: n.name == "CloseTag" ? n.from : t.to };
        }
      }),
      /* @__PURE__ */ fN.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), dp = /* @__PURE__ */ u6.configure({
  wrap: /* @__PURE__ */ RN(l6, c6)
});
function bye(t = {}) {
  let e = "", n;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (n = RN((t.nestedLanguages || []).concat(l6), (t.nestedAttributes || []).concat(c6)));
  let i = n ? u6.configure({ wrap: n, dialect: e }) : e ? dp.configure({ dialect: e }) : dp;
  return new J0(i, [
    dp.data.of({ autocomplete: mye(t) }),
    t.autoCloseTags !== !1 ? Oye : [],
    i6().support,
    vN().support
  ]);
}
const MA = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), Oye = /* @__PURE__ */ ae.inputHandler.of((t, e, n, i, r) => {
  if (t.composing || t.state.readOnly || e != n || i != ">" && i != "/" || !dp.isActiveAt(t.state, e, -1))
    return !1;
  let s = r(), { state: o } = s, a = o.changeByRange((l) => {
    var c, u, d;
    let h = o.doc.sliceString(l.from - 1, l.to) == i, { head: f } = l, p = Nt(o).resolveInner(f, -1), m;
    if (h && i == ">" && p.name == "EndTag") {
      let g = p.parent;
      if (((u = (c = g.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (m = lc(o.doc, g.parent, f)) && !MA.has(m)) {
        let b = f + (o.doc.sliceString(f, f + 1) === ">" ? 1 : 0), _ = `</${m}>`;
        return { range: l, changes: { from: f, to: b, insert: _ } };
      }
    } else if (h && i == "/" && p.name == "IncompleteCloseTag") {
      let g = p.parent;
      if (p.from == f - 2 && ((d = g.lastChild) === null || d === void 0 ? void 0 : d.name) != "CloseTag" && (m = lc(o.doc, g, f)) && !MA.has(m)) {
        let b = f + (o.doc.sliceString(f, f + 1) === ">" ? 1 : 0), _ = `${m}>`;
        return {
          range: j.cursor(f + _.length, -1),
          changes: { from: f, to: b, insert: _ }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    s,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), yye = uh({
  String: D.string,
  Number: D.number,
  "True False": D.bool,
  PropertyName: D.propertyName,
  Null: D.null,
  ",": D.separator,
  "[ ]": D.squareBracket,
  "{ }": D.brace
}), _ye = $a.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [yye],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), vye = /* @__PURE__ */ Ba.define({
  name: "json",
  parser: /* @__PURE__ */ _ye.configure({
    props: [
      /* @__PURE__ */ ph.add({
        Object: /* @__PURE__ */ $l({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ $l({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ mh.add({
        "Object Array": L_
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function xye() {
  return new J0(vye);
}
var wye = ["true", "false", "on", "off", "yes", "no"], Sye = new RegExp("\\b((" + wye.join(")|(") + "))$", "i");
const kye = {
  name: "yaml",
  token: function(t, e) {
    var n = t.peek(), i = e.escaped;
    if (e.escaped = !1, n == "#" && (t.pos == 0 || /\s/.test(t.string.charAt(t.pos - 1))))
      return t.skipToEnd(), "comment";
    if (t.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
      return "string";
    if (e.literal && t.indentation() > e.keyCol)
      return t.skipToEnd(), "string";
    if (e.literal && (e.literal = !1), t.sol()) {
      if (e.keyCol = 0, e.pair = !1, e.pairStart = !1, t.match("---") || t.match("..."))
        return "def";
      if (t.match(/^\s*-\s+/))
        return "meta";
    }
    if (t.match(/^(\{|\}|\[|\])/))
      return n == "{" ? e.inlinePairs++ : n == "}" ? e.inlinePairs-- : n == "[" ? e.inlineList++ : e.inlineList--, "meta";
    if (e.inlineList > 0 && !i && n == ",")
      return t.next(), "meta";
    if (e.inlinePairs > 0 && !i && n == ",")
      return e.keyCol = 0, e.pair = !1, e.pairStart = !1, t.next(), "meta";
    if (e.pairStart) {
      if (t.match(/^\s*(\||\>)\s*/))
        return e.literal = !0, "meta";
      if (t.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i))
        return "variable";
      if (e.inlinePairs == 0 && t.match(/^\s*-?[0-9\.\,]+\s?$/) || e.inlinePairs > 0 && t.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/))
        return "number";
      if (t.match(Sye))
        return "keyword";
    }
    return !e.pair && t.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/) ? (e.pair = !0, e.keyCol = t.indentation(), "atom") : e.pair && t.match(/^:\s*/) ? (e.pairStart = !0, "meta") : (e.pairStart = !1, e.escaped = n == "\\", t.next(), null);
  },
  startState: function() {
    return {
      pair: !1,
      pairStart: !1,
      keyCol: 0,
      inlinePairs: 0,
      inlineList: 0,
      literal: !1,
      escaped: !1
    };
  },
  languageData: {
    commentTokens: { line: "#" }
  }
}, Eye = (t) => {
  let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), i = G_(t.state, n.from);
  return i.line ? Cye(t) : i.block ? Tye(t) : !1;
};
function Y_(t, e) {
  return ({ state: n, dispatch: i }) => {
    if (n.readOnly)
      return !1;
    let r = t(e, n);
    return r ? (i(n.update(r)), !0) : !1;
  };
}
const Cye = /* @__PURE__ */ Y_(
  Rye,
  0
  /* CommentOption.Toggle */
), Aye = /* @__PURE__ */ Y_(
  d6,
  0
  /* CommentOption.Toggle */
), Tye = /* @__PURE__ */ Y_(
  (t, e) => d6(t, e, Pye(e)),
  0
  /* CommentOption.Toggle */
);
function G_(t, e) {
  let n = t.languageDataAt("commentTokens", e);
  return n.length ? n[0] : {};
}
const Uc = 50;
function Mye(t, { open: e, close: n }, i, r) {
  let s = t.sliceDoc(i - Uc, i), o = t.sliceDoc(r, r + Uc), a = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(o)[0].length, c = s.length - a;
  if (s.slice(c - e.length, c) == e && o.slice(l, l + n.length) == n)
    return {
      open: { pos: i - a, margin: a && 1 },
      close: { pos: r + l, margin: l && 1 }
    };
  let u, d;
  r - i <= 2 * Uc ? u = d = t.sliceDoc(i, r) : (u = t.sliceDoc(i, i + Uc), d = t.sliceDoc(r - Uc, r));
  let h = /^\s*/.exec(u)[0].length, f = /\s*$/.exec(d)[0].length, p = d.length - f - n.length;
  return u.slice(h, h + e.length) == e && d.slice(p, p + n.length) == n ? {
    open: {
      pos: i + h + e.length,
      margin: /\s/.test(u.charAt(h + e.length)) ? 1 : 0
    },
    close: {
      pos: r - f - n.length,
      margin: /\s/.test(d.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function Pye(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from), r = n.to <= i.to ? i : t.doc.lineAt(n.to), s = e.length - 1;
    s >= 0 && e[s].to > i.from ? e[s].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to });
  }
  return e;
}
function d6(t, e, n = e.selection.ranges) {
  let i = n.map((s) => G_(e, s.from).block);
  if (!i.every((s) => s))
    return null;
  let r = n.map((s, o) => Mye(e, i[o], s.from, s.to));
  if (t != 2 && !r.every((s) => s))
    return { changes: e.changes(n.map((s, o) => r[o] ? [] : [{ from: s.from, insert: i[o].open + " " }, { from: s.to, insert: " " + i[o].close }])) };
  if (t != 1 && r.some((s) => s)) {
    let s = [];
    for (let o = 0, a; o < r.length; o++)
      if (a = r[o]) {
        let l = i[o], { open: c, close: u } = a;
        s.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function Rye(t, e, n = e.selection.ranges) {
  let i = [], r = -1;
  for (let { from: s, to: o } of n) {
    let a = i.length, l = 1e9, c = G_(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let d = e.doc.lineAt(u);
        if (d.from > r && (s == o || o > d.from)) {
          r = d.from;
          let h = /^\s*/.exec(d.text)[0].length, f = h == d.length, p = d.text.slice(h, h + c.length) == c ? h : -1;
          h < d.text.length && h < l && (l = h), i.push({ line: d, comment: p, token: c, indent: h, empty: f, single: !1 });
        }
        u = d.to + 1;
      }
      if (l < 1e9)
        for (let u = a; u < i.length; u++)
          i[u].indent < i[u].line.text.length && (i[u].indent = l);
      i.length == a + 1 && (i[a].single = !0);
    }
  }
  if (t != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: c, empty: u, single: d } of i)
      (d || !u) && s.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && i.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: a, token: l } of i)
      if (a >= 0) {
        let c = o.from + a, u = c + l.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const Ry = /* @__PURE__ */ $s.define(), $ye = /* @__PURE__ */ $s.define(), Nye = /* @__PURE__ */ de.define(), h6 = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (i, r) => e(i, r) || n(i, r)
    });
  }
}), f6 = /* @__PURE__ */ ln.define({
  create() {
    return Qr.empty;
  },
  update(t, e) {
    let n = e.state.facet(h6), i = e.annotation(Ry);
    if (i) {
      let l = ii.fromTransaction(e, i.selection), c = i.side, u = c == 0 ? t.undone : t.done;
      return l ? u = Xm(u, u.length, n.minDepth, l) : u = g6(u, e.startState.selection), new Qr(c == 0 ? i.rest : u, c == 0 ? u : i.rest);
    }
    let r = e.annotation($ye);
    if ((r == "full" || r == "before") && (t = t.isolate()), e.annotation(Vt.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = ii.fromTransaction(e), o = e.annotation(Vt.time), a = e.annotation(Vt.userEvent);
    return s ? t = t.addChanges(s, o, a, n, e) : e.selection && (t = t.addSelection(e.startState.selection, o, a, n.newGroupDelay)), (r == "full" || r == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Qr(t.done.map(ii.fromJSON), t.undone.map(ii.fromJSON));
  }
});
function Dye(t = {}) {
  return [
    f6,
    h6.of(t),
    ae.domEventHandlers({
      beforeinput(e, n) {
        let i = e.inputType == "historyUndo" ? p6 : e.inputType == "historyRedo" ? $y : null;
        return i ? (e.preventDefault(), i(n)) : !1;
      }
    })
  ];
}
function sg(t, e) {
  return function({ state: n, dispatch: i }) {
    if (!e && n.readOnly)
      return !1;
    let r = n.field(f6, !1);
    if (!r)
      return !1;
    let s = r.pop(t, n, e);
    return s ? (i(s), !0) : !1;
  };
}
const p6 = /* @__PURE__ */ sg(0, !1), $y = /* @__PURE__ */ sg(1, !1), Iye = /* @__PURE__ */ sg(0, !0), Lye = /* @__PURE__ */ sg(1, !0);
class ii {
  constructor(e, n, i, r, s) {
    this.changes = e, this.effects = n, this.mapped = i, this.startSelection = r, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new ii(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(e) {
    return new ii(e.changes && Xt.fromJSON(e.changes), [], e.mapped && Xr.fromJSON(e.mapped), e.startSelection && j.fromJSON(e.startSelection), e.selectionsAfter.map(j.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, n) {
    let i = Bi;
    for (let r of e.startState.facet(Nye)) {
      let s = r(e);
      s.length && (i = i.concat(s));
    }
    return !i.length && e.changes.empty ? null : new ii(e.changes.invert(e.startState.doc), i, void 0, n || e.startState.selection, Bi);
  }
  static selection(e) {
    return new ii(void 0, Bi, void 0, void 0, e);
  }
}
function Xm(t, e, n, i) {
  let r = e + 1 > n + 20 ? e - n - 1 : 0, s = t.slice(r, e);
  return s.push(i), s;
}
function Bye(t, e) {
  let n = [], i = !1;
  return t.iterChangedRanges((r, s) => n.push(r, s)), e.iterChangedRanges((r, s, o, a) => {
    for (let l = 0; l < n.length; ) {
      let c = n[l++], u = n[l++];
      a >= c && o <= u && (i = !0);
    }
  }), i;
}
function Qye(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, i) => n.empty != e.ranges[i].empty).length === 0;
}
function m6(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Bi = [], Fye = 200;
function g6(t, e) {
  if (t.length) {
    let n = t[t.length - 1], i = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - Fye));
    return i.length && i[i.length - 1].eq(e) ? t : (i.push(e), Xm(t, t.length - 1, 1e9, n.setSelAfter(i)));
  } else
    return [ii.selection([e])];
}
function zye(t) {
  let e = t[t.length - 1], n = t.slice();
  return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function ab(t, e) {
  if (!t.length)
    return t;
  let n = t.length, i = Bi;
  for (; n; ) {
    let r = Uye(t[n - 1], e, i);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let s = t.slice(0, n);
      return s[n - 1] = r, s;
    } else
      e = r.mapped, n--, i = r.selectionsAfter;
  }
  return i.length ? [ii.selection(i)] : Bi;
}
function Uye(t, e, n) {
  let i = m6(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : Bi, n);
  if (!t.changes)
    return ii.selection(i);
  let r = t.changes.map(e), s = e.mapDesc(t.changes, !0), o = t.mapped ? t.mapped.composeDesc(s) : s;
  return new ii(r, Me.mapEffects(t.effects, e), o, t.startSelection.map(s), i);
}
const Wye = /^(input\.type|delete)($|\.)/;
class Qr {
  constructor(e, n, i = 0, r = void 0) {
    this.done = e, this.undone = n, this.prevTime = i, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new Qr(this.done, this.undone) : this;
  }
  addChanges(e, n, i, r, s) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!i || Wye.test(i)) && (!a.selectionsAfter.length && n - this.prevTime < r.newGroupDelay && r.joinToEvent(s, Bye(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? o = Xm(o, o.length - 1, r.minDepth, new ii(e.changes.compose(a.changes), m6(e.effects, a.effects), a.mapped, a.startSelection, Bi)) : o = Xm(o, o.length, r.minDepth, e), new Qr(o, Bi, n, i);
  }
  addSelection(e, n, i, r) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Bi;
    return s.length > 0 && n - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && Qye(s[s.length - 1], e) ? this : new Qr(g6(this.done, e), this.undone, n, i);
  }
  addMapping(e) {
    return new Qr(ab(this.done, e), ab(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, i) {
    let r = e == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let s = r[r.length - 1], o = s.selectionsAfter[0] || n.selection;
    if (i && s.selectionsAfter.length)
      return n.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: Ry.of({ side: e, rest: zye(r), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let a = r.length == 1 ? Bi : r.slice(0, r.length - 1);
      return s.mapped && (a = ab(a, s.mapped)), n.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: Ry.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Qr.empty = /* @__PURE__ */ new Qr(Bi, Bi);
const Vye = [
  { key: "Mod-z", run: p6, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: $y, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: $y, preventDefault: !0 },
  { key: "Mod-u", run: Iye, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: Lye, preventDefault: !0 }
];
function Ac(t, e) {
  return j.create(t.ranges.map(e), t.mainIndex);
}
function rs(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Or({ state: t, dispatch: e }, n) {
  let i = Ac(t.selection, n);
  return i.eq(t.selection, !0) ? !1 : (e(rs(t, i)), !0);
}
function og(t, e) {
  return j.cursor(e ? t.to : t.from);
}
function b6(t, e) {
  return Or(t, (n) => n.empty ? t.moveByChar(n, e) : og(n, e));
}
function Rn(t) {
  return t.textDirectionAt(t.state.selection.main.head) == At.LTR;
}
const O6 = (t) => b6(t, !Rn(t)), y6 = (t) => b6(t, Rn(t));
function _6(t, e) {
  return Or(t, (n) => n.empty ? t.moveByGroup(n, e) : og(n, e));
}
const Zye = (t) => _6(t, !Rn(t)), Hye = (t) => _6(t, Rn(t));
function qye(t, e, n) {
  if (e.type.prop(n))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function ag(t, e, n) {
  let i = Nt(t).resolveInner(e.head), r = n ? De.closedBy : De.openedBy;
  for (let l = e.head; ; ) {
    let c = n ? i.childAfter(l) : i.childBefore(l);
    if (!c)
      break;
    qye(t, c, r) ? i = c : l = n ? c.to : c.from;
  }
  let s = i.type.prop(r), o, a;
  return s && (o = n ? Br(t, i.from, 1) : Br(t, i.to, -1)) && o.matched ? a = n ? o.end.to : o.end.from : a = n ? i.to : i.from, j.cursor(a, n ? -1 : 1);
}
const Xye = (t) => Or(t, (e) => ag(t.state, e, !Rn(t))), jye = (t) => Or(t, (e) => ag(t.state, e, Rn(t)));
function v6(t, e) {
  return Or(t, (n) => {
    if (!n.empty)
      return og(n, e);
    let i = t.moveVertically(n, e);
    return i.head != n.head ? i : t.moveToLineBoundary(n, e);
  });
}
const x6 = (t) => v6(t, !1), w6 = (t) => v6(t, !0);
function S6(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, i = 0, r;
  if (e) {
    for (let s of t.state.facet(ae.scrollMargins)) {
      let o = s(t);
      o != null && o.top && (n = Math.max(o == null ? void 0 : o.top, n)), o != null && o.bottom && (i = Math.max(o == null ? void 0 : o.bottom, i));
    }
    r = t.scrollDOM.clientHeight - n - i;
  } else
    r = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, r - 5)
  };
}
function k6(t, e) {
  let n = S6(t), { state: i } = t, r = Ac(i.selection, (o) => o.empty ? t.moveVertically(o, e, n.height) : og(o, e));
  if (r.eq(i.selection))
    return !1;
  let s;
  if (n.selfScroll) {
    let o = t.coordsAtPos(i.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + n.marginTop, c = a.bottom - n.marginBottom;
    o && o.top > l && o.bottom < c && (s = ae.scrollIntoView(r.main.head, { y: "start", yMargin: o.top - l }));
  }
  return t.dispatch(rs(i, r), { effects: s }), !0;
}
const PA = (t) => k6(t, !1), Ny = (t) => k6(t, !0);
function zo(t, e, n) {
  let i = t.lineBlockAt(e.head), r = t.moveToLineBoundary(e, n);
  if (r.head == e.head && r.head != (n ? i.to : i.from) && (r = t.moveToLineBoundary(e, n, !1)), !n && r.head == i.from && i.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    s && e.head != i.from + s && (r = j.cursor(i.from + s));
  }
  return r;
}
const Yye = (t) => Or(t, (e) => zo(t, e, !0)), Gye = (t) => Or(t, (e) => zo(t, e, !1)), Kye = (t) => Or(t, (e) => zo(t, e, !Rn(t))), Jye = (t) => Or(t, (e) => zo(t, e, Rn(t))), e2e = (t) => Or(t, (e) => j.cursor(t.lineBlockAt(e.head).from, 1)), t2e = (t) => Or(t, (e) => j.cursor(t.lineBlockAt(e.head).to, -1));
function n2e(t, e, n) {
  let i = !1, r = Ac(t.selection, (s) => {
    let o = Br(t, s.head, -1) || Br(t, s.head, 1) || s.head > 0 && Br(t, s.head - 1, 1) || s.head < t.doc.length && Br(t, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    i = !0;
    let a = o.start.from == s.head ? o.end.to : o.end.from;
    return j.cursor(a);
  });
  return i ? (e(rs(t, r)), !0) : !1;
}
const i2e = ({ state: t, dispatch: e }) => n2e(t, e);
function Ki(t, e) {
  let n = Ac(t.state.selection, (i) => {
    let r = e(i);
    return j.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(rs(t.state, n)), !0);
}
function E6(t, e) {
  return Ki(t, (n) => t.moveByChar(n, e));
}
const C6 = (t) => E6(t, !Rn(t)), A6 = (t) => E6(t, Rn(t));
function T6(t, e) {
  return Ki(t, (n) => t.moveByGroup(n, e));
}
const r2e = (t) => T6(t, !Rn(t)), s2e = (t) => T6(t, Rn(t)), o2e = (t) => Ki(t, (e) => ag(t.state, e, !Rn(t))), a2e = (t) => Ki(t, (e) => ag(t.state, e, Rn(t)));
function M6(t, e) {
  return Ki(t, (n) => t.moveVertically(n, e));
}
const P6 = (t) => M6(t, !1), R6 = (t) => M6(t, !0);
function $6(t, e) {
  return Ki(t, (n) => t.moveVertically(n, e, S6(t).height));
}
const RA = (t) => $6(t, !1), $A = (t) => $6(t, !0), l2e = (t) => Ki(t, (e) => zo(t, e, !0)), c2e = (t) => Ki(t, (e) => zo(t, e, !1)), u2e = (t) => Ki(t, (e) => zo(t, e, !Rn(t))), d2e = (t) => Ki(t, (e) => zo(t, e, Rn(t))), h2e = (t) => Ki(t, (e) => j.cursor(t.lineBlockAt(e.head).from)), f2e = (t) => Ki(t, (e) => j.cursor(t.lineBlockAt(e.head).to)), NA = ({ state: t, dispatch: e }) => (e(rs(t, { anchor: 0 })), !0), DA = ({ state: t, dispatch: e }) => (e(rs(t, { anchor: t.doc.length })), !0), IA = ({ state: t, dispatch: e }) => (e(rs(t, { anchor: t.selection.main.anchor, head: 0 })), !0), LA = ({ state: t, dispatch: e }) => (e(rs(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), p2e = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), m2e = ({ state: t, dispatch: e }) => {
  let n = lg(t).map(({ from: i, to: r }) => j.range(i, Math.min(r + 1, t.doc.length)));
  return e(t.update({ selection: j.create(n), userEvent: "select" })), !0;
}, g2e = ({ state: t, dispatch: e }) => {
  let n = Ac(t.selection, (i) => {
    var r;
    let s = Nt(t).resolveStack(i.from, 1);
    for (let o = s; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < i.from && a.to >= i.to || a.to > i.to && a.from <= i.from) && (!((r = a.parent) === null || r === void 0) && r.parent))
        return j.range(a.to, a.from);
    }
    return i;
  });
  return e(rs(t, n)), !0;
}, b2e = ({ state: t, dispatch: e }) => {
  let n = t.selection, i = null;
  return n.ranges.length > 1 ? i = j.create([n.main]) : n.main.empty || (i = j.create([j.cursor(n.main.head)])), i ? (e(rs(t, i)), !0) : !1;
};
function Oh(t, e) {
  if (t.state.readOnly)
    return !1;
  let n = "delete.selection", { state: i } = t, r = i.changeByRange((s) => {
    let { from: o, to: a } = s;
    if (o == a) {
      let l = e(s);
      l < o ? (n = "delete.backward", l = Df(t, l, !1)) : l > o && (n = "delete.forward", l = Df(t, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = Df(t, o, !1), a = Df(t, a, !0);
    return o == a ? { range: s } : { changes: { from: o, to: a }, range: j.cursor(o, o < s.head ? -1 : 1) };
  });
  return r.changes.empty ? !1 : (t.dispatch(i.update(r, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? ae.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Df(t, e, n) {
  if (t instanceof ae)
    for (let i of t.state.facet(ae.atomicRanges).map((r) => r(t)))
      i.between(e, e, (r, s) => {
        r < e && s > e && (e = n ? s : r);
      });
  return e;
}
const N6 = (t, e, n) => Oh(t, (i) => {
  let r = i.from, { state: s } = t, o = s.doc.lineAt(r), a, l;
  if (n && !e && r > o.from && r < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, r - o.from))) {
    if (a[a.length - 1] == "	")
      return r - 1;
    let c = Ec(a, s.tabSize), u = c % Qa(s) || Qa(s);
    for (let d = 0; d < u && a[a.length - 1 - d] == " "; d++)
      r--;
    l = r;
  } else
    l = bn(o.text, r - o.from, e, e) + o.from, l == r && o.number != (e ? s.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, r - o.from)) && (l = bn(o.text, l - o.from, !1, !1) + o.from);
  return l;
}), Dy = (t) => N6(t, !1, !0), D6 = (t) => N6(t, !0, !1), I6 = (t, e) => Oh(t, (n) => {
  let i = n.head, { state: r } = t, s = r.doc.lineAt(i), o = r.charCategorizer(i);
  for (let a = null; ; ) {
    if (i == (e ? s.to : s.from)) {
      i == n.head && s.number != (e ? r.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let l = bn(s.text, i - s.from, e) + s.from, c = s.text.slice(Math.min(i, l) - s.from, Math.max(i, l) - s.from), u = o(c);
    if (a != null && u != a)
      break;
    (c != " " || i != n.head) && (a = u), i = l;
  }
  return i;
}), L6 = (t) => I6(t, !1), O2e = (t) => I6(t, !0), y2e = (t) => Oh(t, (e) => {
  let n = t.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), _2e = (t) => Oh(t, (e) => {
  let n = t.moveToLineBoundary(e, !1).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
}), v2e = (t) => Oh(t, (e) => {
  let n = t.moveToLineBoundary(e, !0).head;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), x2e = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: Ge.of(["", ""]) },
    range: j.cursor(i.from)
  }));
  return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, w2e = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == t.doc.length)
      return { range: i };
    let r = i.from, s = t.doc.lineAt(r), o = r == s.from ? r - 1 : bn(s.text, r - s.from, !1) + s.from, a = r == s.to ? r + 1 : bn(s.text, r - s.from, !0) + s.from;
    return {
      changes: { from: o, to: a, insert: t.doc.slice(r, a).append(t.doc.slice(o, r)) },
      range: j.cursor(a)
    };
  });
  return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function lg(t) {
  let e = [], n = -1;
  for (let i of t.selection.ranges) {
    let r = t.doc.lineAt(i.from), s = t.doc.lineAt(i.to);
    if (!i.empty && i.to == s.from && (s = t.doc.lineAt(i.to - 1)), n >= r.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(i);
    } else
      e.push({ from: r.from, to: s.to, ranges: [i] });
    n = s.number + 1;
  }
  return e;
}
function B6(t, e, n) {
  if (t.readOnly)
    return !1;
  let i = [], r = [];
  for (let s of lg(t)) {
    if (n ? s.to == t.doc.length : s.from == 0)
      continue;
    let o = t.doc.lineAt(n ? s.to + 1 : s.from - 1), a = o.length + 1;
    if (n) {
      i.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + t.lineBreak });
      for (let l of s.ranges)
        r.push(j.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
    } else {
      i.push({ from: o.from, to: s.from }, { from: s.to, insert: t.lineBreak + o.text });
      for (let l of s.ranges)
        r.push(j.range(l.anchor - a, l.head - a));
    }
  }
  return i.length ? (e(t.update({
    changes: i,
    scrollIntoView: !0,
    selection: j.create(r, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const S2e = ({ state: t, dispatch: e }) => B6(t, e, !1), k2e = ({ state: t, dispatch: e }) => B6(t, e, !0);
function Q6(t, e, n) {
  if (t.readOnly)
    return !1;
  let i = [];
  for (let r of lg(t))
    n ? i.push({ from: r.from, insert: t.doc.slice(r.from, r.to) + t.lineBreak }) : i.push({ from: r.to, insert: t.lineBreak + t.doc.slice(r.from, r.to) });
  return e(t.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const E2e = ({ state: t, dispatch: e }) => Q6(t, e, !1), C2e = ({ state: t, dispatch: e }) => Q6(t, e, !0), A2e = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, n = e.changes(lg(e).map(({ from: r, to: s }) => (r > 0 ? r-- : s < e.doc.length && s++, { from: r, to: s }))), i = Ac(e.selection, (r) => {
    let s;
    if (t.lineWrapping) {
      let o = t.lineBlockAt(r.head), a = t.coordsAtPos(r.head, r.assoc || 1);
      a && (s = o.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(r, !0, s);
  }).map(n);
  return t.dispatch({ changes: n, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function T2e(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = Nt(t).resolveInner(e), i = n.childBefore(e), r = n.childAfter(e), s;
  return i && r && i.to <= e && r.from >= e && (s = i.type.prop(De.closedBy)) && s.indexOf(r.name) > -1 && t.doc.lineAt(i.to).from == t.doc.lineAt(r.from).from && !/\S/.test(t.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null;
}
const M2e = /* @__PURE__ */ F6(!1), P2e = /* @__PURE__ */ F6(!0);
function F6(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((r) => {
      let { from: s, to: o } = r, a = e.doc.lineAt(s), l = !t && s == o && T2e(e, s);
      t && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new tg(e, { simulateBreak: s, simulateDoubleBreak: !!l }), u = D_(c, s);
      for (u == null && (u = Ec(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: s, to: o } = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let d = ["", Md(e, u)];
      return l && d.push(Md(e, c.lineIndent(a.from, -1))), {
        changes: { from: s, to: o, insert: Ge.of(d) },
        range: j.cursor(s + 1 + d[1].length)
      };
    });
    return n(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function K_(t, e) {
  let n = -1;
  return t.changeByRange((i) => {
    let r = [];
    for (let o = i.from; o <= i.to; ) {
      let a = t.doc.lineAt(o);
      a.number > n && (i.empty || i.to > a.from) && (e(a, r, i), n = a.number), o = a.to + 1;
    }
    let s = t.changes(r);
    return {
      changes: r,
      range: j.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1))
    };
  });
}
const R2e = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), i = new tg(t, { overrideIndentation: (s) => {
    let o = n[s];
    return o ?? -1;
  } }), r = K_(t, (s, o, a) => {
    let l = D_(i, s.from);
    if (l == null)
      return;
    /\S/.test(s.text) || (l = 0);
    let c = /^\s*/.exec(s.text)[0], u = Md(t, l);
    (c != u || a.from < s.from + c.length) && (n[s.from] = l, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return r.changes.empty || e(t.update(r, { userEvent: "indent" })), !0;
}, $2e = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(K_(t, (n, i) => {
  i.push({ from: n.from, insert: t.facet(eg) });
}), { userEvent: "input.indent" })), !0), N2e = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(K_(t, (n, i) => {
  let r = /^\s*/.exec(n.text)[0];
  if (!r)
    return;
  let s = Ec(r, t.tabSize), o = 0, a = Md(t, Math.max(0, s - Qa(t)));
  for (; o < r.length && o < a.length && r.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  i.push({ from: n.from + o, to: n.from + r.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), D2e = (t) => (t.setTabFocusMode(), !0), I2e = [
  { key: "Ctrl-b", run: O6, shift: C6, preventDefault: !0 },
  { key: "Ctrl-f", run: y6, shift: A6 },
  { key: "Ctrl-p", run: x6, shift: P6 },
  { key: "Ctrl-n", run: w6, shift: R6 },
  { key: "Ctrl-a", run: e2e, shift: h2e },
  { key: "Ctrl-e", run: t2e, shift: f2e },
  { key: "Ctrl-d", run: D6 },
  { key: "Ctrl-h", run: Dy },
  { key: "Ctrl-k", run: y2e },
  { key: "Ctrl-Alt-h", run: L6 },
  { key: "Ctrl-o", run: x2e },
  { key: "Ctrl-t", run: w2e },
  { key: "Ctrl-v", run: Ny }
], L2e = /* @__PURE__ */ [
  { key: "ArrowLeft", run: O6, shift: C6, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: Zye, shift: r2e, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: Kye, shift: u2e, preventDefault: !0 },
  { key: "ArrowRight", run: y6, shift: A6, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: Hye, shift: s2e, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: Jye, shift: d2e, preventDefault: !0 },
  { key: "ArrowUp", run: x6, shift: P6, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: NA, shift: IA },
  { mac: "Ctrl-ArrowUp", run: PA, shift: RA },
  { key: "ArrowDown", run: w6, shift: R6, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: DA, shift: LA },
  { mac: "Ctrl-ArrowDown", run: Ny, shift: $A },
  { key: "PageUp", run: PA, shift: RA },
  { key: "PageDown", run: Ny, shift: $A },
  { key: "Home", run: Gye, shift: c2e, preventDefault: !0 },
  { key: "Mod-Home", run: NA, shift: IA },
  { key: "End", run: Yye, shift: l2e, preventDefault: !0 },
  { key: "Mod-End", run: DA, shift: LA },
  { key: "Enter", run: M2e },
  { key: "Mod-a", run: p2e },
  { key: "Backspace", run: Dy, shift: Dy },
  { key: "Delete", run: D6 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: L6 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: O2e },
  { mac: "Mod-Backspace", run: _2e },
  { mac: "Mod-Delete", run: v2e }
].concat(/* @__PURE__ */ I2e.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), B2e = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: Xye, shift: o2e },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: jye, shift: a2e },
  { key: "Alt-ArrowUp", run: S2e },
  { key: "Shift-Alt-ArrowUp", run: E2e },
  { key: "Alt-ArrowDown", run: k2e },
  { key: "Shift-Alt-ArrowDown", run: C2e },
  { key: "Escape", run: b2e },
  { key: "Mod-Enter", run: P2e },
  { key: "Alt-l", mac: "Ctrl-l", run: m2e },
  { key: "Mod-i", run: g2e, preventDefault: !0 },
  { key: "Mod-[", run: N2e },
  { key: "Mod-]", run: $2e },
  { key: "Mod-Alt-\\", run: R2e },
  { key: "Shift-Mod-k", run: A2e },
  { key: "Shift-Mod-\\", run: i2e },
  { key: "Mod-/", run: Eye },
  { key: "Alt-A", run: Aye },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: D2e }
].concat(L2e), BA = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class uc {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, n, i = 0, r = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, r), this.bufferStart = i, this.normalize = s ? (a) => s(BA(a)) : BA, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return pn(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let n = __(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += $i(e);
      let r = this.normalize(n);
      for (let s = 0, o = i; ; s++) {
        let a = r.charCodeAt(s), l = this.match(a, o, this.bufferPos + this.bufferStart);
        if (s == r.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        o == i && s < n.length && n.charCodeAt(s) == a && o++;
      }
    }
  }
  match(e, n, i) {
    let r = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? r = { from: this.matches[s + 1], to: i } : (this.matches[s]++, a = !0)), a || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: n, to: i } : this.matches.push(1, n)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r;
  }
}
typeof Symbol < "u" && (uc.prototype[Symbol.iterator] = function() {
  return this;
});
const z6 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, J_ = "gm" + (/x/.unicode == null ? "" : "u");
class U6 {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, n, i, r = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = z6, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new W6(e, n, i, r, s);
    this.re = new RegExp(n, J_ + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let o = e.lineAt(r);
    this.curLineStart = o.from, this.matchPos = jm(e, r), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let i = this.curLineStart + n.index, r = i + n[0].length;
        if (this.matchPos = jm(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, n)))
          return this.value = { from: i, to: r, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const lb = /* @__PURE__ */ new WeakMap();
class Dl {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, i) {
    let r = lb.get(e);
    if (!r || r.from >= i || r.to <= n) {
      let a = new Dl(n, e.sliceString(n, i));
      return lb.set(e, a), a;
    }
    if (r.from == n && r.to == i)
      return r;
    let { text: s, from: o } = r;
    return o > n && (s = e.sliceString(n, o) + s, o = n), r.to < i && (s += e.sliceString(r.to, i)), lb.set(e, new Dl(o, s)), new Dl(n, s.slice(n - o, i - o));
  }
}
class W6 {
  constructor(e, n, i, r, s) {
    this.text = e, this.to = s, this.done = !1, this.value = z6, this.matchPos = jm(e, r), this.re = new RegExp(n, J_ + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Dl.get(e, r, this.chunkEnd(
      r + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let i = this.flat.from + n.index, r = i + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, r, n)))
          return this.value = { from: i, to: r, match: n }, this.matchPos = jm(this.text, r + (i == r ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Dl.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (U6.prototype[Symbol.iterator] = W6.prototype[Symbol.iterator] = function() {
  return this;
});
function Q2e(t) {
  try {
    return new RegExp(t, J_), !0;
  } catch {
    return !1;
  }
}
function jm(t, e) {
  if (e >= t.length)
    return e;
  let n = t.lineAt(e), i;
  for (; e < n.to && (i = n.text.charCodeAt(e - n.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function Iy(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = Fe("input", { class: "cm-textfield", name: "line", value: e }), i = Fe("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: Ym.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), r());
    },
    onsubmit: (s) => {
      s.preventDefault(), r();
    }
  }, Fe("label", t.state.phrase("Go to line"), ": ", n), " ", Fe("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function r() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!s)
      return;
    let { state: o } = t, a = o.doc.lineAt(o.selection.main.head), [, l, c, u, d] = s, h = u ? +u.slice(1) : 0, f = c ? +c : a.number;
    if (c && d) {
      let g = f / 100;
      l && (g = g * (l == "-" ? -1 : 1) + a.number / o.doc.lines), f = Math.round(o.doc.lines * g);
    } else c && l && (f = f * (l == "-" ? -1 : 1) + a.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, f))), m = j.cursor(p.from + Math.max(0, Math.min(h, p.length)));
    t.dispatch({
      effects: [Ym.of(!1), ae.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), t.focus();
  }
  return { dom: i };
}
const Ym = /* @__PURE__ */ Me.define(), QA = /* @__PURE__ */ ln.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(Ym) && (t = n.value);
    return t;
  },
  provide: (t) => Td.from(t, (e) => e ? Iy : null)
}), F2e = (t) => {
  let e = Ad(t, Iy);
  if (!e) {
    let n = [Ym.of(!0)];
    t.state.field(QA, !1) == null && n.push(Me.appendConfig.of([QA, z2e])), t.dispatch({ effects: n }), e = Ad(t, Iy);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, z2e = /* @__PURE__ */ ae.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), U2e = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, W2e = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, U2e, {
      highlightWordAroundCursor: (e, n) => e || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function V2e(t) {
  return [j2e, X2e];
}
const Z2e = /* @__PURE__ */ ve.mark({ class: "cm-selectionMatch" }), H2e = /* @__PURE__ */ ve.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function FA(t, e, n, i) {
  return (n == 0 || t(e.sliceDoc(n - 1, n)) != Mt.Word) && (i == e.doc.length || t(e.sliceDoc(i, i + 1)) != Mt.Word);
}
function q2e(t, e, n, i) {
  return t(e.sliceDoc(n, n + 1)) == Mt.Word && t(e.sliceDoc(i - 1, i)) == Mt.Word;
}
const X2e = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(W2e), { state: n } = t, i = n.selection;
    if (i.ranges.length > 1)
      return ve.none;
    let r = i.main, s, o = null;
    if (r.empty) {
      if (!e.highlightWordAroundCursor)
        return ve.none;
      let l = n.wordAt(r.head);
      if (!l)
        return ve.none;
      o = n.charCategorizer(r.head), s = n.sliceDoc(l.from, l.to);
    } else {
      let l = r.to - r.from;
      if (l < e.minSelectionLength || l > 200)
        return ve.none;
      if (e.wholeWords) {
        if (s = n.sliceDoc(r.from, r.to), o = n.charCategorizer(r.head), !(FA(o, n, r.from, r.to) && q2e(o, n, r.from, r.to)))
          return ve.none;
      } else if (s = n.sliceDoc(r.from, r.to), !s)
        return ve.none;
    }
    let a = [];
    for (let l of t.visibleRanges) {
      let c = new uc(n.doc, s, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: u, to: d } = c.value;
        if ((!o || FA(o, n, u, d)) && (r.empty && u <= r.from && d >= r.to ? a.push(H2e.range(u, d)) : (u >= r.to || d <= r.from) && a.push(Z2e.range(u, d)), a.length > e.maxMatches))
          return ve.none;
      }
    }
    return ve.set(a);
  }
}, {
  decorations: (t) => t.decorations
}), j2e = /* @__PURE__ */ ae.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Y2e = ({ state: t, dispatch: e }) => {
  let { selection: n } = t, i = j.create(n.ranges.map((r) => t.wordAt(r.head) || j.cursor(r.head)), n.mainIndex);
  return i.eq(n) ? !1 : (e(t.update({ selection: i })), !0);
};
function G2e(t, e) {
  let { main: n, ranges: i } = t.selection, r = t.wordAt(n.head), s = r && r.from == n.from && r.to == n.to;
  for (let o = !1, a = new uc(t.doc, e, i[i.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new uc(t.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((l) => l.from == a.value.from))
        continue;
      if (s) {
        let l = t.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const K2e = ({ state: t, dispatch: e }) => {
  let { ranges: n } = t.selection;
  if (n.some((s) => s.from === s.to))
    return Y2e({ state: t, dispatch: e });
  let i = t.sliceDoc(n[0].from, n[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != i))
    return !1;
  let r = G2e(t, i);
  return r ? (e(t.update({
    selection: t.selection.addRange(j.range(r.from, r.to), !1),
    effects: ae.scrollIntoView(r.to)
  })), !0) : !1;
}, Tc = /* @__PURE__ */ de.define({
  combine(t) {
    return is(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new u_e(e),
      scrollToMatch: (e) => ae.scrollIntoView(e)
    });
  }
});
class V6 {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Q2e(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new n_e(this) : new e_e(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, n = 0, i) {
    let r = e.doc ? e : je.create({ doc: e });
    return i == null && (i = r.doc.length), this.regexp ? bl(this, r, n, i) : gl(this, r, n, i);
  }
}
class Z6 {
  constructor(e) {
    this.spec = e;
  }
}
function gl(t, e, n, i) {
  return new uc(e.doc, t.unquoted, n, i, t.caseSensitive ? void 0 : (r) => r.toLowerCase(), t.wholeWord ? J2e(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function J2e(t, e) {
  return (n, i, r, s) => ((s > n || s + r.length < i) && (s = Math.max(0, n - 2), r = t.sliceString(s, Math.min(t.length, i + 2))), (e(Gm(r, n - s)) != Mt.Word || e(Km(r, n - s)) != Mt.Word) && (e(Km(r, i - s)) != Mt.Word || e(Gm(r, i - s)) != Mt.Word));
}
class e_e extends Z6 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, i) {
    let r = gl(this.spec, e, i, e.doc.length).nextOverlapping();
    return r.done && (r = gl(this.spec, e, 0, n).nextOverlapping()), r.done ? null : r.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, n, i) {
    for (let r = i; ; ) {
      let s = Math.max(n, r - 1e4 - this.spec.unquoted.length), o = gl(this.spec, e, s, r), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (s == n)
        return null;
      r -= 1e4;
    }
  }
  prevMatch(e, n, i) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let i = gl(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= n)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, n, i, r) {
    let s = gl(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
function bl(t, e, n, i) {
  return new U6(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? t_e(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, i);
}
function Gm(t, e) {
  return t.slice(bn(t, e, !1), e);
}
function Km(t, e) {
  return t.slice(e, bn(t, e));
}
function t_e(t) {
  return (e, n, i) => !i[0].length || (t(Gm(i.input, i.index)) != Mt.Word || t(Km(i.input, i.index)) != Mt.Word) && (t(Km(i.input, i.index + i[0].length)) != Mt.Word || t(Gm(i.input, i.index + i[0].length)) != Mt.Word);
}
class n_e extends Z6 {
  nextMatch(e, n, i) {
    let r = bl(this.spec, e, i, e.doc.length).next();
    return r.done && (r = bl(this.spec, e, 0, n).next()), r.done ? null : r.value;
  }
  prevMatchInRange(e, n, i) {
    for (let r = 1; ; r++) {
      let s = Math.max(
        n,
        i - r * 1e4
        /* FindPrev.ChunkSize */
      ), o = bl(this.spec, e, s, i), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (s == n || a.from > s + 10))
        return a;
      if (s == n)
        return null;
    }
  }
  prevMatch(e, n, i) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : n);
  }
  matchAll(e, n) {
    let i = bl(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= n)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, n, i, r) {
    let s = bl(this.spec, e, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
const Dd = /* @__PURE__ */ Me.define(), ev = /* @__PURE__ */ Me.define(), wo = /* @__PURE__ */ ln.define({
  create(t) {
    return new cb(Ly(t).create(), null);
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(Dd) ? t = new cb(n.value.create(), t.panel) : n.is(ev) && (t = new cb(t.query, n.value ? tv : null));
    return t;
  },
  provide: (t) => Td.from(t, (e) => e.panel)
});
class cb {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
}
const i_e = /* @__PURE__ */ ve.mark({ class: "cm-searchMatch" }), r_e = /* @__PURE__ */ ve.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), s_e = /* @__PURE__ */ Ht.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(wo));
  }
  update(t) {
    let e = t.state.field(wo);
    (e != t.startState.field(wo) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return ve.none;
    let { view: n } = this, i = new Ao();
    for (let r = 0, s = n.visibleRanges, o = s.length; r < o; r++) {
      let { from: a, to: l } = s[r];
      for (; r < o - 1 && l > s[r + 1].from - 2 * 250; )
        l = s[++r].to;
      t.highlight(n.state, a, l, (c, u) => {
        let d = n.state.selection.ranges.some((h) => h.from == c && h.to == u);
        i.add(c, u, d ? r_e : i_e);
      });
    }
    return i.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function yh(t) {
  return (e) => {
    let n = e.state.field(wo, !1);
    return n && n.query.spec.valid ? t(e, n) : X6(e);
  };
}
const Jm = /* @__PURE__ */ yh((t, { query: e }) => {
  let { to: n } = t.state.selection.main, i = e.nextMatch(t.state, n, n);
  if (!i)
    return !1;
  let r = j.single(i.from, i.to), s = t.state.facet(Tc);
  return t.dispatch({
    selection: r,
    effects: [nv(t, i), s.scrollToMatch(r.main, t)],
    userEvent: "select.search"
  }), q6(t), !0;
}), e0 = /* @__PURE__ */ yh((t, { query: e }) => {
  let { state: n } = t, { from: i } = n.selection.main, r = e.prevMatch(n, i, i);
  if (!r)
    return !1;
  let s = j.single(r.from, r.to), o = t.state.facet(Tc);
  return t.dispatch({
    selection: s,
    effects: [nv(t, r), o.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), q6(t), !0;
}), o_e = /* @__PURE__ */ yh((t, { query: e }) => {
  let n = e.matchAll(t.state, 1e3);
  return !n || !n.length ? !1 : (t.dispatch({
    selection: j.create(n.map((i) => j.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), a_e = ({ state: t, dispatch: e }) => {
  let n = t.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: i, to: r } = n.main, s = [], o = 0;
  for (let a = new uc(t.doc, t.sliceDoc(i, r)); !a.next().done; ) {
    if (s.length > 1e3)
      return !1;
    a.value.from == i && (o = s.length), s.push(j.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: j.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, zA = /* @__PURE__ */ yh((t, { query: e }) => {
  let { state: n } = t, { from: i, to: r } = n.selection.main;
  if (n.readOnly)
    return !1;
  let s = e.nextMatch(n, i, i);
  if (!s)
    return !1;
  let o = [], a, l, c = [];
  if (s.from == i && s.to == r && (l = n.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: l }), s = e.nextMatch(n, s.from, s.to), c.push(ae.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(i).number) + "."))), s) {
    let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - l.length;
    a = j.single(s.from - u, s.to - u), c.push(nv(t, s)), c.push(n.facet(Tc).scrollToMatch(a.main, t));
  }
  return t.dispatch({
    changes: o,
    selection: a,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), l_e = /* @__PURE__ */ yh((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let n = e.matchAll(t.state, 1e9).map((r) => {
    let { from: s, to: o } = r;
    return { from: s, to: o, insert: e.getReplacement(r) };
  });
  if (!n.length)
    return !1;
  let i = t.state.phrase("replaced $ matches", n.length) + ".";
  return t.dispatch({
    changes: n,
    effects: ae.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function tv(t) {
  return t.state.facet(Tc).createPanel(t);
}
function Ly(t, e) {
  var n, i, r, s, o;
  let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = t.facet(Tc);
  return new V6({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive,
    literal: (r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function H6(t) {
  let e = Ad(t, tv);
  return e && e.dom.querySelector("[main-field]");
}
function q6(t) {
  let e = H6(t);
  e && e == t.root.activeElement && e.select();
}
const X6 = (t) => {
  let e = t.state.field(wo, !1);
  if (e && e.panel) {
    let n = H6(t);
    if (n && n != t.root.activeElement) {
      let i = Ly(t.state, e.query.spec);
      i.valid && t.dispatch({ effects: Dd.of(i) }), n.focus(), n.select();
    }
  } else
    t.dispatch({ effects: [
      ev.of(!0),
      e ? Dd.of(Ly(t.state, e.query.spec)) : Me.appendConfig.of(h_e)
    ] });
  return !0;
}, j6 = (t) => {
  let e = t.state.field(wo, !1);
  if (!e || !e.panel)
    return !1;
  let n = Ad(t, tv);
  return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: ev.of(!1) }), !0;
}, c_e = [
  { key: "Mod-f", run: X6, scope: "editor search-panel" },
  { key: "F3", run: Jm, shift: e0, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Jm, shift: e0, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: j6, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: a_e },
  { key: "Mod-Alt-g", run: F2e },
  { key: "Mod-d", run: K2e, preventDefault: !0 }
];
class u_e {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(wo).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Fe("input", {
      value: n.search,
      placeholder: fi(e, "Find"),
      "aria-label": fi(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Fe("input", {
      value: n.replace,
      placeholder: fi(e, "Replace"),
      "aria-label": fi(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Fe("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = Fe("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = Fe("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function i(r, s, o) {
      return Fe("button", { class: "cm-button", name: r, onclick: s, type: "button" }, o);
    }
    this.dom = Fe("div", { onkeydown: (r) => this.keydown(r), class: "cm-search" }, [
      this.searchField,
      i("next", () => Jm(e), [fi(e, "next")]),
      i("prev", () => e0(e), [fi(e, "previous")]),
      i("select", () => o_e(e), [fi(e, "all")]),
      Fe("label", null, [this.caseField, fi(e, "match case")]),
      Fe("label", null, [this.reField, fi(e, "regexp")]),
      Fe("label", null, [this.wordField, fi(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Fe("br"),
        this.replaceField,
        i("replace", () => zA(e), [fi(e, "replace")]),
        i("replaceAll", () => l_e(e), [fi(e, "replace all")])
      ],
      Fe("button", {
        name: "close",
        onclick: () => j6(e),
        "aria-label": fi(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new V6({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Dd.of(e) }));
  }
  keydown(e) {
    Y0e(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? e0 : Jm)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), zA(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let i of n.effects)
        i.is(Dd) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Tc).top;
  }
}
function fi(t, e) {
  return t.state.phrase(e);
}
const If = 30, Lf = /[\s\.,:;?!]/;
function nv(t, { from: e, to: n }) {
  let i = t.state.doc.lineAt(e), r = t.state.doc.lineAt(n).to, s = Math.max(i.from, e - If), o = Math.min(r, n + If), a = t.state.sliceDoc(s, o);
  if (s != i.from) {
    for (let l = 0; l < If; l++)
      if (!Lf.test(a[l + 1]) && Lf.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != r) {
    for (let l = a.length - 1; l > a.length - If; l--)
      if (!Lf.test(a[l - 1]) && Lf.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return ae.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${i.number}.`);
}
const d_e = /* @__PURE__ */ ae.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), h_e = [
  wo,
  /* @__PURE__ */ Fo.low(s_e),
  d_e
];
class f_e {
  constructor(e, n, i) {
    this.from = e, this.to = n, this.diagnostic = i;
  }
}
class ea {
  constructor(e, n, i) {
    this.diagnostics = e, this.panel = n, this.selected = i;
  }
  static init(e, n, i) {
    let r = e, s = i.facet(Id).markerFilter;
    s && (r = s(r, i));
    let o = ve.set(r.map((a) => a.from == a.to || a.from == a.to - 1 && i.doc.lineAt(a.from).to == a.from ? ve.widget({
      widget: new x_e(a),
      diagnostic: a
    }).range(a.from) : ve.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity + (a.markClass ? " " + a.markClass : "") },
      diagnostic: a
    }).range(a.from, a.to)), !0);
    return new ea(o, n, dc(o));
  }
}
function dc(t, e = null, n = 0) {
  let i = null;
  return t.between(n, 1e9, (r, s, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return i = new f_e(r, s, o.diagnostic), !1;
  }), i;
}
function p_e(t, e) {
  let n = e.pos, i = e.end || n, r = t.state.facet(Id).hideOn(t, n, i);
  if (r != null)
    return r;
  let s = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((o) => o.is(Y6)) || t.changes.touchesRange(s.from, Math.max(s.to, i)));
}
function m_e(t, e) {
  return t.field(vi, !1) ? e : e.concat(Me.appendConfig.of(k_e));
}
const Y6 = /* @__PURE__ */ Me.define(), iv = /* @__PURE__ */ Me.define(), G6 = /* @__PURE__ */ Me.define(), vi = /* @__PURE__ */ ln.define({
  create() {
    return new ea(ve.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let n = t.diagnostics.map(e.changes), i = null, r = t.panel;
      if (t.selected) {
        let s = e.changes.mapPos(t.selected.from, 1);
        i = dc(n, t.selected.diagnostic, s) || dc(n, null, s);
      }
      !n.size && r && e.state.facet(Id).autoPanel && (r = null), t = new ea(n, r, i);
    }
    for (let n of e.effects)
      if (n.is(Y6)) {
        let i = e.state.facet(Id).autoPanel ? n.value.length ? Ld.open : null : t.panel;
        t = ea.init(n.value, i, e.state);
      } else n.is(iv) ? t = new ea(t.diagnostics, n.value ? Ld.open : null, t.selected) : n.is(G6) && (t = new ea(t.diagnostics, t.panel, n.value));
    return t;
  },
  provide: (t) => [
    Td.from(t, (e) => e.panel),
    ae.decorations.from(t, (e) => e.diagnostics)
  ]
}), g_e = /* @__PURE__ */ ve.mark({ class: "cm-lintRange cm-lintRange-active" });
function b_e(t, e, n) {
  let { diagnostics: i } = t.state.field(vi), r = [], s = 2e8, o = 0;
  i.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (l, c, { spec: u }) => {
    e >= l && e <= c && (l == c || (e > l || n > 0) && (e < c || n < 0)) && (r.push(u.diagnostic), s = Math.min(l, s), o = Math.max(c, o));
  });
  let a = t.state.facet(Id).tooltipFilter;
  return a && (r = a(r, t.state)), r.length ? {
    pos: s,
    end: o,
    above: t.state.doc.lineAt(s).to < o,
    create() {
      return { dom: O_e(t, r) };
    }
  } : null;
}
function O_e(t, e) {
  return Fe("ul", { class: "cm-tooltip-lint" }, e.map((n) => J6(t, n, !1)));
}
const y_e = (t) => {
  let e = t.state.field(vi, !1);
  (!e || !e.panel) && t.dispatch({ effects: m_e(t.state, [iv.of(!0)]) });
  let n = Ad(t, Ld.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, UA = (t) => {
  let e = t.state.field(vi, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: iv.of(!1) }), !0);
}, __e = (t) => {
  let e = t.state.field(vi, !1);
  if (!e)
    return !1;
  let n = t.state.selection.main, i = e.diagnostics.iter(n.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == n.from && i.to == n.to) ? !1 : (t.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, v_e = [
  { key: "Mod-Shift-m", run: y_e, preventDefault: !0 },
  { key: "F8", run: __e }
], Id = /* @__PURE__ */ de.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, is(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, n) => e ? n ? (i) => e(i) || n(i) : e : n
    }));
  }
});
function K6(t) {
  let e = [];
  if (t)
    e: for (let { name: n } of t) {
      for (let i = 0; i < n.length; i++) {
        let r = n[i];
        if (/[a-zA-Z]/.test(r) && !e.some((s) => s.toLowerCase() == r.toLowerCase())) {
          e.push(r);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function J6(t, e, n) {
  var i;
  let r = n ? K6(e.actions) : [];
  return Fe("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Fe("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((s, o) => {
    let a = !1, l = (h) => {
      if (h.preventDefault(), a)
        return;
      a = !0;
      let f = dc(t.state.field(vi).diagnostics, e);
      f && s.apply(t, f.from, f.to);
    }, { name: c } = s, u = r[o] ? c.indexOf(r[o]) : -1, d = u < 0 ? c : [
      c.slice(0, u),
      Fe("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ];
    return Fe("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${r[o]})"`}.`
    }, d);
  }), e.source && Fe("div", { class: "cm-diagnosticSource" }, e.source));
}
class x_e extends Ns {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Fe("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class WA {
  constructor(e, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = J6(e, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Ld {
  constructor(e) {
    this.view = e, this.items = [];
    let n = (r) => {
      if (r.keyCode == 27)
        UA(this.view), this.view.focus();
      else if (r.keyCode == 38 || r.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (r.keyCode == 40 || r.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (r.keyCode == 36)
        this.moveSelection(0);
      else if (r.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (r.keyCode == 13)
        this.view.focus();
      else if (r.keyCode >= 65 && r.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = K6(s.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == r.keyCode) {
            let l = dc(this.view.state.field(vi).diagnostics, s);
            l && s.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      r.preventDefault();
    }, i = (r) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(r.target) && this.moveSelection(s);
    };
    this.list = Fe("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: i
    }), this.dom = Fe("div", { class: "cm-panel-lint" }, this.list, Fe("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => UA(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(vi).selected;
    if (!e)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == e.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(vi), i = 0, r = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (o, a, { spec: l }) => {
      let c = -1, u;
      for (let d = i; d < this.items.length; d++)
        if (this.items[d].diagnostic == l.diagnostic) {
          c = d;
          break;
        }
      c < 0 ? (u = new WA(this.view, l.diagnostic), this.items.splice(i, 0, u), r = !0) : (u = this.items[c], c > i && (this.items.splice(i, c - i), r = !0)), n && u.diagnostic == n.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), s = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      r = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new WA(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), r = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: a }) => {
        let l = a.height / this.list.offsetHeight;
        o.top < a.top ? this.list.scrollTop -= (a.top - o.top) / l : o.bottom > a.bottom && (this.list.scrollTop += (o.bottom - a.bottom) / l);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), r && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          n();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(vi), i = dc(n.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: G6.of(i)
    });
  }
  static open(e) {
    return new Ld(e);
  }
}
function w_e(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Bf(t) {
  return w_e(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const S_e = /* @__PURE__ */ ae.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Bf("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Bf("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Bf("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Bf("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), k_e = [
  vi,
  /* @__PURE__ */ ae.decorations.compute([vi], (t) => {
    let { selected: e, panel: n } = t.field(vi);
    return !e || !n || e.from == e.to ? ve.none : ve.set([
      g_e.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ Ige(b_e, { hideOn: p_e }),
  S_e
], E_e = [
  Zge(),
  Xge(),
  fge(),
  Dye(),
  y1e(),
  nge(),
  age(),
  je.allowMultipleSelections.of(!0),
  o1e(),
  v1e(S1e, { fallback: !0 }),
  P1e(),
  WOe(),
  eye(),
  kge(),
  Age(),
  yge(),
  V2e(),
  G0.of([
    ...qOe,
    ...B2e,
    ...c_e,
    ...Vye,
    ...m1e,
    ...HN,
    ...v_e
  ])
], C_e = /* @__PURE__ */ ke({
  __name: "Codemirror",
  props: {
    modelValue: { default: "" },
    height: { default: "auto" },
    language: { default: "yaml" },
    extensions: { default: () => [] }
  },
  emits: ["update:modelValue", "change"],
  setup(t, { emit: e }) {
    const n = {
      yaml: B_.define(kye),
      html: bye(),
      javascript: i6({
        jsx: !0,
        typescript: !0
      }),
      css: vN(),
      json: xye()
    }, i = t, r = e, s = ae.theme({
      "&": {
        height: i.height,
        width: "100%"
      }
    }), o = ru(), a = ru(), l = ru(), c = () => {
      const u = typeof i.language == "string" ? n[i.language] : i.language;
      let d = [
        E_e,
        ae.lineWrapping,
        s,
        u,
        ae.updateListener.of((h) => {
          if (h.docChanged) {
            const f = h.state.doc.toString();
            r("update:modelValue", f), r("change", f);
          }
        })
      ];
      i.extensions && (d = d.concat(i.extensions)), a.value = je.create({
        doc: i.modelValue,
        extensions: d
      }), l.value = new ae({
        state: a.value,
        parent: o.value
      });
    };
    return Gi(() => {
      c(), In(
        () => i.modelValue,
        (u) => {
          var d, h, f;
          u !== ((d = l.value) == null ? void 0 : d.state.doc.toString()) && ((f = l.value) == null || f.dispatch({
            changes: {
              from: 0,
              to: (h = l.value) == null ? void 0 : h.state.doc.length,
              insert: u
            }
          }));
        }
      );
    }), hc(() => {
      l.value && l.value.destroy();
    }), (u, d) => (P(), L("div", {
      ref_key: "wrapper",
      ref: o,
      class: "codemirror-wrapper contents"
    }, null, 512));
  }
}), A_e = { class: "text-diagram-nav" }, T_e = { class: "text-diagram-nav-start" }, M_e = /* @__PURE__ */ A("div", null, "", -1), P_e = ["value"], R_e = ["href"], $_e = { class: "text-diagram-nav-end" }, N_e = { class: "text-diagram-editor-panel" }, D_e = { class: "text-diagram-code" }, I_e = /* @__PURE__ */ ke({
  __name: "TextDiagramView",
  props: lq,
  setup(t) {
    const { load: e, unload: n } = vne(
      "https://cdn.jsdelivr.net/npm/mermaid@10.3.1/dist/mermaid.min.js",
      () => {
        window.mermaid.initialize({ startOnLoad: !1 });
      },
      { manual: !0 }
    ), i = t, r = pt(), s = pt(!1), o = [
      {
        value: "mermaid",
        label: "Mermaid",
        document: "https://mermaid.js.org/"
      },
      {
        value: "plantuml",
        label: "PlantUML",
        document: "https://plantuml.com/zh/"
      }
    ], a = Be({
      get: () => {
        var h;
        return (h = i.node) == null ? void 0 : h.attrs.type;
      },
      set: (h) => {
        console.log("language", h), i.updateAttributes({ type: h });
      }
    }), l = Be(() => o.find((h) => h.value === a.value)), c = async function() {
      const h = r.value;
      if (!h) return;
      const f = i.node.attrs.content;
      switch (a.value) {
        case "mermaid": {
          const p = `mermaid-${Date.now()}`;
          try {
            const { svg: m } = await window.mermaid.render(
              p,
              f,
              h
            );
            h.innerHTML = m;
          } catch (m) {
            h.innerHTML = `<pre style="color: red; background-color: #f6f8fa">${m}</pre>`;
          }
          break;
        }
        case "plantuml": {
          const p = qfe(f);
          i.updateAttributes({ src: p }), h.innerHTML = `<img src="${p}" alt="plantuml"/>`;
          break;
        }
      }
    }, u = mne(() => c(), 250);
    Gi(async () => {
      await e(), In(
        () => i.node.attrs.content,
        () => {
          Il(() => {
            u();
          });
        }
      ), In(
        () => i.node.attrs.type,
        () => {
          Il(() => {
            u();
          });
        }
      ), u();
    }), Fy(() => {
      n();
    });
    function d(h) {
      i.updateAttributes({ content: h });
    }
    return (h, f) => (P(), Re(Z(bc), {
      class: Ot(["text-diagram-container", { "text-diagram-fullscreen": s.value }])
    }, {
      default: ze(() => [
        A("div", A_e, [
          A("div", T_e, [
            M_e,
            ut(A("select", {
              "onUpdate:modelValue": f[0] || (f[0] = (p) => a.value = p),
              class: "text-diagram-type-select block rounded-md border border-gray-300 bg-gray-50 px-2 py-1.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500",
              contenteditable: "false"
            }, [
              (P(), L(Yt, null, Fr(o, (p, m) => A("option", {
                key: m,
                value: p.value
              }, Ft(p.label), 9, P_e)), 64))
            ], 512), [
              [ZA, a.value]
            ]),
            l.value ? ut((P(), L("a", {
              key: 0,
              href: l.value.document,
              target: "_blank"
            }, [
              fe(Z(Jfe))
            ], 8, R_e)), [
              [Z(mo), ` ${l.value.label} `]
            ]) : ei("", !0)
          ]),
          A("div", $_e, [
            A("div", {
              class: "text-diagram-fullscreen-icon",
              onClick: f[1] || (f[1] = (p) => s.value = !s.value)
            }, [
              s.value ? ut((P(), Re(Z(cpe), { key: 0 }, null, 512)), [
                [Z(mo), ""]
              ]) : ut((P(), Re(Z(rpe), { key: 1 }, null, 512)), [
                [Z(mo), ""]
              ])
            ])
          ])
        ]),
        A("div", N_e, [
          A("div", D_e, [
            fe(C_e, {
              "model-value": h.node.attrs.content,
              height: "100%",
              onChange: d
            }, null, 8, ["model-value"])
          ]),
          A("div", {
            ref_key: "previewRef",
            ref: r,
            class: "text-diagram-preview",
            contenteditable: "false"
          }, null, 512)
        ])
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), L_e = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
}, B_e = /* @__PURE__ */ A("path", {
  fill: "currentColor",
  d: "M19.69 13.419h-2.527l-2.667-4.555a1.29 1.29 0 0 0 1.035-1.28V4.16c0-.725-.576-1.312-1.302-1.312H9.771c-.726 0-1.312.576-1.312 1.301v3.435c0 .619.426 1.152 1.034 1.28l-2.666 4.555H4.309c-.725 0-1.312.576-1.312 1.301v3.435c0 .725.576 1.312 1.302 1.312h4.458c.726 0 1.312-.576 1.312-1.302v-3.434c0-.726-.576-1.312-1.301-1.312h-.437l2.645-4.523h2.059l2.656 4.523h-.438c-.725 0-1.312.576-1.312 1.301v3.435c0 .725.576 1.312 1.302 1.312H19.7c.726 0 1.312-.576 1.312-1.302v-3.434c0-.726-.576-1.312-1.301-1.312zM24 22.976c0 .565-.459 1.024-1.013 1.024H1.024A1.02 1.02 0 0 1 0 22.987V1.024C0 .459.459 0 1.013 0h21.963C23.541 0 24 .459 24 1.013z"
}, null, -1), Q_e = [
  B_e
];
function F_e(t, e) {
  return P(), L("svg", L_e, [...Q_e]);
}
const VA = { name: "simple-icons-diagramsdotnet", render: F_e }, z_e = wt.create({
  name: "text-diagram",
  inline: !1,
  content: "",
  marks: "",
  group: "block",
  code: !0,
  atom: !0,
  defining: !0,
  addAttributes() {
    return {
      type: {
        default: "mermaid",
        parseHTML: (t) => t.getAttribute("data-type"),
        renderHTML: (t) => t.type ? {
          "data-type": t.type
        } : {}
      },
      content: {
        default: "",
        parseHTML: (t) => t.getAttribute("data-content"),
        renderHTML: (t) => t.content ? {
          "data-content": t.content
        } : {}
      },
      src: {
        default: "",
        parseHTML: (t) => t.getAttribute("data-src"),
        renderHTML: (t) => t.src ? {
          "data-src": t.src
        } : {}
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "text-diagram[data-type]"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    switch (t.attrs.type) {
      case "plantuml":
        return [
          "text-diagram",
          Ee(e),
          [
            "img",
            {
              src: e["data-src"]
            }
          ]
        ];
      case "mermaid":
        return [
          "text-diagram",
          Ee(e),
          t.attrs.content
        ];
      default:
        return [
          "text-diagram",
          Ee(e),
          t.attrs.content
        ];
    }
  },
  addNodeView() {
    return Oc(I_e);
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      getToolboxItems({ editor: e }) {
        return [
          {
            priority: 100,
            component: R(Qo),
            props: {
              editor: e,
              icon: R(VA),
              title: "",
              action: () => {
                e.chain().focus().insertContent([
                  { type: "text-diagram", attrs: {} },
                  { type: "paragraph", content: "" }
                ]).run();
              }
            }
          }
        ];
      },
      // 
      getCommandMenuItems() {
        return {
          priority: 100,
          icon: R(VA),
          title: "",
          keywords: ["text-diagram", "wenbenhuitu"],
          command: ({ editor: e, range: n }) => {
            e.chain().focus().deleteRange(n).insertContent([
              { type: "text-diagram", attrs: {} },
              { type: "paragraph", content: "" }
            ]).run();
          }
        };
      }
    };
  }
}), yxe = [
  tX,
  dX,
  OX,
  EX,
  Wq,
  Vq.configure({
    width: 2,
    class: "dropcursor",
    color: "skyblue"
  }),
  qoe,
  Zq,
  OO,
  IG,
  Hq,
  HG,
  AK,
  IK,
  Eue,
  wn,
  $ee,
  SG,
  aY,
  fY,
  EO.configure({
    autolink: !0,
    openOnClick: !1
  }),
  Jee.configure({
    types: ["heading", "paragraph"]
  }),
  ste,
  Yo.configure({
    resizable: !0
  }),
  UK,
  XK,
  qq.configure({
    placeholder: Q.global.t("editor.extensions.commands_menu.placeholder")
  }),
  _se.configure({
    suggestion: {}
  }),
  cse.configure({
    lowlight: V0
  }),
  Jt,
  ft,
  _n,
  Rle,
  ld,
  o_,
  Ile,
  Cue,
  nue,
  loe,
  Woe,
  Lle,
  z_e
], _xe = {
  install(t) {
    t.component("RichTextEditor", Uq);
  }
};
export {
  _s as AddMarkStep,
  no as AddNodeMarkStep,
  ri as AllSelection,
  ga as AttrStep,
  Ol as BlockActionButton,
  Ll as BlockActionInput,
  Qt as BlockActionSeparator,
  V_e as BlockCard,
  Ky as BubbleItem,
  rxe as BubbleMenu,
  JU as CellBookmark,
  at as CellSelection,
  or as Change,
  qL as ChangeSet,
  E0 as CommandManager,
  Sa as ContentMatch,
  wZ as CoreEditor,
  ws as DOMParser,
  Wa as DOMSerializer,
  zt as Decoration,
  We as DecorationSet,
  Fu as DocAttrStep,
  Ave as Dropdown,
  Tve as DropdownSubmenu,
  VP as Editor,
  oq as EditorContent,
  X9 as EditorState,
  qB as EditorView,
  mt as Extension,
  _n as ExtensionAudio,
  tX as ExtensionBlockquote,
  dX as ExtensionBold,
  OX as ExtensionBulletList,
  loe as ExtensionClearFormat,
  EX as ExtensionCode,
  cse as ExtensionCodeBlock,
  aY as ExtensionColor,
  o_ as ExtensionColumn,
  ld as ExtensionColumns,
  _se as ExtensionCommands,
  Wq as ExtensionDocument,
  fxe as ExtensionDraggable,
  Vq as ExtensionDropcursor,
  fY as ExtensionFontSize,
  Woe as ExtensionFormatBrush,
  qoe as ExtensionGapcursor,
  Zq as ExtensionHardBreak,
  OO as ExtensionHeading,
  SG as ExtensionHighlight,
  IG as ExtensionHistory,
  Hq as ExtensionHorizontalRule,
  Jt as ExtensionIframe,
  wn as ExtensionImage,
  Rle as ExtensionIndent,
  HG as ExtensionItalic,
  EO as ExtensionLink,
  axe as ExtensionListKeymap,
  Ile as ExtensionNodeSelected,
  AK as ExtensionOrderedList,
  yl as ExtensionParagraph,
  qq as ExtensionPlaceholder,
  Lle as ExtensionRangeSelection,
  nue as ExtensionSearchAndReplace,
  IK as ExtensionStrike,
  UK as ExtensionSubscript,
  XK as ExtensionSuperscript,
  Yo as ExtensionTable,
  $ee as ExtensionTaskList,
  Eue as ExtensionText,
  Jee as ExtensionTextAlign,
  z_e as ExtensionTextDiagram,
  HP as ExtensionTextStyle,
  Cue as ExtensionTrailingNode,
  ste as ExtensionUnderline,
  ft as ExtensionVideo,
  sxe as FloatingMenu,
  Y as Fragment,
  ci as GapCursor,
  Hd as InputRule,
  Pb as MapResult,
  wl as Mapping,
  Tn as Mark,
  c0 as MarkType,
  oU as MarkdownParser,
  lU as MarkdownSerializer,
  uU as MarkdownSerializerState,
  Va as MenuItem,
  wt as Node,
  hq as NodeBubbleMenu,
  Ko as NodePos,
  Sp as NodeRange,
  ge as NodeSelection,
  cx as NodeType,
  kZ as NodeView,
  aq as NodeViewContent,
  bc as NodeViewWrapper,
  Do as PMInputRule,
  nt as PMMark,
  Wr as PMNode,
  E2 as PasteRule,
  Ue as Plugin,
  Ke as PluginKey,
  Jn as RangeSelection,
  ar as RemoveMarkStep,
  Fl as RemoveNodeMarkStep,
  on as ReplaceAroundStep,
  xp as ReplaceError,
  tn as ReplaceStep,
  gW as ResizeState,
  Qu as ResolvedPos,
  Uq as RichTextEditor,
  u0 as Schema,
  _e as Selection,
  Cp as SelectionRange,
  ne as Slice,
  ct as Span,
  Pn as Step,
  Oi as StepMap,
  Wt as StepResult,
  Je as TableMap,
  pW as TableView,
  ce as TextSelection,
  $t as ToolbarItem,
  Xn as ToolbarSubItem,
  Qo as ToolboxItem,
  nxe as Tracker,
  H9 as Transaction,
  e2 as Transform,
  zl as TransformError,
  Oc as VueNodeViewRenderer,
  ZP as VueRenderer,
  lW as __clipCells,
  cve as __endComposition,
  $w as __insertCells,
  lve as __parseFromClipboard,
  oW as __pastedCells,
  HB as __serializeForClipboard,
  GM as addColSpan,
  iP as addColumn,
  rP as addColumnAfter,
  EW as addColumnBefore,
  Qve as addListNodes,
  sP as addRow,
  oP as addRowAfter,
  MW as addRowBefore,
  yxe as allExtensions,
  rve as autoJoin,
  sve as baseKeymap,
  Ive as blockTypeItem,
  IU as bulletList,
  Ne as callOrReturn,
  es as canJoin,
  Vr as canSplit,
  gc as cellAround,
  o2 as chainCommands,
  pQ as closeDoubleQuote,
  fve as closeHistory,
  gQ as closeSingleQuote,
  Wve as colCount,
  K_e as collab,
  KU as columnIsHeader,
  mW as columnResizing,
  Pi as columnResizingPluginKey,
  VV as combineTransactionSteps,
  k0 as createChainableState,
  aO as createDocument,
  Bp as createNodeFromContent,
  AT as createParagraphNear,
  xZ as createStyleTag,
  _xe as default,
  ZV as defaultBlockAt,
  Eve as defaultMarkdownParser,
  Cve as defaultMarkdownSerializer,
  AW as deleteColumn,
  vc as deleteNode,
  td as deleteNodeByPos,
  Hw as deleteProps,
  RW as deleteRow,
  n2 as deleteSelection,
  QW as deleteTable,
  a7 as dropCursor,
  dT as dropPoint,
  Xc as elementFromString,
  xve as ellipsis,
  vve as emDash,
  EZ as escapeForRegEx,
  CT as exitCode,
  Gve as extensions,
  Uve as findCell,
  lO as findChildren,
  HV as findChildrenInRange,
  KW as findDuplicates,
  Hi as findParentNode,
  mP as findParentNodeClosestToPos,
  d0 as findWrapping,
  eP as fixTables,
  rW as fixTablesKey,
  WW as fromString,
  dve as gapCursor,
  pY as generateAnchor,
  mY as generateAnchorId,
  Xve as generateHTML,
  jve as generateJSON,
  Yve as generateText,
  OP as getAttributes,
  aP as getAttributesFromExtensions,
  YV as getChangedRanges,
  GV as getDebugJSON,
  he as getExtensionField,
  gP as getHTMLFromFragment,
  Xd as getMarkAttributes,
  A2 as getMarkRange,
  Io as getMarkType,
  M2 as getMarksBetween,
  KV as getNodeAtPosition,
  qV as getNodeAttributes,
  Zt as getNodeType,
  sO as getRenderedAttributes,
  T2 as getSchema,
  cP as getSchemaByResolvedExtensions,
  Vg as getSchemaTypeByName,
  M0 as getSchemaTypeNameByName,
  Xf as getSplittedAttributes,
  bP as getText,
  uP as getTextBetween,
  VW as getTextContentFromNodes,
  C2 as getTextSerializersFromSchema,
  tve as getVersion,
  zw as goToNextCell,
  hW as handlePaste,
  uQ as history,
  Zd as icons,
  S2 as inSameTable,
  Ww as injectExtensionAttributesToParseRule,
  yve as inputRules,
  HW as inputRulesPlugin,
  B9 as insertPoint,
  xi as isActive,
  JV as isAtEndOfNode,
  eZ as isAtStartOfNode,
  UW as isEmptyObject,
  Zw as isExtensionRulesEnabled,
  lP as isFunction,
  mr as isInTable,
  uO as isList,
  pP as isMacOS,
  cO as isMarkActive,
  Fi as isNodeActive,
  P2 as isNodeEmpty,
  Qp as isNodeSelection,
  qW as isNumber,
  Bh as isPlainObject,
  k2 as isRegExp,
  exe as isString,
  qd as isTextSelection,
  T0 as isiOS,
  _T as joinBackward,
  J9 as joinDown,
  ST as joinForward,
  h0 as joinPoint,
  G9 as joinTextblockBackward,
  K9 as joinTextblockForward,
  $b as joinUp,
  Mve as joinUpItem,
  m0 as keydownHandler,
  p7 as keymap,
  Nb as lift,
  TT as liftEmptyBlock,
  Pve as liftItem,
  zU as liftListItem,
  pc as liftTarget,
  LU as listItem,
  V0 as lowlight,
  DT as macBaseKeymap,
  nU as markDownSchema,
  Aa as markInputRule,
  Eo as markPasteRule,
  PU as marks,
  Lve as menuBar,
  Ee as mergeAttributes,
  Bw as mergeCells,
  A0 as mergeDeep,
  xs as minMax,
  GU as moveCellForward,
  ET as newlineInCode,
  YM as nextCell,
  jd as nodeInputRule,
  CZ as nodePasteRule,
  lq as nodeViewProps,
  CU as nodes,
  Lp as objectIncludes,
  fQ as openDoubleQuote,
  mQ as openSingleQuote,
  DU as orderedList,
  GW as pasteRulesPlugin,
  ms as pcBaseKeymap,
  kve as pmTextblockTypeInputRule,
  Sve as pmWrappingInputRule,
  nO as pointsAtCell,
  R2 as posToDOMRect,
  j9 as rebaseSteps,
  J_e as receiveTransaction,
  $p as redo,
  bve as redoDepth,
  Nve as redoItem,
  mve as redoNoScroll,
  Ca as removeColSpan,
  CW as removeColumn,
  XV as removeDuplicates,
  PW as removeRow,
  mU as renderGrouped,
  f0 as replaceStep,
  hP as resolveFocusPosition,
  TW as rowIsHeader,
  Bve as schema,
  t7 as selectAll,
  xT as selectNodeBackward,
  kT as selectNodeForward,
  Db as selectParentNode,
  Rve as selectParentNodeItem,
  NT as selectTextblockEnd,
  $T as selectTextblockStart,
  gr as selectedRect,
  S0 as selectionCell,
  OV as selectionToInsertionEnd,
  eve as sendableSteps,
  Lb as setBlockType,
  DW as setCellAttr,
  Z_e as simplifyChanges,
  VU as sinkListItem,
  wve as smartQuotes,
  MT as splitBlock,
  e7 as splitBlockAs,
  nve as splitBlockKeepMarks,
  Qw as splitCell,
  NW as splitCellWithType,
  C0 as splitExtensions,
  FU as splitListItem,
  Fve as splitListItemKeepMarks,
  FW as tableEditing,
  Gs as tableEditingKey,
  An as tableNodeTypes,
  zve as tableNodes,
  Jve as textInputRule,
  txe as textPasteRule,
  dO as textblockTypeInputRule,
  Ku as toggleHeader,
  LW as toggleHeaderCell,
  Hve as toggleHeaderColumn,
  Zve as toggleHeaderRow,
  ive as toggleMark,
  qve as trailingNode,
  Rp as undo,
  gve as undoDepth,
  _ve as undoInputRule,
  $ve as undoItem,
  pve as undoNoScroll,
  rO as updateColumnsOnResize,
  oxe as useEditor,
  Ib as wrapIn,
  BU as wrapInList,
  Dve as wrapItem,
  Hl as wrappingInputRule
};
